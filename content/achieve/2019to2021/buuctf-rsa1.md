---
title: buuctf-rsa1
date: 2020-04-08 00:15:53
tags: 
- crypto
categories:
- CTF

math:
  enable: true

---


## 题目：
```python
p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 
q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 
dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 
dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 
c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852

```
> 已知 dq，dp，q，p，c，求 m ，一个中国剩余定理扩展的题，原理咱也不太懂，用就完事了

## 证明过程：  

已知：
 d = dp mod (p-1)
 d = dq mod (q-1)
令：
m<sub>1</sub> = c<sup>d</sup> mod p 
m<sub>2</sub> = c<sup>d</sup> mod q
有：c<sup>d</sup> = k*p + m<sub>1</sub>
故：m<sub>2</sub> = ( k*p + m<sub>1</sub> ）mod q     -->   m<sub>2</sub> - m<sub>1</sub> = k*p mod q

取 p 逆模 ： ( m<sub>2</sub> - m<sub>1</sub> ) * p<sup>-1</sup> = k mod q

k = ( m<sub>2</sub> - m<sub>1</sub> ) * p<sup>-1</sup> mod q  ---->  k = ( k<sub>1</sub> * q + [ ( m<sub>2</sub> - m<sub>1</sub> ) * p<sup>-1</sup> mod q ] )
c<sup>d</sup> = k*p + m<sub>1</sub>
c<sup>d</sup> = ( k<sub>1</sub> * q + [ ( m<sub>2</sub> - m<sub>1</sub> ) * p<sup>-1</sup> mod q ] ) * p + m<sub>1</sub>
c<sup>d</sup> =  k<sub>1</sub> * q *p + [ ( m<sub>2</sub> - m<sub>1</sub> ) * p<sup>-1</sup> mod q ] * p   + m<sub>1</sub>

m =  c<sup>d</sup> mod n =  { k<sub>1</sub> * q *p + [ ( m<sub>2</sub> - m<sub>1</sub> ) * p<sup>-1</sup> mod q ] * p   + m<sub>1</sub> } mod n      (n = p*q)

故：m =   { [ ( m<sub>2</sub> - m<sub>1</sub> ) * p<sup>-1</sup> mod q ] * p   + m<sub>1</sub> } mod n     —— ①

d = k*( p-1 ) + dp

故：c<sup>d</sup> = c<sup>k*( p-1 ) + dp</sup> 

m<sub>1</sub> = c<sup>d</sup>  mod p = c<sup>k*( p-1 ) + dp</sup>  mod p 

由于 **费马小定理** :

m<sub>1</sub> = c<sup>  dp</sup>  mod p    

同理 ：m<sub>2</sub>  = c<sup>  dq</sup>  mod q   

## exp：

```python
import libnum 
import Crypto.Util.number
p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 
q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 
dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 
dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 
c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852

invq=libnum.invmod(p,q)
mp=pow(c,dp,p)
mq=pow(c,dq,q)
m=((mp-mq)*invq%p)*q+mq
print(libnum.n2s(m))
#noxCTF{W31c0m3_70_Ch1n470wn}

```
> 证明过程用了模运算的一些特性，掌握模运算性质的话还是比较简单的。。。。


